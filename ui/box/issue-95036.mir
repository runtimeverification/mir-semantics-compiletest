// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn by_ref(_1: &mut Box<[u8; 1], &std::alloc::Global>) -> () {
    debug node => _1;
    let mut _0: ();
    let _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let mut _5: std::boxed::Box<[u8; 1], &std::alloc::Global>;
    let mut _6: *const [u8; 1];

    bb0: {
        _2 = const 0_usize;
        _3 = const 1_usize;
        _4 = Lt(_2, _3);
        assert(move _4, "index out of bounds: the length is {} but the index is {}", move _3, _2) -> [success: bb1, unwind continue];
    }

    bb1: {
        _5 = deref_copy (*_1);
        _6 = (((_5.0: std::ptr::Unique<[u8; 1]>).0: std::ptr::NonNull<[u8; 1]>).0: *const [u8; 1]);
        (*_6)[_2] = const 9_u8;
        return;
    }
}

by_ref::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let mut _1: std::boxed::Box<[u8; 1], &std::alloc::Global>;
    let mut _2: [u8; 1];
    let _3: usize;
    let mut _4: usize;
    let mut _5: bool;
    let _6: std::boxed::Box<[u8; 1], &std::alloc::Global>;
    let mut _7: std::boxed::Box<[u8; 1], &std::alloc::Global>;
    let mut _9: [u8; 1];
    let _10: ();
    let mut _11: &mut std::boxed::Box<[u8; 1], &std::alloc::Global>;
    let _12: std::boxed::Box<[u8; 1], &std::alloc::Global>;
    let mut _13: std::boxed::Box<[u8; 1], &std::alloc::Global>;
    let mut _15: &std::alloc::Global;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: &mut std::boxed::Box<[u8; 1], &std::alloc::Global>;
    let mut _19: ();
    let mut _20: *const [u8; 1];
    scope 1 {
        debug node => _1;
        let mut _8: std::boxed::Box<[u8; 1], &std::alloc::Global>;
        let mut _14: &std::alloc::Global;
        scope 2 {
            debug node => _8;
        }
    }

    bb0: {
        _17 = const false;
        _16 = const false;
        _2 = [const 5_u8];
        _15 = const _;
        _17 = const true;
        _1 = Box::<[u8; 1], &std::alloc::Global>::new_in(move _2, _15) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = const 0_usize;
        _4 = const 1_usize;
        _5 = Lt(_3, _4);
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> [success: bb2, unwind: bb13];
    }

    bb2: {
        _20 = (((_1.0: std::ptr::Unique<[u8; 1]>).0: std::ptr::NonNull<[u8; 1]>).0: *const [u8; 1]);
        (*_20)[_3] = const 7_u8;
        _17 = const false;
        _7 = move _1;
        _6 = std::hint::black_box::<Box<[u8; 1], &std::alloc::Global>>(move _7) -> [return: bb3, unwind: bb13];
    }

    bb3: {
        drop(_6) -> [return: bb4, unwind: bb13];
    }

    bb4: {
        _9 = [const 5_u8];
        _14 = const _;
        _8 = Box::<[u8; 1], &std::alloc::Global>::new_in(move _9, _14) -> [return: bb5, unwind: bb13];
    }

    bb5: {
        _16 = const true;
        _11 = &mut _8;
        _10 = by_ref(_11) -> [return: bb6, unwind: bb11];
    }

    bb6: {
        _16 = const false;
        _13 = move _8;
        _12 = std::hint::black_box::<Box<[u8; 1], &std::alloc::Global>>(move _13) -> [return: bb7, unwind: bb11];
    }

    bb7: {
        drop(_12) -> [return: bb8, unwind: bb11];
    }

    bb8: {
        _16 = const false;
        _17 = const false;
        return;
    }

    bb9 (cleanup): {
        resume;
    }

    bb10 (cleanup): {
        drop(_8) -> [return: bb13, unwind terminate];
    }

    bb11 (cleanup): {
        switchInt(_16) -> [0: bb13, otherwise: bb10];
    }

    bb12 (cleanup): {
        _17 = const false;
        _18 = &mut _1;
        _19 = <Box<[u8; 1], &std::alloc::Global> as Drop>::drop(move _18) -> [return: bb14, unwind terminate];
    }

    bb13 (cleanup): {
        switchInt(_17) -> [0: bb9, otherwise: bb12];
    }

    bb14 (cleanup): {
        goto -> bb9;
    }
}

promoted[0] in main: &std::alloc::Global = {
    let mut _0: &std::alloc::Global;
    let mut _1: std::alloc::Global;

    bb0: {
        _1 = std::alloc::Global;
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &std::alloc::Global = {
    let mut _0: &std::alloc::Global;
    let mut _1: std::alloc::Global;

    bb0: {
        _1 = std::alloc::Global;
        _0 = &_1;
        return;
    }
}
