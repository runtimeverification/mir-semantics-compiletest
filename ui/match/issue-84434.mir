// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
const MY_A: A = {
    let mut _0: A;                       // return place in scope 0 at ui/match/issue-84434.rs:8:13: 8:14
    let mut _1: for<'a, 'b> fn(bool, &'a std::path::Path, std::option::Option<&'b std::path::Path>); // in scope 0 at ui/match/issue-84434.rs:9:11: 15:6
    let mut _2: [closure@ui/match/issue-84434.rs:9:11: 9:24]; // in scope 0 at ui/match/issue-84434.rs:9:11: 15:6

    bb0: {
        StorageLive(_1);                 // scope 0 at ui/match/issue-84434.rs:9:11: 15:6
        StorageLive(_2);                 // scope 0 at ui/match/issue-84434.rs:9:11: 15:6
        _2 = [closure@ui/match/issue-84434.rs:9:11: 9:24]; // scope 0 at ui/match/issue-84434.rs:9:11: 15:6
                                         // closure
                                         // + def_id: DefId(0:7 ~ issue_84434[0485]::MY_A::{closure#0})
                                         // + substs: [
                                         //     i8,
                                         //     for<'a, 'b> extern "rust-call" fn((bool, &'a std::path::Path, std::option::Option<&'b std::path::Path>)),
                                         //     (),
                                         // ]
        _1 = move _2 as for<'a, 'b> fn(bool, &'a std::path::Path, std::option::Option<&'b std::path::Path>) (Pointer(ClosureFnPointer(Normal))); // scope 0 at ui/match/issue-84434.rs:9:11: 15:6
        StorageDead(_2);                 // scope 0 at ui/match/issue-84434.rs:9:23: 9:24
        _0 = A { func: move _1 };        // scope 0 at ui/match/issue-84434.rs:8:17: 16:2
        StorageDead(_1);                 // scope 0 at ui/match/issue-84434.rs:16:1: 16:2
        return;                          // scope 0 at ui/match/issue-84434.rs:8:1: 16:3
    }
}

fn MY_A::{closure#0}(_1: &[closure@ui/match/issue-84434.rs:9:11: 9:24], _2: bool, _3: &Path, _4: Option<&Path>) -> () {
    debug check => _2;                   // in scope 0 at ui/match/issue-84434.rs:9:12: 9:17
    debug a => _3;                       // in scope 0 at ui/match/issue-84434.rs:9:19: 9:20
    debug b => _4;                       // in scope 0 at ui/match/issue-84434.rs:9:22: 9:23
    let mut _0: ();                      // return place in scope 0 at ui/match/issue-84434.rs:9:25: 9:25
    let mut _5: bool;                    // in scope 0 at ui/match/issue-84434.rs:10:12: 10:17
    let mut _6: std::option::Option<&std::path::Path>; // in scope 0 at ui/match/issue-84434.rs:12:38: 12:64
    let mut _7: std::option::Option<&std::path::Path>; // in scope 0 at ui/match/issue-84434.rs:12:38: 12:39
    let mut _8: [closure@ui/match/issue-84434.rs:12:49: 12:52]; // in scope 0 at ui/match/issue-84434.rs:12:49: 12:63
    let mut _9: isize;                   // in scope 0 at ui/match/issue-84434.rs:12:23: 12:35
    scope 1 {
    }
    scope 2 {
        debug parent => _10;             // in scope 2 at ui/match/issue-84434.rs:12:28: 12:34
        let _10: &std::path::Path;       // in scope 2 at ui/match/issue-84434.rs:12:28: 12:34
        scope 3 {
        }
    }

    bb0: {
        _5 = _2;                         // scope 0 at ui/match/issue-84434.rs:10:12: 10:17
        switchInt(move _5) -> [0: bb1, otherwise: bb4]; // scope 0 at ui/match/issue-84434.rs:10:12: 10:17
    }

    bb1: {
        _7 = _4;                         // scope 2 at ui/match/issue-84434.rs:12:38: 12:39
        _6 = Option::<&Path>::and_then::<&Path, [closure@ui/match/issue-84434.rs:12:49: 12:52]>(move _7, move _8) -> bb2; // scope 2 at ui/match/issue-84434.rs:12:38: 12:64
                                         // mir::Constant
                                         // + span: ui/match/issue-84434.rs:12:40: 12:48
                                         // + literal: Const { ty: fn(Option<&Path>, [closure@ui/match/issue-84434.rs:12:49: 12:52]) -> Option<&Path> {Option::<&Path>::and_then::<&Path, [closure@ui/match/issue-84434.rs:12:49: 12:52]>}, val: Value(<ZST>) }
    }

    bb2: {
        _9 = discriminant(_6);           // scope 2 at ui/match/issue-84434.rs:12:23: 12:35
        switchInt(move _9) -> [1: bb3, otherwise: bb4]; // scope 2 at ui/match/issue-84434.rs:12:23: 12:35
    }

    bb3: {
        _10 = ((_6 as Some).0: &std::path::Path); // scope 2 at ui/match/issue-84434.rs:12:28: 12:34
        goto -> bb4;                     // scope 0 at ui/match/issue-84434.rs:12:16: 14:10
    }

    bb4: {
        return;                          // scope 0 at ui/match/issue-84434.rs:15:6: 15:6
    }
}

fn MY_A::{closure#0}::{closure#0}(_1: [closure@ui/match/issue-84434.rs:12:49: 12:52], _2: &Path) -> Option<&Path> {
    debug p => _2;                       // in scope 0 at ui/match/issue-84434.rs:12:50: 12:51
    let mut _0: std::option::Option<&std::path::Path>; // return place in scope 0 at ui/match/issue-84434.rs:12:53: 12:53
    let mut _3: &std::path::Path;        // in scope 0 at ui/match/issue-84434.rs:12:53: 12:63

    bb0: {
        _3 = _2;                         // scope 0 at ui/match/issue-84434.rs:12:53: 12:63
        _0 = Path::parent(move _3) -> bb1; // scope 0 at ui/match/issue-84434.rs:12:53: 12:63
                                         // mir::Constant
                                         // + span: ui/match/issue-84434.rs:12:55: 12:61
                                         // + literal: Const { ty: for<'a> fn(&'a Path) -> Option<&'a Path> {Path::parent}, val: Value(<ZST>) }
    }

    bb1: {
        return;                          // scope 0 at ui/match/issue-84434.rs:12:63: 12:63
    }
}

fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/match/issue-84434.rs:18:11: 18:11

    bb0: {
        return;                          // scope 0 at ui/match/issue-84434.rs:18:13: 18:13
    }
}
