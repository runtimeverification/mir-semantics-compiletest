// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn any_lifetime() -> &u32 {
    let mut _0: &u32;

    bb0: {
        _0 = const _;
        return;
    }
}

promoted[0] in any_lifetime: &u32 = {
    let mut _0: &u32;
    let mut _1: u32;

    bb0: {
        _1 = const 5_u32;
        _0 = &_1;
        return;
    }
}

fn static_lifetime() -> &u32 {
    let mut _0: &u32;

    bb0: {
        _0 = const _;
        return;
    }
}

promoted[0] in static_lifetime: &u32 = {
    let mut _0: &u32;
    let mut _1: u32;

    bb0: {
        _1 = const 5_u32;
        _0 = &_1;
        return;
    }
}

fn any_lifetime_as_static_impl_trait() -> impl Debug {
    let mut _0: impl std::fmt::Debug;

    bb0: {
        _0 = any_lifetime::<'_>() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn lifetimes_as_static_impl_trait() -> impl Debug {
    let mut _0: impl std::fmt::Debug;

    bb0: {
        _0 = static_lifetime() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn no_params_or_lifetimes_is_static() -> impl Debug + 'static {
    let mut _0: impl std::fmt::Debug + 'static;

    bb0: {
        _0 = lifetimes_as_static_impl_trait() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn static_input_type_is_static(_1: T) -> impl Debug + 'static {
    debug x => _1;
    let mut _0: impl std::fmt::Debug + 'static;

    bb0: {
        _0 = move _1;
        return;
    }
}

fn type_outlives_reference_lifetime(_1: &T) -> impl Debug + '_ {
    debug x => _1;
    let mut _0: impl std::fmt::Debug + '_;

    bb0: {
        _0 = _1;
        return;
    }
}

fn type_outlives_reference_lifetime_elided(_1: &T) -> impl Debug + '_ {
    debug x => _1;
    let mut _0: impl std::fmt::Debug + '_;

    bb0: {
        _0 = _1;
        return;
    }
}

fn simple_type_hrtb() -> impl for<'a> SingleRegionTrait<'a> {
    let mut _0: impl for<'a> SingleRegionTrait<'a>;

    bb0: {
        _0 = const 5_u32;
        return;
    }
}

fn elision_single_region_trait(_1: &u32) -> impl SingleRegionTrait<'_> {
    debug x => _1;
    let mut _0: impl SingleRegionTrait<'_>;

    bb0: {
        _0 = _1;
        return;
    }
}

fn elision_single_region_struct(_1: SingleRegionStruct<'_>) -> impl Into<SingleRegionStruct<'_>> {
    debug x => _1;
    let mut _0: impl std::convert::Into<SingleRegionStruct<'_>>;

    bb0: {
        _0 = move _1;
        return;
    }
}

fn closure_hrtb() -> impl for<'a> Fn(&'a u32) {
    let mut _0: impl for<'a> Fn(&'a u32);

    bb0: {
        return;
    }
}

fn closure_hrtb::{closure#0}(_1: &[closure@ui/impl-trait/lifetimes.rs:38:49: 38:52], _2: &u32) -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}

fn closure_hr_elided() -> impl for<'a> Fn(&'a u32) {
    let mut _0: impl for<'a> Fn(&'a u32);

    bb0: {
        return;
    }
}

fn closure_hr_elided::{closure#0}(_1: &[closure@ui/impl-trait/lifetimes.rs:39:43: 39:46], _2: &u32) -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}

fn closure_hr_elided_return() -> impl for<'a> Fn(&'a u32) -> for<'a> &'a u32 {
    let mut _0: impl for<'a> Fn(&'a u32) -> for<'a> &'a u32;

    bb0: {
        return;
    }
}

fn closure_hr_elided_return::{closure#0}(_1: &[closure@ui/impl-trait/lifetimes.rs:40:58: 40:61], _2: &u32) -> &u32 {
    debug x => _2;
    let mut _0: &u32;

    bb0: {
        _0 = _2;
        return;
    }
}

fn closure_pass_through_elided_return(_1: impl Fn(&u32) -> &u32) -> impl for<'a> Fn(&'a u32) -> for<'a> &'a u32 {
    debug x => _1;
    let mut _0: impl for<'a> Fn(&'a u32) -> for<'a> &'a u32;

    bb0: {
        _0 = move _1;
        return;
    }
}

fn closure_pass_through_reference_elided(_1: &impl Fn(&u32) -> &u32) -> &impl for<'a> Fn(&'a u32) -> for<'a> &'a u32 {
    debug x => _1;
    let mut _0: &impl for<'a> Fn(&'a u32) -> for<'a> &'a u32;

    bb0: {
        _0 = _1;
        return;
    }
}

fn nested_lifetime(_1: &str) -> impl Iterator<Item = impl Iterator<Item = i32> + '_> + '_ {
    debug input => _1;
    let mut _0: impl std::iter::Iterator<Item = impl std::iter::Iterator<Item = i32> + '_> + '_;
    let mut _2: std::str::Lines<'_>;

    bb0: {
        _2 = core::str::<impl str>::lines(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <std::str::Lines<'_> as Iterator>::map::<Map<SplitWhitespace<'_>, [closure@ui/impl-trait/lifetimes.rs:48:37: 48:43]>, [closure@ui/impl-trait/lifetimes.rs:47:23: 47:29]>(move _2, const ZeroSized: [closure@ui/impl-trait/lifetimes.rs:47:23: 47:29]) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn nested_lifetime::{closure#0}(_1: &mut [closure@ui/impl-trait/lifetimes.rs:47:23: 47:29], _2: &str) -> Map<SplitWhitespace<'_>, [closure@ui/impl-trait/lifetimes.rs:48:37: 48:43]> {
    debug line => _2;
    let mut _0: std::iter::Map<std::str::SplitWhitespace<'_>, [closure@ui/impl-trait/lifetimes.rs:48:37: 48:43]>;
    let mut _3: std::str::SplitWhitespace<'_>;

    bb0: {
        _3 = core::str::<impl str>::split_whitespace(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <SplitWhitespace<'_> as Iterator>::map::<i32, [closure@ui/impl-trait/lifetimes.rs:48:37: 48:43]>(move _3, const ZeroSized: [closure@ui/impl-trait/lifetimes.rs:48:37: 48:43]) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn nested_lifetime::{closure#0}::{closure#0}(_1: &mut [closure@ui/impl-trait/lifetimes.rs:48:37: 48:43], _2: &str) -> i32 {
    debug cell => _2;
    let mut _0: i32;
    let mut _3: std::result::Result<i32, std::num::ParseIntError>;

    bb0: {
        _3 = core::str::<impl str>::parse::<i32>(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<i32, ParseIntError>::unwrap(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn pass_through_elision(_1: &u32) -> impl Into<&u32> {
    debug x => _1;
    let mut _0: impl std::convert::Into<&u32>;

    bb0: {
        _0 = _1;
        return;
    }
}

fn pass_through_elision_with_fn_ptr(_1: &for<'a> fn(&'a u32) -> &'a u32) -> impl Into<&for<'a> fn(&'a u32) -> &'a u32> {
    debug x => _1;
    let mut _0: impl std::convert::Into<&for<'a> fn(&'a u32) -> &'a u32>;

    bb0: {
        _0 = _1;
        return;
    }
}

fn pass_through_elision_with_fn_path(_1: &T) -> &impl for<'a> Fn(&'a u32) -> for<'a> &'a u32 {
    debug x => _1;
    let mut _0: &impl for<'a> Fn(&'a u32) -> for<'a> &'a u32;

    bb0: {
        _0 = _1;
        return;
    }
}

fn foo(_1: &impl Debug) -> &impl Debug {
    debug x => _1;
    let mut _0: &impl std::fmt::Debug;

    bb0: {
        _0 = _1;
        return;
    }
}

fn foo_explicit_lifetime(_1: &impl Debug) -> &impl Debug {
    debug x => _1;
    let mut _0: &impl std::fmt::Debug;

    bb0: {
        _0 = _1;
        return;
    }
}

fn foo_explicit_arg(_1: &T) -> &impl Debug {
    debug x => _1;
    let mut _0: &impl std::fmt::Debug;

    bb0: {
        _0 = _1;
        return;
    }
}

fn mixed_lifetimes() -> impl for<'b> Fn(&'b &u32) {
    let mut _0: impl for<'b> Fn(&'b &u32);

    bb0: {
        return;
    }
}

fn mixed_lifetimes::{closure#0}(_1: &[closure@ui/impl-trait/lifetimes.rs:63:60: 63:63], _2: &&u32) -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}

fn mixed_as_static() -> impl Fn(&'static &'static u32) {
    let mut _0: impl Fn(&'static &'static u32);

    bb0: {
        _0 = mixed_lifetimes::<'_>() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/impl-trait/lifetimes.rs:68:10: 68:15>::fmt(_1: &MultiRegionStruct<'_, '_>, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&u32;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&&u32;
    let _8: &&u32;

    bb0: {
        _3 = const "MultiRegionStruct";
        _5 = &((*_1).0: &u32);
        _4 = _5 as &dyn std::fmt::Debug (Pointer(Unsize));
        _8 = &((*_1).1: &u32);
        _7 = &_8;
        _6 = _7 as &dyn std::fmt::Debug (Pointer(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field2_finish(_2, _3, move _4, move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/impl-trait/lifetimes.rs:72:10: 72:15>::fmt(_1: &NoRegionStruct, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "NoRegionStruct";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn finds_least_region(_1: &u32, _2: &u32) -> impl MultiRegionTrait<'_, '_> {
    debug x => _1;
    debug y => _2;
    let mut _0: impl MultiRegionTrait<'_, '_>;

    bb0: {
        _0 = MultiRegionStruct::<'_, '_>(_1, _2);
        return;
    }
}

fn finds_explicit_bound(_1: &u32, _2: &u32) -> impl MultiRegionTrait<'_, '_> + '_ {
    debug x => _1;
    debug y => _2;
    let mut _0: impl MultiRegionTrait<'_, '_> + '_;

    bb0: {
        _0 = MultiRegionStruct::<'_, '_>(_1, _2);
        return;
    }
}

fn finds_explicit_bound_even_without_least_region(_1: &u32, _2: &u32) -> impl MultiRegionTrait<'_, '_> + '_ {
    debug x => _1;
    debug y => _2;
    let mut _0: impl MultiRegionTrait<'_, '_> + '_;

    bb0: {
        return;
    }
}

fn unnamed_lifetimes_arent_contained_in_impl_trait_and_will_unify(_1: &u32, _2: &u32) -> impl Debug {
    debug x => _1;
    debug y => _2;
    let mut _0: impl std::fmt::Debug;
    let mut _3: bool;

    bb0: {
        _3 = const true;
        switchInt(move _3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = unnamed_lifetimes_arent_contained_in_impl_trait_and_will_unify::deref(_1) -> [return: bb3, unwind continue];
    }

    bb2: {
        _0 = unnamed_lifetimes_arent_contained_in_impl_trait_and_will_unify::deref(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn unnamed_lifetimes_arent_contained_in_impl_trait_and_will_unify::deref(_1: &u32) -> impl Debug {
    debug x => _1;
    let mut _0: impl std::fmt::Debug;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn can_add_region_bound_to_static_type(_1: &u32) -> impl Debug + '_ {
    let mut _0: impl std::fmt::Debug + '_;

    bb0: {
        _0 = const 5_i32;
        return;
    }
}

fn <impl at ui/impl-trait/lifetimes.rs:112:1: 112:34>::iter_doesnt_capture_unnecessary_lifetime(_1: &MyVec) -> impl Iterator<Item = &u8> {
    debug self => _1;
    let mut _0: impl std::iter::Iterator<Item = &u8>;
    let mut _2: std::slice::Iter<'_, std::vec::Vec<u8>>;
    let mut _3: &[std::vec::Vec<u8>];
    let _4: &[std::vec::Vec<u8>];
    let mut _5: &std::vec::Vec<std::vec::Vec<u8>>;

    bb0: {
        _5 = &((*_1).0: std::vec::Vec<std::vec::Vec<u8>>);
        _4 = <Vec<Vec<u8>> as Deref>::deref(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = _4;
        _2 = core::slice::<impl [Vec<u8>]>::iter(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = <std::slice::Iter<'_, Vec<u8>> as Iterator>::flat_map::<std::slice::Iter<'_, u8>, [closure@ui/impl-trait/lifetimes.rs:114:32: 114:43]>(move _2, const ZeroSized: [closure@ui/impl-trait/lifetimes.rs:114:32: 114:43]) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn <impl at ui/impl-trait/lifetimes.rs:112:1: 112:34>::iter_doesnt_capture_unnecessary_lifetime::{closure#0}(_1: &mut [closure@ui/impl-trait/lifetimes.rs:114:32: 114:43], _2: &Vec<u8>) -> std::slice::Iter<'_, u8> {
    debug inner_vec => _2;
    let mut _0: std::slice::Iter<'_, u8>;
    let mut _3: &[u8];
    let _4: &[u8];

    bb0: {
        _4 = <Vec<u8> as Deref>::deref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = _4;
        _0 = core::slice::<impl [u8]>::iter(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn <impl at ui/impl-trait/lifetimes.rs:112:1: 112:34>::generator_doesnt_capture_unnecessary_lifetime() -> impl Sized {
    let mut _0: impl Sized;

    bb0: {
        _0 = [generator@ui/impl-trait/lifetimes.rs:118:9: 118:11 (#0)];
        return;
    }
}

fn <impl at ui/impl-trait/lifetimes.rs:112:1: 112:34>::generator_doesnt_capture_unnecessary_lifetime::{closure#0}(_1: Pin<&mut [generator@ui/impl-trait/lifetimes.rs:118:9: 118:11]>, _2: ()) -> GeneratorState<(), ()> {
    let mut _0: std::ops::GeneratorState<(), ()>;
    let mut _3: ();
    let mut _4: u32;
    let mut _5: &mut [generator@ui/impl-trait/lifetimes.rs:118:9: 118:11];
    let mut _6: &mut [generator@ui/impl-trait/lifetimes.rs:118:9: 118:11];
    let mut _7: &mut [generator@ui/impl-trait/lifetimes.rs:118:9: 118:11];

    bb0: {
        _5 = deref_copy (_1.0: &mut [generator@ui/impl-trait/lifetimes.rs:118:9: 118:11]);
        _4 = discriminant((*_5));
        switchInt(move _4) -> [0: bb1, 1: bb3, 3: bb2, otherwise: bb4];
    }

    bb1: {
        _3 = ();
        _0 = GeneratorState::<(), ()>::Yielded(move _3);
        _6 = deref_copy (_1.0: &mut [generator@ui/impl-trait/lifetimes.rs:118:9: 118:11]);
        discriminant((*_6)) = 3;
        return;
    }

    bb2: {
        _0 = GeneratorState::<(), ()>::Complete(move _2);
        _7 = deref_copy (_1.0: &mut [generator@ui/impl-trait/lifetimes.rs:118:9: 118:11]);
        discriminant((*_7)) = 1;
        return;
    }

    bb3: {
        assert(const false, "generator resumed after completion") -> [success: bb3, unwind continue];
    }

    bb4: {
        unreachable;
    }
}

fn main() -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}

fn SingleRegionStruct(_1: &u32) -> SingleRegionStruct<'_> {
    let mut _0: SingleRegionStruct<'_>;

    bb0: {
        _0 = SingleRegionStruct::<'_>(move _1);
        return;
    }
}

// MIR FOR CTFE
fn SingleRegionStruct(_1: &u32) -> SingleRegionStruct<'_> {
    let mut _0: SingleRegionStruct<'_>;

    bb0: {
        _0 = SingleRegionStruct::<'_>(move _1);
        return;
    }
}

fn MultiRegionStruct(_1: &u32, _2: &u32) -> MultiRegionStruct<'_, '_> {
    let mut _0: MultiRegionStruct<'_, '_>;

    bb0: {
        _0 = MultiRegionStruct::<'_, '_>(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn MultiRegionStruct(_1: &u32, _2: &u32) -> MultiRegionStruct<'_, '_> {
    let mut _0: MultiRegionStruct<'_, '_>;

    bb0: {
        _0 = MultiRegionStruct::<'_, '_>(move _1, move _2);
        return;
    }
}

fn MyVec(_1: Vec<Vec<u8>>) -> MyVec {
    let mut _0: MyVec;

    bb0: {
        _0 = MyVec(move _1);
        return;
    }
}

// MIR FOR CTFE
fn MyVec(_1: Vec<Vec<u8>>) -> MyVec {
    let mut _0: MyVec;

    bb0: {
        _0 = MyVec(move _1);
        return;
    }
}
