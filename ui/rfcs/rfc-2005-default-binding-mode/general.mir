// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn some_or_wildcard(_1: &Option<i32>, _2: &i32) -> () {
    debug r => _1;
    debug b => _2;
    let mut _0: ();
    let mut _3: isize;
    let _4: &i32;
    scope 1 {
    }
    scope 2 {
        debug a => _4;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [1: bb1, otherwise: bb2];
    }

    bb1: {
        _4 = &(((*_1) as Some).0: i32);
        goto -> bb2;
    }

    bb2: {
        return;
    }
}

fn none_or_wildcard(_1: &Option<i32>, _2: &i32) -> () {
    debug r => _1;
    debug b => _2;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn some_or_ref_none(_1: &Option<i32>, _2: &i32) -> () {
    debug r => _1;
    debug b => _2;
    let mut _0: ();
    let mut _3: isize;
    let _4: &i32;
    scope 1 {
    }
    scope 2 {
        debug a => _4;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb2, otherwise: bb1];
    }

    bb1: {
        unreachable;
    }

    bb2: {
        _4 = &(((*_1) as Some).0: i32);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn ref_some_or_none(_1: &Option<i32>, _2: &i32) -> () {
    debug r => _1;
    debug b => _2;
    let mut _0: ();
    let mut _3: isize;
    let _4: &i32;
    scope 1 {
    }
    scope 2 {
        debug a => _4;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb2, otherwise: bb1];
    }

    bb1: {
        unreachable;
    }

    bb2: {
        _4 = &(((*_1) as Some).0: i32);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn some_or_self(_1: &Option<i32>) -> () {
    debug r => _1;
    let mut _0: ();
    let mut _2: isize;
    let _3: &i32;
    scope 1 {
    }
    scope 2 {
        debug n => _3;
        scope 3 {
        }
    }
    scope 4 {
        debug x => _1;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [1: bb1, otherwise: bb2];
    }

    bb1: {
        _3 = &(((*_1) as Some).0: i32);
        goto -> bb2;
    }

    bb2: {
        return;
    }
}

fn multiple_deref(_1: &&&&&Option<i32>) -> () {
    debug r => _1;
    let mut _0: ();
    let mut _2: isize;
    let _3: &i32;
    let mut _4: &&&&std::option::Option<i32>;
    let mut _5: &&&std::option::Option<i32>;
    let mut _6: &&std::option::Option<i32>;
    let mut _7: &std::option::Option<i32>;
    let mut _8: &&&&std::option::Option<i32>;
    let mut _9: &&&std::option::Option<i32>;
    let mut _10: &&std::option::Option<i32>;
    let mut _11: &std::option::Option<i32>;
    scope 1 {
    }
    scope 2 {
        debug a => _3;
    }

    bb0: {
        _4 = deref_copy (*_1);
        _5 = deref_copy (*_4);
        _6 = deref_copy (*_5);
        _7 = deref_copy (*_6);
        _2 = discriminant((*_7));
        switchInt(move _2) -> [0: bb3, 1: bb2, otherwise: bb1];
    }

    bb1: {
        unreachable;
    }

    bb2: {
        _8 = deref_copy (*_1);
        _9 = deref_copy (*_8);
        _10 = deref_copy (*_9);
        _11 = deref_copy (*_10);
        _3 = &(((*_11) as Some).0: i32);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn match_with_or() -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}

fn nested_mixed() -> () {
    let mut _0: ();
    let mut _1: (&std::option::Option<i32>, &std::option::Option<i32>);
    let mut _2: isize;
    let mut _3: isize;
    let _4: &i32;
    let mut _5: i32;
    let mut _6: &std::option::Option<i32>;
    let mut _7: &std::option::Option<i32>;
    let mut _8: &std::option::Option<i32>;
    let mut _9: &std::option::Option<i32>;
    let mut _10: &std::option::Option<i32>;
    let mut _11: &std::option::Option<i32>;
    scope 1 {
        debug a => _4;
        debug b => _5;
        scope 2 {
            scope 3 {
            }
        }
    }

    bb0: {
        _7 = const _;
        _6 = const _;
        _1 = (_7, _6);
        _8 = deref_copy (_1.0: &std::option::Option<i32>);
        _3 = discriminant((*_8));
        switchInt(move _3) -> [1: bb1, otherwise: bb3];
    }

    bb1: {
        _9 = deref_copy (_1.1: &std::option::Option<i32>);
        _2 = discriminant((*_9));
        switchInt(move _2) -> [1: bb2, otherwise: bb3];
    }

    bb2: {
        _10 = deref_copy (_1.0: &std::option::Option<i32>);
        _4 = &(((*_10) as Some).0: i32);
        _11 = deref_copy (_1.1: &std::option::Option<i32>);
        _5 = (((*_11) as Some).0: i32);
        _5 = const 7_i32;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in nested_mixed: &Option<i32> = {
    let mut _0: &std::option::Option<i32>;
    let mut _1: std::option::Option<i32>;

    bb0: {
        _1 = Option::<i32>::Some(const 6_i32);
        _0 = &_1;
        return;
    }
}

promoted[1] in nested_mixed: &Option<i32> = {
    let mut _0: &std::option::Option<i32>;
    let mut _1: std::option::Option<i32>;

    bb0: {
        _1 = Option::<i32>::Some(const 5_i32);
        _0 = &_1;
        return;
    }
}

fn nested_mixed_multiple_deref_1() -> () {
    let mut _0: ();
    let _1: (i32, &std::option::Option<i32>);
    let _3: std::option::Option<(i32, &std::option::Option<i32>)>;
    let mut _4: isize;
    let mut _5: isize;
    let mut _8: &std::option::Option<i32>;
    let mut _9: &std::option::Option<i32>;
    let mut _10: &std::option::Option<i32>;
    scope 1 {
        debug x => _1;
        let _2: &std::option::Option<(i32, &std::option::Option<i32>)>;
        scope 2 {
            debug y => _2;
            let _6: &i32;
            let _7: &i32;
            scope 3 {
                debug a => _6;
                debug b => _7;
                scope 4 {
                    scope 5 {
                    }
                }
            }
        }
    }

    bb0: {
        _8 = const _;
        _1 = (const 1_i32, _8);
        _3 = Option::<(i32, &Option<i32>)>::Some(_1);
        _2 = &_3;
        _5 = discriminant((*_2));
        switchInt(move _5) -> [1: bb1, otherwise: bb3];
    }

    bb1: {
        _9 = deref_copy ((((*_2) as Some).0: (i32, &std::option::Option<i32>)).1: &std::option::Option<i32>);
        _4 = discriminant((*_9));
        switchInt(move _4) -> [1: bb2, otherwise: bb3];
    }

    bb2: {
        _6 = &((((*_2) as Some).0: (i32, &std::option::Option<i32>)).0: i32);
        _10 = deref_copy ((((*_2) as Some).0: (i32, &std::option::Option<i32>)).1: &std::option::Option<i32>);
        _7 = &(((*_10) as Some).0: i32);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in nested_mixed_multiple_deref_1: &Option<i32> = {
    let mut _0: &std::option::Option<i32>;
    let mut _1: std::option::Option<i32>;

    bb0: {
        _1 = Option::<i32>::Some(const 5_i32);
        _0 = &_1;
        return;
    }
}

fn nested_mixed_multiple_deref_2() -> () {
    let mut _0: ();
    let _1: &std::option::Option<i32>;
    let mut _3: isize;
    let mut _5: &std::option::Option<i32>;
    let mut _6: &std::option::Option<i32>;
    let mut _7: &std::option::Option<i32>;
    scope 1 {
        debug x => _1;
        let _2: &&std::option::Option<i32>;
        scope 2 {
            debug y => _2;
            let _4: &i32;
            scope 3 {
                debug z => _4;
                scope 4 {
                }
            }
        }
    }

    bb0: {
        _5 = const _;
        _1 = _5;
        _2 = &_1;
        _6 = deref_copy (*_2);
        _3 = discriminant((*_6));
        switchInt(move _3) -> [1: bb1, otherwise: bb2];
    }

    bb1: {
        _7 = deref_copy (*_2);
        _4 = &(((*_7) as Some).0: i32);
        goto -> bb2;
    }

    bb2: {
        return;
    }
}

promoted[0] in nested_mixed_multiple_deref_2: &Option<i32> = {
    let mut _0: &std::option::Option<i32>;
    let mut _1: std::option::Option<i32>;

    bb0: {
        _1 = Option::<i32>::Some(const 5_i32);
        _0 = &_1;
        return;
    }
}

fn new_mutable_reference() -> () {
    let mut _0: ();
    let mut _1: &mut std::option::Option<i32>;
    let mut _2: std::option::Option<i32>;
    let mut _3: &mut &mut std::option::Option<i32>;
    let mut _4: isize;
    let mut _6: &mut &mut std::option::Option<i32>;
    let mut _7: isize;
    let _9: ();
    let mut _10: std::fmt::Arguments<'_>;
    let mut _11: &[&str];
    let mut _12: &[core::fmt::rt::Argument<'_>];
    let _13: &[core::fmt::rt::Argument<'_>; 1];
    let _14: [core::fmt::rt::Argument<'_>; 1];
    let mut _15: core::fmt::rt::Argument<'_>;
    let _16: &i32;
    let mut _18: &mut std::option::Option<i32>;
    let mut _19: &mut std::option::Option<i32>;
    let mut _20: &mut std::option::Option<i32>;
    let mut _21: &mut std::option::Option<i32>;
    scope 1 {
        debug x => _1;
        let _5: &mut i32;
        let _8: &mut i32;
        scope 2 {
            debug y => _5;
        }
        scope 3 {
            debug y => _8;
            let mut _17: &[&str; 2];
        }
    }

    bb0: {
        _2 = Option::<i32>::Some(const 5_i32);
        _1 = &mut _2;
        _3 = &mut _1;
        _18 = deref_copy (*_3);
        _4 = discriminant((*_18));
        switchInt(move _4) -> [0: bb3, 1: bb2, otherwise: bb1];
    }

    bb1: {
        unreachable;
    }

    bb2: {
        _19 = deref_copy (*_3);
        _5 = &mut (((*_19) as Some).0: i32);
        (*_5) = const 5_i32;
        goto -> bb3;
    }

    bb3: {
        _6 = &mut _1;
        _20 = deref_copy (*_6);
        _7 = discriminant((*_20));
        switchInt(move _7) -> [0: bb7, 1: bb4, otherwise: bb1];
    }

    bb4: {
        _21 = deref_copy (*_6);
        _8 = &mut (((*_21) as Some).0: i32);
        _17 = const _;
        _11 = _17 as &[&str] (Pointer(Unsize));
        _16 = &(*_8);
        _15 = core::fmt::rt::Argument::<'_>::new_display::<i32>(_16) -> [return: bb5, unwind continue];
    }

    bb5: {
        _14 = [move _15];
        _13 = &_14;
        _12 = _13 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _10 = Arguments::<'_>::new_v1(move _11, move _12) -> [return: bb6, unwind continue];
    }

    bb6: {
        _9 = _print(move _10) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

promoted[0] in new_mutable_reference: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n"];
        _0 = &_1;
        return;
    }
}

fn let_implicit_ref_binding() -> () {
    let mut _0: ();
    let _1: &i32;
    let mut _2: &let_implicit_ref_binding::Foo;
    scope 1 {
        debug x => _1;
        scope 2 {
        }
    }

    bb0: {
        _2 = const _;
        _1 = &((*_2).0: i32);
        return;
    }
}

promoted[0] in let_implicit_ref_binding: &Foo = {
    let mut _0: &let_implicit_ref_binding::Foo;
    let mut _1: let_implicit_ref_binding::Foo;

    bb0: {
        _1 = Foo(const 3_i32);
        _0 = &_1;
        return;
    }
}

fn explicit_mut_binding() -> () {
    let mut _0: ();
    let mut _1: isize;
    let mut _2: i32;
    let mut _3: &mut std::option::Option<i32>;
    let mut _4: std::option::Option<i32>;
    let mut _5: isize;
    let _6: &mut i32;
    let mut _7: &mut &mut std::option::Option<i32>;
    let mut _8: &mut std::option::Option<i32>;
    let mut _9: std::option::Option<i32>;
    let mut _10: isize;
    let _11: &mut i32;
    let mut _12: &std::option::Option<i32>;
    let mut _13: &mut std::option::Option<i32>;
    let mut _14: &mut std::option::Option<i32>;
    scope 1 {
        debug n => _2;
        scope 2 {
        }
    }
    scope 3 {
        debug n => _6;
        scope 4 {
        }
    }
    scope 5 {
        debug n => _11;
        scope 6 {
        }
    }

    bb0: {
        _12 = const _;
        _1 = discriminant((*_12));
        switchInt(move _1) -> [0: bb3, 1: bb2, otherwise: bb1];
    }

    bb1: {
        unreachable;
    }

    bb2: {
        _2 = (((*_12) as Some).0: i32);
        _2 = Add(_2, const 1_i32);
        goto -> bb3;
    }

    bb3: {
        _4 = Option::<i32>::Some(const 5_i32);
        _3 = &mut _4;
        _5 = discriminant((*_3));
        switchInt(move _5) -> [0: bb5, 1: bb4, otherwise: bb1];
    }

    bb4: {
        _6 = &mut (((*_3) as Some).0: i32);
        (*_6) = Add((*_6), const 1_i32);
        goto -> bb5;
    }

    bb5: {
        _9 = Option::<i32>::Some(const 5_i32);
        _8 = &mut _9;
        _7 = &mut _8;
        _13 = deref_copy (*_7);
        _10 = discriminant((*_13));
        switchInt(move _10) -> [0: bb7, 1: bb6, otherwise: bb1];
    }

    bb6: {
        _14 = deref_copy (*_7);
        _11 = &mut (((*_14) as Some).0: i32);
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

promoted[0] in explicit_mut_binding: &Option<i32> = {
    let mut _0: &std::option::Option<i32>;
    let mut _1: std::option::Option<i32>;

    bb0: {
        _1 = Option::<i32>::Some(const 5_i32);
        _0 = &_1;
        return;
    }
}

fn tuple_mut_and_mut_mut() -> () {
    let mut _0: ();
    let mut _1: (std::option::Option<i32>, &std::option::Option<i32>);
    let mut _2: std::option::Option<i32>;
    let mut _3: isize;
    let mut _4: isize;
    let _5: i32;
    let _6: &i32;
    let mut _7: (&std::option::Option<i32>, &&std::option::Option<i32>);
    let mut _8: isize;
    let mut _9: isize;
    let _10: &i32;
    let _11: &i32;
    let mut _12: &mut &mut (std::option::Option<i32>, std::option::Option<i32>);
    let mut _13: &mut (std::option::Option<i32>, std::option::Option<i32>);
    let mut _14: (std::option::Option<i32>, std::option::Option<i32>);
    let mut _15: std::option::Option<i32>;
    let mut _16: std::option::Option<i32>;
    let mut _17: isize;
    let mut _18: isize;
    let _19: &mut i32;
    let _20: &mut i32;
    let mut _21: (&mut std::option::Option<i32>, &mut &mut std::option::Option<i32>);
    let mut _22: &mut std::option::Option<i32>;
    let mut _23: std::option::Option<i32>;
    let mut _24: &mut &mut std::option::Option<i32>;
    let mut _25: &mut std::option::Option<i32>;
    let mut _26: std::option::Option<i32>;
    let mut _27: isize;
    let mut _28: isize;
    let _29: &mut i32;
    let _30: &mut i32;
    let mut _31: &&std::option::Option<i32>;
    let mut _32: &std::option::Option<i32>;
    let mut _33: &std::option::Option<i32>;
    let mut _34: &std::option::Option<i32>;
    let mut _35: &std::option::Option<i32>;
    let mut _36: &std::option::Option<i32>;
    let mut _37: &&std::option::Option<i32>;
    let mut _38: &std::option::Option<i32>;
    let mut _39: &std::option::Option<i32>;
    let mut _40: &&std::option::Option<i32>;
    let mut _41: &std::option::Option<i32>;
    let mut _42: &mut (std::option::Option<i32>, std::option::Option<i32>);
    let mut _43: &mut (std::option::Option<i32>, std::option::Option<i32>);
    let mut _44: &mut (std::option::Option<i32>, std::option::Option<i32>);
    let mut _45: &mut (std::option::Option<i32>, std::option::Option<i32>);
    let mut _46: &mut std::option::Option<i32>;
    let mut _47: &mut &mut std::option::Option<i32>;
    let mut _48: &mut std::option::Option<i32>;
    let mut _49: &mut std::option::Option<i32>;
    let mut _50: &mut &mut std::option::Option<i32>;
    let mut _51: &mut std::option::Option<i32>;
    scope 1 {
        debug n => _5;
        debug m => _6;
        scope 2 {
            debug r => _5;
            scope 3 {
                scope 4 {
                    debug q => _6;
                    scope 5 {
                        scope 6 {
                            scope 7 {
                            }
                        }
                    }
                }
            }
        }
    }
    scope 8 {
        debug n => _10;
        debug m => _11;
        scope 9 {
            scope 10 {
            }
        }
    }
    scope 11 {
        debug n => _19;
        debug m => _20;
        scope 12 {
            scope 13 {
            }
        }
    }
    scope 14 {
        debug n => _29;
        debug m => _30;
        scope 15 {
            scope 16 {
            }
        }
    }

    bb0: {
        _2 = Option::<i32>::Some(const 5_i32);
        _33 = const _;
        _1 = (move _2, _33);
        _4 = discriminant((_1.0: std::option::Option<i32>));
        switchInt(move _4) -> [1: bb1, otherwise: bb3];
    }

    bb1: {
        _34 = deref_copy (_1.1: &std::option::Option<i32>);
        _3 = discriminant((*_34));
        switchInt(move _3) -> [1: bb2, otherwise: bb3];
    }

    bb2: {
        _5 = (((_1.0: std::option::Option<i32>) as Some).0: i32);
        _35 = deref_copy (_1.1: &std::option::Option<i32>);
        _6 = &(((*_35) as Some).0: i32);
        goto -> bb3;
    }

    bb3: {
        _32 = const _;
        _31 = const _;
        _7 = (_32, _31);
        _36 = deref_copy (_7.0: &std::option::Option<i32>);
        _9 = discriminant((*_36));
        switchInt(move _9) -> [1: bb4, otherwise: bb6];
    }

    bb4: {
        _37 = deref_copy (_7.1: &&std::option::Option<i32>);
        _38 = deref_copy (*_37);
        _8 = discriminant((*_38));
        switchInt(move _8) -> [1: bb5, otherwise: bb6];
    }

    bb5: {
        _39 = deref_copy (_7.0: &std::option::Option<i32>);
        _10 = &(((*_39) as Some).0: i32);
        _40 = deref_copy (_7.1: &&std::option::Option<i32>);
        _41 = deref_copy (*_40);
        _11 = &(((*_41) as Some).0: i32);
        goto -> bb6;
    }

    bb6: {
        _15 = Option::<i32>::Some(const 5_i32);
        _16 = Option::<i32>::Some(const 5_i32);
        _14 = (move _15, move _16);
        _13 = &mut _14;
        _12 = &mut _13;
        _42 = deref_copy (*_12);
        _18 = discriminant(((*_42).0: std::option::Option<i32>));
        switchInt(move _18) -> [1: bb7, otherwise: bb9];
    }

    bb7: {
        _43 = deref_copy (*_12);
        _17 = discriminant(((*_43).1: std::option::Option<i32>));
        switchInt(move _17) -> [1: bb8, otherwise: bb9];
    }

    bb8: {
        _44 = deref_copy (*_12);
        _19 = &mut ((((*_44).0: std::option::Option<i32>) as Some).0: i32);
        _45 = deref_copy (*_12);
        _20 = &mut ((((*_45).1: std::option::Option<i32>) as Some).0: i32);
        goto -> bb9;
    }

    bb9: {
        _23 = Option::<i32>::Some(const 5_i32);
        _22 = &mut _23;
        _26 = Option::<i32>::Some(const 5_i32);
        _25 = &mut _26;
        _24 = &mut _25;
        _21 = (move _22, move _24);
        _46 = deref_copy (_21.0: &mut std::option::Option<i32>);
        _28 = discriminant((*_46));
        switchInt(move _28) -> [1: bb10, otherwise: bb12];
    }

    bb10: {
        _47 = deref_copy (_21.1: &mut &mut std::option::Option<i32>);
        _48 = deref_copy (*_47);
        _27 = discriminant((*_48));
        switchInt(move _27) -> [1: bb11, otherwise: bb12];
    }

    bb11: {
        _49 = deref_copy (_21.0: &mut std::option::Option<i32>);
        _29 = &mut (((*_49) as Some).0: i32);
        _50 = deref_copy (_21.1: &mut &mut std::option::Option<i32>);
        _51 = deref_copy (*_50);
        _30 = &mut (((*_51) as Some).0: i32);
        goto -> bb12;
    }

    bb12: {
        return;
    }
}

promoted[0] in tuple_mut_and_mut_mut: &&Option<i32> = {
    let mut _0: &&std::option::Option<i32>;
    let mut _1: &std::option::Option<i32>;
    let mut _2: std::option::Option<i32>;

    bb0: {
        _2 = Option::<i32>::Some(const 5_i32);
        _1 = &_2;
        _0 = &_1;
        return;
    }
}

promoted[1] in tuple_mut_and_mut_mut: &Option<i32> = {
    let mut _0: &std::option::Option<i32>;
    let mut _1: std::option::Option<i32>;

    bb0: {
        _1 = Option::<i32>::Some(const 5_i32);
        _0 = &_1;
        return;
    }
}

promoted[2] in tuple_mut_and_mut_mut: &Option<i32> = {
    let mut _0: &std::option::Option<i32>;
    let mut _1: std::option::Option<i32>;

    bb0: {
        _1 = Option::<i32>::Some(const 5_i32);
        _0 = &_1;
        return;
    }
}

fn min_mir_embedded_type() -> () {
    let mut _0: ();
    let mut _1: (u8, &&std::option::Option<i32>);
    let mut _2: isize;
    let _3: &i32;
    let mut _4: &&std::option::Option<i32>;
    let mut _5: &&std::option::Option<i32>;
    let mut _6: &std::option::Option<i32>;
    let mut _7: &&std::option::Option<i32>;
    let mut _8: &std::option::Option<i32>;
    scope 1 {
        debug m => _3;
        scope 2 {
        }
    }

    bb0: {
        _4 = const _;
        _1 = (const 0_u8, _4);
        _5 = deref_copy (_1.1: &&std::option::Option<i32>);
        _6 = deref_copy (*_5);
        _2 = discriminant((*_6));
        switchInt(move _2) -> [1: bb1, otherwise: bb2];
    }

    bb1: {
        _7 = deref_copy (_1.1: &&std::option::Option<i32>);
        _8 = deref_copy (*_7);
        _3 = &(((*_8) as Some).0: i32);
        goto -> bb2;
    }

    bb2: {
        return;
    }
}

promoted[0] in min_mir_embedded_type: &&Option<i32> = {
    let mut _0: &&std::option::Option<i32>;
    let mut _1: &std::option::Option<i32>;
    let mut _2: std::option::Option<i32>;

    bb0: {
        _2 = Option::<i32>::Some(const 5_i32);
        _1 = &_2;
        _0 = &_1;
        return;
    }
}

fn no_autoderef() -> () {
    let mut _0: ();
    let _1: ();
    let mut _2: std::fmt::Arguments<'_>;
    let mut _3: &[&str];
    let mut _4: &[core::fmt::rt::Argument<'_>];
    let _5: &[core::fmt::rt::Argument<'_>; 1];
    let _6: [core::fmt::rt::Argument<'_>; 1];
    let mut _7: core::fmt::rt::Argument<'_>;
    let mut _8: (&i32, &i32);
    let mut _9: &i32;
    let _10: i32;
    let mut _11: &str;
    let mut _12: bool;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: i32;
    let mut _18: i32;
    let _20: !;
    let mut _21: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _26: &i32;
    scope 1 {
        debug x => const _;
        let mut _25: &[&str; 2];
        scope 2 {
            let _13: &i32;
            let _14: &i32;
            let _22: i32;
            let mut _23: &i32;
            let mut _24: &i32;
            scope 3 {
                debug left_val => _13;
                debug right_val => _14;
                let _19: core::panicking::AssertKind;
                scope 4 {
                    debug kind => _19;
                }
            }
            scope 5 {
                debug x => _22;
            }
        }
    }

    bb0: {
        _26 = const _;
        _25 = const _;
        _3 = _25 as &[&str] (Pointer(Unsize));
        _7 = core::fmt::rt::Argument::<'_>::new_display::<i32>(_26) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = [move _7];
        _5 = &_6;
        _4 = _5 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _2 = Arguments::<'_>::new_v1(move _3, move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _1 = _print(move _2) -> [return: bb3, unwind continue];
    }

    bb3: {
        _24 = const _;
        _11 = const "foo";
        _12 = <str as PartialEq>::eq(_11, const "foo") -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _12) -> [0: bb5, otherwise: bb6];
    }

    bb5: {
        _10 = const 1_i32;
        goto -> bb7;
    }

    bb6: {
        _10 = const 0_i32;
        goto -> bb7;
    }

    bb7: {
        _9 = &_10;
        _8 = (_24, move _9);
        _13 = (_8.0: &i32);
        _14 = (_8.1: &i32);
        _17 = (*_13);
        _18 = (*_14);
        _16 = Eq(move _17, move _18);
        _15 = Not(move _16);
        switchInt(move _15) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _19 = core::panicking::AssertKind::Eq;
        _21 = Option::<Arguments<'_>>::None;
        _20 = core::panicking::assert_failed::<i32, i32>(move _19, _13, _14, move _21) -> unwind continue;
    }

    bb9: {
        _23 = const _;
        _22 = (*_23);
        return;
    }
}

promoted[0] in no_autoderef: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 3_i32;
        _0 = &_1;
        return;
    }
}

promoted[1] in no_autoderef: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 0_i32;
        _0 = &_1;
        return;
    }
}

promoted[2] in no_autoderef: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 3_i32;
        _0 = &_1;
        return;
    }
}

promoted[3] in no_autoderef: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[4] in no_autoderef: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 3_i32;
        _0 = &_1;
        return;
    }
}

const Y: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "foo";
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: &std::option::Option<i32>;
    let _2: ();
    let mut _3: &std::option::Option<i32>;
    let _4: ();
    let mut _5: &std::option::Option<i32>;
    let _6: ();
    let mut _7: &std::option::Option<i32>;
    let _8: ();
    let mut _9: &std::option::Option<i32>;
    let _10: ();
    let mut _11: &std::option::Option<i32>;
    let _12: ();
    let _13: &&&&&std::option::Option<i32>;
    let _14: &&&&std::option::Option<i32>;
    let _15: &&&std::option::Option<i32>;
    let _16: &&std::option::Option<i32>;
    let _17: ();
    let _18: ();
    let _19: ();
    let _20: ();
    let _21: ();
    let _22: ();
    let _23: ();
    let _24: ();
    let _25: ();
    let _26: ();
    let mut _28: &std::option::Option<i32>;
    scope 1 {
        debug r => _1;
        let mut _27: &i32;
        scope 2 {
            debug b => const _;
        }
    }

    bb0: {
        _28 = const _;
        _1 = _28;
        _27 = const _;
        _3 = _1;
        _2 = none_or_wildcard(move _3, _27) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = _1;
        _4 = some_or_wildcard(move _5, _27) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = _1;
        _6 = some_or_ref_none(move _7, _27) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = _1;
        _8 = ref_some_or_none(move _9, _27) -> [return: bb4, unwind continue];
    }

    bb4: {
        _11 = _1;
        _10 = some_or_self(move _11) -> [return: bb5, unwind continue];
    }

    bb5: {
        _16 = &_1;
        _15 = &_16;
        _14 = &_15;
        _13 = &_14;
        _12 = multiple_deref(_13) -> [return: bb6, unwind continue];
    }

    bb6: {
        _17 = match_with_or() -> [return: bb7, unwind continue];
    }

    bb7: {
        _18 = nested_mixed() -> [return: bb8, unwind continue];
    }

    bb8: {
        _19 = nested_mixed_multiple_deref_1() -> [return: bb9, unwind continue];
    }

    bb9: {
        _20 = nested_mixed_multiple_deref_2() -> [return: bb10, unwind continue];
    }

    bb10: {
        _21 = new_mutable_reference() -> [return: bb11, unwind continue];
    }

    bb11: {
        _22 = explicit_mut_binding() -> [return: bb12, unwind continue];
    }

    bb12: {
        _23 = tuple_mut_and_mut_mut() -> [return: bb13, unwind continue];
    }

    bb13: {
        _24 = min_mir_embedded_type() -> [return: bb14, unwind continue];
    }

    bb14: {
        _25 = let_implicit_ref_binding() -> [return: bb15, unwind continue];
    }

    bb15: {
        _26 = no_autoderef() -> [return: bb16, unwind continue];
    }

    bb16: {
        return;
    }
}

promoted[0] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 4_i32;
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &Option<i32> = {
    let mut _0: &std::option::Option<i32>;
    let mut _1: std::option::Option<i32>;

    bb0: {
        _1 = Option::<i32>::Some(const 3_i32);
        _0 = &_1;
        return;
    }
}

fn Foo(_1: i32) -> Foo {
    let mut _0: let_implicit_ref_binding::Foo;

    bb0: {
        _0 = Foo(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Foo(_1: i32) -> Foo {
    let mut _0: let_implicit_ref_binding::Foo;

    bb0: {
        _0 = Foo(move _1);
        return;
    }
}
