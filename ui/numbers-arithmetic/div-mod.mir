// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();
    let _1: isize;
    let mut _3: (&isize, &isize);
    let mut _4: &isize;
    let _5: isize;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: isize;
    let mut _15: isize;
    let _17: !;
    let mut _18: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _19: (&isize, &isize);
    let mut _20: &isize;
    let _21: isize;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: bool;
    let mut _28: bool;
    let mut _29: bool;
    let mut _30: isize;
    let mut _31: isize;
    let _33: !;
    let mut _34: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _35: (&isize, &isize);
    let mut _36: &isize;
    let _37: isize;
    let mut _38: bool;
    let mut _39: bool;
    let mut _40: bool;
    let mut _41: bool;
    let mut _44: bool;
    let mut _45: bool;
    let mut _46: isize;
    let mut _47: isize;
    let _49: !;
    let mut _50: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _51: (&isize, &isize);
    let mut _52: &isize;
    let _53: isize;
    let mut _54: bool;
    let mut _55: bool;
    let mut _56: bool;
    let mut _57: bool;
    let mut _60: bool;
    let mut _61: bool;
    let mut _62: isize;
    let mut _63: isize;
    let _65: !;
    let mut _66: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _67: (&isize, &isize);
    let mut _68: &isize;
    let _69: isize;
    let mut _70: bool;
    let mut _71: bool;
    let mut _72: bool;
    let mut _73: bool;
    let mut _76: bool;
    let mut _77: bool;
    let mut _78: isize;
    let mut _79: isize;
    let _81: !;
    let mut _82: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _83: (&isize, &isize);
    let mut _84: &isize;
    let _85: isize;
    let mut _86: bool;
    let mut _87: bool;
    let mut _88: bool;
    let mut _89: bool;
    let mut _92: bool;
    let mut _93: bool;
    let mut _94: isize;
    let mut _95: isize;
    let _97: !;
    let mut _98: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _99: (&isize, &isize);
    let mut _100: &isize;
    let _101: isize;
    let mut _102: bool;
    let mut _103: bool;
    let mut _104: bool;
    let mut _105: bool;
    let mut _108: bool;
    let mut _109: bool;
    let mut _110: isize;
    let mut _111: isize;
    let _113: !;
    let mut _114: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _115: (&isize, &isize);
    let mut _116: &isize;
    let _117: isize;
    let mut _118: bool;
    let mut _119: bool;
    let mut _120: bool;
    let mut _121: bool;
    let mut _124: bool;
    let mut _125: bool;
    let mut _126: isize;
    let mut _127: isize;
    let _129: !;
    let mut _130: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _131: (&isize, &isize);
    let mut _132: &isize;
    let _133: isize;
    let mut _134: bool;
    let mut _135: bool;
    let mut _136: bool;
    let mut _137: bool;
    let mut _140: bool;
    let mut _141: bool;
    let mut _142: isize;
    let mut _143: isize;
    let _145: !;
    let mut _146: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _147: (&isize, &isize);
    let mut _148: &isize;
    let _149: isize;
    let mut _150: bool;
    let mut _151: bool;
    let mut _152: bool;
    let mut _153: bool;
    let mut _156: bool;
    let mut _157: bool;
    let mut _158: isize;
    let mut _159: isize;
    let _161: !;
    let mut _162: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug x => const 15_isize;
        let _2: isize;
        scope 2 {
            debug y => const 5_isize;
            let _10: &isize;
            let _11: &isize;
            let _26: &isize;
            let _27: &isize;
            let _42: &isize;
            let _43: &isize;
            let _58: &isize;
            let _59: &isize;
            let _74: &isize;
            let _75: &isize;
            let _90: &isize;
            let _91: &isize;
            let _106: &isize;
            let _107: &isize;
            let _122: &isize;
            let _123: &isize;
            let _138: &isize;
            let _139: &isize;
            let _154: &isize;
            let _155: &isize;
            let mut _163: &isize;
            let mut _164: &isize;
            let mut _165: &isize;
            let mut _166: &isize;
            let mut _167: &isize;
            let mut _168: &isize;
            let mut _169: &isize;
            let mut _170: &isize;
            let mut _171: &isize;
            let mut _172: &isize;
            scope 3 {
                debug left_val => _10;
                debug right_val => _11;
                let _16: core::panicking::AssertKind;
                scope 4 {
                    debug kind => _16;
                }
            }
            scope 5 {
                debug left_val => _26;
                debug right_val => _27;
                let _32: core::panicking::AssertKind;
                scope 6 {
                    debug kind => _32;
                }
            }
            scope 7 {
                debug left_val => _42;
                debug right_val => _43;
                let _48: core::panicking::AssertKind;
                scope 8 {
                    debug kind => _48;
                }
            }
            scope 9 {
                debug left_val => _58;
                debug right_val => _59;
                let _64: core::panicking::AssertKind;
                scope 10 {
                    debug kind => _64;
                }
            }
            scope 11 {
                debug left_val => _74;
                debug right_val => _75;
                let _80: core::panicking::AssertKind;
                scope 12 {
                    debug kind => _80;
                }
            }
            scope 13 {
                debug left_val => _90;
                debug right_val => _91;
                let _96: core::panicking::AssertKind;
                scope 14 {
                    debug kind => _96;
                }
            }
            scope 15 {
                debug left_val => _106;
                debug right_val => _107;
                let _112: core::panicking::AssertKind;
                scope 16 {
                    debug kind => _112;
                }
            }
            scope 17 {
                debug left_val => _122;
                debug right_val => _123;
                let _128: core::panicking::AssertKind;
                scope 18 {
                    debug kind => _128;
                }
            }
            scope 19 {
                debug left_val => _138;
                debug right_val => _139;
                let _144: core::panicking::AssertKind;
                scope 20 {
                    debug kind => _144;
                }
            }
            scope 21 {
                debug left_val => _154;
                debug right_val => _155;
                let _160: core::panicking::AssertKind;
                scope 22 {
                    debug kind => _160;
                }
            }
        }
    }

    bb0: {
        _1 = const 15_isize;
        _2 = const 5_isize;
        _6 = Eq(const 5_isize, const 0_isize);
        assert(!move _6, "attempt to divide `{}` by zero", _1) -> [success: bb1, unwind continue];
    }

    bb1: {
        _7 = Eq(const 5_isize, const -1_isize);
        _8 = Eq(_1, const isize::MIN);
        _9 = BitAnd(move _7, move _8);
        assert(!move _9, "attempt to compute `{} / {}`, which would overflow", _1, const 5_isize) -> [success: bb2, unwind continue];
    }

    bb2: {
        _5 = Div(_1, const 5_isize);
        _4 = &_5;
        _172 = const _;
        _3 = (move _4, _172);
        _10 = (_3.0: &isize);
        _11 = (_3.1: &isize);
        _14 = (*_10);
        _15 = (*_11);
        _13 = Eq(move _14, move _15);
        _12 = Not(move _13);
        switchInt(move _12) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _16 = core::panicking::AssertKind::Eq;
        _18 = Option::<Arguments<'_>>::None;
        _17 = core::panicking::assert_failed::<isize, isize>(move _16, _10, _11, move _18) -> unwind continue;
    }

    bb4: {
        _22 = Eq(const 4_isize, const 0_isize);
        assert(!move _22, "attempt to divide `{}` by zero", _1) -> [success: bb5, unwind continue];
    }

    bb5: {
        _23 = Eq(const 4_isize, const -1_isize);
        _24 = Eq(_1, const isize::MIN);
        _25 = BitAnd(move _23, move _24);
        assert(!move _25, "attempt to compute `{} / {}`, which would overflow", _1, const 4_isize) -> [success: bb6, unwind continue];
    }

    bb6: {
        _21 = Div(_1, const 4_isize);
        _20 = &_21;
        _171 = const _;
        _19 = (move _20, _171);
        _26 = (_19.0: &isize);
        _27 = (_19.1: &isize);
        _30 = (*_26);
        _31 = (*_27);
        _29 = Eq(move _30, move _31);
        _28 = Not(move _29);
        switchInt(move _28) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _32 = core::panicking::AssertKind::Eq;
        _34 = Option::<Arguments<'_>>::None;
        _33 = core::panicking::assert_failed::<isize, isize>(move _32, _26, _27, move _34) -> unwind continue;
    }

    bb8: {
        _38 = Eq(const 3_isize, const 0_isize);
        assert(!move _38, "attempt to divide `{}` by zero", _1) -> [success: bb9, unwind continue];
    }

    bb9: {
        _39 = Eq(const 3_isize, const -1_isize);
        _40 = Eq(_1, const isize::MIN);
        _41 = BitAnd(move _39, move _40);
        assert(!move _41, "attempt to compute `{} / {}`, which would overflow", _1, const 3_isize) -> [success: bb10, unwind continue];
    }

    bb10: {
        _37 = Div(_1, const 3_isize);
        _36 = &_37;
        _170 = const _;
        _35 = (move _36, _170);
        _42 = (_35.0: &isize);
        _43 = (_35.1: &isize);
        _46 = (*_42);
        _47 = (*_43);
        _45 = Eq(move _46, move _47);
        _44 = Not(move _45);
        switchInt(move _44) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _48 = core::panicking::AssertKind::Eq;
        _50 = Option::<Arguments<'_>>::None;
        _49 = core::panicking::assert_failed::<isize, isize>(move _48, _42, _43, move _50) -> unwind continue;
    }

    bb12: {
        _54 = Eq(_2, const 0_isize);
        assert(!move _54, "attempt to divide `{}` by zero", _1) -> [success: bb13, unwind continue];
    }

    bb13: {
        _55 = Eq(_2, const -1_isize);
        _56 = Eq(_1, const isize::MIN);
        _57 = BitAnd(move _55, move _56);
        assert(!move _57, "attempt to compute `{} / {}`, which would overflow", _1, _2) -> [success: bb14, unwind continue];
    }

    bb14: {
        _53 = Div(_1, _2);
        _52 = &_53;
        _169 = const _;
        _51 = (move _52, _169);
        _58 = (_51.0: &isize);
        _59 = (_51.1: &isize);
        _62 = (*_58);
        _63 = (*_59);
        _61 = Eq(move _62, move _63);
        _60 = Not(move _61);
        switchInt(move _60) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _64 = core::panicking::AssertKind::Eq;
        _66 = Option::<Arguments<'_>>::None;
        _65 = core::panicking::assert_failed::<isize, isize>(move _64, _58, _59, move _66) -> unwind continue;
    }

    bb16: {
        _70 = Eq(_2, const 0_isize);
        assert(!move _70, "attempt to divide `{}` by zero", const 15_isize) -> [success: bb17, unwind continue];
    }

    bb17: {
        _71 = Eq(_2, const -1_isize);
        _72 = Eq(const 15_isize, const isize::MIN);
        _73 = BitAnd(move _71, move _72);
        assert(!move _73, "attempt to compute `{} / {}`, which would overflow", const 15_isize, _2) -> [success: bb18, unwind continue];
    }

    bb18: {
        _69 = Div(const 15_isize, _2);
        _68 = &_69;
        _168 = const _;
        _67 = (move _68, _168);
        _74 = (_67.0: &isize);
        _75 = (_67.1: &isize);
        _78 = (*_74);
        _79 = (*_75);
        _77 = Eq(move _78, move _79);
        _76 = Not(move _77);
        switchInt(move _76) -> [0: bb20, otherwise: bb19];
    }

    bb19: {
        _80 = core::panicking::AssertKind::Eq;
        _82 = Option::<Arguments<'_>>::None;
        _81 = core::panicking::assert_failed::<isize, isize>(move _80, _74, _75, move _82) -> unwind continue;
    }

    bb20: {
        _86 = Eq(const 5_isize, const 0_isize);
        assert(!move _86, "attempt to calculate the remainder of `{}` with a divisor of zero", _1) -> [success: bb21, unwind continue];
    }

    bb21: {
        _87 = Eq(const 5_isize, const -1_isize);
        _88 = Eq(_1, const isize::MIN);
        _89 = BitAnd(move _87, move _88);
        assert(!move _89, "attempt to compute the remainder of `{} % {}`, which would overflow", _1, const 5_isize) -> [success: bb22, unwind continue];
    }

    bb22: {
        _85 = Rem(_1, const 5_isize);
        _84 = &_85;
        _167 = const _;
        _83 = (move _84, _167);
        _90 = (_83.0: &isize);
        _91 = (_83.1: &isize);
        _94 = (*_90);
        _95 = (*_91);
        _93 = Eq(move _94, move _95);
        _92 = Not(move _93);
        switchInt(move _92) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _96 = core::panicking::AssertKind::Eq;
        _98 = Option::<Arguments<'_>>::None;
        _97 = core::panicking::assert_failed::<isize, isize>(move _96, _90, _91, move _98) -> unwind continue;
    }

    bb24: {
        _102 = Eq(const 4_isize, const 0_isize);
        assert(!move _102, "attempt to calculate the remainder of `{}` with a divisor of zero", _1) -> [success: bb25, unwind continue];
    }

    bb25: {
        _103 = Eq(const 4_isize, const -1_isize);
        _104 = Eq(_1, const isize::MIN);
        _105 = BitAnd(move _103, move _104);
        assert(!move _105, "attempt to compute the remainder of `{} % {}`, which would overflow", _1, const 4_isize) -> [success: bb26, unwind continue];
    }

    bb26: {
        _101 = Rem(_1, const 4_isize);
        _100 = &_101;
        _166 = const _;
        _99 = (move _100, _166);
        _106 = (_99.0: &isize);
        _107 = (_99.1: &isize);
        _110 = (*_106);
        _111 = (*_107);
        _109 = Eq(move _110, move _111);
        _108 = Not(move _109);
        switchInt(move _108) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        _112 = core::panicking::AssertKind::Eq;
        _114 = Option::<Arguments<'_>>::None;
        _113 = core::panicking::assert_failed::<isize, isize>(move _112, _106, _107, move _114) -> unwind continue;
    }

    bb28: {
        _118 = Eq(const 3_isize, const 0_isize);
        assert(!move _118, "attempt to calculate the remainder of `{}` with a divisor of zero", _1) -> [success: bb29, unwind continue];
    }

    bb29: {
        _119 = Eq(const 3_isize, const -1_isize);
        _120 = Eq(_1, const isize::MIN);
        _121 = BitAnd(move _119, move _120);
        assert(!move _121, "attempt to compute the remainder of `{} % {}`, which would overflow", _1, const 3_isize) -> [success: bb30, unwind continue];
    }

    bb30: {
        _117 = Rem(_1, const 3_isize);
        _116 = &_117;
        _165 = const _;
        _115 = (move _116, _165);
        _122 = (_115.0: &isize);
        _123 = (_115.1: &isize);
        _126 = (*_122);
        _127 = (*_123);
        _125 = Eq(move _126, move _127);
        _124 = Not(move _125);
        switchInt(move _124) -> [0: bb32, otherwise: bb31];
    }

    bb31: {
        _128 = core::panicking::AssertKind::Eq;
        _130 = Option::<Arguments<'_>>::None;
        _129 = core::panicking::assert_failed::<isize, isize>(move _128, _122, _123, move _130) -> unwind continue;
    }

    bb32: {
        _134 = Eq(_2, const 0_isize);
        assert(!move _134, "attempt to calculate the remainder of `{}` with a divisor of zero", _1) -> [success: bb33, unwind continue];
    }

    bb33: {
        _135 = Eq(_2, const -1_isize);
        _136 = Eq(_1, const isize::MIN);
        _137 = BitAnd(move _135, move _136);
        assert(!move _137, "attempt to compute the remainder of `{} % {}`, which would overflow", _1, _2) -> [success: bb34, unwind continue];
    }

    bb34: {
        _133 = Rem(_1, _2);
        _132 = &_133;
        _164 = const _;
        _131 = (move _132, _164);
        _138 = (_131.0: &isize);
        _139 = (_131.1: &isize);
        _142 = (*_138);
        _143 = (*_139);
        _141 = Eq(move _142, move _143);
        _140 = Not(move _141);
        switchInt(move _140) -> [0: bb36, otherwise: bb35];
    }

    bb35: {
        _144 = core::panicking::AssertKind::Eq;
        _146 = Option::<Arguments<'_>>::None;
        _145 = core::panicking::assert_failed::<isize, isize>(move _144, _138, _139, move _146) -> unwind continue;
    }

    bb36: {
        _150 = Eq(_2, const 0_isize);
        assert(!move _150, "attempt to calculate the remainder of `{}` with a divisor of zero", const 15_isize) -> [success: bb37, unwind continue];
    }

    bb37: {
        _151 = Eq(_2, const -1_isize);
        _152 = Eq(const 15_isize, const isize::MIN);
        _153 = BitAnd(move _151, move _152);
        assert(!move _153, "attempt to compute the remainder of `{} % {}`, which would overflow", const 15_isize, _2) -> [success: bb38, unwind continue];
    }

    bb38: {
        _149 = Rem(const 15_isize, _2);
        _148 = &_149;
        _163 = const _;
        _147 = (move _148, _163);
        _154 = (_147.0: &isize);
        _155 = (_147.1: &isize);
        _158 = (*_154);
        _159 = (*_155);
        _157 = Eq(move _158, move _159);
        _156 = Not(move _157);
        switchInt(move _156) -> [0: bb40, otherwise: bb39];
    }

    bb39: {
        _160 = core::panicking::AssertKind::Eq;
        _162 = Option::<Arguments<'_>>::None;
        _161 = core::panicking::assert_failed::<isize, isize>(move _160, _154, _155, move _162) -> unwind continue;
    }

    bb40: {
        return;
    }
}

promoted[0] in main: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 0_isize;
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 0_isize;
        _0 = &_1;
        return;
    }
}

promoted[2] in main: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 0_isize;
        _0 = &_1;
        return;
    }
}

promoted[3] in main: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 3_isize;
        _0 = &_1;
        return;
    }
}

promoted[4] in main: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 0_isize;
        _0 = &_1;
        return;
    }
}

promoted[5] in main: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 3_isize;
        _0 = &_1;
        return;
    }
}

promoted[6] in main: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 3_isize;
        _0 = &_1;
        return;
    }
}

promoted[7] in main: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 5_isize;
        _0 = &_1;
        return;
    }
}

promoted[8] in main: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 3_isize;
        _0 = &_1;
        return;
    }
}

promoted[9] in main: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 3_isize;
        _0 = &_1;
        return;
    }
}
