// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn with_parens(_1: T) -> String {
    debug arg => _1;                     // in scope 0 at ui/path-lookahead.rs:9:29: 9:32
    let mut _0: std::string::String;     // return place in scope 0 at ui/path-lookahead.rs:9:40: 9:46
    let mut _2: &T;                      // in scope 0 at ui/path-lookahead.rs:10:40: 10:44
    let _3: &T;                          // in scope 0 at ui/path-lookahead.rs:10:40: 10:44

    bb0: {
        _3 = &_1;                        // scope 0 at ui/path-lookahead.rs:10:40: 10:44
        _2 = _3;                         // scope 0 at ui/path-lookahead.rs:10:40: 10:44
        _0 = <T as ToString>::to_string(move _2) -> [return: bb1, unwind: bb3]; // scope 0 at ui/path-lookahead.rs:10:12: 10:46
                                         // mir::Constant
                                         // + span: ui/path-lookahead.rs:10:13: 10:39
                                         // + literal: Const { ty: for<'a> fn(&'a T) -> String {<T as ToString>::to_string}, val: Value(<ZST>) }
    }

    bb1: {
        drop(_1) -> bb2;                 // scope 0 at ui/path-lookahead.rs:11:1: 11:2
    }

    bb2: {
        return;                          // scope 0 at ui/path-lookahead.rs:11:2: 11:2
    }

    bb3 (cleanup): {
        drop(_1) -> bb4;                 // scope 0 at ui/path-lookahead.rs:11:1: 11:2
    }

    bb4 (cleanup): {
        resume;                          // scope 0 at ui/path-lookahead.rs:9:1: 11:2
    }
}

fn no_parens(_1: T) -> String {
    debug arg => _1;                     // in scope 0 at ui/path-lookahead.rs:13:27: 13:30
    let mut _0: std::string::String;     // return place in scope 0 at ui/path-lookahead.rs:13:38: 13:44
    let mut _2: &T;                      // in scope 0 at ui/path-lookahead.rs:14:39: 14:43
    let _3: &T;                          // in scope 0 at ui/path-lookahead.rs:14:39: 14:43

    bb0: {
        _3 = &_1;                        // scope 0 at ui/path-lookahead.rs:14:39: 14:43
        _2 = _3;                         // scope 0 at ui/path-lookahead.rs:14:39: 14:43
        _0 = <T as ToString>::to_string(move _2) -> [return: bb1, unwind: bb3]; // scope 0 at ui/path-lookahead.rs:14:12: 14:44
                                         // mir::Constant
                                         // + span: ui/path-lookahead.rs:14:12: 14:38
                                         // + literal: Const { ty: for<'a> fn(&'a T) -> String {<T as ToString>::to_string}, val: Value(<ZST>) }
    }

    bb1: {
        drop(_1) -> bb2;                 // scope 0 at ui/path-lookahead.rs:15:1: 15:2
    }

    bb2: {
        return;                          // scope 0 at ui/path-lookahead.rs:15:2: 15:2
    }

    bb3 (cleanup): {
        drop(_1) -> bb4;                 // scope 0 at ui/path-lookahead.rs:15:1: 15:2
    }

    bb4 (cleanup): {
        resume;                          // scope 0 at ui/path-lookahead.rs:13:1: 15:2
    }
}

fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/path-lookahead.rs:17:11: 17:11

    bb0: {
        return;                          // scope 0 at ui/path-lookahead.rs:17:13: 17:13
    }
}
