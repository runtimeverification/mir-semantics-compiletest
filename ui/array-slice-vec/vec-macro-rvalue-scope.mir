// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn one() -> i32 {
    let mut _0: i32;

    bb0: {
        _0 = const 1_i32;
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let mut _1: (&std::vec::Vec<&i32>, &std::vec::Vec<&i32>);
    let mut _2: &std::vec::Vec<&i32>;
    let _3: std::vec::Vec<&i32>;
    let mut _4: std::boxed::Box<[&i32]>;
    let mut _5: std::boxed::Box<[&i32; 3]>;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: *mut u8;
    let mut _9: std::boxed::Box<[&i32; 3]>;
    let mut _10: &i32;
    let _11: i32;
    let _12: &i32;
    let _13: i32;
    let mut _14: &std::vec::Vec<&i32>;
    let _15: std::vec::Vec<&i32>;
    let mut _16: std::boxed::Box<[&i32]>;
    let mut _17: std::boxed::Box<[&i32; 3]>;
    let mut _18: usize;
    let mut _19: usize;
    let mut _20: *mut u8;
    let mut _21: std::boxed::Box<[&i32; 3]>;
    let _22: &i32;
    let _23: i32;
    let mut _24: i32;
    let mut _25: i32;
    let _26: &std::vec::Vec<&i32>;
    let _27: &std::vec::Vec<&i32>;
    let mut _28: bool;
    let mut _29: bool;
    let _31: !;
    let mut _32: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _33: (&std::vec::Vec<&i32>, &std::vec::Vec<&i32>);
    let mut _34: &std::vec::Vec<&i32>;
    let _35: std::vec::Vec<&i32>;
    let mut _36: &i32;
    let _37: i32;
    let mut _38: &std::vec::Vec<&i32>;
    let _39: std::vec::Vec<&i32>;
    let mut _40: std::boxed::Box<[&i32]>;
    let mut _41: std::boxed::Box<[&i32; 2]>;
    let mut _42: usize;
    let mut _43: usize;
    let mut _44: *mut u8;
    let mut _45: std::boxed::Box<[&i32; 2]>;
    let _46: &i32;
    let _47: i32;
    let _48: &std::vec::Vec<&i32>;
    let _49: &std::vec::Vec<&i32>;
    let mut _50: bool;
    let mut _51: bool;
    let _53: !;
    let mut _54: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _55: &i32;
    let mut _56: &i32;
    let mut _57: &i32;
    let mut _58: &i32;
    let mut _59: &mut std::boxed::Box<[&i32; 2]>;
    let mut _60: ();
    let mut _61: &mut std::boxed::Box<[&i32; 3]>;
    let mut _62: ();
    let mut _63: &mut std::boxed::Box<[&i32; 3]>;
    let mut _64: ();
    let mut _65: *const [&i32; 3];
    let mut _66: *const [&i32; 3];
    let mut _67: *const [&i32; 2];
    let mut _68: *const ();
    let mut _69: usize;
    let mut _70: usize;
    let mut _71: usize;
    let mut _72: usize;
    let mut _73: bool;
    let mut _74: *const ();
    let mut _75: usize;
    let mut _76: usize;
    let mut _77: usize;
    let mut _78: usize;
    let mut _79: bool;
    let mut _80: *const ();
    let mut _81: usize;
    let mut _82: usize;
    let mut _83: usize;
    let mut _84: usize;
    let mut _85: bool;
    scope 1 {
    }
    scope 2 {
    }
    scope 3 {
        debug left_val => _26;
        debug right_val => _27;
        let _30: core::panicking::AssertKind;
        scope 4 {
            debug kind => _30;
        }
    }
    scope 5 {
    }
    scope 6 {
        debug left_val => _48;
        debug right_val => _49;
        let _52: core::panicking::AssertKind;
        scope 7 {
            debug kind => _52;
        }
    }

    bb0: {
        _6 = SizeOf([&i32; 3]);
        _7 = AlignOf([&i32; 3]);
        _8 = alloc::alloc::exchange_malloc(move _6, move _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = ShallowInitBox(move _8, [&i32; 3]);
        _11 = one() -> [return: bb2, unwind: bb31];
    }

    bb2: {
        _10 = &_11;
        _13 = one() -> [return: bb3, unwind: bb31];
    }

    bb3: {
        _12 = &_13;
        _58 = const _;
        _65 = (((_9.0: std::ptr::Unique<[&i32; 3]>).0: std::ptr::NonNull<[&i32; 3]>).0: *const [&i32; 3]);
        _80 = _65 as *const () (PtrToPtr);
        _81 = _80 as usize (Transmute);
        _82 = AlignOf(&i32);
        _83 = Sub(_82, const 1_usize);
        _84 = BitAnd(_81, _83);
        _85 = Eq(_84, const 0_usize);
        assert(_85, "misaligned pointer dereference: address must be a multiple of {} but is {}", _82, _81) -> [success: bb34, unwind unreachable];
    }

    bb4: {
        _2 = &_3;
        _18 = SizeOf([&i32; 3]);
        _19 = AlignOf([&i32; 3]);
        _20 = alloc::alloc::exchange_malloc(move _18, move _19) -> [return: bb5, unwind: bb27];
    }

    bb5: {
        _21 = ShallowInitBox(move _20, [&i32; 3]);
        _57 = const _;
        _56 = const _;
        _24 = one() -> [return: bb6, unwind: bb30];
    }

    bb6: {
        _25 = one() -> [return: bb7, unwind: bb30];
    }

    bb7: {
        _23 = Add(move _24, move _25);
        _22 = &_23;
        _66 = (((_21.0: std::ptr::Unique<[&i32; 3]>).0: std::ptr::NonNull<[&i32; 3]>).0: *const [&i32; 3]);
        _74 = _66 as *const () (PtrToPtr);
        _75 = _74 as usize (Transmute);
        _76 = AlignOf(&i32);
        _77 = Sub(_76, const 1_usize);
        _78 = BitAnd(_75, _77);
        _79 = Eq(_78, const 0_usize);
        assert(_79, "misaligned pointer dereference: address must be a multiple of {} but is {}", _76, _75) -> [success: bb33, unwind unreachable];
    }

    bb8: {
        _14 = &_15;
        _1 = (move _2, move _14);
        _26 = (_1.0: &std::vec::Vec<&i32>);
        _27 = (_1.1: &std::vec::Vec<&i32>);
        _29 = <Vec<&i32> as PartialEq>::eq(_26, _27) -> [return: bb9, unwind: bb26];
    }

    bb9: {
        _28 = Not(move _29);
        switchInt(move _28) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _30 = core::panicking::AssertKind::Eq;
        _32 = Option::<Arguments<'_>>::None;
        _31 = core::panicking::assert_failed::<Vec<&i32>, Vec<&i32>>(move _30, _26, _27, move _32) -> bb26;
    }

    bb11: {
        drop(_15) -> [return: bb12, unwind: bb27];
    }

    bb12: {
        drop(_3) -> [return: bb13, unwind continue];
    }

    bb13: {
        _37 = one() -> [return: bb14, unwind continue];
    }

    bb14: {
        _36 = &_37;
        _35 = from_elem::<&i32>(move _36, const 2_usize) -> [return: bb15, unwind continue];
    }

    bb15: {
        _34 = &_35;
        _42 = SizeOf([&i32; 2]);
        _43 = AlignOf([&i32; 2]);
        _44 = alloc::alloc::exchange_malloc(move _42, move _43) -> [return: bb16, unwind: bb25];
    }

    bb16: {
        _45 = ShallowInitBox(move _44, [&i32; 2]);
        _55 = const _;
        _47 = one() -> [return: bb17, unwind: bb29];
    }

    bb17: {
        _46 = &_47;
        _67 = (((_45.0: std::ptr::Unique<[&i32; 2]>).0: std::ptr::NonNull<[&i32; 2]>).0: *const [&i32; 2]);
        _68 = _67 as *const () (PtrToPtr);
        _69 = _68 as usize (Transmute);
        _70 = AlignOf(&i32);
        _71 = Sub(_70, const 1_usize);
        _72 = BitAnd(_69, _71);
        _73 = Eq(_72, const 0_usize);
        assert(_73, "misaligned pointer dereference: address must be a multiple of {} but is {}", _70, _69) -> [success: bb32, unwind unreachable];
    }

    bb18: {
        _38 = &_39;
        _33 = (move _34, move _38);
        _48 = (_33.0: &std::vec::Vec<&i32>);
        _49 = (_33.1: &std::vec::Vec<&i32>);
        _51 = <Vec<&i32> as PartialEq>::eq(_48, _49) -> [return: bb19, unwind: bb24];
    }

    bb19: {
        _50 = Not(move _51);
        switchInt(move _50) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _52 = core::panicking::AssertKind::Eq;
        _54 = Option::<Arguments<'_>>::None;
        _53 = core::panicking::assert_failed::<Vec<&i32>, Vec<&i32>>(move _52, _48, _49, move _54) -> bb24;
    }

    bb21: {
        drop(_39) -> [return: bb22, unwind: bb25];
    }

    bb22: {
        drop(_35) -> [return: bb23, unwind continue];
    }

    bb23: {
        return;
    }

    bb24 (cleanup): {
        drop(_39) -> [return: bb25, unwind terminate];
    }

    bb25 (cleanup): {
        drop(_35) -> [return: bb28, unwind terminate];
    }

    bb26 (cleanup): {
        drop(_15) -> [return: bb27, unwind terminate];
    }

    bb27 (cleanup): {
        drop(_3) -> [return: bb28, unwind terminate];
    }

    bb28 (cleanup): {
        resume;
    }

    bb29 (cleanup): {
        _59 = &mut _45;
        _60 = <Box<[&i32; 2]> as Drop>::drop(move _59) -> [return: bb35, unwind terminate];
    }

    bb30 (cleanup): {
        _61 = &mut _21;
        _62 = <Box<[&i32; 3]> as Drop>::drop(move _61) -> [return: bb36, unwind terminate];
    }

    bb31 (cleanup): {
        _63 = &mut _9;
        _64 = <Box<[&i32; 3]> as Drop>::drop(move _63) -> [return: bb37, unwind terminate];
    }

    bb32: {
        (*_67) = [_55, _46];
        _41 = move _45;
        _40 = move _41 as std::boxed::Box<[&i32]> (Pointer(Unsize));
        _39 = slice::<impl [&i32]>::into_vec::<std::alloc::Global>(move _40) -> [return: bb18, unwind: bb25];
    }

    bb33: {
        (*_66) = [_57, _56, _22];
        _17 = move _21;
        _16 = move _17 as std::boxed::Box<[&i32]> (Pointer(Unsize));
        _15 = slice::<impl [&i32]>::into_vec::<std::alloc::Global>(move _16) -> [return: bb8, unwind: bb27];
    }

    bb34: {
        (*_65) = [move _10, _12, _58];
        _5 = move _9;
        _4 = move _5 as std::boxed::Box<[&i32]> (Pointer(Unsize));
        _3 = slice::<impl [&i32]>::into_vec::<std::alloc::Global>(move _4) -> [return: bb4, unwind continue];
    }

    bb35 (cleanup): {
        goto -> bb25;
    }

    bb36 (cleanup): {
        goto -> bb27;
    }

    bb37 (cleanup): {
        goto -> bb28;
    }
}

promoted[0] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 1_i32;
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 1_i32;
        _0 = &_1;
        return;
    }
}

promoted[2] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 1_i32;
        _0 = &_1;
        return;
    }
}

promoted[3] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 2_i32;
        _0 = &_1;
        return;
    }
}
