// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn foo(_1: &[T]) -> Option<&[T]> {
    debug v => _1;
    let mut _0: std::option::Option<&[T]>;
    let mut _2: std::slice::Iter<'_, T>;
    let mut _3: std::ops::Range<i32>;
    let mut _4: std::ops::Range<i32>;
    let mut _6: std::option::Option<i32>;
    let mut _7: &mut std::ops::Range<i32>;
    let mut _8: isize;
    let mut _9: std::option::Option<&T>;
    let mut _10: &mut std::slice::Iter<'_, T>;
    let mut _11: &[T];
    let _12: &[T];
    let mut _13: &std::slice::Iter<'_, T>;
    scope 1 {
        debug it => _2;
        let mut _5: std::ops::Range<i32>;
        scope 2 {
            debug iter => _5;
            scope 3 {
            }
        }
    }

    bb0: {
        _2 = core::slice::<impl [T]>::iter(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = std::ops::Range::<i32> { start: const 0_i32, end: const 5_i32 };
        _3 = <std::ops::Range<i32> as IntoIterator>::into_iter(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = move _3;
        goto -> bb3;
    }

    bb3: {
        _7 = &mut _5;
        _6 = <std::ops::Range<i32> as Iterator>::next(_7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb7, 1: bb5, otherwise: bb6];
    }

    bb5: {
        _10 = &mut _2;
        _9 = <std::slice::Iter<'_, T> as Iterator>::next(move _10) -> [return: bb3, unwind continue];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _13 = &_2;
        _12 = std::slice::Iter::<'_, T>::as_slice(move _13) -> [return: bb8, unwind continue];
    }

    bb8: {
        _11 = _12;
        _0 = Option::<&[T]>::Some(move _11);
        return;
    }
}

fn foo_mut(_1: &mut [T]) -> Option<&mut [T]> {
    debug v => _1;
    let mut _0: std::option::Option<&mut [T]>;
    let mut _2: std::slice::IterMut<'_, T>;
    let mut _3: std::ops::Range<i32>;
    let mut _4: std::ops::Range<i32>;
    let mut _6: std::option::Option<i32>;
    let mut _7: &mut std::ops::Range<i32>;
    let mut _8: isize;
    let mut _9: std::option::Option<&mut T>;
    let mut _10: &mut std::slice::IterMut<'_, T>;
    let mut _11: &mut [T];
    let mut _12: &mut [T];
    let mut _13: std::slice::IterMut<'_, T>;
    scope 1 {
        debug it => _2;
        let mut _5: std::ops::Range<i32>;
        scope 2 {
            debug iter => _5;
            scope 3 {
            }
        }
    }

    bb0: {
        _2 = core::slice::<impl [T]>::iter_mut(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = std::ops::Range::<i32> { start: const 0_i32, end: const 5_i32 };
        _3 = <std::ops::Range<i32> as IntoIterator>::into_iter(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = move _3;
        goto -> bb3;
    }

    bb3: {
        _7 = &mut _5;
        _6 = <std::ops::Range<i32> as Iterator>::next(_7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb7, 1: bb5, otherwise: bb6];
    }

    bb5: {
        _10 = &mut _2;
        _9 = <std::slice::IterMut<'_, T> as Iterator>::next(move _10) -> [return: bb3, unwind continue];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _13 = move _2;
        _12 = std::slice::IterMut::<'_, T>::into_slice(move _13) -> [return: bb8, unwind continue];
    }

    bb8: {
        _11 = _12;
        _0 = Option::<&mut [T]>::Some(move _11);
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: &[()];
    let _2: &[()];
    let mut _3: *const ();
    let mut _4: (&usize, &usize);
    let mut _5: &usize;
    let _6: usize;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: usize;
    let mut _12: usize;
    let _14: !;
    let mut _15: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _16: (&usize, &usize);
    let mut _17: &usize;
    let _18: usize;
    let mut _19: std::slice::Iter<'_, ()>;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: usize;
    let mut _25: usize;
    let _27: !;
    let mut _28: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _30: bool;
    let mut _31: bool;
    let mut _32: &std::option::Option<&()>;
    let _33: std::option::Option<&()>;
    let mut _34: &mut std::slice::Iter<'_, ()>;
    let mut _35: !;
    let mut _36: (&usize, &usize);
    let mut _37: &usize;
    let _38: usize;
    let mut _39: std::slice::Iter<'_, ()>;
    let mut _42: bool;
    let mut _43: bool;
    let mut _44: usize;
    let mut _45: usize;
    let _47: !;
    let mut _48: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _49: bool;
    let mut _50: bool;
    let mut _51: &std::option::Option<&[()]>;
    let _52: std::option::Option<&[()]>;
    let mut _53: !;
    let mut _54: &mut [()];
    let mut _55: &mut [()];
    let mut _56: *mut ();
    let mut _57: (&usize, &usize);
    let mut _58: &usize;
    let _59: usize;
    let mut _60: &[()];
    let mut _63: bool;
    let mut _64: bool;
    let mut _65: usize;
    let mut _66: usize;
    let _68: !;
    let mut _69: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _70: (&usize, &usize);
    let mut _71: &usize;
    let _72: usize;
    let mut _73: std::slice::IterMut<'_, ()>;
    let mut _76: bool;
    let mut _77: bool;
    let mut _78: usize;
    let mut _79: usize;
    let _81: !;
    let mut _82: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _84: bool;
    let mut _85: bool;
    let mut _86: &std::option::Option<&mut ()>;
    let _87: std::option::Option<&mut ()>;
    let mut _88: &mut std::slice::IterMut<'_, ()>;
    let mut _89: !;
    let mut _90: (&usize, &usize);
    let mut _91: &usize;
    let _92: usize;
    let mut _93: std::slice::IterMut<'_, ()>;
    let mut _96: bool;
    let mut _97: bool;
    let mut _98: usize;
    let mut _99: usize;
    let _101: !;
    let mut _102: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _103: bool;
    let mut _104: bool;
    let mut _105: &std::option::Option<&mut [()]>;
    let _106: std::option::Option<&mut [()]>;
    let mut _107: !;
    scope 1 {
        debug slice => _1;
        let _7: &usize;
        let _8: &usize;
        let _20: &usize;
        let _21: &usize;
        let mut _29: std::slice::Iter<'_, ()>;
        let mut _112: &usize;
        let mut _113: &usize;
        scope 3 {
            debug left_val => _7;
            debug right_val => _8;
            let _13: core::panicking::AssertKind;
            scope 4 {
                debug kind => _13;
            }
        }
        scope 5 {
            debug left_val => _20;
            debug right_val => _21;
            let _26: core::panicking::AssertKind;
            scope 6 {
                debug kind => _26;
            }
        }
        scope 7 {
            debug it => _29;
            let _40: &usize;
            let _41: &usize;
            let mut _111: &usize;
            scope 8 {
                debug left_val => _40;
                debug right_val => _41;
                let _46: core::panicking::AssertKind;
                scope 9 {
                    debug kind => _46;
                }
            }
            scope 10 {
                debug slice => _54;
                let _61: &usize;
                let _62: &usize;
                let _74: &usize;
                let _75: &usize;
                let mut _83: std::slice::IterMut<'_, ()>;
                let mut _109: &usize;
                let mut _110: &usize;
                scope 12 {
                    debug left_val => _61;
                    debug right_val => _62;
                    let _67: core::panicking::AssertKind;
                    scope 13 {
                        debug kind => _67;
                    }
                }
                scope 14 {
                    debug left_val => _74;
                    debug right_val => _75;
                    let _80: core::panicking::AssertKind;
                    scope 15 {
                        debug kind => _80;
                    }
                }
                scope 16 {
                    debug it => _83;
                    let _94: &usize;
                    let _95: &usize;
                    let mut _108: &usize;
                    scope 17 {
                        debug left_val => _94;
                        debug right_val => _95;
                        let _100: core::panicking::AssertKind;
                        scope 18 {
                            debug kind => _100;
                        }
                    }
                }
            }
            scope 11 {
            }
        }
    }
    scope 2 {
    }

    bb0: {
        _3 = const -5_isize as *const () (PointerFromExposedAddress);
        _2 = std::slice::from_raw_parts::<'_, ()>(move _3, const 10_usize) -> [return: bb1, unwind continue];
    }

    bb1: {
        _1 = _2;
        _6 = Len((*_1));
        _5 = &_6;
        _113 = const _;
        _4 = (move _5, _113);
        _7 = (_4.0: &usize);
        _8 = (_4.1: &usize);
        _11 = (*_7);
        _12 = (*_8);
        _10 = Eq(move _11, move _12);
        _9 = Not(move _10);
        switchInt(move _9) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _13 = core::panicking::AssertKind::Eq;
        _15 = Option::<Arguments<'_>>::None;
        _14 = core::panicking::assert_failed::<usize, usize>(move _13, _7, _8, move _15) -> unwind continue;
    }

    bb3: {
        _19 = core::slice::<impl [()]>::iter(_1) -> [return: bb4, unwind continue];
    }

    bb4: {
        _18 = <std::slice::Iter<'_, ()> as Iterator>::count(move _19) -> [return: bb5, unwind continue];
    }

    bb5: {
        _17 = &_18;
        _112 = const _;
        _16 = (move _17, _112);
        _20 = (_16.0: &usize);
        _21 = (_16.1: &usize);
        _24 = (*_20);
        _25 = (*_21);
        _23 = Eq(move _24, move _25);
        _22 = Not(move _23);
        switchInt(move _22) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _26 = core::panicking::AssertKind::Eq;
        _28 = Option::<Arguments<'_>>::None;
        _27 = core::panicking::assert_failed::<usize, usize>(move _26, _20, _21, move _28) -> unwind continue;
    }

    bb7: {
        _29 = core::slice::<impl [()]>::iter(_1) -> [return: bb8, unwind continue];
    }

    bb8: {
        _34 = &mut _29;
        _33 = <std::slice::Iter<'_, ()> as Iterator>::nth(move _34, const 5_usize) -> [return: bb9, unwind continue];
    }

    bb9: {
        _32 = &_33;
        _31 = Option::<&()>::is_some(move _32) -> [return: bb10, unwind continue];
    }

    bb10: {
        _30 = Not(move _31);
        switchInt(move _30) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _35 = core::panicking::panic(const "assertion failed: it.nth(5).is_some()") -> unwind continue;
    }

    bb12: {
        _39 = move _29;
        _38 = <std::slice::Iter<'_, ()> as Iterator>::count(move _39) -> [return: bb13, unwind continue];
    }

    bb13: {
        _37 = &_38;
        _111 = const _;
        _36 = (move _37, _111);
        _40 = (_36.0: &usize);
        _41 = (_36.1: &usize);
        _44 = (*_40);
        _45 = (*_41);
        _43 = Eq(move _44, move _45);
        _42 = Not(move _43);
        switchInt(move _42) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _46 = core::panicking::AssertKind::Eq;
        _48 = Option::<Arguments<'_>>::None;
        _47 = core::panicking::assert_failed::<usize, usize>(move _46, _40, _41, move _48) -> unwind continue;
    }

    bb15: {
        _52 = foo::<()>(_1) -> [return: bb16, unwind continue];
    }

    bb16: {
        _51 = &_52;
        _50 = Option::<&[()]>::is_some(move _51) -> [return: bb17, unwind continue];
    }

    bb17: {
        _49 = Not(move _50);
        switchInt(move _49) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _53 = core::panicking::panic(const "assertion failed: foo(slice).is_some()") -> unwind continue;
    }

    bb19: {
        _56 = const -5_isize as *mut () (PointerFromExposedAddress);
        _55 = std::slice::from_raw_parts_mut::<'_, ()>(move _56, const 10_usize) -> [return: bb20, unwind continue];
    }

    bb20: {
        _54 = _55;
        _60 = &(*_54);
        _59 = Len((*_60));
        _58 = &_59;
        _110 = const _;
        _57 = (move _58, _110);
        _61 = (_57.0: &usize);
        _62 = (_57.1: &usize);
        _65 = (*_61);
        _66 = (*_62);
        _64 = Eq(move _65, move _66);
        _63 = Not(move _64);
        switchInt(move _63) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _67 = core::panicking::AssertKind::Eq;
        _69 = Option::<Arguments<'_>>::None;
        _68 = core::panicking::assert_failed::<usize, usize>(move _67, _61, _62, move _69) -> unwind continue;
    }

    bb22: {
        _73 = core::slice::<impl [()]>::iter_mut(_54) -> [return: bb23, unwind continue];
    }

    bb23: {
        _72 = <std::slice::IterMut<'_, ()> as Iterator>::count(move _73) -> [return: bb24, unwind continue];
    }

    bb24: {
        _71 = &_72;
        _109 = const _;
        _70 = (move _71, _109);
        _74 = (_70.0: &usize);
        _75 = (_70.1: &usize);
        _78 = (*_74);
        _79 = (*_75);
        _77 = Eq(move _78, move _79);
        _76 = Not(move _77);
        switchInt(move _76) -> [0: bb26, otherwise: bb25];
    }

    bb25: {
        _80 = core::panicking::AssertKind::Eq;
        _82 = Option::<Arguments<'_>>::None;
        _81 = core::panicking::assert_failed::<usize, usize>(move _80, _74, _75, move _82) -> unwind continue;
    }

    bb26: {
        _83 = core::slice::<impl [()]>::iter_mut(_54) -> [return: bb27, unwind continue];
    }

    bb27: {
        _88 = &mut _83;
        _87 = <std::slice::IterMut<'_, ()> as Iterator>::nth(move _88, const 5_usize) -> [return: bb28, unwind continue];
    }

    bb28: {
        _86 = &_87;
        _85 = Option::<&mut ()>::is_some(move _86) -> [return: bb29, unwind continue];
    }

    bb29: {
        _84 = Not(move _85);
        switchInt(move _84) -> [0: bb31, otherwise: bb30];
    }

    bb30: {
        _89 = core::panicking::panic(const "assertion failed: it.nth(5).is_some()") -> unwind continue;
    }

    bb31: {
        _93 = move _83;
        _92 = <std::slice::IterMut<'_, ()> as Iterator>::count(move _93) -> [return: bb32, unwind continue];
    }

    bb32: {
        _91 = &_92;
        _108 = const _;
        _90 = (move _91, _108);
        _94 = (_90.0: &usize);
        _95 = (_90.1: &usize);
        _98 = (*_94);
        _99 = (*_95);
        _97 = Eq(move _98, move _99);
        _96 = Not(move _97);
        switchInt(move _96) -> [0: bb34, otherwise: bb33];
    }

    bb33: {
        _100 = core::panicking::AssertKind::Eq;
        _102 = Option::<Arguments<'_>>::None;
        _101 = core::panicking::assert_failed::<usize, usize>(move _100, _94, _95, move _102) -> unwind continue;
    }

    bb34: {
        _106 = foo_mut::<()>(_54) -> [return: bb35, unwind continue];
    }

    bb35: {
        _105 = &_106;
        _104 = Option::<&mut [()]>::is_some(move _105) -> [return: bb36, unwind continue];
    }

    bb36: {
        _103 = Not(move _104);
        switchInt(move _103) -> [0: bb38, otherwise: bb37];
    }

    bb37: {
        _107 = core::panicking::panic(const "assertion failed: foo_mut(slice).is_some()") -> unwind continue;
    }

    bb38: {
        return;
    }
}

promoted[0] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 4_usize;
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 10_usize;
        _0 = &_1;
        return;
    }
}

promoted[2] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 10_usize;
        _0 = &_1;
        return;
    }
}

promoted[3] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 4_usize;
        _0 = &_1;
        return;
    }
}

promoted[4] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 10_usize;
        _0 = &_1;
        return;
    }
}

promoted[5] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 10_usize;
        _0 = &_1;
        return;
    }
}
