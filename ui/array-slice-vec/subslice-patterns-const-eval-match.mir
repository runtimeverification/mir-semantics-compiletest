// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/array-slice-vec/subslice-patterns-const-eval-match.rs:5:10: 5:19>::eq(_1: &N, _2: &N) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u8;
    let mut _4: u8;

    bb0: {
        _3 = ((*_1).0: u8);
        _4 = ((*_2).0: u8);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn <impl at ui/array-slice-vec/subslice-patterns-const-eval-match.rs:5:21: 5:26>::fmt(_1: &N, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&u8;
    let _6: &u8;

    bb0: {
        _3 = const "N";
        _6 = &((*_1).0: u8);
        _5 = &_6;
        _4 = _5 as &dyn std::fmt::Debug (Pointer(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/array-slice-vec/subslice-patterns-const-eval-match.rs:5:28: 5:33>::clone(_1: &N) -> N {
    debug self => _1;
    let mut _0: N;
    let mut _2: u8;
    let _3: &u8;

    bb0: {
        _3 = &((*_1).0: u8);
        _2 = (*_3);
        _0 = N(move _2);
        return;
    }
}

fn <impl at ui/array-slice-vec/subslice-patterns-const-eval-match.rs:8:10: 8:19>::eq(_1: &Z, _2: &Z) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;

    bb0: {
        _0 = const true;
        return;
    }
}

fn <impl at ui/array-slice-vec/subslice-patterns-const-eval-match.rs:8:21: 8:26>::fmt(_1: &Z, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Z";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/array-slice-vec/subslice-patterns-const-eval-match.rs:8:28: 8:33>::clone(_1: &Z) -> Z {
    debug self => _1;
    let mut _0: Z;

    bb0: {
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: std::option::Option<&[N]>;
    let mut _2: &[N];
    let mut _3: usize;
    let mut _4: usize;
    let mut _5: bool;
    let mut _7: (&std::option::Option<&[N]>, &std::option::Option<&[N]>);
    let mut _8: &std::option::Option<&[N]>;
    let mut _11: bool;
    let mut _12: bool;
    let _14: !;
    let mut _15: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _16: (&std::option::Option<&[N]>, &std::option::Option<&[N]>);
    let _17: &std::option::Option<&[N]>;
    let mut _18: &std::option::Option<&[N]>;
    let mut _21: bool;
    let mut _22: bool;
    let _24: !;
    let mut _25: std::option::Option<std::fmt::Arguments<'_>>;
    let _26: std::option::Option<&[N]>;
    let mut _27: &[N];
    let mut _28: usize;
    let mut _29: usize;
    let mut _30: bool;
    let _31: &[N];
    let mut _32: (&std::option::Option<&[N]>, &std::option::Option<&[N]>);
    let mut _33: &std::option::Option<&[N]>;
    let mut _36: bool;
    let mut _37: bool;
    let _39: !;
    let mut _40: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _41: (&std::option::Option<&[N]>, &std::option::Option<&[N]>);
    let _42: &std::option::Option<&[N]>;
    let mut _43: &std::option::Option<&[N]>;
    let mut _46: bool;
    let mut _47: bool;
    let _49: !;
    let mut _50: std::option::Option<std::fmt::Arguments<'_>>;
    let _51: std::option::Option<&N>;
    let mut _52: &[N];
    let mut _53: usize;
    let mut _54: usize;
    let mut _55: bool;
    let mut _57: (&std::option::Option<&N>, &std::option::Option<&N>);
    let mut _58: &std::option::Option<&N>;
    let mut _61: bool;
    let mut _62: bool;
    let _64: !;
    let mut _65: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _66: (&std::option::Option<&N>, &std::option::Option<&N>);
    let _67: &std::option::Option<&N>;
    let mut _68: &std::option::Option<&N>;
    let mut _71: bool;
    let mut _72: bool;
    let _74: !;
    let mut _75: std::option::Option<std::fmt::Arguments<'_>>;
    let _76: std::option::Option<&N>;
    let mut _77: &[N];
    let mut _78: usize;
    let mut _79: usize;
    let mut _80: bool;
    let _81: &N;
    let mut _82: (&std::option::Option<&N>, &std::option::Option<&N>);
    let mut _83: &std::option::Option<&N>;
    let mut _86: bool;
    let mut _87: bool;
    let _89: !;
    let mut _90: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _91: (&std::option::Option<&N>, &std::option::Option<&N>);
    let _92: &std::option::Option<&N>;
    let mut _93: &std::option::Option<&N>;
    let mut _96: bool;
    let mut _97: bool;
    let _99: !;
    let mut _100: std::option::Option<std::fmt::Arguments<'_>>;
    let _101: std::option::Option<&N>;
    let mut _102: &[N];
    let mut _103: usize;
    let mut _104: usize;
    let mut _105: bool;
    let mut _107: (&std::option::Option<&N>, &std::option::Option<&N>);
    let mut _108: &std::option::Option<&N>;
    let mut _111: bool;
    let mut _112: bool;
    let _114: !;
    let mut _115: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _116: (&std::option::Option<&N>, &std::option::Option<&N>);
    let _117: &std::option::Option<&N>;
    let mut _118: &std::option::Option<&N>;
    let mut _121: bool;
    let mut _122: bool;
    let _124: !;
    let mut _125: std::option::Option<std::fmt::Arguments<'_>>;
    let _126: std::option::Option<&N>;
    let mut _127: &[N];
    let mut _128: usize;
    let mut _129: usize;
    let mut _130: bool;
    let _131: &N;
    let mut _132: (&std::option::Option<&N>, &std::option::Option<&N>);
    let mut _133: &std::option::Option<&N>;
    let mut _136: bool;
    let mut _137: bool;
    let _139: !;
    let mut _140: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _141: (&std::option::Option<&N>, &std::option::Option<&N>);
    let _142: &std::option::Option<&N>;
    let mut _143: &std::option::Option<&N>;
    let mut _146: bool;
    let mut _147: bool;
    let _149: !;
    let mut _150: std::option::Option<std::fmt::Arguments<'_>>;
    let _151: std::option::Option<&[N]>;
    let mut _152: &[N];
    let mut _153: usize;
    let mut _154: usize;
    let mut _155: bool;
    let mut _157: (&std::option::Option<&[N]>, &std::option::Option<&[N]>);
    let mut _158: &std::option::Option<&[N]>;
    let mut _161: bool;
    let mut _162: bool;
    let _164: !;
    let mut _165: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _166: (&std::option::Option<&[N]>, &std::option::Option<&[N]>);
    let _167: &std::option::Option<&[N]>;
    let mut _168: &std::option::Option<&[N]>;
    let mut _171: bool;
    let mut _172: bool;
    let _174: !;
    let mut _175: std::option::Option<std::fmt::Arguments<'_>>;
    let _176: std::option::Option<&[N]>;
    let mut _177: &[N];
    let mut _178: usize;
    let mut _179: usize;
    let mut _180: bool;
    let _181: &[N];
    let mut _182: (&std::option::Option<&[N]>, &std::option::Option<&[N]>);
    let mut _183: &std::option::Option<&[N]>;
    let mut _186: bool;
    let mut _187: bool;
    let _189: !;
    let mut _190: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _191: (&std::option::Option<&[N]>, &std::option::Option<&[N]>);
    let _192: &std::option::Option<&[N]>;
    let mut _193: &std::option::Option<&[N]>;
    let mut _196: bool;
    let mut _197: bool;
    let _199: !;
    let mut _200: std::option::Option<std::fmt::Arguments<'_>>;
    let _201: std::option::Option<&N>;
    let mut _202: &[N];
    let mut _203: usize;
    let mut _204: usize;
    let mut _205: bool;
    let mut _207: (&std::option::Option<&N>, &std::option::Option<&N>);
    let mut _208: &std::option::Option<&N>;
    let mut _211: bool;
    let mut _212: bool;
    let _214: !;
    let mut _215: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _216: (&std::option::Option<&N>, &std::option::Option<&N>);
    let _217: &std::option::Option<&N>;
    let mut _218: &std::option::Option<&N>;
    let mut _221: bool;
    let mut _222: bool;
    let _224: !;
    let mut _225: std::option::Option<std::fmt::Arguments<'_>>;
    let _226: std::option::Option<&N>;
    let mut _227: &[N];
    let mut _228: usize;
    let mut _229: usize;
    let mut _230: bool;
    let _231: &N;
    let mut _232: (&std::option::Option<&N>, &std::option::Option<&N>);
    let mut _233: &std::option::Option<&N>;
    let mut _236: bool;
    let mut _237: bool;
    let _239: !;
    let mut _240: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _241: (&std::option::Option<&N>, &std::option::Option<&N>);
    let _242: &std::option::Option<&N>;
    let mut _243: &std::option::Option<&N>;
    let mut _246: bool;
    let mut _247: bool;
    let _249: !;
    let mut _250: std::option::Option<std::fmt::Arguments<'_>>;
    let _251: std::option::Option<&N>;
    let mut _252: &[N];
    let mut _253: usize;
    let mut _254: usize;
    let mut _255: bool;
    let mut _257: (&std::option::Option<&N>, &std::option::Option<&N>);
    let mut _258: &std::option::Option<&N>;
    let mut _261: bool;
    let mut _262: bool;
    let _264: !;
    let mut _265: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _266: (&std::option::Option<&N>, &std::option::Option<&N>);
    let _267: &std::option::Option<&N>;
    let mut _268: &std::option::Option<&N>;
    let mut _271: bool;
    let mut _272: bool;
    let _274: !;
    let mut _275: std::option::Option<std::fmt::Arguments<'_>>;
    let _276: std::option::Option<&N>;
    let mut _277: &[N];
    let mut _278: usize;
    let mut _279: usize;
    let mut _280: bool;
    let _281: &N;
    let mut _282: (&std::option::Option<&N>, &std::option::Option<&N>);
    let mut _283: &std::option::Option<&N>;
    let mut _286: bool;
    let mut _287: bool;
    let _289: !;
    let mut _290: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _291: (&std::option::Option<&N>, &std::option::Option<&N>);
    let _292: &std::option::Option<&N>;
    let mut _293: &std::option::Option<&N>;
    let mut _296: bool;
    let mut _297: bool;
    let _299: !;
    let mut _300: std::option::Option<std::fmt::Arguments<'_>>;
    let _301: std::option::Option<&[N]>;
    let mut _302: &[N];
    let mut _303: usize;
    let mut _304: usize;
    let mut _305: bool;
    let mut _307: (&std::option::Option<&[N]>, &std::option::Option<&[N]>);
    let mut _308: &std::option::Option<&[N]>;
    let mut _311: bool;
    let mut _312: bool;
    let _314: !;
    let mut _315: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _316: (&std::option::Option<&[N]>, &std::option::Option<&[N]>);
    let _317: &std::option::Option<&[N]>;
    let mut _318: &std::option::Option<&[N]>;
    let mut _321: bool;
    let mut _322: bool;
    let _324: !;
    let mut _325: std::option::Option<std::fmt::Arguments<'_>>;
    let _326: std::option::Option<&[N]>;
    let mut _327: &[N];
    let mut _328: usize;
    let mut _329: usize;
    let mut _330: bool;
    let _331: &[N];
    let mut _332: (&std::option::Option<&[N]>, &std::option::Option<&[N]>);
    let mut _333: &std::option::Option<&[N]>;
    let mut _336: bool;
    let mut _337: bool;
    let _339: !;
    let mut _340: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _341: (&std::option::Option<&[N]>, &std::option::Option<&[N]>);
    let _342: &std::option::Option<&[N]>;
    let mut _343: &std::option::Option<&[N]>;
    let mut _346: bool;
    let mut _347: bool;
    let _349: !;
    let mut _350: std::option::Option<std::fmt::Arguments<'_>>;
    let _351: std::option::Option<&N>;
    let mut _352: &[N];
    let mut _353: usize;
    let mut _354: usize;
    let mut _355: bool;
    let mut _357: (&std::option::Option<&N>, &std::option::Option<&N>);
    let mut _358: &std::option::Option<&N>;
    let mut _361: bool;
    let mut _362: bool;
    let _364: !;
    let mut _365: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _366: (&std::option::Option<&N>, &std::option::Option<&N>);
    let _367: &std::option::Option<&N>;
    let mut _368: &std::option::Option<&N>;
    let mut _371: bool;
    let mut _372: bool;
    let _374: !;
    let mut _375: std::option::Option<std::fmt::Arguments<'_>>;
    let _376: std::option::Option<&N>;
    let mut _377: &[N];
    let mut _378: usize;
    let mut _379: usize;
    let mut _380: bool;
    let _381: &N;
    let mut _382: (&std::option::Option<&N>, &std::option::Option<&N>);
    let mut _383: &std::option::Option<&N>;
    let mut _386: bool;
    let mut _387: bool;
    let _389: !;
    let mut _390: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _391: (&std::option::Option<&N>, &std::option::Option<&N>);
    let _392: &std::option::Option<&N>;
    let mut _393: &std::option::Option<&N>;
    let mut _396: bool;
    let mut _397: bool;
    let _399: !;
    let mut _400: std::option::Option<std::fmt::Arguments<'_>>;
    let _401: std::option::Option<&N>;
    let mut _402: &[N];
    let mut _403: usize;
    let mut _404: usize;
    let mut _405: bool;
    let mut _407: (&std::option::Option<&N>, &std::option::Option<&N>);
    let mut _408: &std::option::Option<&N>;
    let mut _411: bool;
    let mut _412: bool;
    let _414: !;
    let mut _415: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _416: (&std::option::Option<&N>, &std::option::Option<&N>);
    let _417: &std::option::Option<&N>;
    let mut _418: &std::option::Option<&N>;
    let mut _421: bool;
    let mut _422: bool;
    let _424: !;
    let mut _425: std::option::Option<std::fmt::Arguments<'_>>;
    let _426: std::option::Option<&N>;
    let mut _427: &[N];
    let mut _428: usize;
    let mut _429: usize;
    let mut _430: bool;
    let _431: &N;
    let mut _432: (&std::option::Option<&N>, &std::option::Option<&N>);
    let mut _433: &std::option::Option<&N>;
    let mut _436: bool;
    let mut _437: bool;
    let _439: !;
    let mut _440: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _441: (&std::option::Option<&N>, &std::option::Option<&N>);
    let _442: &std::option::Option<&N>;
    let mut _443: &std::option::Option<&N>;
    let mut _446: bool;
    let mut _447: bool;
    let _449: !;
    let mut _450: std::option::Option<std::fmt::Arguments<'_>>;
    let _451: std::option::Option<&[Z]>;
    let mut _452: &[Z];
    let mut _453: usize;
    let mut _454: usize;
    let mut _455: bool;
    let mut _457: (&std::option::Option<&[Z]>, &std::option::Option<&[Z]>);
    let mut _458: &std::option::Option<&[Z]>;
    let mut _461: bool;
    let mut _462: bool;
    let _464: !;
    let mut _465: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _466: (&std::option::Option<&[Z]>, &std::option::Option<&[Z]>);
    let _467: &std::option::Option<&[Z]>;
    let mut _468: &std::option::Option<&[Z]>;
    let mut _471: bool;
    let mut _472: bool;
    let _474: !;
    let mut _475: std::option::Option<std::fmt::Arguments<'_>>;
    let _476: std::option::Option<&[Z]>;
    let mut _477: &[Z];
    let mut _478: usize;
    let mut _479: usize;
    let mut _480: bool;
    let _481: &[Z];
    let mut _482: (&std::option::Option<&[Z]>, &std::option::Option<&[Z]>);
    let mut _483: &std::option::Option<&[Z]>;
    let mut _486: bool;
    let mut _487: bool;
    let _489: !;
    let mut _490: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _491: (&std::option::Option<&[Z]>, &std::option::Option<&[Z]>);
    let _492: &std::option::Option<&[Z]>;
    let mut _493: &std::option::Option<&[Z]>;
    let mut _496: bool;
    let mut _497: bool;
    let _499: !;
    let mut _500: std::option::Option<std::fmt::Arguments<'_>>;
    let _501: std::option::Option<&Z>;
    let mut _502: &[Z];
    let mut _503: usize;
    let mut _504: usize;
    let mut _505: bool;
    let mut _507: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let mut _508: &std::option::Option<&Z>;
    let mut _511: bool;
    let mut _512: bool;
    let _514: !;
    let mut _515: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _516: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let _517: &std::option::Option<&Z>;
    let mut _518: &std::option::Option<&Z>;
    let mut _521: bool;
    let mut _522: bool;
    let _524: !;
    let mut _525: std::option::Option<std::fmt::Arguments<'_>>;
    let _526: std::option::Option<&Z>;
    let mut _527: &[Z];
    let mut _528: usize;
    let mut _529: usize;
    let mut _530: bool;
    let _531: &Z;
    let mut _532: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let mut _533: &std::option::Option<&Z>;
    let mut _536: bool;
    let mut _537: bool;
    let _539: !;
    let mut _540: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _541: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let _542: &std::option::Option<&Z>;
    let mut _543: &std::option::Option<&Z>;
    let mut _546: bool;
    let mut _547: bool;
    let _549: !;
    let mut _550: std::option::Option<std::fmt::Arguments<'_>>;
    let _551: std::option::Option<&Z>;
    let mut _552: &[Z];
    let mut _553: usize;
    let mut _554: usize;
    let mut _555: bool;
    let mut _557: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let mut _558: &std::option::Option<&Z>;
    let mut _561: bool;
    let mut _562: bool;
    let _564: !;
    let mut _565: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _566: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let _567: &std::option::Option<&Z>;
    let mut _568: &std::option::Option<&Z>;
    let mut _571: bool;
    let mut _572: bool;
    let _574: !;
    let mut _575: std::option::Option<std::fmt::Arguments<'_>>;
    let _576: std::option::Option<&Z>;
    let mut _577: &[Z];
    let mut _578: usize;
    let mut _579: usize;
    let mut _580: bool;
    let _581: &Z;
    let mut _582: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let mut _583: &std::option::Option<&Z>;
    let mut _586: bool;
    let mut _587: bool;
    let _589: !;
    let mut _590: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _591: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let _592: &std::option::Option<&Z>;
    let mut _593: &std::option::Option<&Z>;
    let mut _596: bool;
    let mut _597: bool;
    let _599: !;
    let mut _600: std::option::Option<std::fmt::Arguments<'_>>;
    let _601: std::option::Option<&[Z]>;
    let mut _602: &[Z];
    let mut _603: usize;
    let mut _604: usize;
    let mut _605: bool;
    let mut _607: (&std::option::Option<&[Z]>, &std::option::Option<&[Z]>);
    let mut _608: &std::option::Option<&[Z]>;
    let mut _611: bool;
    let mut _612: bool;
    let _614: !;
    let mut _615: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _616: (&std::option::Option<&[Z]>, &std::option::Option<&[Z]>);
    let _617: &std::option::Option<&[Z]>;
    let mut _618: &std::option::Option<&[Z]>;
    let mut _621: bool;
    let mut _622: bool;
    let _624: !;
    let mut _625: std::option::Option<std::fmt::Arguments<'_>>;
    let _626: std::option::Option<&[Z]>;
    let mut _627: &[Z];
    let mut _628: usize;
    let mut _629: usize;
    let mut _630: bool;
    let _631: &[Z];
    let mut _632: (&std::option::Option<&[Z]>, &std::option::Option<&[Z]>);
    let mut _633: &std::option::Option<&[Z]>;
    let mut _636: bool;
    let mut _637: bool;
    let _639: !;
    let mut _640: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _641: (&std::option::Option<&[Z]>, &std::option::Option<&[Z]>);
    let _642: &std::option::Option<&[Z]>;
    let mut _643: &std::option::Option<&[Z]>;
    let mut _646: bool;
    let mut _647: bool;
    let _649: !;
    let mut _650: std::option::Option<std::fmt::Arguments<'_>>;
    let _651: std::option::Option<&Z>;
    let mut _652: &[Z];
    let mut _653: usize;
    let mut _654: usize;
    let mut _655: bool;
    let mut _657: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let mut _658: &std::option::Option<&Z>;
    let mut _661: bool;
    let mut _662: bool;
    let _664: !;
    let mut _665: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _666: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let _667: &std::option::Option<&Z>;
    let mut _668: &std::option::Option<&Z>;
    let mut _671: bool;
    let mut _672: bool;
    let _674: !;
    let mut _675: std::option::Option<std::fmt::Arguments<'_>>;
    let _676: std::option::Option<&Z>;
    let mut _677: &[Z];
    let mut _678: usize;
    let mut _679: usize;
    let mut _680: bool;
    let _681: &Z;
    let mut _682: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let mut _683: &std::option::Option<&Z>;
    let mut _686: bool;
    let mut _687: bool;
    let _689: !;
    let mut _690: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _691: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let _692: &std::option::Option<&Z>;
    let mut _693: &std::option::Option<&Z>;
    let mut _696: bool;
    let mut _697: bool;
    let _699: !;
    let mut _700: std::option::Option<std::fmt::Arguments<'_>>;
    let _701: std::option::Option<&Z>;
    let mut _702: &[Z];
    let mut _703: usize;
    let mut _704: usize;
    let mut _705: bool;
    let mut _707: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let mut _708: &std::option::Option<&Z>;
    let mut _711: bool;
    let mut _712: bool;
    let _714: !;
    let mut _715: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _716: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let _717: &std::option::Option<&Z>;
    let mut _718: &std::option::Option<&Z>;
    let mut _721: bool;
    let mut _722: bool;
    let _724: !;
    let mut _725: std::option::Option<std::fmt::Arguments<'_>>;
    let _726: std::option::Option<&Z>;
    let mut _727: &[Z];
    let mut _728: usize;
    let mut _729: usize;
    let mut _730: bool;
    let _731: &Z;
    let mut _732: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let mut _733: &std::option::Option<&Z>;
    let mut _736: bool;
    let mut _737: bool;
    let _739: !;
    let mut _740: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _741: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let _742: &std::option::Option<&Z>;
    let mut _743: &std::option::Option<&Z>;
    let mut _746: bool;
    let mut _747: bool;
    let _749: !;
    let mut _750: std::option::Option<std::fmt::Arguments<'_>>;
    let _751: std::option::Option<&[Z]>;
    let mut _752: &[Z];
    let mut _753: usize;
    let mut _754: usize;
    let mut _755: bool;
    let mut _757: (&std::option::Option<&[Z]>, &std::option::Option<&[Z]>);
    let mut _758: &std::option::Option<&[Z]>;
    let mut _761: bool;
    let mut _762: bool;
    let _764: !;
    let mut _765: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _766: (&std::option::Option<&[Z]>, &std::option::Option<&[Z]>);
    let _767: &std::option::Option<&[Z]>;
    let mut _768: &std::option::Option<&[Z]>;
    let mut _771: bool;
    let mut _772: bool;
    let _774: !;
    let mut _775: std::option::Option<std::fmt::Arguments<'_>>;
    let _776: std::option::Option<&[Z]>;
    let mut _777: &[Z];
    let mut _778: usize;
    let mut _779: usize;
    let mut _780: bool;
    let _781: &[Z];
    let mut _782: (&std::option::Option<&[Z]>, &std::option::Option<&[Z]>);
    let mut _783: &std::option::Option<&[Z]>;
    let mut _786: bool;
    let mut _787: bool;
    let _789: !;
    let mut _790: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _791: (&std::option::Option<&[Z]>, &std::option::Option<&[Z]>);
    let _792: &std::option::Option<&[Z]>;
    let mut _793: &std::option::Option<&[Z]>;
    let mut _796: bool;
    let mut _797: bool;
    let _799: !;
    let mut _800: std::option::Option<std::fmt::Arguments<'_>>;
    let _801: std::option::Option<&Z>;
    let mut _802: &[Z];
    let mut _803: usize;
    let mut _804: usize;
    let mut _805: bool;
    let mut _807: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let mut _808: &std::option::Option<&Z>;
    let mut _811: bool;
    let mut _812: bool;
    let _814: !;
    let mut _815: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _816: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let _817: &std::option::Option<&Z>;
    let mut _818: &std::option::Option<&Z>;
    let mut _821: bool;
    let mut _822: bool;
    let _824: !;
    let mut _825: std::option::Option<std::fmt::Arguments<'_>>;
    let _826: std::option::Option<&Z>;
    let mut _827: &[Z];
    let mut _828: usize;
    let mut _829: usize;
    let mut _830: bool;
    let _831: &Z;
    let mut _832: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let mut _833: &std::option::Option<&Z>;
    let mut _836: bool;
    let mut _837: bool;
    let _839: !;
    let mut _840: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _841: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let _842: &std::option::Option<&Z>;
    let mut _843: &std::option::Option<&Z>;
    let mut _846: bool;
    let mut _847: bool;
    let _849: !;
    let mut _850: std::option::Option<std::fmt::Arguments<'_>>;
    let _851: std::option::Option<&Z>;
    let mut _852: &[Z];
    let mut _853: usize;
    let mut _854: usize;
    let mut _855: bool;
    let mut _857: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let mut _858: &std::option::Option<&Z>;
    let mut _861: bool;
    let mut _862: bool;
    let _864: !;
    let mut _865: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _866: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let _867: &std::option::Option<&Z>;
    let mut _868: &std::option::Option<&Z>;
    let mut _871: bool;
    let mut _872: bool;
    let _874: !;
    let mut _875: std::option::Option<std::fmt::Arguments<'_>>;
    let _876: std::option::Option<&Z>;
    let mut _877: &[Z];
    let mut _878: usize;
    let mut _879: usize;
    let mut _880: bool;
    let _881: &Z;
    let mut _882: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let mut _883: &std::option::Option<&Z>;
    let mut _886: bool;
    let mut _887: bool;
    let _889: !;
    let mut _890: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _891: (&std::option::Option<&Z>, &std::option::Option<&Z>);
    let _892: &std::option::Option<&Z>;
    let mut _893: &std::option::Option<&Z>;
    let mut _896: bool;
    let mut _897: bool;
    let _899: !;
    let mut _900: std::option::Option<std::fmt::Arguments<'_>>;
    let _901: std::option::Option<&u8>;
    let mut _902: &[N];
    let mut _903: usize;
    let mut _904: usize;
    let mut _905: bool;
    let mut _907: (&std::option::Option<&u8>, &std::option::Option<&u8>);
    let mut _908: &std::option::Option<&u8>;
    let mut _911: bool;
    let mut _912: bool;
    let _914: !;
    let mut _915: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _916: (&std::option::Option<&u8>, &std::option::Option<&u8>);
    let _917: &std::option::Option<&u8>;
    let mut _918: &std::option::Option<&u8>;
    let mut _921: bool;
    let mut _922: bool;
    let _924: !;
    let mut _925: std::option::Option<std::fmt::Arguments<'_>>;
    let _926: std::option::Option<&u8>;
    let mut _927: &[N];
    let mut _928: usize;
    let mut _929: usize;
    let mut _930: bool;
    let _931: &u8;
    let mut _932: (&std::option::Option<&u8>, &std::option::Option<&u8>);
    let mut _933: &std::option::Option<&u8>;
    let mut _936: bool;
    let mut _937: bool;
    let _939: !;
    let mut _940: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _941: (&std::option::Option<&u8>, &std::option::Option<&u8>);
    let _942: &std::option::Option<&u8>;
    let mut _943: &std::option::Option<&u8>;
    let mut _946: bool;
    let mut _947: bool;
    let _949: !;
    let mut _950: std::option::Option<std::fmt::Arguments<'_>>;
    let _951: std::option::Option<&u8>;
    let mut _952: &[N];
    let mut _953: usize;
    let mut _954: usize;
    let mut _955: bool;
    let mut _957: (&std::option::Option<&u8>, &std::option::Option<&u8>);
    let mut _958: &std::option::Option<&u8>;
    let mut _961: bool;
    let mut _962: bool;
    let _964: !;
    let mut _965: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _966: (&std::option::Option<&u8>, &std::option::Option<&u8>);
    let _967: &std::option::Option<&u8>;
    let mut _968: &std::option::Option<&u8>;
    let mut _971: bool;
    let mut _972: bool;
    let _974: !;
    let mut _975: std::option::Option<std::fmt::Arguments<'_>>;
    let _976: std::option::Option<&u8>;
    let mut _977: &[N];
    let mut _978: usize;
    let mut _979: usize;
    let mut _980: bool;
    let _981: &u8;
    let mut _982: (&std::option::Option<&u8>, &std::option::Option<&u8>);
    let mut _983: &std::option::Option<&u8>;
    let mut _986: bool;
    let mut _987: bool;
    let _989: !;
    let mut _990: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _991: (&std::option::Option<&u8>, &std::option::Option<&u8>);
    let _992: &std::option::Option<&u8>;
    let mut _993: &std::option::Option<&u8>;
    let mut _996: bool;
    let mut _997: bool;
    let _999: !;
    let mut _1000: std::option::Option<std::fmt::Arguments<'_>>;
    let _1001: std::option::Option<&u8>;
    let mut _1002: &[N];
    let mut _1003: usize;
    let mut _1004: usize;
    let mut _1005: bool;
    let mut _1007: (&std::option::Option<&u8>, &std::option::Option<&u8>);
    let mut _1008: &std::option::Option<&u8>;
    let mut _1011: bool;
    let mut _1012: bool;
    let _1014: !;
    let mut _1015: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _1016: (&std::option::Option<&u8>, &std::option::Option<&u8>);
    let _1017: &std::option::Option<&u8>;
    let mut _1018: &std::option::Option<&u8>;
    let mut _1021: bool;
    let mut _1022: bool;
    let _1024: !;
    let mut _1025: std::option::Option<std::fmt::Arguments<'_>>;
    let _1026: std::option::Option<&u8>;
    let mut _1027: &[N];
    let mut _1028: usize;
    let mut _1029: usize;
    let mut _1030: bool;
    let _1031: &u8;
    let mut _1032: (&std::option::Option<&u8>, &std::option::Option<&u8>);
    let mut _1033: &std::option::Option<&u8>;
    let mut _1036: bool;
    let mut _1037: bool;
    let _1039: !;
    let mut _1040: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _1041: (&std::option::Option<&u8>, &std::option::Option<&u8>);
    let _1042: &std::option::Option<&u8>;
    let mut _1043: &std::option::Option<&u8>;
    let mut _1046: bool;
    let mut _1047: bool;
    let _1049: !;
    let mut _1050: std::option::Option<std::fmt::Arguments<'_>>;
    let _1051: std::option::Option<&u8>;
    let mut _1052: &[N];
    let mut _1053: usize;
    let mut _1054: usize;
    let mut _1055: bool;
    let mut _1057: (&std::option::Option<&u8>, &std::option::Option<&u8>);
    let mut _1058: &std::option::Option<&u8>;
    let mut _1061: bool;
    let mut _1062: bool;
    let _1064: !;
    let mut _1065: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _1066: (&std::option::Option<&u8>, &std::option::Option<&u8>);
    let _1067: &std::option::Option<&u8>;
    let mut _1068: &std::option::Option<&u8>;
    let mut _1071: bool;
    let mut _1072: bool;
    let _1074: !;
    let mut _1075: std::option::Option<std::fmt::Arguments<'_>>;
    let _1076: std::option::Option<&u8>;
    let mut _1077: &[N];
    let mut _1078: usize;
    let mut _1079: usize;
    let mut _1080: bool;
    let _1081: &u8;
    let mut _1082: (&std::option::Option<&u8>, &std::option::Option<&u8>);
    let mut _1083: &std::option::Option<&u8>;
    let mut _1086: bool;
    let mut _1087: bool;
    let _1089: !;
    let mut _1090: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _1091: (&std::option::Option<&u8>, &std::option::Option<&u8>);
    let _1092: &std::option::Option<&u8>;
    let mut _1093: &std::option::Option<&u8>;
    let mut _1096: bool;
    let mut _1097: bool;
    let _1099: !;
    let mut _1100: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _1102: &[N; 2];
    let mut _1106: &[N; 2];
    let mut _1110: &[N; 4];
    let mut _1114: &[N; 4];
    let mut _1118: &[Z; 1];
    let mut _1122: &[Z; 1];
    let mut _1126: &[Z; 1];
    let mut _1130: &[Z; 2];
    let mut _1134: &[Z; 2];
    let mut _1138: &[Z; 2];
    let mut _1142: &[Z; 4];
    let mut _1146: &[Z; 4];
    let mut _1150: &[Z; 4];
    let mut _1154: &[N; 1];
    let mut _1158: &[N; 1];
    let mut _1162: &[N; 1];
    let mut _1166: &[N; 2];
    let mut _1170: &[N; 2];
    let mut _1174: &[N; 2];
    let mut _1178: &[N; 4];
    let mut _1182: &[N; 4];
    let mut _1186: &[N; 4];
    scope 1 {
        debug runtime_eval => _1;
        let _9: &std::option::Option<&[N]>;
        let _10: &std::option::Option<&[N]>;
        let _19: &std::option::Option<&[N]>;
        let _20: &std::option::Option<&[N]>;
        let mut _1187: &std::option::Option<&[N]>;
        scope 3 {
            debug left_val => _9;
            debug right_val => _10;
            let _13: core::panicking::AssertKind;
            scope 4 {
                debug kind => _13;
            }
        }
        scope 5 {
            debug left_val => _19;
            debug right_val => _20;
            let _23: core::panicking::AssertKind;
            scope 6 {
                debug kind => _23;
            }
        }
    }
    scope 2 {
        debug x => _6;
        let _6: &[N];
        let mut _1188: &[N; 4];
    }
    scope 7 {
        debug runtime_eval => _26;
        let _34: &std::option::Option<&[N]>;
        let _35: &std::option::Option<&[N]>;
        let _44: &std::option::Option<&[N]>;
        let _45: &std::option::Option<&[N]>;
        let mut _1185: &std::option::Option<&[N]>;
        scope 9 {
            debug left_val => _34;
            debug right_val => _35;
            let _38: core::panicking::AssertKind;
            scope 10 {
                debug kind => _38;
            }
        }
        scope 11 {
            debug left_val => _44;
            debug right_val => _45;
            let _48: core::panicking::AssertKind;
            scope 12 {
                debug kind => _48;
            }
        }
    }
    scope 8 {
        debug x => _31;
    }
    scope 13 {
        debug runtime_eval => _51;
        let _59: &std::option::Option<&N>;
        let _60: &std::option::Option<&N>;
        let _69: &std::option::Option<&N>;
        let _70: &std::option::Option<&N>;
        let mut _1183: &std::option::Option<&N>;
        scope 15 {
            debug left_val => _59;
            debug right_val => _60;
            let _63: core::panicking::AssertKind;
            scope 16 {
                debug kind => _63;
            }
        }
        scope 17 {
            debug left_val => _69;
            debug right_val => _70;
            let _73: core::panicking::AssertKind;
            scope 18 {
                debug kind => _73;
            }
        }
    }
    scope 14 {
        debug x => _56;
        let _56: &N;
        let mut _1184: &[N; 4];
    }
    scope 19 {
        debug runtime_eval => _76;
        let _84: &std::option::Option<&N>;
        let _85: &std::option::Option<&N>;
        let _94: &std::option::Option<&N>;
        let _95: &std::option::Option<&N>;
        let mut _1181: &std::option::Option<&N>;
        scope 21 {
            debug left_val => _84;
            debug right_val => _85;
            let _88: core::panicking::AssertKind;
            scope 22 {
                debug kind => _88;
            }
        }
        scope 23 {
            debug left_val => _94;
            debug right_val => _95;
            let _98: core::panicking::AssertKind;
            scope 24 {
                debug kind => _98;
            }
        }
    }
    scope 20 {
        debug x => _81;
    }
    scope 25 {
        debug runtime_eval => _101;
        let _109: &std::option::Option<&N>;
        let _110: &std::option::Option<&N>;
        let _119: &std::option::Option<&N>;
        let _120: &std::option::Option<&N>;
        let mut _1179: &std::option::Option<&N>;
        scope 27 {
            debug left_val => _109;
            debug right_val => _110;
            let _113: core::panicking::AssertKind;
            scope 28 {
                debug kind => _113;
            }
        }
        scope 29 {
            debug left_val => _119;
            debug right_val => _120;
            let _123: core::panicking::AssertKind;
            scope 30 {
                debug kind => _123;
            }
        }
    }
    scope 26 {
        debug x => _106;
        let _106: &N;
        let mut _1180: &[N; 4];
    }
    scope 31 {
        debug runtime_eval => _126;
        let _134: &std::option::Option<&N>;
        let _135: &std::option::Option<&N>;
        let _144: &std::option::Option<&N>;
        let _145: &std::option::Option<&N>;
        let mut _1177: &std::option::Option<&N>;
        scope 33 {
            debug left_val => _134;
            debug right_val => _135;
            let _138: core::panicking::AssertKind;
            scope 34 {
                debug kind => _138;
            }
        }
        scope 35 {
            debug left_val => _144;
            debug right_val => _145;
            let _148: core::panicking::AssertKind;
            scope 36 {
                debug kind => _148;
            }
        }
    }
    scope 32 {
        debug x => _131;
    }
    scope 37 {
        debug runtime_eval => _151;
        let _159: &std::option::Option<&[N]>;
        let _160: &std::option::Option<&[N]>;
        let _169: &std::option::Option<&[N]>;
        let _170: &std::option::Option<&[N]>;
        let mut _1175: &std::option::Option<&[N]>;
        scope 39 {
            debug left_val => _159;
            debug right_val => _160;
            let _163: core::panicking::AssertKind;
            scope 40 {
                debug kind => _163;
            }
        }
        scope 41 {
            debug left_val => _169;
            debug right_val => _170;
            let _173: core::panicking::AssertKind;
            scope 42 {
                debug kind => _173;
            }
        }
    }
    scope 38 {
        debug x => _156;
        let _156: &[N];
        let mut _1176: &[N; 2];
    }
    scope 43 {
        debug runtime_eval => _176;
        let _184: &std::option::Option<&[N]>;
        let _185: &std::option::Option<&[N]>;
        let _194: &std::option::Option<&[N]>;
        let _195: &std::option::Option<&[N]>;
        let mut _1173: &std::option::Option<&[N]>;
        scope 45 {
            debug left_val => _184;
            debug right_val => _185;
            let _188: core::panicking::AssertKind;
            scope 46 {
                debug kind => _188;
            }
        }
        scope 47 {
            debug left_val => _194;
            debug right_val => _195;
            let _198: core::panicking::AssertKind;
            scope 48 {
                debug kind => _198;
            }
        }
    }
    scope 44 {
        debug x => _181;
    }
    scope 49 {
        debug runtime_eval => _201;
        let _209: &std::option::Option<&N>;
        let _210: &std::option::Option<&N>;
        let _219: &std::option::Option<&N>;
        let _220: &std::option::Option<&N>;
        let mut _1171: &std::option::Option<&N>;
        scope 51 {
            debug left_val => _209;
            debug right_val => _210;
            let _213: core::panicking::AssertKind;
            scope 52 {
                debug kind => _213;
            }
        }
        scope 53 {
            debug left_val => _219;
            debug right_val => _220;
            let _223: core::panicking::AssertKind;
            scope 54 {
                debug kind => _223;
            }
        }
    }
    scope 50 {
        debug x => _206;
        let _206: &N;
        let mut _1172: &[N; 2];
    }
    scope 55 {
        debug runtime_eval => _226;
        let _234: &std::option::Option<&N>;
        let _235: &std::option::Option<&N>;
        let _244: &std::option::Option<&N>;
        let _245: &std::option::Option<&N>;
        let mut _1169: &std::option::Option<&N>;
        scope 57 {
            debug left_val => _234;
            debug right_val => _235;
            let _238: core::panicking::AssertKind;
            scope 58 {
                debug kind => _238;
            }
        }
        scope 59 {
            debug left_val => _244;
            debug right_val => _245;
            let _248: core::panicking::AssertKind;
            scope 60 {
                debug kind => _248;
            }
        }
    }
    scope 56 {
        debug x => _231;
    }
    scope 61 {
        debug runtime_eval => _251;
        let _259: &std::option::Option<&N>;
        let _260: &std::option::Option<&N>;
        let _269: &std::option::Option<&N>;
        let _270: &std::option::Option<&N>;
        let mut _1167: &std::option::Option<&N>;
        scope 63 {
            debug left_val => _259;
            debug right_val => _260;
            let _263: core::panicking::AssertKind;
            scope 64 {
                debug kind => _263;
            }
        }
        scope 65 {
            debug left_val => _269;
            debug right_val => _270;
            let _273: core::panicking::AssertKind;
            scope 66 {
                debug kind => _273;
            }
        }
    }
    scope 62 {
        debug x => _256;
        let _256: &N;
        let mut _1168: &[N; 2];
    }
    scope 67 {
        debug runtime_eval => _276;
        let _284: &std::option::Option<&N>;
        let _285: &std::option::Option<&N>;
        let _294: &std::option::Option<&N>;
        let _295: &std::option::Option<&N>;
        let mut _1165: &std::option::Option<&N>;
        scope 69 {
            debug left_val => _284;
            debug right_val => _285;
            let _288: core::panicking::AssertKind;
            scope 70 {
                debug kind => _288;
            }
        }
        scope 71 {
            debug left_val => _294;
            debug right_val => _295;
            let _298: core::panicking::AssertKind;
            scope 72 {
                debug kind => _298;
            }
        }
    }
    scope 68 {
        debug x => _281;
    }
    scope 73 {
        debug runtime_eval => _301;
        let _309: &std::option::Option<&[N]>;
        let _310: &std::option::Option<&[N]>;
        let _319: &std::option::Option<&[N]>;
        let _320: &std::option::Option<&[N]>;
        let mut _1163: &std::option::Option<&[N]>;
        scope 75 {
            debug left_val => _309;
            debug right_val => _310;
            let _313: core::panicking::AssertKind;
            scope 76 {
                debug kind => _313;
            }
        }
        scope 77 {
            debug left_val => _319;
            debug right_val => _320;
            let _323: core::panicking::AssertKind;
            scope 78 {
                debug kind => _323;
            }
        }
    }
    scope 74 {
        debug x => _306;
        let _306: &[N];
        let mut _1164: &[N; 1];
    }
    scope 79 {
        debug runtime_eval => _326;
        let _334: &std::option::Option<&[N]>;
        let _335: &std::option::Option<&[N]>;
        let _344: &std::option::Option<&[N]>;
        let _345: &std::option::Option<&[N]>;
        let mut _1161: &std::option::Option<&[N]>;
        scope 81 {
            debug left_val => _334;
            debug right_val => _335;
            let _338: core::panicking::AssertKind;
            scope 82 {
                debug kind => _338;
            }
        }
        scope 83 {
            debug left_val => _344;
            debug right_val => _345;
            let _348: core::panicking::AssertKind;
            scope 84 {
                debug kind => _348;
            }
        }
    }
    scope 80 {
        debug x => _331;
    }
    scope 85 {
        debug runtime_eval => _351;
        let _359: &std::option::Option<&N>;
        let _360: &std::option::Option<&N>;
        let _369: &std::option::Option<&N>;
        let _370: &std::option::Option<&N>;
        let mut _1159: &std::option::Option<&N>;
        scope 87 {
            debug left_val => _359;
            debug right_val => _360;
            let _363: core::panicking::AssertKind;
            scope 88 {
                debug kind => _363;
            }
        }
        scope 89 {
            debug left_val => _369;
            debug right_val => _370;
            let _373: core::panicking::AssertKind;
            scope 90 {
                debug kind => _373;
            }
        }
    }
    scope 86 {
        debug x => _356;
        let _356: &N;
        let mut _1160: &[N; 1];
    }
    scope 91 {
        debug runtime_eval => _376;
        let _384: &std::option::Option<&N>;
        let _385: &std::option::Option<&N>;
        let _394: &std::option::Option<&N>;
        let _395: &std::option::Option<&N>;
        let mut _1157: &std::option::Option<&N>;
        scope 93 {
            debug left_val => _384;
            debug right_val => _385;
            let _388: core::panicking::AssertKind;
            scope 94 {
                debug kind => _388;
            }
        }
        scope 95 {
            debug left_val => _394;
            debug right_val => _395;
            let _398: core::panicking::AssertKind;
            scope 96 {
                debug kind => _398;
            }
        }
    }
    scope 92 {
        debug x => _381;
    }
    scope 97 {
        debug runtime_eval => _401;
        let _409: &std::option::Option<&N>;
        let _410: &std::option::Option<&N>;
        let _419: &std::option::Option<&N>;
        let _420: &std::option::Option<&N>;
        let mut _1155: &std::option::Option<&N>;
        scope 99 {
            debug left_val => _409;
            debug right_val => _410;
            let _413: core::panicking::AssertKind;
            scope 100 {
                debug kind => _413;
            }
        }
        scope 101 {
            debug left_val => _419;
            debug right_val => _420;
            let _423: core::panicking::AssertKind;
            scope 102 {
                debug kind => _423;
            }
        }
    }
    scope 98 {
        debug x => _406;
        let _406: &N;
        let mut _1156: &[N; 1];
    }
    scope 103 {
        debug runtime_eval => _426;
        let _434: &std::option::Option<&N>;
        let _435: &std::option::Option<&N>;
        let _444: &std::option::Option<&N>;
        let _445: &std::option::Option<&N>;
        let mut _1153: &std::option::Option<&N>;
        scope 105 {
            debug left_val => _434;
            debug right_val => _435;
            let _438: core::panicking::AssertKind;
            scope 106 {
                debug kind => _438;
            }
        }
        scope 107 {
            debug left_val => _444;
            debug right_val => _445;
            let _448: core::panicking::AssertKind;
            scope 108 {
                debug kind => _448;
            }
        }
    }
    scope 104 {
        debug x => _431;
    }
    scope 109 {
        debug runtime_eval => _451;
        let _459: &std::option::Option<&[Z]>;
        let _460: &std::option::Option<&[Z]>;
        let _469: &std::option::Option<&[Z]>;
        let _470: &std::option::Option<&[Z]>;
        let mut _1151: &std::option::Option<&[Z]>;
        scope 111 {
            debug left_val => _459;
            debug right_val => _460;
            let _463: core::panicking::AssertKind;
            scope 112 {
                debug kind => _463;
            }
        }
        scope 113 {
            debug left_val => _469;
            debug right_val => _470;
            let _473: core::panicking::AssertKind;
            scope 114 {
                debug kind => _473;
            }
        }
    }
    scope 110 {
        debug x => _456;
        let _456: &[Z];
        let mut _1152: &[Z; 4];
    }
    scope 115 {
        debug runtime_eval => _476;
        let _484: &std::option::Option<&[Z]>;
        let _485: &std::option::Option<&[Z]>;
        let _494: &std::option::Option<&[Z]>;
        let _495: &std::option::Option<&[Z]>;
        let mut _1149: &std::option::Option<&[Z]>;
        scope 117 {
            debug left_val => _484;
            debug right_val => _485;
            let _488: core::panicking::AssertKind;
            scope 118 {
                debug kind => _488;
            }
        }
        scope 119 {
            debug left_val => _494;
            debug right_val => _495;
            let _498: core::panicking::AssertKind;
            scope 120 {
                debug kind => _498;
            }
        }
    }
    scope 116 {
        debug x => _481;
    }
    scope 121 {
        debug runtime_eval => _501;
        let _509: &std::option::Option<&Z>;
        let _510: &std::option::Option<&Z>;
        let _519: &std::option::Option<&Z>;
        let _520: &std::option::Option<&Z>;
        let mut _1147: &std::option::Option<&Z>;
        scope 123 {
            debug left_val => _509;
            debug right_val => _510;
            let _513: core::panicking::AssertKind;
            scope 124 {
                debug kind => _513;
            }
        }
        scope 125 {
            debug left_val => _519;
            debug right_val => _520;
            let _523: core::panicking::AssertKind;
            scope 126 {
                debug kind => _523;
            }
        }
    }
    scope 122 {
        debug x => _506;
        let _506: &Z;
        let mut _1148: &[Z; 4];
    }
    scope 127 {
        debug runtime_eval => _526;
        let _534: &std::option::Option<&Z>;
        let _535: &std::option::Option<&Z>;
        let _544: &std::option::Option<&Z>;
        let _545: &std::option::Option<&Z>;
        let mut _1145: &std::option::Option<&Z>;
        scope 129 {
            debug left_val => _534;
            debug right_val => _535;
            let _538: core::panicking::AssertKind;
            scope 130 {
                debug kind => _538;
            }
        }
        scope 131 {
            debug left_val => _544;
            debug right_val => _545;
            let _548: core::panicking::AssertKind;
            scope 132 {
                debug kind => _548;
            }
        }
    }
    scope 128 {
        debug x => _531;
    }
    scope 133 {
        debug runtime_eval => _551;
        let _559: &std::option::Option<&Z>;
        let _560: &std::option::Option<&Z>;
        let _569: &std::option::Option<&Z>;
        let _570: &std::option::Option<&Z>;
        let mut _1143: &std::option::Option<&Z>;
        scope 135 {
            debug left_val => _559;
            debug right_val => _560;
            let _563: core::panicking::AssertKind;
            scope 136 {
                debug kind => _563;
            }
        }
        scope 137 {
            debug left_val => _569;
            debug right_val => _570;
            let _573: core::panicking::AssertKind;
            scope 138 {
                debug kind => _573;
            }
        }
    }
    scope 134 {
        debug x => _556;
        let _556: &Z;
        let mut _1144: &[Z; 4];
    }
    scope 139 {
        debug runtime_eval => _576;
        let _584: &std::option::Option<&Z>;
        let _585: &std::option::Option<&Z>;
        let _594: &std::option::Option<&Z>;
        let _595: &std::option::Option<&Z>;
        let mut _1141: &std::option::Option<&Z>;
        scope 141 {
            debug left_val => _584;
            debug right_val => _585;
            let _588: core::panicking::AssertKind;
            scope 142 {
                debug kind => _588;
            }
        }
        scope 143 {
            debug left_val => _594;
            debug right_val => _595;
            let _598: core::panicking::AssertKind;
            scope 144 {
                debug kind => _598;
            }
        }
    }
    scope 140 {
        debug x => _581;
    }
    scope 145 {
        debug runtime_eval => _601;
        let _609: &std::option::Option<&[Z]>;
        let _610: &std::option::Option<&[Z]>;
        let _619: &std::option::Option<&[Z]>;
        let _620: &std::option::Option<&[Z]>;
        let mut _1139: &std::option::Option<&[Z]>;
        scope 147 {
            debug left_val => _609;
            debug right_val => _610;
            let _613: core::panicking::AssertKind;
            scope 148 {
                debug kind => _613;
            }
        }
        scope 149 {
            debug left_val => _619;
            debug right_val => _620;
            let _623: core::panicking::AssertKind;
            scope 150 {
                debug kind => _623;
            }
        }
    }
    scope 146 {
        debug x => _606;
        let _606: &[Z];
        let mut _1140: &[Z; 2];
    }
    scope 151 {
        debug runtime_eval => _626;
        let _634: &std::option::Option<&[Z]>;
        let _635: &std::option::Option<&[Z]>;
        let _644: &std::option::Option<&[Z]>;
        let _645: &std::option::Option<&[Z]>;
        let mut _1137: &std::option::Option<&[Z]>;
        scope 153 {
            debug left_val => _634;
            debug right_val => _635;
            let _638: core::panicking::AssertKind;
            scope 154 {
                debug kind => _638;
            }
        }
        scope 155 {
            debug left_val => _644;
            debug right_val => _645;
            let _648: core::panicking::AssertKind;
            scope 156 {
                debug kind => _648;
            }
        }
    }
    scope 152 {
        debug x => _631;
    }
    scope 157 {
        debug runtime_eval => _651;
        let _659: &std::option::Option<&Z>;
        let _660: &std::option::Option<&Z>;
        let _669: &std::option::Option<&Z>;
        let _670: &std::option::Option<&Z>;
        let mut _1135: &std::option::Option<&Z>;
        scope 159 {
            debug left_val => _659;
            debug right_val => _660;
            let _663: core::panicking::AssertKind;
            scope 160 {
                debug kind => _663;
            }
        }
        scope 161 {
            debug left_val => _669;
            debug right_val => _670;
            let _673: core::panicking::AssertKind;
            scope 162 {
                debug kind => _673;
            }
        }
    }
    scope 158 {
        debug x => _656;
        let _656: &Z;
        let mut _1136: &[Z; 2];
    }
    scope 163 {
        debug runtime_eval => _676;
        let _684: &std::option::Option<&Z>;
        let _685: &std::option::Option<&Z>;
        let _694: &std::option::Option<&Z>;
        let _695: &std::option::Option<&Z>;
        let mut _1133: &std::option::Option<&Z>;
        scope 165 {
            debug left_val => _684;
            debug right_val => _685;
            let _688: core::panicking::AssertKind;
            scope 166 {
                debug kind => _688;
            }
        }
        scope 167 {
            debug left_val => _694;
            debug right_val => _695;
            let _698: core::panicking::AssertKind;
            scope 168 {
                debug kind => _698;
            }
        }
    }
    scope 164 {
        debug x => _681;
    }
    scope 169 {
        debug runtime_eval => _701;
        let _709: &std::option::Option<&Z>;
        let _710: &std::option::Option<&Z>;
        let _719: &std::option::Option<&Z>;
        let _720: &std::option::Option<&Z>;
        let mut _1131: &std::option::Option<&Z>;
        scope 171 {
            debug left_val => _709;
            debug right_val => _710;
            let _713: core::panicking::AssertKind;
            scope 172 {
                debug kind => _713;
            }
        }
        scope 173 {
            debug left_val => _719;
            debug right_val => _720;
            let _723: core::panicking::AssertKind;
            scope 174 {
                debug kind => _723;
            }
        }
    }
    scope 170 {
        debug x => _706;
        let _706: &Z;
        let mut _1132: &[Z; 2];
    }
    scope 175 {
        debug runtime_eval => _726;
        let _734: &std::option::Option<&Z>;
        let _735: &std::option::Option<&Z>;
        let _744: &std::option::Option<&Z>;
        let _745: &std::option::Option<&Z>;
        let mut _1129: &std::option::Option<&Z>;
        scope 177 {
            debug left_val => _734;
            debug right_val => _735;
            let _738: core::panicking::AssertKind;
            scope 178 {
                debug kind => _738;
            }
        }
        scope 179 {
            debug left_val => _744;
            debug right_val => _745;
            let _748: core::panicking::AssertKind;
            scope 180 {
                debug kind => _748;
            }
        }
    }
    scope 176 {
        debug x => _731;
    }
    scope 181 {
        debug runtime_eval => _751;
        let _759: &std::option::Option<&[Z]>;
        let _760: &std::option::Option<&[Z]>;
        let _769: &std::option::Option<&[Z]>;
        let _770: &std::option::Option<&[Z]>;
        let mut _1127: &std::option::Option<&[Z]>;
        scope 183 {
            debug left_val => _759;
            debug right_val => _760;
            let _763: core::panicking::AssertKind;
            scope 184 {
                debug kind => _763;
            }
        }
        scope 185 {
            debug left_val => _769;
            debug right_val => _770;
            let _773: core::panicking::AssertKind;
            scope 186 {
                debug kind => _773;
            }
        }
    }
    scope 182 {
        debug x => _756;
        let _756: &[Z];
        let mut _1128: &[Z; 1];
    }
    scope 187 {
        debug runtime_eval => _776;
        let _784: &std::option::Option<&[Z]>;
        let _785: &std::option::Option<&[Z]>;
        let _794: &std::option::Option<&[Z]>;
        let _795: &std::option::Option<&[Z]>;
        let mut _1125: &std::option::Option<&[Z]>;
        scope 189 {
            debug left_val => _784;
            debug right_val => _785;
            let _788: core::panicking::AssertKind;
            scope 190 {
                debug kind => _788;
            }
        }
        scope 191 {
            debug left_val => _794;
            debug right_val => _795;
            let _798: core::panicking::AssertKind;
            scope 192 {
                debug kind => _798;
            }
        }
    }
    scope 188 {
        debug x => _781;
    }
    scope 193 {
        debug runtime_eval => _801;
        let _809: &std::option::Option<&Z>;
        let _810: &std::option::Option<&Z>;
        let _819: &std::option::Option<&Z>;
        let _820: &std::option::Option<&Z>;
        let mut _1123: &std::option::Option<&Z>;
        scope 195 {
            debug left_val => _809;
            debug right_val => _810;
            let _813: core::panicking::AssertKind;
            scope 196 {
                debug kind => _813;
            }
        }
        scope 197 {
            debug left_val => _819;
            debug right_val => _820;
            let _823: core::panicking::AssertKind;
            scope 198 {
                debug kind => _823;
            }
        }
    }
    scope 194 {
        debug x => _806;
        let _806: &Z;
        let mut _1124: &[Z; 1];
    }
    scope 199 {
        debug runtime_eval => _826;
        let _834: &std::option::Option<&Z>;
        let _835: &std::option::Option<&Z>;
        let _844: &std::option::Option<&Z>;
        let _845: &std::option::Option<&Z>;
        let mut _1121: &std::option::Option<&Z>;
        scope 201 {
            debug left_val => _834;
            debug right_val => _835;
            let _838: core::panicking::AssertKind;
            scope 202 {
                debug kind => _838;
            }
        }
        scope 203 {
            debug left_val => _844;
            debug right_val => _845;
            let _848: core::panicking::AssertKind;
            scope 204 {
                debug kind => _848;
            }
        }
    }
    scope 200 {
        debug x => _831;
    }
    scope 205 {
        debug runtime_eval => _851;
        let _859: &std::option::Option<&Z>;
        let _860: &std::option::Option<&Z>;
        let _869: &std::option::Option<&Z>;
        let _870: &std::option::Option<&Z>;
        let mut _1119: &std::option::Option<&Z>;
        scope 207 {
            debug left_val => _859;
            debug right_val => _860;
            let _863: core::panicking::AssertKind;
            scope 208 {
                debug kind => _863;
            }
        }
        scope 209 {
            debug left_val => _869;
            debug right_val => _870;
            let _873: core::panicking::AssertKind;
            scope 210 {
                debug kind => _873;
            }
        }
    }
    scope 206 {
        debug x => _856;
        let _856: &Z;
        let mut _1120: &[Z; 1];
    }
    scope 211 {
        debug runtime_eval => _876;
        let _884: &std::option::Option<&Z>;
        let _885: &std::option::Option<&Z>;
        let _894: &std::option::Option<&Z>;
        let _895: &std::option::Option<&Z>;
        let mut _1117: &std::option::Option<&Z>;
        scope 213 {
            debug left_val => _884;
            debug right_val => _885;
            let _888: core::panicking::AssertKind;
            scope 214 {
                debug kind => _888;
            }
        }
        scope 215 {
            debug left_val => _894;
            debug right_val => _895;
            let _898: core::panicking::AssertKind;
            scope 216 {
                debug kind => _898;
            }
        }
    }
    scope 212 {
        debug x => _881;
    }
    scope 217 {
        debug runtime_eval => _901;
        let _909: &std::option::Option<&u8>;
        let _910: &std::option::Option<&u8>;
        let _919: &std::option::Option<&u8>;
        let _920: &std::option::Option<&u8>;
        let mut _1115: &std::option::Option<&u8>;
        scope 219 {
            debug left_val => _909;
            debug right_val => _910;
            let _913: core::panicking::AssertKind;
            scope 220 {
                debug kind => _913;
            }
        }
        scope 221 {
            debug left_val => _919;
            debug right_val => _920;
            let _923: core::panicking::AssertKind;
            scope 222 {
                debug kind => _923;
            }
        }
    }
    scope 218 {
        debug x => _906;
        let _906: &u8;
        let mut _1116: &[N; 4];
    }
    scope 223 {
        debug runtime_eval => _926;
        let _934: &std::option::Option<&u8>;
        let _935: &std::option::Option<&u8>;
        let _944: &std::option::Option<&u8>;
        let _945: &std::option::Option<&u8>;
        let mut _1113: &std::option::Option<&u8>;
        scope 225 {
            debug left_val => _934;
            debug right_val => _935;
            let _938: core::panicking::AssertKind;
            scope 226 {
                debug kind => _938;
            }
        }
        scope 227 {
            debug left_val => _944;
            debug right_val => _945;
            let _948: core::panicking::AssertKind;
            scope 228 {
                debug kind => _948;
            }
        }
    }
    scope 224 {
        debug x => _931;
    }
    scope 229 {
        debug runtime_eval => _951;
        let _959: &std::option::Option<&u8>;
        let _960: &std::option::Option<&u8>;
        let _969: &std::option::Option<&u8>;
        let _970: &std::option::Option<&u8>;
        let mut _1111: &std::option::Option<&u8>;
        scope 231 {
            debug left_val => _959;
            debug right_val => _960;
            let _963: core::panicking::AssertKind;
            scope 232 {
                debug kind => _963;
            }
        }
        scope 233 {
            debug left_val => _969;
            debug right_val => _970;
            let _973: core::panicking::AssertKind;
            scope 234 {
                debug kind => _973;
            }
        }
    }
    scope 230 {
        debug x => _956;
        let _956: &u8;
        let mut _1112: &[N; 4];
    }
    scope 235 {
        debug runtime_eval => _976;
        let _984: &std::option::Option<&u8>;
        let _985: &std::option::Option<&u8>;
        let _994: &std::option::Option<&u8>;
        let _995: &std::option::Option<&u8>;
        let mut _1109: &std::option::Option<&u8>;
        scope 237 {
            debug left_val => _984;
            debug right_val => _985;
            let _988: core::panicking::AssertKind;
            scope 238 {
                debug kind => _988;
            }
        }
        scope 239 {
            debug left_val => _994;
            debug right_val => _995;
            let _998: core::panicking::AssertKind;
            scope 240 {
                debug kind => _998;
            }
        }
    }
    scope 236 {
        debug x => _981;
    }
    scope 241 {
        debug runtime_eval => _1001;
        let _1009: &std::option::Option<&u8>;
        let _1010: &std::option::Option<&u8>;
        let _1019: &std::option::Option<&u8>;
        let _1020: &std::option::Option<&u8>;
        let mut _1107: &std::option::Option<&u8>;
        scope 243 {
            debug left_val => _1009;
            debug right_val => _1010;
            let _1013: core::panicking::AssertKind;
            scope 244 {
                debug kind => _1013;
            }
        }
        scope 245 {
            debug left_val => _1019;
            debug right_val => _1020;
            let _1023: core::panicking::AssertKind;
            scope 246 {
                debug kind => _1023;
            }
        }
    }
    scope 242 {
        debug x => _1006;
        let _1006: &u8;
        let mut _1108: &[N; 2];
    }
    scope 247 {
        debug runtime_eval => _1026;
        let _1034: &std::option::Option<&u8>;
        let _1035: &std::option::Option<&u8>;
        let _1044: &std::option::Option<&u8>;
        let _1045: &std::option::Option<&u8>;
        let mut _1105: &std::option::Option<&u8>;
        scope 249 {
            debug left_val => _1034;
            debug right_val => _1035;
            let _1038: core::panicking::AssertKind;
            scope 250 {
                debug kind => _1038;
            }
        }
        scope 251 {
            debug left_val => _1044;
            debug right_val => _1045;
            let _1048: core::panicking::AssertKind;
            scope 252 {
                debug kind => _1048;
            }
        }
    }
    scope 248 {
        debug x => _1031;
    }
    scope 253 {
        debug runtime_eval => _1051;
        let _1059: &std::option::Option<&u8>;
        let _1060: &std::option::Option<&u8>;
        let _1069: &std::option::Option<&u8>;
        let _1070: &std::option::Option<&u8>;
        let mut _1103: &std::option::Option<&u8>;
        scope 255 {
            debug left_val => _1059;
            debug right_val => _1060;
            let _1063: core::panicking::AssertKind;
            scope 256 {
                debug kind => _1063;
            }
        }
        scope 257 {
            debug left_val => _1069;
            debug right_val => _1070;
            let _1073: core::panicking::AssertKind;
            scope 258 {
                debug kind => _1073;
            }
        }
    }
    scope 254 {
        debug x => _1056;
        let _1056: &u8;
        let mut _1104: &[N; 2];
    }
    scope 259 {
        debug runtime_eval => _1076;
        let _1084: &std::option::Option<&u8>;
        let _1085: &std::option::Option<&u8>;
        let _1094: &std::option::Option<&u8>;
        let _1095: &std::option::Option<&u8>;
        let mut _1101: &std::option::Option<&u8>;
        scope 261 {
            debug left_val => _1084;
            debug right_val => _1085;
            let _1088: core::panicking::AssertKind;
            scope 262 {
                debug kind => _1088;
            }
        }
        scope 263 {
            debug left_val => _1094;
            debug right_val => _1095;
            let _1098: core::panicking::AssertKind;
            scope 264 {
                debug kind => _1098;
            }
        }
    }
    scope 260 {
        debug x => _1081;
    }

    bb0: {
        _1188 = const _;
        _2 = _1188 as &[N] (Pointer(Unsize));
        _3 = Len((*_2));
        _4 = const 2_usize;
        _5 = Ge(move _3, move _4);
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = &(*_2)[1:-1];
        _1 = Option::<&[N]>::Some(_6);
        goto -> bb3;
    }

    bb2: {
        _1 = Option::<&[N]>::None;
        goto -> bb3;
    }

    bb3: {
        _1187 = const _;
        _8 = &_1;
        _7 = (_1187, move _8);
        _9 = (_7.0: &std::option::Option<&[N]>);
        _10 = (_7.1: &std::option::Option<&[N]>);
        _12 = <Option<&[N]> as PartialEq>::eq(_9, _10) -> [return: bb4, unwind continue];
    }

    bb4: {
        _11 = Not(move _12);
        switchInt(move _11) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _13 = core::panicking::AssertKind::Eq;
        _15 = Option::<Arguments<'_>>::None;
        _14 = core::panicking::assert_failed::<Option<&[N]>, Option<&[N]>>(move _13, _9, _10, move _15) -> unwind continue;
    }

    bb6: {
        _17 = const {alloc1: &Option<&[N]>};
        _18 = &_1;
        _16 = (_17, move _18);
        _19 = (_16.0: &std::option::Option<&[N]>);
        _20 = (_16.1: &std::option::Option<&[N]>);
        _22 = <Option<&[N]> as PartialEq>::eq(_19, _20) -> [return: bb7, unwind continue];
    }

    bb7: {
        _21 = Not(move _22);
        switchInt(move _21) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _23 = core::panicking::AssertKind::Eq;
        _25 = Option::<Arguments<'_>>::None;
        _24 = core::panicking::assert_failed::<Option<&[N]>, Option<&[N]>>(move _23, _19, _20, move _25) -> unwind continue;
    }

    bb9: {
        _1186 = const _;
        _27 = _1186 as &[N] (Pointer(Unsize));
        _28 = Len((*_27));
        _29 = const 2_usize;
        _30 = Ge(move _28, move _29);
        switchInt(move _30) -> [0: bb10, otherwise: bb11];
    }

    bb10: {
        _26 = Option::<&[N]>::None;
        goto -> bb12;
    }

    bb11: {
        _31 = &(*_27)[1:-1];
        _26 = Option::<&[N]>::Some(_31);
        goto -> bb12;
    }

    bb12: {
        _1185 = const _;
        _33 = &_26;
        _32 = (_1185, move _33);
        _34 = (_32.0: &std::option::Option<&[N]>);
        _35 = (_32.1: &std::option::Option<&[N]>);
        _37 = <Option<&[N]> as PartialEq>::eq(_34, _35) -> [return: bb13, unwind continue];
    }

    bb13: {
        _36 = Not(move _37);
        switchInt(move _36) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _38 = core::panicking::AssertKind::Eq;
        _40 = Option::<Arguments<'_>>::None;
        _39 = core::panicking::assert_failed::<Option<&[N]>, Option<&[N]>>(move _38, _34, _35, move _40) -> unwind continue;
    }

    bb15: {
        _42 = const {alloc2: &Option<&[N]>};
        _43 = &_26;
        _41 = (_42, move _43);
        _44 = (_41.0: &std::option::Option<&[N]>);
        _45 = (_41.1: &std::option::Option<&[N]>);
        _47 = <Option<&[N]> as PartialEq>::eq(_44, _45) -> [return: bb16, unwind continue];
    }

    bb16: {
        _46 = Not(move _47);
        switchInt(move _46) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _48 = core::panicking::AssertKind::Eq;
        _50 = Option::<Arguments<'_>>::None;
        _49 = core::panicking::assert_failed::<Option<&[N]>, Option<&[N]>>(move _48, _44, _45, move _50) -> unwind continue;
    }

    bb18: {
        _1184 = const _;
        _52 = _1184 as &[N] (Pointer(Unsize));
        _53 = Len((*_52));
        _54 = const 2_usize;
        _55 = Ge(move _53, move _54);
        switchInt(move _55) -> [0: bb20, otherwise: bb19];
    }

    bb19: {
        _56 = &(*_52)[0 of 2];
        _51 = Option::<&N>::Some(_56);
        goto -> bb21;
    }

    bb20: {
        _51 = Option::<&N>::None;
        goto -> bb21;
    }

    bb21: {
        _1183 = const _;
        _58 = &_51;
        _57 = (_1183, move _58);
        _59 = (_57.0: &std::option::Option<&N>);
        _60 = (_57.1: &std::option::Option<&N>);
        _62 = <Option<&N> as PartialEq>::eq(_59, _60) -> [return: bb22, unwind continue];
    }

    bb22: {
        _61 = Not(move _62);
        switchInt(move _61) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _63 = core::panicking::AssertKind::Eq;
        _65 = Option::<Arguments<'_>>::None;
        _64 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _63, _59, _60, move _65) -> unwind continue;
    }

    bb24: {
        _67 = const {alloc3: &Option<&N>};
        _68 = &_51;
        _66 = (_67, move _68);
        _69 = (_66.0: &std::option::Option<&N>);
        _70 = (_66.1: &std::option::Option<&N>);
        _72 = <Option<&N> as PartialEq>::eq(_69, _70) -> [return: bb25, unwind continue];
    }

    bb25: {
        _71 = Not(move _72);
        switchInt(move _71) -> [0: bb27, otherwise: bb26];
    }

    bb26: {
        _73 = core::panicking::AssertKind::Eq;
        _75 = Option::<Arguments<'_>>::None;
        _74 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _73, _69, _70, move _75) -> unwind continue;
    }

    bb27: {
        _1182 = const _;
        _77 = _1182 as &[N] (Pointer(Unsize));
        _78 = Len((*_77));
        _79 = const 2_usize;
        _80 = Ge(move _78, move _79);
        switchInt(move _80) -> [0: bb28, otherwise: bb29];
    }

    bb28: {
        _76 = Option::<&N>::None;
        goto -> bb30;
    }

    bb29: {
        _81 = &(*_77)[0 of 2];
        _76 = Option::<&N>::Some(_81);
        goto -> bb30;
    }

    bb30: {
        _1181 = const _;
        _83 = &_76;
        _82 = (_1181, move _83);
        _84 = (_82.0: &std::option::Option<&N>);
        _85 = (_82.1: &std::option::Option<&N>);
        _87 = <Option<&N> as PartialEq>::eq(_84, _85) -> [return: bb31, unwind continue];
    }

    bb31: {
        _86 = Not(move _87);
        switchInt(move _86) -> [0: bb33, otherwise: bb32];
    }

    bb32: {
        _88 = core::panicking::AssertKind::Eq;
        _90 = Option::<Arguments<'_>>::None;
        _89 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _88, _84, _85, move _90) -> unwind continue;
    }

    bb33: {
        _92 = const {alloc4: &Option<&N>};
        _93 = &_76;
        _91 = (_92, move _93);
        _94 = (_91.0: &std::option::Option<&N>);
        _95 = (_91.1: &std::option::Option<&N>);
        _97 = <Option<&N> as PartialEq>::eq(_94, _95) -> [return: bb34, unwind continue];
    }

    bb34: {
        _96 = Not(move _97);
        switchInt(move _96) -> [0: bb36, otherwise: bb35];
    }

    bb35: {
        _98 = core::panicking::AssertKind::Eq;
        _100 = Option::<Arguments<'_>>::None;
        _99 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _98, _94, _95, move _100) -> unwind continue;
    }

    bb36: {
        _1180 = const _;
        _102 = _1180 as &[N] (Pointer(Unsize));
        _103 = Len((*_102));
        _104 = const 2_usize;
        _105 = Ge(move _103, move _104);
        switchInt(move _105) -> [0: bb38, otherwise: bb37];
    }

    bb37: {
        _106 = &(*_102)[-1 of 2];
        _101 = Option::<&N>::Some(_106);
        goto -> bb39;
    }

    bb38: {
        _101 = Option::<&N>::None;
        goto -> bb39;
    }

    bb39: {
        _1179 = const _;
        _108 = &_101;
        _107 = (_1179, move _108);
        _109 = (_107.0: &std::option::Option<&N>);
        _110 = (_107.1: &std::option::Option<&N>);
        _112 = <Option<&N> as PartialEq>::eq(_109, _110) -> [return: bb40, unwind continue];
    }

    bb40: {
        _111 = Not(move _112);
        switchInt(move _111) -> [0: bb42, otherwise: bb41];
    }

    bb41: {
        _113 = core::panicking::AssertKind::Eq;
        _115 = Option::<Arguments<'_>>::None;
        _114 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _113, _109, _110, move _115) -> unwind continue;
    }

    bb42: {
        _117 = const {alloc5: &Option<&N>};
        _118 = &_101;
        _116 = (_117, move _118);
        _119 = (_116.0: &std::option::Option<&N>);
        _120 = (_116.1: &std::option::Option<&N>);
        _122 = <Option<&N> as PartialEq>::eq(_119, _120) -> [return: bb43, unwind continue];
    }

    bb43: {
        _121 = Not(move _122);
        switchInt(move _121) -> [0: bb45, otherwise: bb44];
    }

    bb44: {
        _123 = core::panicking::AssertKind::Eq;
        _125 = Option::<Arguments<'_>>::None;
        _124 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _123, _119, _120, move _125) -> unwind continue;
    }

    bb45: {
        _1178 = const _;
        _127 = _1178 as &[N] (Pointer(Unsize));
        _128 = Len((*_127));
        _129 = const 2_usize;
        _130 = Ge(move _128, move _129);
        switchInt(move _130) -> [0: bb46, otherwise: bb47];
    }

    bb46: {
        _126 = Option::<&N>::None;
        goto -> bb48;
    }

    bb47: {
        _131 = &(*_127)[-1 of 2];
        _126 = Option::<&N>::Some(_131);
        goto -> bb48;
    }

    bb48: {
        _1177 = const _;
        _133 = &_126;
        _132 = (_1177, move _133);
        _134 = (_132.0: &std::option::Option<&N>);
        _135 = (_132.1: &std::option::Option<&N>);
        _137 = <Option<&N> as PartialEq>::eq(_134, _135) -> [return: bb49, unwind continue];
    }

    bb49: {
        _136 = Not(move _137);
        switchInt(move _136) -> [0: bb51, otherwise: bb50];
    }

    bb50: {
        _138 = core::panicking::AssertKind::Eq;
        _140 = Option::<Arguments<'_>>::None;
        _139 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _138, _134, _135, move _140) -> unwind continue;
    }

    bb51: {
        _142 = const {alloc6: &Option<&N>};
        _143 = &_126;
        _141 = (_142, move _143);
        _144 = (_141.0: &std::option::Option<&N>);
        _145 = (_141.1: &std::option::Option<&N>);
        _147 = <Option<&N> as PartialEq>::eq(_144, _145) -> [return: bb52, unwind continue];
    }

    bb52: {
        _146 = Not(move _147);
        switchInt(move _146) -> [0: bb54, otherwise: bb53];
    }

    bb53: {
        _148 = core::panicking::AssertKind::Eq;
        _150 = Option::<Arguments<'_>>::None;
        _149 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _148, _144, _145, move _150) -> unwind continue;
    }

    bb54: {
        _1176 = const _;
        _152 = _1176 as &[N] (Pointer(Unsize));
        _153 = Len((*_152));
        _154 = const 2_usize;
        _155 = Ge(move _153, move _154);
        switchInt(move _155) -> [0: bb56, otherwise: bb55];
    }

    bb55: {
        _156 = &(*_152)[1:-1];
        _151 = Option::<&[N]>::Some(_156);
        goto -> bb57;
    }

    bb56: {
        _151 = Option::<&[N]>::None;
        goto -> bb57;
    }

    bb57: {
        _1175 = const _;
        _158 = &_151;
        _157 = (_1175, move _158);
        _159 = (_157.0: &std::option::Option<&[N]>);
        _160 = (_157.1: &std::option::Option<&[N]>);
        _162 = <Option<&[N]> as PartialEq>::eq(_159, _160) -> [return: bb58, unwind continue];
    }

    bb58: {
        _161 = Not(move _162);
        switchInt(move _161) -> [0: bb60, otherwise: bb59];
    }

    bb59: {
        _163 = core::panicking::AssertKind::Eq;
        _165 = Option::<Arguments<'_>>::None;
        _164 = core::panicking::assert_failed::<Option<&[N]>, Option<&[N]>>(move _163, _159, _160, move _165) -> unwind continue;
    }

    bb60: {
        _167 = const {alloc7: &Option<&[N]>};
        _168 = &_151;
        _166 = (_167, move _168);
        _169 = (_166.0: &std::option::Option<&[N]>);
        _170 = (_166.1: &std::option::Option<&[N]>);
        _172 = <Option<&[N]> as PartialEq>::eq(_169, _170) -> [return: bb61, unwind continue];
    }

    bb61: {
        _171 = Not(move _172);
        switchInt(move _171) -> [0: bb63, otherwise: bb62];
    }

    bb62: {
        _173 = core::panicking::AssertKind::Eq;
        _175 = Option::<Arguments<'_>>::None;
        _174 = core::panicking::assert_failed::<Option<&[N]>, Option<&[N]>>(move _173, _169, _170, move _175) -> unwind continue;
    }

    bb63: {
        _1174 = const _;
        _177 = _1174 as &[N] (Pointer(Unsize));
        _178 = Len((*_177));
        _179 = const 2_usize;
        _180 = Ge(move _178, move _179);
        switchInt(move _180) -> [0: bb64, otherwise: bb65];
    }

    bb64: {
        _176 = Option::<&[N]>::None;
        goto -> bb66;
    }

    bb65: {
        _181 = &(*_177)[1:-1];
        _176 = Option::<&[N]>::Some(_181);
        goto -> bb66;
    }

    bb66: {
        _1173 = const _;
        _183 = &_176;
        _182 = (_1173, move _183);
        _184 = (_182.0: &std::option::Option<&[N]>);
        _185 = (_182.1: &std::option::Option<&[N]>);
        _187 = <Option<&[N]> as PartialEq>::eq(_184, _185) -> [return: bb67, unwind continue];
    }

    bb67: {
        _186 = Not(move _187);
        switchInt(move _186) -> [0: bb69, otherwise: bb68];
    }

    bb68: {
        _188 = core::panicking::AssertKind::Eq;
        _190 = Option::<Arguments<'_>>::None;
        _189 = core::panicking::assert_failed::<Option<&[N]>, Option<&[N]>>(move _188, _184, _185, move _190) -> unwind continue;
    }

    bb69: {
        _192 = const {alloc8: &Option<&[N]>};
        _193 = &_176;
        _191 = (_192, move _193);
        _194 = (_191.0: &std::option::Option<&[N]>);
        _195 = (_191.1: &std::option::Option<&[N]>);
        _197 = <Option<&[N]> as PartialEq>::eq(_194, _195) -> [return: bb70, unwind continue];
    }

    bb70: {
        _196 = Not(move _197);
        switchInt(move _196) -> [0: bb72, otherwise: bb71];
    }

    bb71: {
        _198 = core::panicking::AssertKind::Eq;
        _200 = Option::<Arguments<'_>>::None;
        _199 = core::panicking::assert_failed::<Option<&[N]>, Option<&[N]>>(move _198, _194, _195, move _200) -> unwind continue;
    }

    bb72: {
        _1172 = const _;
        _202 = _1172 as &[N] (Pointer(Unsize));
        _203 = Len((*_202));
        _204 = const 2_usize;
        _205 = Ge(move _203, move _204);
        switchInt(move _205) -> [0: bb74, otherwise: bb73];
    }

    bb73: {
        _206 = &(*_202)[0 of 2];
        _201 = Option::<&N>::Some(_206);
        goto -> bb75;
    }

    bb74: {
        _201 = Option::<&N>::None;
        goto -> bb75;
    }

    bb75: {
        _1171 = const _;
        _208 = &_201;
        _207 = (_1171, move _208);
        _209 = (_207.0: &std::option::Option<&N>);
        _210 = (_207.1: &std::option::Option<&N>);
        _212 = <Option<&N> as PartialEq>::eq(_209, _210) -> [return: bb76, unwind continue];
    }

    bb76: {
        _211 = Not(move _212);
        switchInt(move _211) -> [0: bb78, otherwise: bb77];
    }

    bb77: {
        _213 = core::panicking::AssertKind::Eq;
        _215 = Option::<Arguments<'_>>::None;
        _214 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _213, _209, _210, move _215) -> unwind continue;
    }

    bb78: {
        _217 = const {alloc9: &Option<&N>};
        _218 = &_201;
        _216 = (_217, move _218);
        _219 = (_216.0: &std::option::Option<&N>);
        _220 = (_216.1: &std::option::Option<&N>);
        _222 = <Option<&N> as PartialEq>::eq(_219, _220) -> [return: bb79, unwind continue];
    }

    bb79: {
        _221 = Not(move _222);
        switchInt(move _221) -> [0: bb81, otherwise: bb80];
    }

    bb80: {
        _223 = core::panicking::AssertKind::Eq;
        _225 = Option::<Arguments<'_>>::None;
        _224 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _223, _219, _220, move _225) -> unwind continue;
    }

    bb81: {
        _1170 = const _;
        _227 = _1170 as &[N] (Pointer(Unsize));
        _228 = Len((*_227));
        _229 = const 2_usize;
        _230 = Ge(move _228, move _229);
        switchInt(move _230) -> [0: bb82, otherwise: bb83];
    }

    bb82: {
        _226 = Option::<&N>::None;
        goto -> bb84;
    }

    bb83: {
        _231 = &(*_227)[0 of 2];
        _226 = Option::<&N>::Some(_231);
        goto -> bb84;
    }

    bb84: {
        _1169 = const _;
        _233 = &_226;
        _232 = (_1169, move _233);
        _234 = (_232.0: &std::option::Option<&N>);
        _235 = (_232.1: &std::option::Option<&N>);
        _237 = <Option<&N> as PartialEq>::eq(_234, _235) -> [return: bb85, unwind continue];
    }

    bb85: {
        _236 = Not(move _237);
        switchInt(move _236) -> [0: bb87, otherwise: bb86];
    }

    bb86: {
        _238 = core::panicking::AssertKind::Eq;
        _240 = Option::<Arguments<'_>>::None;
        _239 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _238, _234, _235, move _240) -> unwind continue;
    }

    bb87: {
        _242 = const {alloc10: &Option<&N>};
        _243 = &_226;
        _241 = (_242, move _243);
        _244 = (_241.0: &std::option::Option<&N>);
        _245 = (_241.1: &std::option::Option<&N>);
        _247 = <Option<&N> as PartialEq>::eq(_244, _245) -> [return: bb88, unwind continue];
    }

    bb88: {
        _246 = Not(move _247);
        switchInt(move _246) -> [0: bb90, otherwise: bb89];
    }

    bb89: {
        _248 = core::panicking::AssertKind::Eq;
        _250 = Option::<Arguments<'_>>::None;
        _249 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _248, _244, _245, move _250) -> unwind continue;
    }

    bb90: {
        _1168 = const _;
        _252 = _1168 as &[N] (Pointer(Unsize));
        _253 = Len((*_252));
        _254 = const 2_usize;
        _255 = Ge(move _253, move _254);
        switchInt(move _255) -> [0: bb92, otherwise: bb91];
    }

    bb91: {
        _256 = &(*_252)[-1 of 2];
        _251 = Option::<&N>::Some(_256);
        goto -> bb93;
    }

    bb92: {
        _251 = Option::<&N>::None;
        goto -> bb93;
    }

    bb93: {
        _1167 = const _;
        _258 = &_251;
        _257 = (_1167, move _258);
        _259 = (_257.0: &std::option::Option<&N>);
        _260 = (_257.1: &std::option::Option<&N>);
        _262 = <Option<&N> as PartialEq>::eq(_259, _260) -> [return: bb94, unwind continue];
    }

    bb94: {
        _261 = Not(move _262);
        switchInt(move _261) -> [0: bb96, otherwise: bb95];
    }

    bb95: {
        _263 = core::panicking::AssertKind::Eq;
        _265 = Option::<Arguments<'_>>::None;
        _264 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _263, _259, _260, move _265) -> unwind continue;
    }

    bb96: {
        _267 = const {alloc11: &Option<&N>};
        _268 = &_251;
        _266 = (_267, move _268);
        _269 = (_266.0: &std::option::Option<&N>);
        _270 = (_266.1: &std::option::Option<&N>);
        _272 = <Option<&N> as PartialEq>::eq(_269, _270) -> [return: bb97, unwind continue];
    }

    bb97: {
        _271 = Not(move _272);
        switchInt(move _271) -> [0: bb99, otherwise: bb98];
    }

    bb98: {
        _273 = core::panicking::AssertKind::Eq;
        _275 = Option::<Arguments<'_>>::None;
        _274 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _273, _269, _270, move _275) -> unwind continue;
    }

    bb99: {
        _1166 = const _;
        _277 = _1166 as &[N] (Pointer(Unsize));
        _278 = Len((*_277));
        _279 = const 2_usize;
        _280 = Ge(move _278, move _279);
        switchInt(move _280) -> [0: bb100, otherwise: bb101];
    }

    bb100: {
        _276 = Option::<&N>::None;
        goto -> bb102;
    }

    bb101: {
        _281 = &(*_277)[-1 of 2];
        _276 = Option::<&N>::Some(_281);
        goto -> bb102;
    }

    bb102: {
        _1165 = const _;
        _283 = &_276;
        _282 = (_1165, move _283);
        _284 = (_282.0: &std::option::Option<&N>);
        _285 = (_282.1: &std::option::Option<&N>);
        _287 = <Option<&N> as PartialEq>::eq(_284, _285) -> [return: bb103, unwind continue];
    }

    bb103: {
        _286 = Not(move _287);
        switchInt(move _286) -> [0: bb105, otherwise: bb104];
    }

    bb104: {
        _288 = core::panicking::AssertKind::Eq;
        _290 = Option::<Arguments<'_>>::None;
        _289 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _288, _284, _285, move _290) -> unwind continue;
    }

    bb105: {
        _292 = const {alloc12: &Option<&N>};
        _293 = &_276;
        _291 = (_292, move _293);
        _294 = (_291.0: &std::option::Option<&N>);
        _295 = (_291.1: &std::option::Option<&N>);
        _297 = <Option<&N> as PartialEq>::eq(_294, _295) -> [return: bb106, unwind continue];
    }

    bb106: {
        _296 = Not(move _297);
        switchInt(move _296) -> [0: bb108, otherwise: bb107];
    }

    bb107: {
        _298 = core::panicking::AssertKind::Eq;
        _300 = Option::<Arguments<'_>>::None;
        _299 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _298, _294, _295, move _300) -> unwind continue;
    }

    bb108: {
        _1164 = const _;
        _302 = _1164 as &[N] (Pointer(Unsize));
        _303 = Len((*_302));
        _304 = const 2_usize;
        _305 = Ge(move _303, move _304);
        switchInt(move _305) -> [0: bb110, otherwise: bb109];
    }

    bb109: {
        _306 = &(*_302)[1:-1];
        _301 = Option::<&[N]>::Some(_306);
        goto -> bb111;
    }

    bb110: {
        _301 = Option::<&[N]>::None;
        goto -> bb111;
    }

    bb111: {
        _1163 = const _;
        _308 = &_301;
        _307 = (_1163, move _308);
        _309 = (_307.0: &std::option::Option<&[N]>);
        _310 = (_307.1: &std::option::Option<&[N]>);
        _312 = <Option<&[N]> as PartialEq>::eq(_309, _310) -> [return: bb112, unwind continue];
    }

    bb112: {
        _311 = Not(move _312);
        switchInt(move _311) -> [0: bb114, otherwise: bb113];
    }

    bb113: {
        _313 = core::panicking::AssertKind::Eq;
        _315 = Option::<Arguments<'_>>::None;
        _314 = core::panicking::assert_failed::<Option<&[N]>, Option<&[N]>>(move _313, _309, _310, move _315) -> unwind continue;
    }

    bb114: {
        _317 = const {alloc13: &Option<&[N]>};
        _318 = &_301;
        _316 = (_317, move _318);
        _319 = (_316.0: &std::option::Option<&[N]>);
        _320 = (_316.1: &std::option::Option<&[N]>);
        _322 = <Option<&[N]> as PartialEq>::eq(_319, _320) -> [return: bb115, unwind continue];
    }

    bb115: {
        _321 = Not(move _322);
        switchInt(move _321) -> [0: bb117, otherwise: bb116];
    }

    bb116: {
        _323 = core::panicking::AssertKind::Eq;
        _325 = Option::<Arguments<'_>>::None;
        _324 = core::panicking::assert_failed::<Option<&[N]>, Option<&[N]>>(move _323, _319, _320, move _325) -> unwind continue;
    }

    bb117: {
        _1162 = const _;
        _327 = _1162 as &[N] (Pointer(Unsize));
        _328 = Len((*_327));
        _329 = const 2_usize;
        _330 = Ge(move _328, move _329);
        switchInt(move _330) -> [0: bb118, otherwise: bb119];
    }

    bb118: {
        _326 = Option::<&[N]>::None;
        goto -> bb120;
    }

    bb119: {
        _331 = &(*_327)[1:-1];
        _326 = Option::<&[N]>::Some(_331);
        goto -> bb120;
    }

    bb120: {
        _1161 = const _;
        _333 = &_326;
        _332 = (_1161, move _333);
        _334 = (_332.0: &std::option::Option<&[N]>);
        _335 = (_332.1: &std::option::Option<&[N]>);
        _337 = <Option<&[N]> as PartialEq>::eq(_334, _335) -> [return: bb121, unwind continue];
    }

    bb121: {
        _336 = Not(move _337);
        switchInt(move _336) -> [0: bb123, otherwise: bb122];
    }

    bb122: {
        _338 = core::panicking::AssertKind::Eq;
        _340 = Option::<Arguments<'_>>::None;
        _339 = core::panicking::assert_failed::<Option<&[N]>, Option<&[N]>>(move _338, _334, _335, move _340) -> unwind continue;
    }

    bb123: {
        _342 = const {alloc14: &Option<&[N]>};
        _343 = &_326;
        _341 = (_342, move _343);
        _344 = (_341.0: &std::option::Option<&[N]>);
        _345 = (_341.1: &std::option::Option<&[N]>);
        _347 = <Option<&[N]> as PartialEq>::eq(_344, _345) -> [return: bb124, unwind continue];
    }

    bb124: {
        _346 = Not(move _347);
        switchInt(move _346) -> [0: bb126, otherwise: bb125];
    }

    bb125: {
        _348 = core::panicking::AssertKind::Eq;
        _350 = Option::<Arguments<'_>>::None;
        _349 = core::panicking::assert_failed::<Option<&[N]>, Option<&[N]>>(move _348, _344, _345, move _350) -> unwind continue;
    }

    bb126: {
        _1160 = const _;
        _352 = _1160 as &[N] (Pointer(Unsize));
        _353 = Len((*_352));
        _354 = const 2_usize;
        _355 = Ge(move _353, move _354);
        switchInt(move _355) -> [0: bb128, otherwise: bb127];
    }

    bb127: {
        _356 = &(*_352)[0 of 2];
        _351 = Option::<&N>::Some(_356);
        goto -> bb129;
    }

    bb128: {
        _351 = Option::<&N>::None;
        goto -> bb129;
    }

    bb129: {
        _1159 = const _;
        _358 = &_351;
        _357 = (_1159, move _358);
        _359 = (_357.0: &std::option::Option<&N>);
        _360 = (_357.1: &std::option::Option<&N>);
        _362 = <Option<&N> as PartialEq>::eq(_359, _360) -> [return: bb130, unwind continue];
    }

    bb130: {
        _361 = Not(move _362);
        switchInt(move _361) -> [0: bb132, otherwise: bb131];
    }

    bb131: {
        _363 = core::panicking::AssertKind::Eq;
        _365 = Option::<Arguments<'_>>::None;
        _364 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _363, _359, _360, move _365) -> unwind continue;
    }

    bb132: {
        _367 = const {alloc15: &Option<&N>};
        _368 = &_351;
        _366 = (_367, move _368);
        _369 = (_366.0: &std::option::Option<&N>);
        _370 = (_366.1: &std::option::Option<&N>);
        _372 = <Option<&N> as PartialEq>::eq(_369, _370) -> [return: bb133, unwind continue];
    }

    bb133: {
        _371 = Not(move _372);
        switchInt(move _371) -> [0: bb135, otherwise: bb134];
    }

    bb134: {
        _373 = core::panicking::AssertKind::Eq;
        _375 = Option::<Arguments<'_>>::None;
        _374 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _373, _369, _370, move _375) -> unwind continue;
    }

    bb135: {
        _1158 = const _;
        _377 = _1158 as &[N] (Pointer(Unsize));
        _378 = Len((*_377));
        _379 = const 2_usize;
        _380 = Ge(move _378, move _379);
        switchInt(move _380) -> [0: bb136, otherwise: bb137];
    }

    bb136: {
        _376 = Option::<&N>::None;
        goto -> bb138;
    }

    bb137: {
        _381 = &(*_377)[0 of 2];
        _376 = Option::<&N>::Some(_381);
        goto -> bb138;
    }

    bb138: {
        _1157 = const _;
        _383 = &_376;
        _382 = (_1157, move _383);
        _384 = (_382.0: &std::option::Option<&N>);
        _385 = (_382.1: &std::option::Option<&N>);
        _387 = <Option<&N> as PartialEq>::eq(_384, _385) -> [return: bb139, unwind continue];
    }

    bb139: {
        _386 = Not(move _387);
        switchInt(move _386) -> [0: bb141, otherwise: bb140];
    }

    bb140: {
        _388 = core::panicking::AssertKind::Eq;
        _390 = Option::<Arguments<'_>>::None;
        _389 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _388, _384, _385, move _390) -> unwind continue;
    }

    bb141: {
        _392 = const {alloc16: &Option<&N>};
        _393 = &_376;
        _391 = (_392, move _393);
        _394 = (_391.0: &std::option::Option<&N>);
        _395 = (_391.1: &std::option::Option<&N>);
        _397 = <Option<&N> as PartialEq>::eq(_394, _395) -> [return: bb142, unwind continue];
    }

    bb142: {
        _396 = Not(move _397);
        switchInt(move _396) -> [0: bb144, otherwise: bb143];
    }

    bb143: {
        _398 = core::panicking::AssertKind::Eq;
        _400 = Option::<Arguments<'_>>::None;
        _399 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _398, _394, _395, move _400) -> unwind continue;
    }

    bb144: {
        _1156 = const _;
        _402 = _1156 as &[N] (Pointer(Unsize));
        _403 = Len((*_402));
        _404 = const 2_usize;
        _405 = Ge(move _403, move _404);
        switchInt(move _405) -> [0: bb146, otherwise: bb145];
    }

    bb145: {
        _406 = &(*_402)[-1 of 2];
        _401 = Option::<&N>::Some(_406);
        goto -> bb147;
    }

    bb146: {
        _401 = Option::<&N>::None;
        goto -> bb147;
    }

    bb147: {
        _1155 = const _;
        _408 = &_401;
        _407 = (_1155, move _408);
        _409 = (_407.0: &std::option::Option<&N>);
        _410 = (_407.1: &std::option::Option<&N>);
        _412 = <Option<&N> as PartialEq>::eq(_409, _410) -> [return: bb148, unwind continue];
    }

    bb148: {
        _411 = Not(move _412);
        switchInt(move _411) -> [0: bb150, otherwise: bb149];
    }

    bb149: {
        _413 = core::panicking::AssertKind::Eq;
        _415 = Option::<Arguments<'_>>::None;
        _414 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _413, _409, _410, move _415) -> unwind continue;
    }

    bb150: {
        _417 = const {alloc17: &Option<&N>};
        _418 = &_401;
        _416 = (_417, move _418);
        _419 = (_416.0: &std::option::Option<&N>);
        _420 = (_416.1: &std::option::Option<&N>);
        _422 = <Option<&N> as PartialEq>::eq(_419, _420) -> [return: bb151, unwind continue];
    }

    bb151: {
        _421 = Not(move _422);
        switchInt(move _421) -> [0: bb153, otherwise: bb152];
    }

    bb152: {
        _423 = core::panicking::AssertKind::Eq;
        _425 = Option::<Arguments<'_>>::None;
        _424 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _423, _419, _420, move _425) -> unwind continue;
    }

    bb153: {
        _1154 = const _;
        _427 = _1154 as &[N] (Pointer(Unsize));
        _428 = Len((*_427));
        _429 = const 2_usize;
        _430 = Ge(move _428, move _429);
        switchInt(move _430) -> [0: bb154, otherwise: bb155];
    }

    bb154: {
        _426 = Option::<&N>::None;
        goto -> bb156;
    }

    bb155: {
        _431 = &(*_427)[-1 of 2];
        _426 = Option::<&N>::Some(_431);
        goto -> bb156;
    }

    bb156: {
        _1153 = const _;
        _433 = &_426;
        _432 = (_1153, move _433);
        _434 = (_432.0: &std::option::Option<&N>);
        _435 = (_432.1: &std::option::Option<&N>);
        _437 = <Option<&N> as PartialEq>::eq(_434, _435) -> [return: bb157, unwind continue];
    }

    bb157: {
        _436 = Not(move _437);
        switchInt(move _436) -> [0: bb159, otherwise: bb158];
    }

    bb158: {
        _438 = core::panicking::AssertKind::Eq;
        _440 = Option::<Arguments<'_>>::None;
        _439 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _438, _434, _435, move _440) -> unwind continue;
    }

    bb159: {
        _442 = const {alloc18: &Option<&N>};
        _443 = &_426;
        _441 = (_442, move _443);
        _444 = (_441.0: &std::option::Option<&N>);
        _445 = (_441.1: &std::option::Option<&N>);
        _447 = <Option<&N> as PartialEq>::eq(_444, _445) -> [return: bb160, unwind continue];
    }

    bb160: {
        _446 = Not(move _447);
        switchInt(move _446) -> [0: bb162, otherwise: bb161];
    }

    bb161: {
        _448 = core::panicking::AssertKind::Eq;
        _450 = Option::<Arguments<'_>>::None;
        _449 = core::panicking::assert_failed::<Option<&N>, Option<&N>>(move _448, _444, _445, move _450) -> unwind continue;
    }

    bb162: {
        _1152 = const _;
        _452 = _1152 as &[Z] (Pointer(Unsize));
        _453 = Len((*_452));
        _454 = const 2_usize;
        _455 = Ge(move _453, move _454);
        switchInt(move _455) -> [0: bb164, otherwise: bb163];
    }

    bb163: {
        _456 = &(*_452)[1:-1];
        _451 = Option::<&[Z]>::Some(_456);
        goto -> bb165;
    }

    bb164: {
        _451 = Option::<&[Z]>::None;
        goto -> bb165;
    }

    bb165: {
        _1151 = const _;
        _458 = &_451;
        _457 = (_1151, move _458);
        _459 = (_457.0: &std::option::Option<&[Z]>);
        _460 = (_457.1: &std::option::Option<&[Z]>);
        _462 = <Option<&[Z]> as PartialEq>::eq(_459, _460) -> [return: bb166, unwind continue];
    }

    bb166: {
        _461 = Not(move _462);
        switchInt(move _461) -> [0: bb168, otherwise: bb167];
    }

    bb167: {
        _463 = core::panicking::AssertKind::Eq;
        _465 = Option::<Arguments<'_>>::None;
        _464 = core::panicking::assert_failed::<Option<&[Z]>, Option<&[Z]>>(move _463, _459, _460, move _465) -> unwind continue;
    }

    bb168: {
        _467 = const {alloc19: &Option<&[Z]>};
        _468 = &_451;
        _466 = (_467, move _468);
        _469 = (_466.0: &std::option::Option<&[Z]>);
        _470 = (_466.1: &std::option::Option<&[Z]>);
        _472 = <Option<&[Z]> as PartialEq>::eq(_469, _470) -> [return: bb169, unwind continue];
    }

    bb169: {
        _471 = Not(move _472);
        switchInt(move _471) -> [0: bb171, otherwise: bb170];
    }

    bb170: {
        _473 = core::panicking::AssertKind::Eq;
        _475 = Option::<Arguments<'_>>::None;
        _474 = core::panicking::assert_failed::<Option<&[Z]>, Option<&[Z]>>(move _473, _469, _470, move _475) -> unwind continue;
    }

    bb171: {
        _1150 = const _;
        _477 = _1150 as &[Z] (Pointer(Unsize));
        _478 = Len((*_477));
        _479 = const 2_usize;
        _480 = Ge(move _478, move _479);
        switchInt(move _480) -> [0: bb172, otherwise: bb173];
    }

    bb172: {
        _476 = Option::<&[Z]>::None;
        goto -> bb174;
    }

    bb173: {
        _481 = &(*_477)[1:-1];
        _476 = Option::<&[Z]>::Some(_481);
        goto -> bb174;
    }

    bb174: {
        _1149 = const _;
        _483 = &_476;
        _482 = (_1149, move _483);
        _484 = (_482.0: &std::option::Option<&[Z]>);
        _485 = (_482.1: &std::option::Option<&[Z]>);
        _487 = <Option<&[Z]> as PartialEq>::eq(_484, _485) -> [return: bb175, unwind continue];
    }

    bb175: {
        _486 = Not(move _487);
        switchInt(move _486) -> [0: bb177, otherwise: bb176];
    }

    bb176: {
        _488 = core::panicking::AssertKind::Eq;
        _490 = Option::<Arguments<'_>>::None;
        _489 = core::panicking::assert_failed::<Option<&[Z]>, Option<&[Z]>>(move _488, _484, _485, move _490) -> unwind continue;
    }

    bb177: {
        _492 = const {alloc20: &Option<&[Z]>};
        _493 = &_476;
        _491 = (_492, move _493);
        _494 = (_491.0: &std::option::Option<&[Z]>);
        _495 = (_491.1: &std::option::Option<&[Z]>);
        _497 = <Option<&[Z]> as PartialEq>::eq(_494, _495) -> [return: bb178, unwind continue];
    }

    bb178: {
        _496 = Not(move _497);
        switchInt(move _496) -> [0: bb180, otherwise: bb179];
    }

    bb179: {
        _498 = core::panicking::AssertKind::Eq;
        _500 = Option::<Arguments<'_>>::None;
        _499 = core::panicking::assert_failed::<Option<&[Z]>, Option<&[Z]>>(move _498, _494, _495, move _500) -> unwind continue;
    }

    bb180: {
        _1148 = const _;
        _502 = _1148 as &[Z] (Pointer(Unsize));
        _503 = Len((*_502));
        _504 = const 2_usize;
        _505 = Ge(move _503, move _504);
        switchInt(move _505) -> [0: bb182, otherwise: bb181];
    }

    bb181: {
        _506 = &(*_502)[0 of 2];
        _501 = Option::<&Z>::Some(_506);
        goto -> bb183;
    }

    bb182: {
        _501 = Option::<&Z>::None;
        goto -> bb183;
    }

    bb183: {
        _1147 = const _;
        _508 = &_501;
        _507 = (_1147, move _508);
        _509 = (_507.0: &std::option::Option<&Z>);
        _510 = (_507.1: &std::option::Option<&Z>);
        _512 = <Option<&Z> as PartialEq>::eq(_509, _510) -> [return: bb184, unwind continue];
    }

    bb184: {
        _511 = Not(move _512);
        switchInt(move _511) -> [0: bb186, otherwise: bb185];
    }

    bb185: {
        _513 = core::panicking::AssertKind::Eq;
        _515 = Option::<Arguments<'_>>::None;
        _514 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _513, _509, _510, move _515) -> unwind continue;
    }

    bb186: {
        _517 = const {alloc21: &Option<&Z>};
        _518 = &_501;
        _516 = (_517, move _518);
        _519 = (_516.0: &std::option::Option<&Z>);
        _520 = (_516.1: &std::option::Option<&Z>);
        _522 = <Option<&Z> as PartialEq>::eq(_519, _520) -> [return: bb187, unwind continue];
    }

    bb187: {
        _521 = Not(move _522);
        switchInt(move _521) -> [0: bb189, otherwise: bb188];
    }

    bb188: {
        _523 = core::panicking::AssertKind::Eq;
        _525 = Option::<Arguments<'_>>::None;
        _524 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _523, _519, _520, move _525) -> unwind continue;
    }

    bb189: {
        _1146 = const _;
        _527 = _1146 as &[Z] (Pointer(Unsize));
        _528 = Len((*_527));
        _529 = const 2_usize;
        _530 = Ge(move _528, move _529);
        switchInt(move _530) -> [0: bb190, otherwise: bb191];
    }

    bb190: {
        _526 = Option::<&Z>::None;
        goto -> bb192;
    }

    bb191: {
        _531 = &(*_527)[0 of 2];
        _526 = Option::<&Z>::Some(_531);
        goto -> bb192;
    }

    bb192: {
        _1145 = const _;
        _533 = &_526;
        _532 = (_1145, move _533);
        _534 = (_532.0: &std::option::Option<&Z>);
        _535 = (_532.1: &std::option::Option<&Z>);
        _537 = <Option<&Z> as PartialEq>::eq(_534, _535) -> [return: bb193, unwind continue];
    }

    bb193: {
        _536 = Not(move _537);
        switchInt(move _536) -> [0: bb195, otherwise: bb194];
    }

    bb194: {
        _538 = core::panicking::AssertKind::Eq;
        _540 = Option::<Arguments<'_>>::None;
        _539 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _538, _534, _535, move _540) -> unwind continue;
    }

    bb195: {
        _542 = const {alloc22: &Option<&Z>};
        _543 = &_526;
        _541 = (_542, move _543);
        _544 = (_541.0: &std::option::Option<&Z>);
        _545 = (_541.1: &std::option::Option<&Z>);
        _547 = <Option<&Z> as PartialEq>::eq(_544, _545) -> [return: bb196, unwind continue];
    }

    bb196: {
        _546 = Not(move _547);
        switchInt(move _546) -> [0: bb198, otherwise: bb197];
    }

    bb197: {
        _548 = core::panicking::AssertKind::Eq;
        _550 = Option::<Arguments<'_>>::None;
        _549 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _548, _544, _545, move _550) -> unwind continue;
    }

    bb198: {
        _1144 = const _;
        _552 = _1144 as &[Z] (Pointer(Unsize));
        _553 = Len((*_552));
        _554 = const 2_usize;
        _555 = Ge(move _553, move _554);
        switchInt(move _555) -> [0: bb200, otherwise: bb199];
    }

    bb199: {
        _556 = &(*_552)[-1 of 2];
        _551 = Option::<&Z>::Some(_556);
        goto -> bb201;
    }

    bb200: {
        _551 = Option::<&Z>::None;
        goto -> bb201;
    }

    bb201: {
        _1143 = const _;
        _558 = &_551;
        _557 = (_1143, move _558);
        _559 = (_557.0: &std::option::Option<&Z>);
        _560 = (_557.1: &std::option::Option<&Z>);
        _562 = <Option<&Z> as PartialEq>::eq(_559, _560) -> [return: bb202, unwind continue];
    }

    bb202: {
        _561 = Not(move _562);
        switchInt(move _561) -> [0: bb204, otherwise: bb203];
    }

    bb203: {
        _563 = core::panicking::AssertKind::Eq;
        _565 = Option::<Arguments<'_>>::None;
        _564 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _563, _559, _560, move _565) -> unwind continue;
    }

    bb204: {
        _567 = const {alloc23: &Option<&Z>};
        _568 = &_551;
        _566 = (_567, move _568);
        _569 = (_566.0: &std::option::Option<&Z>);
        _570 = (_566.1: &std::option::Option<&Z>);
        _572 = <Option<&Z> as PartialEq>::eq(_569, _570) -> [return: bb205, unwind continue];
    }

    bb205: {
        _571 = Not(move _572);
        switchInt(move _571) -> [0: bb207, otherwise: bb206];
    }

    bb206: {
        _573 = core::panicking::AssertKind::Eq;
        _575 = Option::<Arguments<'_>>::None;
        _574 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _573, _569, _570, move _575) -> unwind continue;
    }

    bb207: {
        _1142 = const _;
        _577 = _1142 as &[Z] (Pointer(Unsize));
        _578 = Len((*_577));
        _579 = const 2_usize;
        _580 = Ge(move _578, move _579);
        switchInt(move _580) -> [0: bb208, otherwise: bb209];
    }

    bb208: {
        _576 = Option::<&Z>::None;
        goto -> bb210;
    }

    bb209: {
        _581 = &(*_577)[-1 of 2];
        _576 = Option::<&Z>::Some(_581);
        goto -> bb210;
    }

    bb210: {
        _1141 = const _;
        _583 = &_576;
        _582 = (_1141, move _583);
        _584 = (_582.0: &std::option::Option<&Z>);
        _585 = (_582.1: &std::option::Option<&Z>);
        _587 = <Option<&Z> as PartialEq>::eq(_584, _585) -> [return: bb211, unwind continue];
    }

    bb211: {
        _586 = Not(move _587);
        switchInt(move _586) -> [0: bb213, otherwise: bb212];
    }

    bb212: {
        _588 = core::panicking::AssertKind::Eq;
        _590 = Option::<Arguments<'_>>::None;
        _589 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _588, _584, _585, move _590) -> unwind continue;
    }

    bb213: {
        _592 = const {alloc24: &Option<&Z>};
        _593 = &_576;
        _591 = (_592, move _593);
        _594 = (_591.0: &std::option::Option<&Z>);
        _595 = (_591.1: &std::option::Option<&Z>);
        _597 = <Option<&Z> as PartialEq>::eq(_594, _595) -> [return: bb214, unwind continue];
    }

    bb214: {
        _596 = Not(move _597);
        switchInt(move _596) -> [0: bb216, otherwise: bb215];
    }

    bb215: {
        _598 = core::panicking::AssertKind::Eq;
        _600 = Option::<Arguments<'_>>::None;
        _599 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _598, _594, _595, move _600) -> unwind continue;
    }

    bb216: {
        _1140 = const _;
        _602 = _1140 as &[Z] (Pointer(Unsize));
        _603 = Len((*_602));
        _604 = const 2_usize;
        _605 = Ge(move _603, move _604);
        switchInt(move _605) -> [0: bb218, otherwise: bb217];
    }

    bb217: {
        _606 = &(*_602)[1:-1];
        _601 = Option::<&[Z]>::Some(_606);
        goto -> bb219;
    }

    bb218: {
        _601 = Option::<&[Z]>::None;
        goto -> bb219;
    }

    bb219: {
        _1139 = const _;
        _608 = &_601;
        _607 = (_1139, move _608);
        _609 = (_607.0: &std::option::Option<&[Z]>);
        _610 = (_607.1: &std::option::Option<&[Z]>);
        _612 = <Option<&[Z]> as PartialEq>::eq(_609, _610) -> [return: bb220, unwind continue];
    }

    bb220: {
        _611 = Not(move _612);
        switchInt(move _611) -> [0: bb222, otherwise: bb221];
    }

    bb221: {
        _613 = core::panicking::AssertKind::Eq;
        _615 = Option::<Arguments<'_>>::None;
        _614 = core::panicking::assert_failed::<Option<&[Z]>, Option<&[Z]>>(move _613, _609, _610, move _615) -> unwind continue;
    }

    bb222: {
        _617 = const {alloc25: &Option<&[Z]>};
        _618 = &_601;
        _616 = (_617, move _618);
        _619 = (_616.0: &std::option::Option<&[Z]>);
        _620 = (_616.1: &std::option::Option<&[Z]>);
        _622 = <Option<&[Z]> as PartialEq>::eq(_619, _620) -> [return: bb223, unwind continue];
    }

    bb223: {
        _621 = Not(move _622);
        switchInt(move _621) -> [0: bb225, otherwise: bb224];
    }

    bb224: {
        _623 = core::panicking::AssertKind::Eq;
        _625 = Option::<Arguments<'_>>::None;
        _624 = core::panicking::assert_failed::<Option<&[Z]>, Option<&[Z]>>(move _623, _619, _620, move _625) -> unwind continue;
    }

    bb225: {
        _1138 = const _;
        _627 = _1138 as &[Z] (Pointer(Unsize));
        _628 = Len((*_627));
        _629 = const 2_usize;
        _630 = Ge(move _628, move _629);
        switchInt(move _630) -> [0: bb226, otherwise: bb227];
    }

    bb226: {
        _626 = Option::<&[Z]>::None;
        goto -> bb228;
    }

    bb227: {
        _631 = &(*_627)[1:-1];
        _626 = Option::<&[Z]>::Some(_631);
        goto -> bb228;
    }

    bb228: {
        _1137 = const _;
        _633 = &_626;
        _632 = (_1137, move _633);
        _634 = (_632.0: &std::option::Option<&[Z]>);
        _635 = (_632.1: &std::option::Option<&[Z]>);
        _637 = <Option<&[Z]> as PartialEq>::eq(_634, _635) -> [return: bb229, unwind continue];
    }

    bb229: {
        _636 = Not(move _637);
        switchInt(move _636) -> [0: bb231, otherwise: bb230];
    }

    bb230: {
        _638 = core::panicking::AssertKind::Eq;
        _640 = Option::<Arguments<'_>>::None;
        _639 = core::panicking::assert_failed::<Option<&[Z]>, Option<&[Z]>>(move _638, _634, _635, move _640) -> unwind continue;
    }

    bb231: {
        _642 = const {alloc26: &Option<&[Z]>};
        _643 = &_626;
        _641 = (_642, move _643);
        _644 = (_641.0: &std::option::Option<&[Z]>);
        _645 = (_641.1: &std::option::Option<&[Z]>);
        _647 = <Option<&[Z]> as PartialEq>::eq(_644, _645) -> [return: bb232, unwind continue];
    }

    bb232: {
        _646 = Not(move _647);
        switchInt(move _646) -> [0: bb234, otherwise: bb233];
    }

    bb233: {
        _648 = core::panicking::AssertKind::Eq;
        _650 = Option::<Arguments<'_>>::None;
        _649 = core::panicking::assert_failed::<Option<&[Z]>, Option<&[Z]>>(move _648, _644, _645, move _650) -> unwind continue;
    }

    bb234: {
        _1136 = const _;
        _652 = _1136 as &[Z] (Pointer(Unsize));
        _653 = Len((*_652));
        _654 = const 2_usize;
        _655 = Ge(move _653, move _654);
        switchInt(move _655) -> [0: bb236, otherwise: bb235];
    }

    bb235: {
        _656 = &(*_652)[0 of 2];
        _651 = Option::<&Z>::Some(_656);
        goto -> bb237;
    }

    bb236: {
        _651 = Option::<&Z>::None;
        goto -> bb237;
    }

    bb237: {
        _1135 = const _;
        _658 = &_651;
        _657 = (_1135, move _658);
        _659 = (_657.0: &std::option::Option<&Z>);
        _660 = (_657.1: &std::option::Option<&Z>);
        _662 = <Option<&Z> as PartialEq>::eq(_659, _660) -> [return: bb238, unwind continue];
    }

    bb238: {
        _661 = Not(move _662);
        switchInt(move _661) -> [0: bb240, otherwise: bb239];
    }

    bb239: {
        _663 = core::panicking::AssertKind::Eq;
        _665 = Option::<Arguments<'_>>::None;
        _664 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _663, _659, _660, move _665) -> unwind continue;
    }

    bb240: {
        _667 = const {alloc27: &Option<&Z>};
        _668 = &_651;
        _666 = (_667, move _668);
        _669 = (_666.0: &std::option::Option<&Z>);
        _670 = (_666.1: &std::option::Option<&Z>);
        _672 = <Option<&Z> as PartialEq>::eq(_669, _670) -> [return: bb241, unwind continue];
    }

    bb241: {
        _671 = Not(move _672);
        switchInt(move _671) -> [0: bb243, otherwise: bb242];
    }

    bb242: {
        _673 = core::panicking::AssertKind::Eq;
        _675 = Option::<Arguments<'_>>::None;
        _674 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _673, _669, _670, move _675) -> unwind continue;
    }

    bb243: {
        _1134 = const _;
        _677 = _1134 as &[Z] (Pointer(Unsize));
        _678 = Len((*_677));
        _679 = const 2_usize;
        _680 = Ge(move _678, move _679);
        switchInt(move _680) -> [0: bb244, otherwise: bb245];
    }

    bb244: {
        _676 = Option::<&Z>::None;
        goto -> bb246;
    }

    bb245: {
        _681 = &(*_677)[0 of 2];
        _676 = Option::<&Z>::Some(_681);
        goto -> bb246;
    }

    bb246: {
        _1133 = const _;
        _683 = &_676;
        _682 = (_1133, move _683);
        _684 = (_682.0: &std::option::Option<&Z>);
        _685 = (_682.1: &std::option::Option<&Z>);
        _687 = <Option<&Z> as PartialEq>::eq(_684, _685) -> [return: bb247, unwind continue];
    }

    bb247: {
        _686 = Not(move _687);
        switchInt(move _686) -> [0: bb249, otherwise: bb248];
    }

    bb248: {
        _688 = core::panicking::AssertKind::Eq;
        _690 = Option::<Arguments<'_>>::None;
        _689 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _688, _684, _685, move _690) -> unwind continue;
    }

    bb249: {
        _692 = const {alloc28: &Option<&Z>};
        _693 = &_676;
        _691 = (_692, move _693);
        _694 = (_691.0: &std::option::Option<&Z>);
        _695 = (_691.1: &std::option::Option<&Z>);
        _697 = <Option<&Z> as PartialEq>::eq(_694, _695) -> [return: bb250, unwind continue];
    }

    bb250: {
        _696 = Not(move _697);
        switchInt(move _696) -> [0: bb252, otherwise: bb251];
    }

    bb251: {
        _698 = core::panicking::AssertKind::Eq;
        _700 = Option::<Arguments<'_>>::None;
        _699 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _698, _694, _695, move _700) -> unwind continue;
    }

    bb252: {
        _1132 = const _;
        _702 = _1132 as &[Z] (Pointer(Unsize));
        _703 = Len((*_702));
        _704 = const 2_usize;
        _705 = Ge(move _703, move _704);
        switchInt(move _705) -> [0: bb254, otherwise: bb253];
    }

    bb253: {
        _706 = &(*_702)[-1 of 2];
        _701 = Option::<&Z>::Some(_706);
        goto -> bb255;
    }

    bb254: {
        _701 = Option::<&Z>::None;
        goto -> bb255;
    }

    bb255: {
        _1131 = const _;
        _708 = &_701;
        _707 = (_1131, move _708);
        _709 = (_707.0: &std::option::Option<&Z>);
        _710 = (_707.1: &std::option::Option<&Z>);
        _712 = <Option<&Z> as PartialEq>::eq(_709, _710) -> [return: bb256, unwind continue];
    }

    bb256: {
        _711 = Not(move _712);
        switchInt(move _711) -> [0: bb258, otherwise: bb257];
    }

    bb257: {
        _713 = core::panicking::AssertKind::Eq;
        _715 = Option::<Arguments<'_>>::None;
        _714 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _713, _709, _710, move _715) -> unwind continue;
    }

    bb258: {
        _717 = const {alloc29: &Option<&Z>};
        _718 = &_701;
        _716 = (_717, move _718);
        _719 = (_716.0: &std::option::Option<&Z>);
        _720 = (_716.1: &std::option::Option<&Z>);
        _722 = <Option<&Z> as PartialEq>::eq(_719, _720) -> [return: bb259, unwind continue];
    }

    bb259: {
        _721 = Not(move _722);
        switchInt(move _721) -> [0: bb261, otherwise: bb260];
    }

    bb260: {
        _723 = core::panicking::AssertKind::Eq;
        _725 = Option::<Arguments<'_>>::None;
        _724 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _723, _719, _720, move _725) -> unwind continue;
    }

    bb261: {
        _1130 = const _;
        _727 = _1130 as &[Z] (Pointer(Unsize));
        _728 = Len((*_727));
        _729 = const 2_usize;
        _730 = Ge(move _728, move _729);
        switchInt(move _730) -> [0: bb262, otherwise: bb263];
    }

    bb262: {
        _726 = Option::<&Z>::None;
        goto -> bb264;
    }

    bb263: {
        _731 = &(*_727)[-1 of 2];
        _726 = Option::<&Z>::Some(_731);
        goto -> bb264;
    }

    bb264: {
        _1129 = const _;
        _733 = &_726;
        _732 = (_1129, move _733);
        _734 = (_732.0: &std::option::Option<&Z>);
        _735 = (_732.1: &std::option::Option<&Z>);
        _737 = <Option<&Z> as PartialEq>::eq(_734, _735) -> [return: bb265, unwind continue];
    }

    bb265: {
        _736 = Not(move _737);
        switchInt(move _736) -> [0: bb267, otherwise: bb266];
    }

    bb266: {
        _738 = core::panicking::AssertKind::Eq;
        _740 = Option::<Arguments<'_>>::None;
        _739 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _738, _734, _735, move _740) -> unwind continue;
    }

    bb267: {
        _742 = const {alloc30: &Option<&Z>};
        _743 = &_726;
        _741 = (_742, move _743);
        _744 = (_741.0: &std::option::Option<&Z>);
        _745 = (_741.1: &std::option::Option<&Z>);
        _747 = <Option<&Z> as PartialEq>::eq(_744, _745) -> [return: bb268, unwind continue];
    }

    bb268: {
        _746 = Not(move _747);
        switchInt(move _746) -> [0: bb270, otherwise: bb269];
    }

    bb269: {
        _748 = core::panicking::AssertKind::Eq;
        _750 = Option::<Arguments<'_>>::None;
        _749 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _748, _744, _745, move _750) -> unwind continue;
    }

    bb270: {
        _1128 = const _;
        _752 = _1128 as &[Z] (Pointer(Unsize));
        _753 = Len((*_752));
        _754 = const 2_usize;
        _755 = Ge(move _753, move _754);
        switchInt(move _755) -> [0: bb272, otherwise: bb271];
    }

    bb271: {
        _756 = &(*_752)[1:-1];
        _751 = Option::<&[Z]>::Some(_756);
        goto -> bb273;
    }

    bb272: {
        _751 = Option::<&[Z]>::None;
        goto -> bb273;
    }

    bb273: {
        _1127 = const _;
        _758 = &_751;
        _757 = (_1127, move _758);
        _759 = (_757.0: &std::option::Option<&[Z]>);
        _760 = (_757.1: &std::option::Option<&[Z]>);
        _762 = <Option<&[Z]> as PartialEq>::eq(_759, _760) -> [return: bb274, unwind continue];
    }

    bb274: {
        _761 = Not(move _762);
        switchInt(move _761) -> [0: bb276, otherwise: bb275];
    }

    bb275: {
        _763 = core::panicking::AssertKind::Eq;
        _765 = Option::<Arguments<'_>>::None;
        _764 = core::panicking::assert_failed::<Option<&[Z]>, Option<&[Z]>>(move _763, _759, _760, move _765) -> unwind continue;
    }

    bb276: {
        _767 = const {alloc31: &Option<&[Z]>};
        _768 = &_751;
        _766 = (_767, move _768);
        _769 = (_766.0: &std::option::Option<&[Z]>);
        _770 = (_766.1: &std::option::Option<&[Z]>);
        _772 = <Option<&[Z]> as PartialEq>::eq(_769, _770) -> [return: bb277, unwind continue];
    }

    bb277: {
        _771 = Not(move _772);
        switchInt(move _771) -> [0: bb279, otherwise: bb278];
    }

    bb278: {
        _773 = core::panicking::AssertKind::Eq;
        _775 = Option::<Arguments<'_>>::None;
        _774 = core::panicking::assert_failed::<Option<&[Z]>, Option<&[Z]>>(move _773, _769, _770, move _775) -> unwind continue;
    }

    bb279: {
        _1126 = const _;
        _777 = _1126 as &[Z] (Pointer(Unsize));
        _778 = Len((*_777));
        _779 = const 2_usize;
        _780 = Ge(move _778, move _779);
        switchInt(move _780) -> [0: bb280, otherwise: bb281];
    }

    bb280: {
        _776 = Option::<&[Z]>::None;
        goto -> bb282;
    }

    bb281: {
        _781 = &(*_777)[1:-1];
        _776 = Option::<&[Z]>::Some(_781);
        goto -> bb282;
    }

    bb282: {
        _1125 = const _;
        _783 = &_776;
        _782 = (_1125, move _783);
        _784 = (_782.0: &std::option::Option<&[Z]>);
        _785 = (_782.1: &std::option::Option<&[Z]>);
        _787 = <Option<&[Z]> as PartialEq>::eq(_784, _785) -> [return: bb283, unwind continue];
    }

    bb283: {
        _786 = Not(move _787);
        switchInt(move _786) -> [0: bb285, otherwise: bb284];
    }

    bb284: {
        _788 = core::panicking::AssertKind::Eq;
        _790 = Option::<Arguments<'_>>::None;
        _789 = core::panicking::assert_failed::<Option<&[Z]>, Option<&[Z]>>(move _788, _784, _785, move _790) -> unwind continue;
    }

    bb285: {
        _792 = const {alloc32: &Option<&[Z]>};
        _793 = &_776;
        _791 = (_792, move _793);
        _794 = (_791.0: &std::option::Option<&[Z]>);
        _795 = (_791.1: &std::option::Option<&[Z]>);
        _797 = <Option<&[Z]> as PartialEq>::eq(_794, _795) -> [return: bb286, unwind continue];
    }

    bb286: {
        _796 = Not(move _797);
        switchInt(move _796) -> [0: bb288, otherwise: bb287];
    }

    bb287: {
        _798 = core::panicking::AssertKind::Eq;
        _800 = Option::<Arguments<'_>>::None;
        _799 = core::panicking::assert_failed::<Option<&[Z]>, Option<&[Z]>>(move _798, _794, _795, move _800) -> unwind continue;
    }

    bb288: {
        _1124 = const _;
        _802 = _1124 as &[Z] (Pointer(Unsize));
        _803 = Len((*_802));
        _804 = const 2_usize;
        _805 = Ge(move _803, move _804);
        switchInt(move _805) -> [0: bb290, otherwise: bb289];
    }

    bb289: {
        _806 = &(*_802)[0 of 2];
        _801 = Option::<&Z>::Some(_806);
        goto -> bb291;
    }

    bb290: {
        _801 = Option::<&Z>::None;
        goto -> bb291;
    }

    bb291: {
        _1123 = const _;
        _808 = &_801;
        _807 = (_1123, move _808);
        _809 = (_807.0: &std::option::Option<&Z>);
        _810 = (_807.1: &std::option::Option<&Z>);
        _812 = <Option<&Z> as PartialEq>::eq(_809, _810) -> [return: bb292, unwind continue];
    }

    bb292: {
        _811 = Not(move _812);
        switchInt(move _811) -> [0: bb294, otherwise: bb293];
    }

    bb293: {
        _813 = core::panicking::AssertKind::Eq;
        _815 = Option::<Arguments<'_>>::None;
        _814 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _813, _809, _810, move _815) -> unwind continue;
    }

    bb294: {
        _817 = const {alloc33: &Option<&Z>};
        _818 = &_801;
        _816 = (_817, move _818);
        _819 = (_816.0: &std::option::Option<&Z>);
        _820 = (_816.1: &std::option::Option<&Z>);
        _822 = <Option<&Z> as PartialEq>::eq(_819, _820) -> [return: bb295, unwind continue];
    }

    bb295: {
        _821 = Not(move _822);
        switchInt(move _821) -> [0: bb297, otherwise: bb296];
    }

    bb296: {
        _823 = core::panicking::AssertKind::Eq;
        _825 = Option::<Arguments<'_>>::None;
        _824 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _823, _819, _820, move _825) -> unwind continue;
    }

    bb297: {
        _1122 = const _;
        _827 = _1122 as &[Z] (Pointer(Unsize));
        _828 = Len((*_827));
        _829 = const 2_usize;
        _830 = Ge(move _828, move _829);
        switchInt(move _830) -> [0: bb298, otherwise: bb299];
    }

    bb298: {
        _826 = Option::<&Z>::None;
        goto -> bb300;
    }

    bb299: {
        _831 = &(*_827)[0 of 2];
        _826 = Option::<&Z>::Some(_831);
        goto -> bb300;
    }

    bb300: {
        _1121 = const _;
        _833 = &_826;
        _832 = (_1121, move _833);
        _834 = (_832.0: &std::option::Option<&Z>);
        _835 = (_832.1: &std::option::Option<&Z>);
        _837 = <Option<&Z> as PartialEq>::eq(_834, _835) -> [return: bb301, unwind continue];
    }

    bb301: {
        _836 = Not(move _837);
        switchInt(move _836) -> [0: bb303, otherwise: bb302];
    }

    bb302: {
        _838 = core::panicking::AssertKind::Eq;
        _840 = Option::<Arguments<'_>>::None;
        _839 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _838, _834, _835, move _840) -> unwind continue;
    }

    bb303: {
        _842 = const {alloc34: &Option<&Z>};
        _843 = &_826;
        _841 = (_842, move _843);
        _844 = (_841.0: &std::option::Option<&Z>);
        _845 = (_841.1: &std::option::Option<&Z>);
        _847 = <Option<&Z> as PartialEq>::eq(_844, _845) -> [return: bb304, unwind continue];
    }

    bb304: {
        _846 = Not(move _847);
        switchInt(move _846) -> [0: bb306, otherwise: bb305];
    }

    bb305: {
        _848 = core::panicking::AssertKind::Eq;
        _850 = Option::<Arguments<'_>>::None;
        _849 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _848, _844, _845, move _850) -> unwind continue;
    }

    bb306: {
        _1120 = const _;
        _852 = _1120 as &[Z] (Pointer(Unsize));
        _853 = Len((*_852));
        _854 = const 2_usize;
        _855 = Ge(move _853, move _854);
        switchInt(move _855) -> [0: bb308, otherwise: bb307];
    }

    bb307: {
        _856 = &(*_852)[-1 of 2];
        _851 = Option::<&Z>::Some(_856);
        goto -> bb309;
    }

    bb308: {
        _851 = Option::<&Z>::None;
        goto -> bb309;
    }

    bb309: {
        _1119 = const _;
        _858 = &_851;
        _857 = (_1119, move _858);
        _859 = (_857.0: &std::option::Option<&Z>);
        _860 = (_857.1: &std::option::Option<&Z>);
        _862 = <Option<&Z> as PartialEq>::eq(_859, _860) -> [return: bb310, unwind continue];
    }

    bb310: {
        _861 = Not(move _862);
        switchInt(move _861) -> [0: bb312, otherwise: bb311];
    }

    bb311: {
        _863 = core::panicking::AssertKind::Eq;
        _865 = Option::<Arguments<'_>>::None;
        _864 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _863, _859, _860, move _865) -> unwind continue;
    }

    bb312: {
        _867 = const {alloc35: &Option<&Z>};
        _868 = &_851;
        _866 = (_867, move _868);
        _869 = (_866.0: &std::option::Option<&Z>);
        _870 = (_866.1: &std::option::Option<&Z>);
        _872 = <Option<&Z> as PartialEq>::eq(_869, _870) -> [return: bb313, unwind continue];
    }

    bb313: {
        _871 = Not(move _872);
        switchInt(move _871) -> [0: bb315, otherwise: bb314];
    }

    bb314: {
        _873 = core::panicking::AssertKind::Eq;
        _875 = Option::<Arguments<'_>>::None;
        _874 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _873, _869, _870, move _875) -> unwind continue;
    }

    bb315: {
        _1118 = const _;
        _877 = _1118 as &[Z] (Pointer(Unsize));
        _878 = Len((*_877));
        _879 = const 2_usize;
        _880 = Ge(move _878, move _879);
        switchInt(move _880) -> [0: bb316, otherwise: bb317];
    }

    bb316: {
        _876 = Option::<&Z>::None;
        goto -> bb318;
    }

    bb317: {
        _881 = &(*_877)[-1 of 2];
        _876 = Option::<&Z>::Some(_881);
        goto -> bb318;
    }

    bb318: {
        _1117 = const _;
        _883 = &_876;
        _882 = (_1117, move _883);
        _884 = (_882.0: &std::option::Option<&Z>);
        _885 = (_882.1: &std::option::Option<&Z>);
        _887 = <Option<&Z> as PartialEq>::eq(_884, _885) -> [return: bb319, unwind continue];
    }

    bb319: {
        _886 = Not(move _887);
        switchInt(move _886) -> [0: bb321, otherwise: bb320];
    }

    bb320: {
        _888 = core::panicking::AssertKind::Eq;
        _890 = Option::<Arguments<'_>>::None;
        _889 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _888, _884, _885, move _890) -> unwind continue;
    }

    bb321: {
        _892 = const {alloc36: &Option<&Z>};
        _893 = &_876;
        _891 = (_892, move _893);
        _894 = (_891.0: &std::option::Option<&Z>);
        _895 = (_891.1: &std::option::Option<&Z>);
        _897 = <Option<&Z> as PartialEq>::eq(_894, _895) -> [return: bb322, unwind continue];
    }

    bb322: {
        _896 = Not(move _897);
        switchInt(move _896) -> [0: bb324, otherwise: bb323];
    }

    bb323: {
        _898 = core::panicking::AssertKind::Eq;
        _900 = Option::<Arguments<'_>>::None;
        _899 = core::panicking::assert_failed::<Option<&Z>, Option<&Z>>(move _898, _894, _895, move _900) -> unwind continue;
    }

    bb324: {
        _1116 = const _;
        _902 = _1116 as &[N] (Pointer(Unsize));
        _903 = Len((*_902));
        _904 = const 2_usize;
        _905 = Ge(move _903, move _904);
        switchInt(move _905) -> [0: bb326, otherwise: bb325];
    }

    bb325: {
        _906 = &((*_902)[0 of 2].0: u8);
        _901 = Option::<&u8>::Some(_906);
        goto -> bb327;
    }

    bb326: {
        _901 = Option::<&u8>::None;
        goto -> bb327;
    }

    bb327: {
        _1115 = const _;
        _908 = &_901;
        _907 = (_1115, move _908);
        _909 = (_907.0: &std::option::Option<&u8>);
        _910 = (_907.1: &std::option::Option<&u8>);
        _912 = <Option<&u8> as PartialEq>::eq(_909, _910) -> [return: bb328, unwind continue];
    }

    bb328: {
        _911 = Not(move _912);
        switchInt(move _911) -> [0: bb330, otherwise: bb329];
    }

    bb329: {
        _913 = core::panicking::AssertKind::Eq;
        _915 = Option::<Arguments<'_>>::None;
        _914 = core::panicking::assert_failed::<Option<&u8>, Option<&u8>>(move _913, _909, _910, move _915) -> unwind continue;
    }

    bb330: {
        _917 = const {alloc37: &Option<&u8>};
        _918 = &_901;
        _916 = (_917, move _918);
        _919 = (_916.0: &std::option::Option<&u8>);
        _920 = (_916.1: &std::option::Option<&u8>);
        _922 = <Option<&u8> as PartialEq>::eq(_919, _920) -> [return: bb331, unwind continue];
    }

    bb331: {
        _921 = Not(move _922);
        switchInt(move _921) -> [0: bb333, otherwise: bb332];
    }

    bb332: {
        _923 = core::panicking::AssertKind::Eq;
        _925 = Option::<Arguments<'_>>::None;
        _924 = core::panicking::assert_failed::<Option<&u8>, Option<&u8>>(move _923, _919, _920, move _925) -> unwind continue;
    }

    bb333: {
        _1114 = const _;
        _927 = _1114 as &[N] (Pointer(Unsize));
        _928 = Len((*_927));
        _929 = const 2_usize;
        _930 = Ge(move _928, move _929);
        switchInt(move _930) -> [0: bb334, otherwise: bb335];
    }

    bb334: {
        _926 = Option::<&u8>::None;
        goto -> bb336;
    }

    bb335: {
        _931 = &((*_927)[0 of 2].0: u8);
        _926 = Option::<&u8>::Some(_931);
        goto -> bb336;
    }

    bb336: {
        _1113 = const _;
        _933 = &_926;
        _932 = (_1113, move _933);
        _934 = (_932.0: &std::option::Option<&u8>);
        _935 = (_932.1: &std::option::Option<&u8>);
        _937 = <Option<&u8> as PartialEq>::eq(_934, _935) -> [return: bb337, unwind continue];
    }

    bb337: {
        _936 = Not(move _937);
        switchInt(move _936) -> [0: bb339, otherwise: bb338];
    }

    bb338: {
        _938 = core::panicking::AssertKind::Eq;
        _940 = Option::<Arguments<'_>>::None;
        _939 = core::panicking::assert_failed::<Option<&u8>, Option<&u8>>(move _938, _934, _935, move _940) -> unwind continue;
    }

    bb339: {
        _942 = const {alloc38: &Option<&u8>};
        _943 = &_926;
        _941 = (_942, move _943);
        _944 = (_941.0: &std::option::Option<&u8>);
        _945 = (_941.1: &std::option::Option<&u8>);
        _947 = <Option<&u8> as PartialEq>::eq(_944, _945) -> [return: bb340, unwind continue];
    }

    bb340: {
        _946 = Not(move _947);
        switchInt(move _946) -> [0: bb342, otherwise: bb341];
    }

    bb341: {
        _948 = core::panicking::AssertKind::Eq;
        _950 = Option::<Arguments<'_>>::None;
        _949 = core::panicking::assert_failed::<Option<&u8>, Option<&u8>>(move _948, _944, _945, move _950) -> unwind continue;
    }

    bb342: {
        _1112 = const _;
        _952 = _1112 as &[N] (Pointer(Unsize));
        _953 = Len((*_952));
        _954 = const 2_usize;
        _955 = Ge(move _953, move _954);
        switchInt(move _955) -> [0: bb344, otherwise: bb343];
    }

    bb343: {
        _956 = &((*_952)[-1 of 2].0: u8);
        _951 = Option::<&u8>::Some(_956);
        goto -> bb345;
    }

    bb344: {
        _951 = Option::<&u8>::None;
        goto -> bb345;
    }

    bb345: {
        _1111 = const _;
        _958 = &_951;
        _957 = (_1111, move _958);
        _959 = (_957.0: &std::option::Option<&u8>);
        _960 = (_957.1: &std::option::Option<&u8>);
        _962 = <Option<&u8> as PartialEq>::eq(_959, _960) -> [return: bb346, unwind continue];
    }

    bb346: {
        _961 = Not(move _962);
        switchInt(move _961) -> [0: bb348, otherwise: bb347];
    }

    bb347: {
        _963 = core::panicking::AssertKind::Eq;
        _965 = Option::<Arguments<'_>>::None;
        _964 = core::panicking::assert_failed::<Option<&u8>, Option<&u8>>(move _963, _959, _960, move _965) -> unwind continue;
    }

    bb348: {
        _967 = const {alloc39: &Option<&u8>};
        _968 = &_951;
        _966 = (_967, move _968);
        _969 = (_966.0: &std::option::Option<&u8>);
        _970 = (_966.1: &std::option::Option<&u8>);
        _972 = <Option<&u8> as PartialEq>::eq(_969, _970) -> [return: bb349, unwind continue];
    }

    bb349: {
        _971 = Not(move _972);
        switchInt(move _971) -> [0: bb351, otherwise: bb350];
    }

    bb350: {
        _973 = core::panicking::AssertKind::Eq;
        _975 = Option::<Arguments<'_>>::None;
        _974 = core::panicking::assert_failed::<Option<&u8>, Option<&u8>>(move _973, _969, _970, move _975) -> unwind continue;
    }

    bb351: {
        _1110 = const _;
        _977 = _1110 as &[N] (Pointer(Unsize));
        _978 = Len((*_977));
        _979 = const 2_usize;
        _980 = Ge(move _978, move _979);
        switchInt(move _980) -> [0: bb352, otherwise: bb353];
    }

    bb352: {
        _976 = Option::<&u8>::None;
        goto -> bb354;
    }

    bb353: {
        _981 = &((*_977)[-1 of 2].0: u8);
        _976 = Option::<&u8>::Some(_981);
        goto -> bb354;
    }

    bb354: {
        _1109 = const _;
        _983 = &_976;
        _982 = (_1109, move _983);
        _984 = (_982.0: &std::option::Option<&u8>);
        _985 = (_982.1: &std::option::Option<&u8>);
        _987 = <Option<&u8> as PartialEq>::eq(_984, _985) -> [return: bb355, unwind continue];
    }

    bb355: {
        _986 = Not(move _987);
        switchInt(move _986) -> [0: bb357, otherwise: bb356];
    }

    bb356: {
        _988 = core::panicking::AssertKind::Eq;
        _990 = Option::<Arguments<'_>>::None;
        _989 = core::panicking::assert_failed::<Option<&u8>, Option<&u8>>(move _988, _984, _985, move _990) -> unwind continue;
    }

    bb357: {
        _992 = const {alloc40: &Option<&u8>};
        _993 = &_976;
        _991 = (_992, move _993);
        _994 = (_991.0: &std::option::Option<&u8>);
        _995 = (_991.1: &std::option::Option<&u8>);
        _997 = <Option<&u8> as PartialEq>::eq(_994, _995) -> [return: bb358, unwind continue];
    }

    bb358: {
        _996 = Not(move _997);
        switchInt(move _996) -> [0: bb360, otherwise: bb359];
    }

    bb359: {
        _998 = core::panicking::AssertKind::Eq;
        _1000 = Option::<Arguments<'_>>::None;
        _999 = core::panicking::assert_failed::<Option<&u8>, Option<&u8>>(move _998, _994, _995, move _1000) -> unwind continue;
    }

    bb360: {
        _1108 = const _;
        _1002 = _1108 as &[N] (Pointer(Unsize));
        _1003 = Len((*_1002));
        _1004 = const 2_usize;
        _1005 = Ge(move _1003, move _1004);
        switchInt(move _1005) -> [0: bb362, otherwise: bb361];
    }

    bb361: {
        _1006 = &((*_1002)[0 of 2].0: u8);
        _1001 = Option::<&u8>::Some(_1006);
        goto -> bb363;
    }

    bb362: {
        _1001 = Option::<&u8>::None;
        goto -> bb363;
    }

    bb363: {
        _1107 = const _;
        _1008 = &_1001;
        _1007 = (_1107, move _1008);
        _1009 = (_1007.0: &std::option::Option<&u8>);
        _1010 = (_1007.1: &std::option::Option<&u8>);
        _1012 = <Option<&u8> as PartialEq>::eq(_1009, _1010) -> [return: bb364, unwind continue];
    }

    bb364: {
        _1011 = Not(move _1012);
        switchInt(move _1011) -> [0: bb366, otherwise: bb365];
    }

    bb365: {
        _1013 = core::panicking::AssertKind::Eq;
        _1015 = Option::<Arguments<'_>>::None;
        _1014 = core::panicking::assert_failed::<Option<&u8>, Option<&u8>>(move _1013, _1009, _1010, move _1015) -> unwind continue;
    }

    bb366: {
        _1017 = const {alloc41: &Option<&u8>};
        _1018 = &_1001;
        _1016 = (_1017, move _1018);
        _1019 = (_1016.0: &std::option::Option<&u8>);
        _1020 = (_1016.1: &std::option::Option<&u8>);
        _1022 = <Option<&u8> as PartialEq>::eq(_1019, _1020) -> [return: bb367, unwind continue];
    }

    bb367: {
        _1021 = Not(move _1022);
        switchInt(move _1021) -> [0: bb369, otherwise: bb368];
    }

    bb368: {
        _1023 = core::panicking::AssertKind::Eq;
        _1025 = Option::<Arguments<'_>>::None;
        _1024 = core::panicking::assert_failed::<Option<&u8>, Option<&u8>>(move _1023, _1019, _1020, move _1025) -> unwind continue;
    }

    bb369: {
        _1106 = const _;
        _1027 = _1106 as &[N] (Pointer(Unsize));
        _1028 = Len((*_1027));
        _1029 = const 2_usize;
        _1030 = Ge(move _1028, move _1029);
        switchInt(move _1030) -> [0: bb370, otherwise: bb371];
    }

    bb370: {
        _1026 = Option::<&u8>::None;
        goto -> bb372;
    }

    bb371: {
        _1031 = &((*_1027)[0 of 2].0: u8);
        _1026 = Option::<&u8>::Some(_1031);
        goto -> bb372;
    }

    bb372: {
        _1105 = const _;
        _1033 = &_1026;
        _1032 = (_1105, move _1033);
        _1034 = (_1032.0: &std::option::Option<&u8>);
        _1035 = (_1032.1: &std::option::Option<&u8>);
        _1037 = <Option<&u8> as PartialEq>::eq(_1034, _1035) -> [return: bb373, unwind continue];
    }

    bb373: {
        _1036 = Not(move _1037);
        switchInt(move _1036) -> [0: bb375, otherwise: bb374];
    }

    bb374: {
        _1038 = core::panicking::AssertKind::Eq;
        _1040 = Option::<Arguments<'_>>::None;
        _1039 = core::panicking::assert_failed::<Option<&u8>, Option<&u8>>(move _1038, _1034, _1035, move _1040) -> unwind continue;
    }

    bb375: {
        _1042 = const {alloc42: &Option<&u8>};
        _1043 = &_1026;
        _1041 = (_1042, move _1043);
        _1044 = (_1041.0: &std::option::Option<&u8>);
        _1045 = (_1041.1: &std::option::Option<&u8>);
        _1047 = <Option<&u8> as PartialEq>::eq(_1044, _1045) -> [return: bb376, unwind continue];
    }

    bb376: {
        _1046 = Not(move _1047);
        switchInt(move _1046) -> [0: bb378, otherwise: bb377];
    }

    bb377: {
        _1048 = core::panicking::AssertKind::Eq;
        _1050 = Option::<Arguments<'_>>::None;
        _1049 = core::panicking::assert_failed::<Option<&u8>, Option<&u8>>(move _1048, _1044, _1045, move _1050) -> unwind continue;
    }

    bb378: {
        _1104 = const _;
        _1052 = _1104 as &[N] (Pointer(Unsize));
        _1053 = Len((*_1052));
        _1054 = const 2_usize;
        _1055 = Ge(move _1053, move _1054);
        switchInt(move _1055) -> [0: bb380, otherwise: bb379];
    }

    bb379: {
        _1056 = &((*_1052)[-1 of 2].0: u8);
        _1051 = Option::<&u8>::Some(_1056);
        goto -> bb381;
    }

    bb380: {
        _1051 = Option::<&u8>::None;
        goto -> bb381;
    }

    bb381: {
        _1103 = const _;
        _1058 = &_1051;
        _1057 = (_1103, move _1058);
        _1059 = (_1057.0: &std::option::Option<&u8>);
        _1060 = (_1057.1: &std::option::Option<&u8>);
        _1062 = <Option<&u8> as PartialEq>::eq(_1059, _1060) -> [return: bb382, unwind continue];
    }

    bb382: {
        _1061 = Not(move _1062);
        switchInt(move _1061) -> [0: bb384, otherwise: bb383];
    }

    bb383: {
        _1063 = core::panicking::AssertKind::Eq;
        _1065 = Option::<Arguments<'_>>::None;
        _1064 = core::panicking::assert_failed::<Option<&u8>, Option<&u8>>(move _1063, _1059, _1060, move _1065) -> unwind continue;
    }

    bb384: {
        _1067 = const {alloc43: &Option<&u8>};
        _1068 = &_1051;
        _1066 = (_1067, move _1068);
        _1069 = (_1066.0: &std::option::Option<&u8>);
        _1070 = (_1066.1: &std::option::Option<&u8>);
        _1072 = <Option<&u8> as PartialEq>::eq(_1069, _1070) -> [return: bb385, unwind continue];
    }

    bb385: {
        _1071 = Not(move _1072);
        switchInt(move _1071) -> [0: bb387, otherwise: bb386];
    }

    bb386: {
        _1073 = core::panicking::AssertKind::Eq;
        _1075 = Option::<Arguments<'_>>::None;
        _1074 = core::panicking::assert_failed::<Option<&u8>, Option<&u8>>(move _1073, _1069, _1070, move _1075) -> unwind continue;
    }

    bb387: {
        _1102 = const _;
        _1077 = _1102 as &[N] (Pointer(Unsize));
        _1078 = Len((*_1077));
        _1079 = const 2_usize;
        _1080 = Ge(move _1078, move _1079);
        switchInt(move _1080) -> [0: bb388, otherwise: bb389];
    }

    bb388: {
        _1076 = Option::<&u8>::None;
        goto -> bb390;
    }

    bb389: {
        _1081 = &((*_1077)[-1 of 2].0: u8);
        _1076 = Option::<&u8>::Some(_1081);
        goto -> bb390;
    }

    bb390: {
        _1101 = const _;
        _1083 = &_1076;
        _1082 = (_1101, move _1083);
        _1084 = (_1082.0: &std::option::Option<&u8>);
        _1085 = (_1082.1: &std::option::Option<&u8>);
        _1087 = <Option<&u8> as PartialEq>::eq(_1084, _1085) -> [return: bb391, unwind continue];
    }

    bb391: {
        _1086 = Not(move _1087);
        switchInt(move _1086) -> [0: bb393, otherwise: bb392];
    }

    bb392: {
        _1088 = core::panicking::AssertKind::Eq;
        _1090 = Option::<Arguments<'_>>::None;
        _1089 = core::panicking::assert_failed::<Option<&u8>, Option<&u8>>(move _1088, _1084, _1085, move _1090) -> unwind continue;
    }

    bb393: {
        _1092 = const {alloc44: &Option<&u8>};
        _1093 = &_1076;
        _1091 = (_1092, move _1093);
        _1094 = (_1091.0: &std::option::Option<&u8>);
        _1095 = (_1091.1: &std::option::Option<&u8>);
        _1097 = <Option<&u8> as PartialEq>::eq(_1094, _1095) -> [return: bb394, unwind continue];
    }

    bb394: {
        _1096 = Not(move _1097);
        switchInt(move _1096) -> [0: bb396, otherwise: bb395];
    }

    bb395: {
        _1098 = core::panicking::AssertKind::Eq;
        _1100 = Option::<Arguments<'_>>::None;
        _1099 = core::panicking::assert_failed::<Option<&u8>, Option<&u8>>(move _1098, _1094, _1095, move _1100) -> unwind continue;
    }

    bb396: {
        return;
    }
}

alloc44 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc1089+0x1                          
}

alloc1089 (size: 2, align: 1) {
    01 02                                            ..
}

alloc43 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc1082+0x1                          
}

alloc1082 (size: 2, align: 1) {
    01 02                                            ..
}

alloc42 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc1075                          
}

alloc1075 (size: 2, align: 1) {
    01 02                                            ..
}

alloc41 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc1068                          
}

alloc1068 (size: 2, align: 1) {
    01 02                                            ..
}

alloc40 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc1061+0x3                          
}

alloc1061 (size: 4, align: 1) {
    01 02 03 04                                      ....
}

alloc39 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc1052+0x3                          
}

alloc1052 (size: 4, align: 1) {
    01 02 03 04                                      ....
}

alloc38 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc1043                          
}

alloc1043 (size: 4, align: 1) {
    01 02 03 04                                      ....
}

alloc37 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc1034                          
}

alloc1034 (size: 4, align: 1) {
    01 02 03 04                                      ....
}

alloc36 (static: main::CONST_EVAL2, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                          ........
}

alloc35 (static: main::CONST_EVAL2, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                          ........
}

alloc34 (static: main::CONST_EVAL2, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                          ........
}

alloc33 (static: main::CONST_EVAL2, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                          ........
}

alloc32 (static: main::CONST_EVAL2, size: 16, align: 8) {
    00 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
}

alloc31 (static: main::CONST_EVAL2, size: 16, align: 8) {
    00 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
}

alloc30 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc995                          
}

alloc995 (size: 0, align: 1) {}

alloc29 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc990                          
}

alloc990 (size: 0, align: 1) {}

alloc28 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc985                          
}

alloc985 (size: 0, align: 1) {}

alloc27 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc980                          
}

alloc980 (size: 0, align: 1) {}

alloc26 (static: main::CONST_EVAL2, size: 16, align: 8) {
    alloc975 00 00 00 00 00 00 00 00  ........
}

alloc975 (size: 0, align: 1) {}

alloc25 (static: main::CONST_EVAL2, size: 16, align: 8) {
    alloc970 00 00 00 00 00 00 00 00  ........
}

alloc970 (size: 0, align: 1) {}

alloc24 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc965                          
}

alloc965 (size: 0, align: 1) {}

alloc23 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc960                          
}

alloc960 (size: 0, align: 1) {}

alloc22 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc955                          
}

alloc955 (size: 0, align: 1) {}

alloc21 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc950                          
}

alloc950 (size: 0, align: 1) {}

alloc20 (static: main::CONST_EVAL2, size: 16, align: 8) {
    alloc945 02 00 00 00 00 00 00 00  ........
}

alloc945 (size: 0, align: 1) {}

alloc19 (static: main::CONST_EVAL2, size: 16, align: 8) {
    alloc940 02 00 00 00 00 00 00 00  ........
}

alloc940 (size: 0, align: 1) {}

alloc18 (static: main::CONST_EVAL2, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                          ........
}

alloc17 (static: main::CONST_EVAL2, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                          ........
}

alloc16 (static: main::CONST_EVAL2, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                          ........
}

alloc15 (static: main::CONST_EVAL2, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                          ........
}

alloc14 (static: main::CONST_EVAL2, size: 16, align: 8) {
    00 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
}

alloc13 (static: main::CONST_EVAL2, size: 16, align: 8) {
    00 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
}

alloc12 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc899+0x1                          
}

alloc899 (size: 2, align: 1) {
    01 02                                            ..
}

alloc11 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc892+0x1                          
}

alloc892 (size: 2, align: 1) {
    01 02                                            ..
}

alloc10 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc885                          
}

alloc885 (size: 2, align: 1) {
    01 02                                            ..
}

alloc9 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc878                          
}

alloc878 (size: 2, align: 1) {
    01 02                                            ..
}

alloc8 (static: main::CONST_EVAL2, size: 16, align: 8) {
    alloc871+0x1 00 00 00 00 00 00 00 00  ........
}

alloc871 (size: 2, align: 1) {
    01 02                                            ..
}

alloc7 (static: main::CONST_EVAL2, size: 16, align: 8) {
    alloc864+0x1 00 00 00 00 00 00 00 00  ........
}

alloc864 (size: 2, align: 1) {
    01 02                                            ..
}

alloc6 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc857+0x3                          
}

alloc857 (size: 4, align: 1) {
    01 02 03 04                                      ....
}

alloc5 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc848+0x3                          
}

alloc848 (size: 4, align: 1) {
    01 02 03 04                                      ....
}

alloc4 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc839                          
}

alloc839 (size: 4, align: 1) {
    01 02 03 04                                      ....
}

alloc3 (static: main::CONST_EVAL2, size: 8, align: 8) {
    alloc830                          
}

alloc830 (size: 4, align: 1) {
    01 02 03 04                                      ....
}

alloc2 (static: main::CONST_EVAL2, size: 16, align: 8) {
    alloc821+0x1 02 00 00 00 00 00 00 00  ........
}

alloc821 (size: 4, align: 1) {
    01 02 03 04                                      ....
}

alloc1 (static: main::CONST_EVAL2, size: 16, align: 8) {
    alloc812+0x1 02 00 00 00 00 00 00 00  ........
}

alloc812 (size: 4, align: 1) {
    01 02 03 04                                      ....
}

promoted[0] in main: &Option<&u8> = {
    let mut _0: &std::option::Option<&u8>;
    let mut _1: std::option::Option<&u8>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

promoted[2] in main: &Option<&u8> = {
    let mut _0: &std::option::Option<&u8>;
    let mut _1: std::option::Option<&u8>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in main: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

promoted[4] in main: &Option<&u8> = {
    let mut _0: &std::option::Option<&u8>;
    let mut _1: std::option::Option<&u8>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in main: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

promoted[6] in main: &Option<&u8> = {
    let mut _0: &std::option::Option<&u8>;
    let mut _1: std::option::Option<&u8>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in main: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

promoted[8] in main: &Option<&u8> = {
    let mut _0: &std::option::Option<&u8>;
    let mut _1: std::option::Option<&u8>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[9] in main: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

promoted[10] in main: &Option<&u8> = {
    let mut _0: &std::option::Option<&u8>;
    let mut _1: std::option::Option<&u8>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[11] in main: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

promoted[12] in main: &Option<&u8> = {
    let mut _0: &std::option::Option<&u8>;
    let mut _1: std::option::Option<&u8>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[13] in main: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

promoted[14] in main: &Option<&u8> = {
    let mut _0: &std::option::Option<&u8>;
    let mut _1: std::option::Option<&u8>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[15] in main: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

promoted[16] in main: &Option<&Z> = {
    let mut _0: &std::option::Option<&Z>;
    let mut _1: std::option::Option<&Z>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[17] in main: &[Z; 1] = {
    let mut _0: &[Z; 1];
    let mut _1: [Z; 1];
    let mut _2: Z;

    bb0: {
        _2 = Z;
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

promoted[18] in main: &Option<&Z> = {
    let mut _0: &std::option::Option<&Z>;
    let mut _1: std::option::Option<&Z>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[19] in main: &[Z; 1] = {
    let mut _0: &[Z; 1];
    let mut _1: [Z; 1];
    let mut _2: Z;

    bb0: {
        _2 = Z;
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

promoted[20] in main: &Option<&Z> = {
    let mut _0: &std::option::Option<&Z>;
    let mut _1: std::option::Option<&Z>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[21] in main: &[Z; 1] = {
    let mut _0: &[Z; 1];
    let mut _1: [Z; 1];
    let mut _2: Z;

    bb0: {
        _2 = Z;
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

promoted[22] in main: &Option<&Z> = {
    let mut _0: &std::option::Option<&Z>;
    let mut _1: std::option::Option<&Z>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[23] in main: &[Z; 1] = {
    let mut _0: &[Z; 1];
    let mut _1: [Z; 1];
    let mut _2: Z;

    bb0: {
        _2 = Z;
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

promoted[24] in main: &Option<&[Z]> = {
    let mut _0: &std::option::Option<&[Z]>;
    let mut _1: std::option::Option<&[Z]>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[25] in main: &[Z; 1] = {
    let mut _0: &[Z; 1];
    let mut _1: [Z; 1];
    let mut _2: Z;

    bb0: {
        _2 = Z;
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

promoted[26] in main: &Option<&[Z]> = {
    let mut _0: &std::option::Option<&[Z]>;
    let mut _1: std::option::Option<&[Z]>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[27] in main: &[Z; 1] = {
    let mut _0: &[Z; 1];
    let mut _1: [Z; 1];
    let mut _2: Z;

    bb0: {
        _2 = Z;
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

promoted[28] in main: &Option<&Z> = {
    let mut _0: &std::option::Option<&Z>;
    let mut _1: std::option::Option<&Z>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[29] in main: &[Z; 2] = {
    let mut _0: &[Z; 2];
    let mut _1: [Z; 2];
    let mut _2: Z;
    let mut _3: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

promoted[30] in main: &Option<&Z> = {
    let mut _0: &std::option::Option<&Z>;
    let mut _1: std::option::Option<&Z>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[31] in main: &[Z; 2] = {
    let mut _0: &[Z; 2];
    let mut _1: [Z; 2];
    let mut _2: Z;
    let mut _3: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

promoted[32] in main: &Option<&Z> = {
    let mut _0: &std::option::Option<&Z>;
    let mut _1: std::option::Option<&Z>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[33] in main: &[Z; 2] = {
    let mut _0: &[Z; 2];
    let mut _1: [Z; 2];
    let mut _2: Z;
    let mut _3: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

promoted[34] in main: &Option<&Z> = {
    let mut _0: &std::option::Option<&Z>;
    let mut _1: std::option::Option<&Z>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[35] in main: &[Z; 2] = {
    let mut _0: &[Z; 2];
    let mut _1: [Z; 2];
    let mut _2: Z;
    let mut _3: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

promoted[36] in main: &Option<&[Z]> = {
    let mut _0: &std::option::Option<&[Z]>;
    let mut _1: std::option::Option<&[Z]>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[37] in main: &[Z; 2] = {
    let mut _0: &[Z; 2];
    let mut _1: [Z; 2];
    let mut _2: Z;
    let mut _3: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

promoted[38] in main: &Option<&[Z]> = {
    let mut _0: &std::option::Option<&[Z]>;
    let mut _1: std::option::Option<&[Z]>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[39] in main: &[Z; 2] = {
    let mut _0: &[Z; 2];
    let mut _1: [Z; 2];
    let mut _2: Z;
    let mut _3: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

promoted[40] in main: &Option<&Z> = {
    let mut _0: &std::option::Option<&Z>;
    let mut _1: std::option::Option<&Z>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[41] in main: &[Z; 4] = {
    let mut _0: &[Z; 4];
    let mut _1: [Z; 4];
    let mut _2: Z;
    let mut _3: Z;
    let mut _4: Z;
    let mut _5: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _4 = Z;
        _5 = Z;
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

promoted[42] in main: &Option<&Z> = {
    let mut _0: &std::option::Option<&Z>;
    let mut _1: std::option::Option<&Z>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[43] in main: &[Z; 4] = {
    let mut _0: &[Z; 4];
    let mut _1: [Z; 4];
    let mut _2: Z;
    let mut _3: Z;
    let mut _4: Z;
    let mut _5: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _4 = Z;
        _5 = Z;
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

promoted[44] in main: &Option<&Z> = {
    let mut _0: &std::option::Option<&Z>;
    let mut _1: std::option::Option<&Z>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[45] in main: &[Z; 4] = {
    let mut _0: &[Z; 4];
    let mut _1: [Z; 4];
    let mut _2: Z;
    let mut _3: Z;
    let mut _4: Z;
    let mut _5: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _4 = Z;
        _5 = Z;
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

promoted[46] in main: &Option<&Z> = {
    let mut _0: &std::option::Option<&Z>;
    let mut _1: std::option::Option<&Z>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[47] in main: &[Z; 4] = {
    let mut _0: &[Z; 4];
    let mut _1: [Z; 4];
    let mut _2: Z;
    let mut _3: Z;
    let mut _4: Z;
    let mut _5: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _4 = Z;
        _5 = Z;
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

promoted[48] in main: &Option<&[Z]> = {
    let mut _0: &std::option::Option<&[Z]>;
    let mut _1: std::option::Option<&[Z]>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[49] in main: &[Z; 4] = {
    let mut _0: &[Z; 4];
    let mut _1: [Z; 4];
    let mut _2: Z;
    let mut _3: Z;
    let mut _4: Z;
    let mut _5: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _4 = Z;
        _5 = Z;
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

promoted[50] in main: &Option<&[Z]> = {
    let mut _0: &std::option::Option<&[Z]>;
    let mut _1: std::option::Option<&[Z]>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[51] in main: &[Z; 4] = {
    let mut _0: &[Z; 4];
    let mut _1: [Z; 4];
    let mut _2: Z;
    let mut _3: Z;
    let mut _4: Z;
    let mut _5: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _4 = Z;
        _5 = Z;
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

promoted[52] in main: &Option<&N> = {
    let mut _0: &std::option::Option<&N>;
    let mut _1: std::option::Option<&N>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[53] in main: &[N; 1] = {
    let mut _0: &[N; 1];
    let mut _1: [N; 1];
    let mut _2: N;

    bb0: {
        _2 = N(const 1_u8);
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

promoted[54] in main: &Option<&N> = {
    let mut _0: &std::option::Option<&N>;
    let mut _1: std::option::Option<&N>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[55] in main: &[N; 1] = {
    let mut _0: &[N; 1];
    let mut _1: [N; 1];
    let mut _2: N;

    bb0: {
        _2 = N(const 1_u8);
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

promoted[56] in main: &Option<&N> = {
    let mut _0: &std::option::Option<&N>;
    let mut _1: std::option::Option<&N>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[57] in main: &[N; 1] = {
    let mut _0: &[N; 1];
    let mut _1: [N; 1];
    let mut _2: N;

    bb0: {
        _2 = N(const 1_u8);
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

promoted[58] in main: &Option<&N> = {
    let mut _0: &std::option::Option<&N>;
    let mut _1: std::option::Option<&N>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[59] in main: &[N; 1] = {
    let mut _0: &[N; 1];
    let mut _1: [N; 1];
    let mut _2: N;

    bb0: {
        _2 = N(const 1_u8);
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

promoted[60] in main: &Option<&[N]> = {
    let mut _0: &std::option::Option<&[N]>;
    let mut _1: std::option::Option<&[N]>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[61] in main: &[N; 1] = {
    let mut _0: &[N; 1];
    let mut _1: [N; 1];
    let mut _2: N;

    bb0: {
        _2 = N(const 1_u8);
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

promoted[62] in main: &Option<&[N]> = {
    let mut _0: &std::option::Option<&[N]>;
    let mut _1: std::option::Option<&[N]>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[63] in main: &[N; 1] = {
    let mut _0: &[N; 1];
    let mut _1: [N; 1];
    let mut _2: N;

    bb0: {
        _2 = N(const 1_u8);
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

promoted[64] in main: &Option<&N> = {
    let mut _0: &std::option::Option<&N>;
    let mut _1: std::option::Option<&N>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[65] in main: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

promoted[66] in main: &Option<&N> = {
    let mut _0: &std::option::Option<&N>;
    let mut _1: std::option::Option<&N>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[67] in main: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

promoted[68] in main: &Option<&N> = {
    let mut _0: &std::option::Option<&N>;
    let mut _1: std::option::Option<&N>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[69] in main: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

promoted[70] in main: &Option<&N> = {
    let mut _0: &std::option::Option<&N>;
    let mut _1: std::option::Option<&N>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[71] in main: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

promoted[72] in main: &Option<&[N]> = {
    let mut _0: &std::option::Option<&[N]>;
    let mut _1: std::option::Option<&[N]>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[73] in main: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

promoted[74] in main: &Option<&[N]> = {
    let mut _0: &std::option::Option<&[N]>;
    let mut _1: std::option::Option<&[N]>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[75] in main: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

promoted[76] in main: &Option<&N> = {
    let mut _0: &std::option::Option<&N>;
    let mut _1: std::option::Option<&N>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[77] in main: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

promoted[78] in main: &Option<&N> = {
    let mut _0: &std::option::Option<&N>;
    let mut _1: std::option::Option<&N>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[79] in main: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

promoted[80] in main: &Option<&N> = {
    let mut _0: &std::option::Option<&N>;
    let mut _1: std::option::Option<&N>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[81] in main: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

promoted[82] in main: &Option<&N> = {
    let mut _0: &std::option::Option<&N>;
    let mut _1: std::option::Option<&N>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[83] in main: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

promoted[84] in main: &Option<&[N]> = {
    let mut _0: &std::option::Option<&[N]>;
    let mut _1: std::option::Option<&[N]>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[85] in main: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

promoted[86] in main: &Option<&[N]> = {
    let mut _0: &std::option::Option<&[N]>;
    let mut _1: std::option::Option<&[N]>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[87] in main: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

const main::CONST_EVAL: Option<&[N]> = {
    let mut _0: std::option::Option<&[N]>;
    let mut _1: &[N];
    let mut _2: &[N; 4];
    let _3: &[N; 4];
    let _4: [N; 4];
    let mut _5: N;
    let mut _6: N;
    let mut _7: N;
    let mut _8: N;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _13: &[N];
    scope 1 {
        debug x => _12;
        let _12: &[N];
        let mut _14: &[N; 4];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_12);
        _12 = &(*_1)[1:-1];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&[N]>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&[N]>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&[N]> {
    let mut _0: std::option::Option<&[N]>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &[N];
        let mut _6: &[N; 4];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &(*_1)[1:-1];
        _0 = Option::<&[N]>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&[N]>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&[N]> {
    let mut _0: std::option::Option<&[N]>;
    let mut _1: &[N];
    let mut _2: &[N; 4];
    let _3: &[N; 4];
    let _4: [N; 4];
    let mut _5: N;
    let mut _6: N;
    let mut _7: N;
    let mut _8: N;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _13: &[N];
    scope 1 {
        debug x => _12;
        let _12: &[N];
        let mut _14: &[N; 4];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_12);
        _12 = &(*_1)[1:-1];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&[N]>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&[N]>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&[N]> = {
    let mut _0: std::option::Option<&[N]>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&[N]> = {
    let mut _0: std::option::Option<&[N]>;
    let mut _1: &[N];
    let mut _2: &[N; 4];
    let _3: &[N; 4];
    let _4: [N; 4];
    let mut _5: N;
    let mut _6: N;
    let mut _7: N;
    let mut _8: N;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _12: &[N];
    let mut _13: &[N];
    let mut _14: &[N; 4];
    scope 1 {
        debug x => _12;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&[N]>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_12);
        _12 = &(*_1)[1:-1];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&[N]>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&[N]> {
    let mut _0: std::option::Option<&[N]>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &[N];
    let mut _6: &[N; 4];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&[N]>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &(*_1)[1:-1];
        _0 = Option::<&[N]>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&[N]> {
    let mut _0: std::option::Option<&[N]>;
    let mut _1: &[N];
    let mut _2: &[N; 4];
    let _3: &[N; 4];
    let _4: [N; 4];
    let mut _5: N;
    let mut _6: N;
    let mut _7: N;
    let mut _8: N;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _12: &[N];
    let mut _13: &[N];
    let mut _14: &[N; 4];
    scope 1 {
        debug x => _12;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&[N]>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_12);
        _12 = &(*_1)[1:-1];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&[N]>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&[N]> = {
    let mut _0: std::option::Option<&[N]>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&N> = {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 4];
    let _3: &[N; 4];
    let _4: [N; 4];
    let mut _5: N;
    let mut _6: N;
    let mut _7: N;
    let mut _8: N;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _13: &N;
    scope 1 {
        debug x => _12;
        let _12: &N;
        let mut _14: &[N; 4];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_12);
        _12 = &(*_1)[0 of 2];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&N>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &N;
        let mut _6: &[N; 4];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &(*_1)[0 of 2];
        _0 = Option::<&N>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 4];
    let _3: &[N; 4];
    let _4: [N; 4];
    let mut _5: N;
    let mut _6: N;
    let mut _7: N;
    let mut _8: N;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _13: &N;
    scope 1 {
        debug x => _12;
        let _12: &N;
        let mut _14: &[N; 4];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_12);
        _12 = &(*_1)[0 of 2];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&N>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&N> = {
    let mut _0: std::option::Option<&N>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&N> = {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 4];
    let _3: &[N; 4];
    let _4: [N; 4];
    let mut _5: N;
    let mut _6: N;
    let mut _7: N;
    let mut _8: N;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _12: &N;
    let mut _13: &N;
    let mut _14: &[N; 4];
    scope 1 {
        debug x => _12;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_12);
        _12 = &(*_1)[0 of 2];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&N>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &N;
    let mut _6: &[N; 4];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &(*_1)[0 of 2];
        _0 = Option::<&N>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 4];
    let _3: &[N; 4];
    let _4: [N; 4];
    let mut _5: N;
    let mut _6: N;
    let mut _7: N;
    let mut _8: N;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _12: &N;
    let mut _13: &N;
    let mut _14: &[N; 4];
    scope 1 {
        debug x => _12;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_12);
        _12 = &(*_1)[0 of 2];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&N>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&N> = {
    let mut _0: std::option::Option<&N>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&N> = {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 4];
    let _3: &[N; 4];
    let _4: [N; 4];
    let mut _5: N;
    let mut _6: N;
    let mut _7: N;
    let mut _8: N;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _13: &N;
    scope 1 {
        debug x => _12;
        let _12: &N;
        let mut _14: &[N; 4];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_12);
        _12 = &(*_1)[-1 of 2];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&N>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &N;
        let mut _6: &[N; 4];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &(*_1)[-1 of 2];
        _0 = Option::<&N>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 4];
    let _3: &[N; 4];
    let _4: [N; 4];
    let mut _5: N;
    let mut _6: N;
    let mut _7: N;
    let mut _8: N;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _13: &N;
    scope 1 {
        debug x => _12;
        let _12: &N;
        let mut _14: &[N; 4];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_12);
        _12 = &(*_1)[-1 of 2];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&N>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&N> = {
    let mut _0: std::option::Option<&N>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&N> = {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 4];
    let _3: &[N; 4];
    let _4: [N; 4];
    let mut _5: N;
    let mut _6: N;
    let mut _7: N;
    let mut _8: N;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _12: &N;
    let mut _13: &N;
    let mut _14: &[N; 4];
    scope 1 {
        debug x => _12;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_12);
        _12 = &(*_1)[-1 of 2];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&N>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &N;
    let mut _6: &[N; 4];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &(*_1)[-1 of 2];
        _0 = Option::<&N>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 4];
    let _3: &[N; 4];
    let _4: [N; 4];
    let mut _5: N;
    let mut _6: N;
    let mut _7: N;
    let mut _8: N;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _12: &N;
    let mut _13: &N;
    let mut _14: &[N; 4];
    scope 1 {
        debug x => _12;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_12);
        _12 = &(*_1)[-1 of 2];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&N>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&N> = {
    let mut _0: std::option::Option<&N>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&[N]> = {
    let mut _0: std::option::Option<&[N]>;
    let mut _1: &[N];
    let mut _2: &[N; 2];
    let _3: &[N; 2];
    let _4: [N; 2];
    let mut _5: N;
    let mut _6: N;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _11: &[N];
    scope 1 {
        debug x => _10;
        let _10: &[N];
        let mut _12: &[N; 2];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_10);
        _10 = &(*_1)[1:-1];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&[N]>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&[N]>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&[N]> {
    let mut _0: std::option::Option<&[N]>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &[N];
        let mut _6: &[N; 2];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &(*_1)[1:-1];
        _0 = Option::<&[N]>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&[N]>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&[N]> {
    let mut _0: std::option::Option<&[N]>;
    let mut _1: &[N];
    let mut _2: &[N; 2];
    let _3: &[N; 2];
    let _4: [N; 2];
    let mut _5: N;
    let mut _6: N;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _11: &[N];
    scope 1 {
        debug x => _10;
        let _10: &[N];
        let mut _12: &[N; 2];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_10);
        _10 = &(*_1)[1:-1];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&[N]>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&[N]>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&[N]> = {
    let mut _0: std::option::Option<&[N]>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&[N]> = {
    let mut _0: std::option::Option<&[N]>;
    let mut _1: &[N];
    let mut _2: &[N; 2];
    let _3: &[N; 2];
    let _4: [N; 2];
    let mut _5: N;
    let mut _6: N;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let _10: &[N];
    let mut _11: &[N];
    let mut _12: &[N; 2];
    scope 1 {
        debug x => _10;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&[N]>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_10);
        _10 = &(*_1)[1:-1];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&[N]>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&[N]> {
    let mut _0: std::option::Option<&[N]>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &[N];
    let mut _6: &[N; 2];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&[N]>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &(*_1)[1:-1];
        _0 = Option::<&[N]>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&[N]> {
    let mut _0: std::option::Option<&[N]>;
    let mut _1: &[N];
    let mut _2: &[N; 2];
    let _3: &[N; 2];
    let _4: [N; 2];
    let mut _5: N;
    let mut _6: N;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let _10: &[N];
    let mut _11: &[N];
    let mut _12: &[N; 2];
    scope 1 {
        debug x => _10;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&[N]>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_10);
        _10 = &(*_1)[1:-1];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&[N]>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&[N]> = {
    let mut _0: std::option::Option<&[N]>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&N> = {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 2];
    let _3: &[N; 2];
    let _4: [N; 2];
    let mut _5: N;
    let mut _6: N;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _11: &N;
    scope 1 {
        debug x => _10;
        let _10: &N;
        let mut _12: &[N; 2];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_10);
        _10 = &(*_1)[0 of 2];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&N>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &N;
        let mut _6: &[N; 2];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &(*_1)[0 of 2];
        _0 = Option::<&N>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 2];
    let _3: &[N; 2];
    let _4: [N; 2];
    let mut _5: N;
    let mut _6: N;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _11: &N;
    scope 1 {
        debug x => _10;
        let _10: &N;
        let mut _12: &[N; 2];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_10);
        _10 = &(*_1)[0 of 2];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&N>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&N> = {
    let mut _0: std::option::Option<&N>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&N> = {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 2];
    let _3: &[N; 2];
    let _4: [N; 2];
    let mut _5: N;
    let mut _6: N;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let _10: &N;
    let mut _11: &N;
    let mut _12: &[N; 2];
    scope 1 {
        debug x => _10;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_10);
        _10 = &(*_1)[0 of 2];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&N>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &N;
    let mut _6: &[N; 2];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &(*_1)[0 of 2];
        _0 = Option::<&N>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 2];
    let _3: &[N; 2];
    let _4: [N; 2];
    let mut _5: N;
    let mut _6: N;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let _10: &N;
    let mut _11: &N;
    let mut _12: &[N; 2];
    scope 1 {
        debug x => _10;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_10);
        _10 = &(*_1)[0 of 2];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&N>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&N> = {
    let mut _0: std::option::Option<&N>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&N> = {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 2];
    let _3: &[N; 2];
    let _4: [N; 2];
    let mut _5: N;
    let mut _6: N;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _11: &N;
    scope 1 {
        debug x => _10;
        let _10: &N;
        let mut _12: &[N; 2];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_10);
        _10 = &(*_1)[-1 of 2];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&N>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &N;
        let mut _6: &[N; 2];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &(*_1)[-1 of 2];
        _0 = Option::<&N>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 2];
    let _3: &[N; 2];
    let _4: [N; 2];
    let mut _5: N;
    let mut _6: N;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _11: &N;
    scope 1 {
        debug x => _10;
        let _10: &N;
        let mut _12: &[N; 2];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_10);
        _10 = &(*_1)[-1 of 2];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&N>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&N> = {
    let mut _0: std::option::Option<&N>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&N> = {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 2];
    let _3: &[N; 2];
    let _4: [N; 2];
    let mut _5: N;
    let mut _6: N;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let _10: &N;
    let mut _11: &N;
    let mut _12: &[N; 2];
    scope 1 {
        debug x => _10;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_10);
        _10 = &(*_1)[-1 of 2];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&N>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &N;
    let mut _6: &[N; 2];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &(*_1)[-1 of 2];
        _0 = Option::<&N>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 2];
    let _3: &[N; 2];
    let _4: [N; 2];
    let mut _5: N;
    let mut _6: N;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let _10: &N;
    let mut _11: &N;
    let mut _12: &[N; 2];
    scope 1 {
        debug x => _10;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_10);
        _10 = &(*_1)[-1 of 2];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&N>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&N> = {
    let mut _0: std::option::Option<&N>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&[N]> = {
    let mut _0: std::option::Option<&[N]>;
    let mut _1: &[N];
    let mut _2: &[N; 1];
    let _3: &[N; 1];
    let _4: [N; 1];
    let mut _5: N;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _10: &[N];
    scope 1 {
        debug x => _9;
        let _9: &[N];
        let mut _11: &[N; 1];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_9);
        _9 = &(*_1)[1:-1];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&[N]>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&[N]>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 1] = {
    let mut _0: &[N; 1];
    let mut _1: [N; 1];
    let mut _2: N;

    bb0: {
        _2 = N(const 1_u8);
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&[N]> {
    let mut _0: std::option::Option<&[N]>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &[N];
        let mut _6: &[N; 1];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &(*_1)[1:-1];
        _0 = Option::<&[N]>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&[N]>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 1] = {
    let mut _0: &[N; 1];
    let mut _1: [N; 1];
    let mut _2: N;

    bb0: {
        _2 = N(const 1_u8);
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&[N]> {
    let mut _0: std::option::Option<&[N]>;
    let mut _1: &[N];
    let mut _2: &[N; 1];
    let _3: &[N; 1];
    let _4: [N; 1];
    let mut _5: N;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _10: &[N];
    scope 1 {
        debug x => _9;
        let _9: &[N];
        let mut _11: &[N; 1];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_9);
        _9 = &(*_1)[1:-1];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&[N]>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&[N]>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&[N]> = {
    let mut _0: std::option::Option<&[N]>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&[N]> = {
    let mut _0: std::option::Option<&[N]>;
    let mut _1: &[N];
    let mut _2: &[N; 1];
    let _3: &[N; 1];
    let _4: [N; 1];
    let mut _5: N;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: &[N];
    let mut _10: &[N];
    let mut _11: &[N; 1];
    scope 1 {
        debug x => _9;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&[N]>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_9);
        _9 = &(*_1)[1:-1];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&[N]>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 1] = {
    let mut _0: &[N; 1];
    let mut _1: [N; 1];
    let mut _2: N;

    bb0: {
        _2 = N(const 1_u8);
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&[N]> {
    let mut _0: std::option::Option<&[N]>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &[N];
    let mut _6: &[N; 1];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&[N]>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &(*_1)[1:-1];
        _0 = Option::<&[N]>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 1] = {
    let mut _0: &[N; 1];
    let mut _1: [N; 1];
    let mut _2: N;

    bb0: {
        _2 = N(const 1_u8);
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&[N]> {
    let mut _0: std::option::Option<&[N]>;
    let mut _1: &[N];
    let mut _2: &[N; 1];
    let _3: &[N; 1];
    let _4: [N; 1];
    let mut _5: N;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: &[N];
    let mut _10: &[N];
    let mut _11: &[N; 1];
    scope 1 {
        debug x => _9;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&[N]>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_9);
        _9 = &(*_1)[1:-1];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&[N]>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&[N]> = {
    let mut _0: std::option::Option<&[N]>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&N> = {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 1];
    let _3: &[N; 1];
    let _4: [N; 1];
    let mut _5: N;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _10: &N;
    scope 1 {
        debug x => _9;
        let _9: &N;
        let mut _11: &[N; 1];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_9);
        _9 = &(*_1)[0 of 2];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&N>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 1] = {
    let mut _0: &[N; 1];
    let mut _1: [N; 1];
    let mut _2: N;

    bb0: {
        _2 = N(const 1_u8);
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &N;
        let mut _6: &[N; 1];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &(*_1)[0 of 2];
        _0 = Option::<&N>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 1] = {
    let mut _0: &[N; 1];
    let mut _1: [N; 1];
    let mut _2: N;

    bb0: {
        _2 = N(const 1_u8);
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 1];
    let _3: &[N; 1];
    let _4: [N; 1];
    let mut _5: N;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _10: &N;
    scope 1 {
        debug x => _9;
        let _9: &N;
        let mut _11: &[N; 1];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_9);
        _9 = &(*_1)[0 of 2];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&N>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&N> = {
    let mut _0: std::option::Option<&N>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&N> = {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 1];
    let _3: &[N; 1];
    let _4: [N; 1];
    let mut _5: N;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: &N;
    let mut _10: &N;
    let mut _11: &[N; 1];
    scope 1 {
        debug x => _9;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_9);
        _9 = &(*_1)[0 of 2];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&N>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 1] = {
    let mut _0: &[N; 1];
    let mut _1: [N; 1];
    let mut _2: N;

    bb0: {
        _2 = N(const 1_u8);
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &N;
    let mut _6: &[N; 1];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &(*_1)[0 of 2];
        _0 = Option::<&N>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 1] = {
    let mut _0: &[N; 1];
    let mut _1: [N; 1];
    let mut _2: N;

    bb0: {
        _2 = N(const 1_u8);
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 1];
    let _3: &[N; 1];
    let _4: [N; 1];
    let mut _5: N;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: &N;
    let mut _10: &N;
    let mut _11: &[N; 1];
    scope 1 {
        debug x => _9;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_9);
        _9 = &(*_1)[0 of 2];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&N>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&N> = {
    let mut _0: std::option::Option<&N>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&N> = {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 1];
    let _3: &[N; 1];
    let _4: [N; 1];
    let mut _5: N;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _10: &N;
    scope 1 {
        debug x => _9;
        let _9: &N;
        let mut _11: &[N; 1];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_9);
        _9 = &(*_1)[-1 of 2];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&N>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 1] = {
    let mut _0: &[N; 1];
    let mut _1: [N; 1];
    let mut _2: N;

    bb0: {
        _2 = N(const 1_u8);
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &N;
        let mut _6: &[N; 1];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &(*_1)[-1 of 2];
        _0 = Option::<&N>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 1] = {
    let mut _0: &[N; 1];
    let mut _1: [N; 1];
    let mut _2: N;

    bb0: {
        _2 = N(const 1_u8);
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 1];
    let _3: &[N; 1];
    let _4: [N; 1];
    let mut _5: N;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _10: &N;
    scope 1 {
        debug x => _9;
        let _9: &N;
        let mut _11: &[N; 1];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_9);
        _9 = &(*_1)[-1 of 2];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&N>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&N> = {
    let mut _0: std::option::Option<&N>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&N> = {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 1];
    let _3: &[N; 1];
    let _4: [N; 1];
    let mut _5: N;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: &N;
    let mut _10: &N;
    let mut _11: &[N; 1];
    scope 1 {
        debug x => _9;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_9);
        _9 = &(*_1)[-1 of 2];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&N>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 1] = {
    let mut _0: &[N; 1];
    let mut _1: [N; 1];
    let mut _2: N;

    bb0: {
        _2 = N(const 1_u8);
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &N;
    let mut _6: &[N; 1];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &(*_1)[-1 of 2];
        _0 = Option::<&N>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 1] = {
    let mut _0: &[N; 1];
    let mut _1: [N; 1];
    let mut _2: N;

    bb0: {
        _2 = N(const 1_u8);
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&N> {
    let mut _0: std::option::Option<&N>;
    let mut _1: &[N];
    let mut _2: &[N; 1];
    let _3: &[N; 1];
    let _4: [N; 1];
    let mut _5: N;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: &N;
    let mut _10: &N;
    let mut _11: &[N; 1];
    scope 1 {
        debug x => _9;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&N>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_9);
        _9 = &(*_1)[-1 of 2];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&N>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&N> = {
    let mut _0: std::option::Option<&N>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&[Z]> = {
    let mut _0: std::option::Option<&[Z]>;
    let mut _1: &[Z];
    let mut _2: &[Z; 4];
    let _3: &[Z; 4];
    let _4: [Z; 4];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: Z;
    let mut _8: Z;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _13: &[Z];
    scope 1 {
        debug x => _12;
        let _12: &[Z];
        let mut _14: &[Z; 4];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_12);
        _12 = &(*_1)[1:-1];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&[Z]>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&[Z]>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[Z; 4] = {
    let mut _0: &[Z; 4];
    let mut _1: [Z; 4];
    let mut _2: Z;
    let mut _3: Z;
    let mut _4: Z;
    let mut _5: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _4 = Z;
        _5 = Z;
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&[Z]> {
    let mut _0: std::option::Option<&[Z]>;
    let mut _1: &[Z];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &[Z];
        let mut _6: &[Z; 4];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[Z] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &(*_1)[1:-1];
        _0 = Option::<&[Z]>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&[Z]>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[Z; 4] = {
    let mut _0: &[Z; 4];
    let mut _1: [Z; 4];
    let mut _2: Z;
    let mut _3: Z;
    let mut _4: Z;
    let mut _5: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _4 = Z;
        _5 = Z;
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&[Z]> {
    let mut _0: std::option::Option<&[Z]>;
    let mut _1: &[Z];
    let mut _2: &[Z; 4];
    let _3: &[Z; 4];
    let _4: [Z; 4];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: Z;
    let mut _8: Z;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _13: &[Z];
    scope 1 {
        debug x => _12;
        let _12: &[Z];
        let mut _14: &[Z; 4];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_12);
        _12 = &(*_1)[1:-1];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&[Z]>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&[Z]>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&[Z]> = {
    let mut _0: std::option::Option<&[Z]>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&[Z]> = {
    let mut _0: std::option::Option<&[Z]>;
    let mut _1: &[Z];
    let mut _2: &[Z; 4];
    let _3: &[Z; 4];
    let _4: [Z; 4];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: Z;
    let mut _8: Z;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _12: &[Z];
    let mut _13: &[Z];
    let mut _14: &[Z; 4];
    scope 1 {
        debug x => _12;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&[Z]>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_12);
        _12 = &(*_1)[1:-1];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&[Z]>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[Z; 4] = {
    let mut _0: &[Z; 4];
    let mut _1: [Z; 4];
    let mut _2: Z;
    let mut _3: Z;
    let mut _4: Z;
    let mut _5: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _4 = Z;
        _5 = Z;
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&[Z]> {
    let mut _0: std::option::Option<&[Z]>;
    let mut _1: &[Z];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &[Z];
    let mut _6: &[Z; 4];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[Z] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&[Z]>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &(*_1)[1:-1];
        _0 = Option::<&[Z]>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[Z; 4] = {
    let mut _0: &[Z; 4];
    let mut _1: [Z; 4];
    let mut _2: Z;
    let mut _3: Z;
    let mut _4: Z;
    let mut _5: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _4 = Z;
        _5 = Z;
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&[Z]> {
    let mut _0: std::option::Option<&[Z]>;
    let mut _1: &[Z];
    let mut _2: &[Z; 4];
    let _3: &[Z; 4];
    let _4: [Z; 4];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: Z;
    let mut _8: Z;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _12: &[Z];
    let mut _13: &[Z];
    let mut _14: &[Z; 4];
    scope 1 {
        debug x => _12;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&[Z]>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_12);
        _12 = &(*_1)[1:-1];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&[Z]>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&[Z]> = {
    let mut _0: std::option::Option<&[Z]>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 4];
    let _3: &[Z; 4];
    let _4: [Z; 4];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: Z;
    let mut _8: Z;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _13: &Z;
    scope 1 {
        debug x => _12;
        let _12: &Z;
        let mut _14: &[Z; 4];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_12);
        _12 = &(*_1)[0 of 2];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&Z>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[Z; 4] = {
    let mut _0: &[Z; 4];
    let mut _1: [Z; 4];
    let mut _2: Z;
    let mut _3: Z;
    let mut _4: Z;
    let mut _5: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _4 = Z;
        _5 = Z;
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &Z;
        let mut _6: &[Z; 4];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[Z] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &(*_1)[0 of 2];
        _0 = Option::<&Z>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[Z; 4] = {
    let mut _0: &[Z; 4];
    let mut _1: [Z; 4];
    let mut _2: Z;
    let mut _3: Z;
    let mut _4: Z;
    let mut _5: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _4 = Z;
        _5 = Z;
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 4];
    let _3: &[Z; 4];
    let _4: [Z; 4];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: Z;
    let mut _8: Z;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _13: &Z;
    scope 1 {
        debug x => _12;
        let _12: &Z;
        let mut _14: &[Z; 4];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_12);
        _12 = &(*_1)[0 of 2];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&Z>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 4];
    let _3: &[Z; 4];
    let _4: [Z; 4];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: Z;
    let mut _8: Z;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _12: &Z;
    let mut _13: &Z;
    let mut _14: &[Z; 4];
    scope 1 {
        debug x => _12;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_12);
        _12 = &(*_1)[0 of 2];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&Z>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[Z; 4] = {
    let mut _0: &[Z; 4];
    let mut _1: [Z; 4];
    let mut _2: Z;
    let mut _3: Z;
    let mut _4: Z;
    let mut _5: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _4 = Z;
        _5 = Z;
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &Z;
    let mut _6: &[Z; 4];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[Z] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &(*_1)[0 of 2];
        _0 = Option::<&Z>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[Z; 4] = {
    let mut _0: &[Z; 4];
    let mut _1: [Z; 4];
    let mut _2: Z;
    let mut _3: Z;
    let mut _4: Z;
    let mut _5: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _4 = Z;
        _5 = Z;
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 4];
    let _3: &[Z; 4];
    let _4: [Z; 4];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: Z;
    let mut _8: Z;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _12: &Z;
    let mut _13: &Z;
    let mut _14: &[Z; 4];
    scope 1 {
        debug x => _12;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_12);
        _12 = &(*_1)[0 of 2];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&Z>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 4];
    let _3: &[Z; 4];
    let _4: [Z; 4];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: Z;
    let mut _8: Z;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _13: &Z;
    scope 1 {
        debug x => _12;
        let _12: &Z;
        let mut _14: &[Z; 4];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_12);
        _12 = &(*_1)[-1 of 2];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&Z>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[Z; 4] = {
    let mut _0: &[Z; 4];
    let mut _1: [Z; 4];
    let mut _2: Z;
    let mut _3: Z;
    let mut _4: Z;
    let mut _5: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _4 = Z;
        _5 = Z;
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &Z;
        let mut _6: &[Z; 4];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[Z] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &(*_1)[-1 of 2];
        _0 = Option::<&Z>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[Z; 4] = {
    let mut _0: &[Z; 4];
    let mut _1: [Z; 4];
    let mut _2: Z;
    let mut _3: Z;
    let mut _4: Z;
    let mut _5: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _4 = Z;
        _5 = Z;
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 4];
    let _3: &[Z; 4];
    let _4: [Z; 4];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: Z;
    let mut _8: Z;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _13: &Z;
    scope 1 {
        debug x => _12;
        let _12: &Z;
        let mut _14: &[Z; 4];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_12);
        _12 = &(*_1)[-1 of 2];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&Z>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 4];
    let _3: &[Z; 4];
    let _4: [Z; 4];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: Z;
    let mut _8: Z;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _12: &Z;
    let mut _13: &Z;
    let mut _14: &[Z; 4];
    scope 1 {
        debug x => _12;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_12);
        _12 = &(*_1)[-1 of 2];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&Z>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[Z; 4] = {
    let mut _0: &[Z; 4];
    let mut _1: [Z; 4];
    let mut _2: Z;
    let mut _3: Z;
    let mut _4: Z;
    let mut _5: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _4 = Z;
        _5 = Z;
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &Z;
    let mut _6: &[Z; 4];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[Z] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &(*_1)[-1 of 2];
        _0 = Option::<&Z>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[Z; 4] = {
    let mut _0: &[Z; 4];
    let mut _1: [Z; 4];
    let mut _2: Z;
    let mut _3: Z;
    let mut _4: Z;
    let mut _5: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _4 = Z;
        _5 = Z;
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 4];
    let _3: &[Z; 4];
    let _4: [Z; 4];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: Z;
    let mut _8: Z;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _12: &Z;
    let mut _13: &Z;
    let mut _14: &[Z; 4];
    scope 1 {
        debug x => _12;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_12);
        _12 = &(*_1)[-1 of 2];
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&Z>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&[Z]> = {
    let mut _0: std::option::Option<&[Z]>;
    let mut _1: &[Z];
    let mut _2: &[Z; 2];
    let _3: &[Z; 2];
    let _4: [Z; 2];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _11: &[Z];
    scope 1 {
        debug x => _10;
        let _10: &[Z];
        let mut _12: &[Z; 2];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_10);
        _10 = &(*_1)[1:-1];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&[Z]>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&[Z]>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[Z; 2] = {
    let mut _0: &[Z; 2];
    let mut _1: [Z; 2];
    let mut _2: Z;
    let mut _3: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&[Z]> {
    let mut _0: std::option::Option<&[Z]>;
    let mut _1: &[Z];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &[Z];
        let mut _6: &[Z; 2];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[Z] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &(*_1)[1:-1];
        _0 = Option::<&[Z]>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&[Z]>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[Z; 2] = {
    let mut _0: &[Z; 2];
    let mut _1: [Z; 2];
    let mut _2: Z;
    let mut _3: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&[Z]> {
    let mut _0: std::option::Option<&[Z]>;
    let mut _1: &[Z];
    let mut _2: &[Z; 2];
    let _3: &[Z; 2];
    let _4: [Z; 2];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _11: &[Z];
    scope 1 {
        debug x => _10;
        let _10: &[Z];
        let mut _12: &[Z; 2];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_10);
        _10 = &(*_1)[1:-1];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&[Z]>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&[Z]>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&[Z]> = {
    let mut _0: std::option::Option<&[Z]>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&[Z]> = {
    let mut _0: std::option::Option<&[Z]>;
    let mut _1: &[Z];
    let mut _2: &[Z; 2];
    let _3: &[Z; 2];
    let _4: [Z; 2];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let _10: &[Z];
    let mut _11: &[Z];
    let mut _12: &[Z; 2];
    scope 1 {
        debug x => _10;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&[Z]>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_10);
        _10 = &(*_1)[1:-1];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&[Z]>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[Z; 2] = {
    let mut _0: &[Z; 2];
    let mut _1: [Z; 2];
    let mut _2: Z;
    let mut _3: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&[Z]> {
    let mut _0: std::option::Option<&[Z]>;
    let mut _1: &[Z];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &[Z];
    let mut _6: &[Z; 2];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[Z] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&[Z]>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &(*_1)[1:-1];
        _0 = Option::<&[Z]>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[Z; 2] = {
    let mut _0: &[Z; 2];
    let mut _1: [Z; 2];
    let mut _2: Z;
    let mut _3: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&[Z]> {
    let mut _0: std::option::Option<&[Z]>;
    let mut _1: &[Z];
    let mut _2: &[Z; 2];
    let _3: &[Z; 2];
    let _4: [Z; 2];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let _10: &[Z];
    let mut _11: &[Z];
    let mut _12: &[Z; 2];
    scope 1 {
        debug x => _10;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&[Z]>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_10);
        _10 = &(*_1)[1:-1];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&[Z]>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&[Z]> = {
    let mut _0: std::option::Option<&[Z]>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 2];
    let _3: &[Z; 2];
    let _4: [Z; 2];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _11: &Z;
    scope 1 {
        debug x => _10;
        let _10: &Z;
        let mut _12: &[Z; 2];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_10);
        _10 = &(*_1)[0 of 2];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&Z>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[Z; 2] = {
    let mut _0: &[Z; 2];
    let mut _1: [Z; 2];
    let mut _2: Z;
    let mut _3: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &Z;
        let mut _6: &[Z; 2];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[Z] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &(*_1)[0 of 2];
        _0 = Option::<&Z>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[Z; 2] = {
    let mut _0: &[Z; 2];
    let mut _1: [Z; 2];
    let mut _2: Z;
    let mut _3: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 2];
    let _3: &[Z; 2];
    let _4: [Z; 2];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _11: &Z;
    scope 1 {
        debug x => _10;
        let _10: &Z;
        let mut _12: &[Z; 2];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_10);
        _10 = &(*_1)[0 of 2];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&Z>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 2];
    let _3: &[Z; 2];
    let _4: [Z; 2];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let _10: &Z;
    let mut _11: &Z;
    let mut _12: &[Z; 2];
    scope 1 {
        debug x => _10;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_10);
        _10 = &(*_1)[0 of 2];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&Z>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[Z; 2] = {
    let mut _0: &[Z; 2];
    let mut _1: [Z; 2];
    let mut _2: Z;
    let mut _3: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &Z;
    let mut _6: &[Z; 2];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[Z] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &(*_1)[0 of 2];
        _0 = Option::<&Z>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[Z; 2] = {
    let mut _0: &[Z; 2];
    let mut _1: [Z; 2];
    let mut _2: Z;
    let mut _3: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 2];
    let _3: &[Z; 2];
    let _4: [Z; 2];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let _10: &Z;
    let mut _11: &Z;
    let mut _12: &[Z; 2];
    scope 1 {
        debug x => _10;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_10);
        _10 = &(*_1)[0 of 2];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&Z>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 2];
    let _3: &[Z; 2];
    let _4: [Z; 2];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _11: &Z;
    scope 1 {
        debug x => _10;
        let _10: &Z;
        let mut _12: &[Z; 2];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_10);
        _10 = &(*_1)[-1 of 2];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&Z>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[Z; 2] = {
    let mut _0: &[Z; 2];
    let mut _1: [Z; 2];
    let mut _2: Z;
    let mut _3: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &Z;
        let mut _6: &[Z; 2];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[Z] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &(*_1)[-1 of 2];
        _0 = Option::<&Z>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[Z; 2] = {
    let mut _0: &[Z; 2];
    let mut _1: [Z; 2];
    let mut _2: Z;
    let mut _3: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 2];
    let _3: &[Z; 2];
    let _4: [Z; 2];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _11: &Z;
    scope 1 {
        debug x => _10;
        let _10: &Z;
        let mut _12: &[Z; 2];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_10);
        _10 = &(*_1)[-1 of 2];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&Z>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 2];
    let _3: &[Z; 2];
    let _4: [Z; 2];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let _10: &Z;
    let mut _11: &Z;
    let mut _12: &[Z; 2];
    scope 1 {
        debug x => _10;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_10);
        _10 = &(*_1)[-1 of 2];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&Z>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[Z; 2] = {
    let mut _0: &[Z; 2];
    let mut _1: [Z; 2];
    let mut _2: Z;
    let mut _3: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &Z;
    let mut _6: &[Z; 2];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[Z] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &(*_1)[-1 of 2];
        _0 = Option::<&Z>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[Z; 2] = {
    let mut _0: &[Z; 2];
    let mut _1: [Z; 2];
    let mut _2: Z;
    let mut _3: Z;

    bb0: {
        _2 = Z;
        _3 = Z;
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 2];
    let _3: &[Z; 2];
    let _4: [Z; 2];
    let mut _5: Z;
    let mut _6: Z;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let _10: &Z;
    let mut _11: &Z;
    let mut _12: &[Z; 2];
    scope 1 {
        debug x => _10;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_10);
        _10 = &(*_1)[-1 of 2];
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&Z>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&[Z]> = {
    let mut _0: std::option::Option<&[Z]>;
    let mut _1: &[Z];
    let mut _2: &[Z; 1];
    let _3: &[Z; 1];
    let _4: [Z; 1];
    let mut _5: Z;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _10: &[Z];
    scope 1 {
        debug x => _9;
        let _9: &[Z];
        let mut _11: &[Z; 1];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_9);
        _9 = &(*_1)[1:-1];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&[Z]>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&[Z]>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[Z; 1] = {
    let mut _0: &[Z; 1];
    let mut _1: [Z; 1];
    let mut _2: Z;

    bb0: {
        _2 = Z;
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&[Z]> {
    let mut _0: std::option::Option<&[Z]>;
    let mut _1: &[Z];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &[Z];
        let mut _6: &[Z; 1];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[Z] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &(*_1)[1:-1];
        _0 = Option::<&[Z]>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&[Z]>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[Z; 1] = {
    let mut _0: &[Z; 1];
    let mut _1: [Z; 1];
    let mut _2: Z;

    bb0: {
        _2 = Z;
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&[Z]> {
    let mut _0: std::option::Option<&[Z]>;
    let mut _1: &[Z];
    let mut _2: &[Z; 1];
    let _3: &[Z; 1];
    let _4: [Z; 1];
    let mut _5: Z;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _10: &[Z];
    scope 1 {
        debug x => _9;
        let _9: &[Z];
        let mut _11: &[Z; 1];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_9);
        _9 = &(*_1)[1:-1];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&[Z]>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&[Z]>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&[Z]> = {
    let mut _0: std::option::Option<&[Z]>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&[Z]> = {
    let mut _0: std::option::Option<&[Z]>;
    let mut _1: &[Z];
    let mut _2: &[Z; 1];
    let _3: &[Z; 1];
    let _4: [Z; 1];
    let mut _5: Z;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: &[Z];
    let mut _10: &[Z];
    let mut _11: &[Z; 1];
    scope 1 {
        debug x => _9;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&[Z]>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_9);
        _9 = &(*_1)[1:-1];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&[Z]>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[Z; 1] = {
    let mut _0: &[Z; 1];
    let mut _1: [Z; 1];
    let mut _2: Z;

    bb0: {
        _2 = Z;
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&[Z]> {
    let mut _0: std::option::Option<&[Z]>;
    let mut _1: &[Z];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &[Z];
    let mut _6: &[Z; 1];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[Z] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&[Z]>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &(*_1)[1:-1];
        _0 = Option::<&[Z]>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[Z; 1] = {
    let mut _0: &[Z; 1];
    let mut _1: [Z; 1];
    let mut _2: Z;

    bb0: {
        _2 = Z;
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&[Z]> {
    let mut _0: std::option::Option<&[Z]>;
    let mut _1: &[Z];
    let mut _2: &[Z; 1];
    let _3: &[Z; 1];
    let _4: [Z; 1];
    let mut _5: Z;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: &[Z];
    let mut _10: &[Z];
    let mut _11: &[Z; 1];
    scope 1 {
        debug x => _9;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&[Z]>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_9);
        _9 = &(*_1)[1:-1];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&[Z]>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&[Z]> = {
    let mut _0: std::option::Option<&[Z]>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 1];
    let _3: &[Z; 1];
    let _4: [Z; 1];
    let mut _5: Z;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _10: &Z;
    scope 1 {
        debug x => _9;
        let _9: &Z;
        let mut _11: &[Z; 1];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_9);
        _9 = &(*_1)[0 of 2];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&Z>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[Z; 1] = {
    let mut _0: &[Z; 1];
    let mut _1: [Z; 1];
    let mut _2: Z;

    bb0: {
        _2 = Z;
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &Z;
        let mut _6: &[Z; 1];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[Z] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &(*_1)[0 of 2];
        _0 = Option::<&Z>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[Z; 1] = {
    let mut _0: &[Z; 1];
    let mut _1: [Z; 1];
    let mut _2: Z;

    bb0: {
        _2 = Z;
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 1];
    let _3: &[Z; 1];
    let _4: [Z; 1];
    let mut _5: Z;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _10: &Z;
    scope 1 {
        debug x => _9;
        let _9: &Z;
        let mut _11: &[Z; 1];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_9);
        _9 = &(*_1)[0 of 2];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&Z>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 1];
    let _3: &[Z; 1];
    let _4: [Z; 1];
    let mut _5: Z;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: &Z;
    let mut _10: &Z;
    let mut _11: &[Z; 1];
    scope 1 {
        debug x => _9;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_9);
        _9 = &(*_1)[0 of 2];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&Z>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[Z; 1] = {
    let mut _0: &[Z; 1];
    let mut _1: [Z; 1];
    let mut _2: Z;

    bb0: {
        _2 = Z;
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &Z;
    let mut _6: &[Z; 1];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[Z] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &(*_1)[0 of 2];
        _0 = Option::<&Z>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[Z; 1] = {
    let mut _0: &[Z; 1];
    let mut _1: [Z; 1];
    let mut _2: Z;

    bb0: {
        _2 = Z;
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 1];
    let _3: &[Z; 1];
    let _4: [Z; 1];
    let mut _5: Z;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: &Z;
    let mut _10: &Z;
    let mut _11: &[Z; 1];
    scope 1 {
        debug x => _9;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_9);
        _9 = &(*_1)[0 of 2];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&Z>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 1];
    let _3: &[Z; 1];
    let _4: [Z; 1];
    let mut _5: Z;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _10: &Z;
    scope 1 {
        debug x => _9;
        let _9: &Z;
        let mut _11: &[Z; 1];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_9);
        _9 = &(*_1)[-1 of 2];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&Z>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[Z; 1] = {
    let mut _0: &[Z; 1];
    let mut _1: [Z; 1];
    let mut _2: Z;

    bb0: {
        _2 = Z;
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &Z;
        let mut _6: &[Z; 1];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[Z] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &(*_1)[-1 of 2];
        _0 = Option::<&Z>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[Z; 1] = {
    let mut _0: &[Z; 1];
    let mut _1: [Z; 1];
    let mut _2: Z;

    bb0: {
        _2 = Z;
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 1];
    let _3: &[Z; 1];
    let _4: [Z; 1];
    let mut _5: Z;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _10: &Z;
    scope 1 {
        debug x => _9;
        let _9: &Z;
        let mut _11: &[Z; 1];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_9);
        _9 = &(*_1)[-1 of 2];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&Z>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 1];
    let _3: &[Z; 1];
    let _4: [Z; 1];
    let mut _5: Z;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: &Z;
    let mut _10: &Z;
    let mut _11: &[Z; 1];
    scope 1 {
        debug x => _9;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_9);
        _9 = &(*_1)[-1 of 2];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&Z>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[Z; 1] = {
    let mut _0: &[Z; 1];
    let mut _1: [Z; 1];
    let mut _2: Z;

    bb0: {
        _2 = Z;
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &Z;
    let mut _6: &[Z; 1];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[Z] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &(*_1)[-1 of 2];
        _0 = Option::<&Z>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[Z; 1] = {
    let mut _0: &[Z; 1];
    let mut _1: [Z; 1];
    let mut _2: Z;

    bb0: {
        _2 = Z;
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&Z> {
    let mut _0: std::option::Option<&Z>;
    let mut _1: &[Z];
    let mut _2: &[Z; 1];
    let _3: &[Z; 1];
    let _4: [Z; 1];
    let mut _5: Z;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: &Z;
    let mut _10: &Z;
    let mut _11: &[Z; 1];
    scope 1 {
        debug x => _9;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _11 = const _;
        _3 = &(*_11);
        _2 = &(*_3);
        _1 = move _2 as &[Z] (Pointer(Unsize));
        StorageDead(_2);
        _6 = Len((*_1));
        _7 = const 2_usize;
        _8 = Ge(move _6, move _7);
        switchInt(move _8) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&Z>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_9);
        _9 = &(*_1)[-1 of 2];
        StorageLive(_10);
        _10 = &(*_9);
        _0 = Option::<&Z>::Some(move _10);
        StorageDead(_10);
        StorageDead(_9);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&Z> = {
    let mut _0: std::option::Option<&Z>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&u8> = {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: &[N; 4];
    let _3: &[N; 4];
    let _4: [N; 4];
    let mut _5: N;
    let mut _6: N;
    let mut _7: N;
    let mut _8: N;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _13: &u8;
    scope 1 {
        debug x => _12;
        let _12: &u8;
        let mut _14: &[N; 4];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_12);
        _12 = &((*_1)[0 of 2].0: u8);
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&u8>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&u8> {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &u8;
        let mut _6: &[N; 4];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &((*_1)[0 of 2].0: u8);
        _0 = Option::<&u8>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&u8> {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: &[N; 4];
    let _3: &[N; 4];
    let _4: [N; 4];
    let mut _5: N;
    let mut _6: N;
    let mut _7: N;
    let mut _8: N;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _13: &u8;
    scope 1 {
        debug x => _12;
        let _12: &u8;
        let mut _14: &[N; 4];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_12);
        _12 = &((*_1)[0 of 2].0: u8);
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&u8>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&u8> = {
    let mut _0: std::option::Option<&u8>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&u8> = {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: &[N; 4];
    let _3: &[N; 4];
    let _4: [N; 4];
    let mut _5: N;
    let mut _6: N;
    let mut _7: N;
    let mut _8: N;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _12: &u8;
    let mut _13: &u8;
    let mut _14: &[N; 4];
    scope 1 {
        debug x => _12;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_12);
        _12 = &((*_1)[0 of 2].0: u8);
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&u8>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&u8> {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &u8;
    let mut _6: &[N; 4];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &((*_1)[0 of 2].0: u8);
        _0 = Option::<&u8>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&u8> {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: &[N; 4];
    let _3: &[N; 4];
    let _4: [N; 4];
    let mut _5: N;
    let mut _6: N;
    let mut _7: N;
    let mut _8: N;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _12: &u8;
    let mut _13: &u8;
    let mut _14: &[N; 4];
    scope 1 {
        debug x => _12;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_12);
        _12 = &((*_1)[0 of 2].0: u8);
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&u8>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&u8> = {
    let mut _0: std::option::Option<&u8>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&u8> = {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: &[N; 4];
    let _3: &[N; 4];
    let _4: [N; 4];
    let mut _5: N;
    let mut _6: N;
    let mut _7: N;
    let mut _8: N;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _13: &u8;
    scope 1 {
        debug x => _12;
        let _12: &u8;
        let mut _14: &[N; 4];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_12);
        _12 = &((*_1)[-1 of 2].0: u8);
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&u8>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&u8> {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &u8;
        let mut _6: &[N; 4];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &((*_1)[-1 of 2].0: u8);
        _0 = Option::<&u8>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&u8> {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: &[N; 4];
    let _3: &[N; 4];
    let _4: [N; 4];
    let mut _5: N;
    let mut _6: N;
    let mut _7: N;
    let mut _8: N;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _13: &u8;
    scope 1 {
        debug x => _12;
        let _12: &u8;
        let mut _14: &[N; 4];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_12);
        _12 = &((*_1)[-1 of 2].0: u8);
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&u8>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&u8> = {
    let mut _0: std::option::Option<&u8>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&u8> = {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: &[N; 4];
    let _3: &[N; 4];
    let _4: [N; 4];
    let mut _5: N;
    let mut _6: N;
    let mut _7: N;
    let mut _8: N;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _12: &u8;
    let mut _13: &u8;
    let mut _14: &[N; 4];
    scope 1 {
        debug x => _12;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_12);
        _12 = &((*_1)[-1 of 2].0: u8);
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&u8>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&u8> {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &u8;
    let mut _6: &[N; 4];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &((*_1)[-1 of 2].0: u8);
        _0 = Option::<&u8>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 4] = {
    let mut _0: &[N; 4];
    let mut _1: [N; 4];
    let mut _2: N;
    let mut _3: N;
    let mut _4: N;
    let mut _5: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _4 = N(const 3_u8);
        _5 = N(const 4_u8);
        _1 = [move _2, move _3, move _4, move _5];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&u8> {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: &[N; 4];
    let _3: &[N; 4];
    let _4: [N; 4];
    let mut _5: N;
    let mut _6: N;
    let mut _7: N;
    let mut _8: N;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _12: &u8;
    let mut _13: &u8;
    let mut _14: &[N; 4];
    scope 1 {
        debug x => _12;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _14 = const _;
        _3 = &(*_14);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _9 = Len((*_1));
        _10 = const 2_usize;
        _11 = Ge(move _9, move _10);
        switchInt(move _11) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_12);
        _12 = &((*_1)[-1 of 2].0: u8);
        StorageLive(_13);
        _13 = &(*_12);
        _0 = Option::<&u8>::Some(move _13);
        StorageDead(_13);
        StorageDead(_12);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&u8> = {
    let mut _0: std::option::Option<&u8>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&u8> = {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: &[N; 2];
    let _3: &[N; 2];
    let _4: [N; 2];
    let mut _5: N;
    let mut _6: N;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _11: &u8;
    scope 1 {
        debug x => _10;
        let _10: &u8;
        let mut _12: &[N; 2];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_10);
        _10 = &((*_1)[0 of 2].0: u8);
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&u8>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&u8> {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &u8;
        let mut _6: &[N; 2];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &((*_1)[0 of 2].0: u8);
        _0 = Option::<&u8>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&u8> {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: &[N; 2];
    let _3: &[N; 2];
    let _4: [N; 2];
    let mut _5: N;
    let mut _6: N;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _11: &u8;
    scope 1 {
        debug x => _10;
        let _10: &u8;
        let mut _12: &[N; 2];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_10);
        _10 = &((*_1)[0 of 2].0: u8);
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&u8>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&u8> = {
    let mut _0: std::option::Option<&u8>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&u8> = {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: &[N; 2];
    let _3: &[N; 2];
    let _4: [N; 2];
    let mut _5: N;
    let mut _6: N;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let _10: &u8;
    let mut _11: &u8;
    let mut _12: &[N; 2];
    scope 1 {
        debug x => _10;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_10);
        _10 = &((*_1)[0 of 2].0: u8);
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&u8>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&u8> {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &u8;
    let mut _6: &[N; 2];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &((*_1)[0 of 2].0: u8);
        _0 = Option::<&u8>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&u8> {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: &[N; 2];
    let _3: &[N; 2];
    let _4: [N; 2];
    let mut _5: N;
    let mut _6: N;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let _10: &u8;
    let mut _11: &u8;
    let mut _12: &[N; 2];
    scope 1 {
        debug x => _10;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_10);
        _10 = &((*_1)[0 of 2].0: u8);
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&u8>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&u8> = {
    let mut _0: std::option::Option<&u8>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&u8> = {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: &[N; 2];
    let _3: &[N; 2];
    let _4: [N; 2];
    let mut _5: N;
    let mut _6: N;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _11: &u8;
    scope 1 {
        debug x => _10;
        let _10: &u8;
        let mut _12: &[N; 2];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_10);
        _10 = &((*_1)[-1 of 2].0: u8);
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&u8>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&u8> {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    scope 1 {
        debug x => _5;
        let _5: &u8;
        let mut _6: &[N; 2];
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = &((*_1)[-1 of 2].0: u8);
        _0 = Option::<&u8>::Some(_5);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&u8> {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: &[N; 2];
    let _3: &[N; 2];
    let _4: [N; 2];
    let mut _5: N;
    let mut _6: N;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _11: &u8;
    scope 1 {
        debug x => _10;
        let _10: &u8;
        let mut _12: &[N; 2];
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageLive(_10);
        _10 = &((*_1)[-1 of 2].0: u8);
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&u8>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&u8> = {
    let mut _0: std::option::Option<&u8>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const main::CONST_EVAL: Option<&u8> = {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: &[N; 2];
    let _3: &[N; 2];
    let _4: [N; 2];
    let mut _5: N;
    let mut _6: N;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let _10: &u8;
    let mut _11: &u8;
    let mut _12: &[N; 2];
    scope 1 {
        debug x => _10;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_10);
        _10 = &((*_1)[-1 of 2].0: u8);
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&u8>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in main::CONST_EVAL: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

fn main::const_eval() -> Option<&u8> {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &u8;
    let mut _6: &[N; 2];
    scope 1 {
        debug x => _5;
    }

    bb0: {
        _6 = const _;
        _1 = _6 as &[N] (Pointer(Unsize));
        _2 = Len((*_1));
        _3 = const 2_usize;
        _4 = Ge(move _2, move _3);
        switchInt(move _4) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb2: {
        _5 = &((*_1)[-1 of 2].0: u8);
        _0 = Option::<&u8>::Some(_5);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

promoted[0] in main::const_eval: &[N; 2] = {
    let mut _0: &[N; 2];
    let mut _1: [N; 2];
    let mut _2: N;
    let mut _3: N;

    bb0: {
        _2 = N(const 1_u8);
        _3 = N(const 2_u8);
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn main::const_eval() -> Option<&u8> {
    let mut _0: std::option::Option<&u8>;
    let mut _1: &[N];
    let mut _2: &[N; 2];
    let _3: &[N; 2];
    let _4: [N; 2];
    let mut _5: N;
    let mut _6: N;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let _10: &u8;
    let mut _11: &u8;
    let mut _12: &[N; 2];
    scope 1 {
        debug x => _10;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _12 = const _;
        _3 = &(*_12);
        _2 = &(*_3);
        _1 = move _2 as &[N] (Pointer(Unsize));
        StorageDead(_2);
        _7 = Len((*_1));
        _8 = const 2_usize;
        _9 = Ge(move _7, move _8);
        switchInt(move _9) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<&u8>::None;
        goto -> bb3;
    }

    bb2: {
        StorageLive(_10);
        _10 = &((*_1)[-1 of 2].0: u8);
        StorageLive(_11);
        _11 = &(*_10);
        _0 = Option::<&u8>::Some(move _11);
        StorageDead(_11);
        StorageDead(_10);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

static main::CONST_EVAL2: Option<&u8> = {
    let mut _0: std::option::Option<&u8>;

    bb0: {
        ConstEvalCounter;
        _0 = main::const_eval() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn N(_1: u8) -> N {
    let mut _0: N;

    bb0: {
        _0 = N(move _1);
        return;
    }
}

// MIR FOR CTFE
fn N(_1: u8) -> N {
    let mut _0: N;

    bb0: {
        _0 = N(move _1);
        return;
    }
}
