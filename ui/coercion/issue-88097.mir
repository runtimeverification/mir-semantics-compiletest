// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn peculiar() -> impl Fn(u8) -> u8 {
    let mut _0: impl Fn(u8) -> u8;       // return place in scope 0 at ui/coercion/issue-88097.rs:7:18: 7:35

    bb0: {
        return;                          // scope 0 at ui/coercion/issue-88097.rs:9:2: 9:2
    }
}

fn peculiar::{closure#0}(_1: &[closure@ui/coercion/issue-88097.rs:8:12: 8:15], _2: u8) -> u8 {
    debug x => _2;                       // in scope 0 at ui/coercion/issue-88097.rs:8:13: 8:14
    let mut _0: u8;                      // return place in scope 0 at ui/coercion/issue-88097.rs:8:16: 8:16
    let mut _3: u8;                      // in scope 0 at ui/coercion/issue-88097.rs:8:16: 8:17
    let mut _4: (u8, bool);              // in scope 0 at ui/coercion/issue-88097.rs:8:16: 8:21

    bb0: {
        _3 = _2;                         // scope 0 at ui/coercion/issue-88097.rs:8:16: 8:17
        _4 = CheckedAdd(_3, const 1_u8); // scope 0 at ui/coercion/issue-88097.rs:8:16: 8:21
        assert(!move (_4.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3, const 1_u8) -> bb1; // scope 0 at ui/coercion/issue-88097.rs:8:16: 8:21
    }

    bb1: {
        _0 = move (_4.0: u8);            // scope 0 at ui/coercion/issue-88097.rs:8:16: 8:21
        return;                          // scope 0 at ui/coercion/issue-88097.rs:8:21: 8:21
    }
}

fn peculiar2() -> impl Fn(u8) -> u8 {
    let mut _0: impl Fn(u8) -> u8;       // return place in scope 0 at ui/coercion/issue-88097.rs:11:19: 11:36

    bb0: {
        return;                          // scope 0 at ui/coercion/issue-88097.rs:13:2: 13:2
    }
}

fn peculiar2::{closure#0}(_1: &[closure@ui/coercion/issue-88097.rs:12:12: 12:15], _2: u8) -> u8 {
    debug x => _2;                       // in scope 0 at ui/coercion/issue-88097.rs:12:13: 12:14
    let mut _0: u8;                      // return place in scope 0 at ui/coercion/issue-88097.rs:12:16: 12:16
    let mut _3: u8;                      // in scope 0 at ui/coercion/issue-88097.rs:12:16: 12:17
    let mut _4: (u8, bool);              // in scope 0 at ui/coercion/issue-88097.rs:12:16: 12:21

    bb0: {
        _3 = _2;                         // scope 0 at ui/coercion/issue-88097.rs:12:16: 12:17
        _4 = CheckedAdd(_3, const 1_u8); // scope 0 at ui/coercion/issue-88097.rs:12:16: 12:21
        assert(!move (_4.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3, const 1_u8) -> bb1; // scope 0 at ui/coercion/issue-88097.rs:12:16: 12:21
    }

    bb1: {
        _0 = move (_4.0: u8);            // scope 0 at ui/coercion/issue-88097.rs:12:16: 12:21
        return;                          // scope 0 at ui/coercion/issue-88097.rs:12:21: 12:21
    }
}

fn peculiar3() -> impl Fn(u8) -> u8 {
    let mut _0: impl Fn(u8) -> u8;       // return place in scope 0 at ui/coercion/issue-88097.rs:15:19: 15:36
    let _1: [closure@ui/coercion/issue-88097.rs:16:13: 16:16]; // in scope 0 at ui/coercion/issue-88097.rs:16:9: 16:10
    scope 1 {
        debug f => _1;                   // in scope 1 at ui/coercion/issue-88097.rs:16:9: 16:10
    }

    bb0: {
        return;                          // scope 0 at ui/coercion/issue-88097.rs:18:2: 18:2
    }
}

fn peculiar3::{closure#0}(_1: &[closure@ui/coercion/issue-88097.rs:16:13: 16:16], _2: u8) -> u8 {
    debug x => _2;                       // in scope 0 at ui/coercion/issue-88097.rs:16:14: 16:15
    let mut _0: u8;                      // return place in scope 0 at ui/coercion/issue-88097.rs:16:17: 16:17
    let mut _3: u8;                      // in scope 0 at ui/coercion/issue-88097.rs:16:17: 16:18
    let mut _4: (u8, bool);              // in scope 0 at ui/coercion/issue-88097.rs:16:17: 16:22

    bb0: {
        _3 = _2;                         // scope 0 at ui/coercion/issue-88097.rs:16:17: 16:18
        _4 = CheckedAdd(_3, const 1_u8); // scope 0 at ui/coercion/issue-88097.rs:16:17: 16:22
        assert(!move (_4.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3, const 1_u8) -> bb1; // scope 0 at ui/coercion/issue-88097.rs:16:17: 16:22
    }

    bb1: {
        _0 = move (_4.0: u8);            // scope 0 at ui/coercion/issue-88097.rs:16:17: 16:22
        return;                          // scope 0 at ui/coercion/issue-88097.rs:16:22: 16:22
    }
}

fn peculiar4() -> impl Fn(u8) -> u8 {
    let mut _0: impl Fn(u8) -> u8;       // return place in scope 0 at ui/coercion/issue-88097.rs:20:19: 20:36
    let _1: [closure@ui/coercion/issue-88097.rs:21:13: 21:16]; // in scope 0 at ui/coercion/issue-88097.rs:21:9: 21:10
    scope 1 {
        debug f => _1;                   // in scope 1 at ui/coercion/issue-88097.rs:21:9: 21:10
    }

    bb0: {
        return;                          // scope 0 at ui/coercion/issue-88097.rs:23:2: 23:2
    }
}

fn peculiar4::{closure#0}(_1: &[closure@ui/coercion/issue-88097.rs:21:13: 21:16], _2: u8) -> u8 {
    debug x => _2;                       // in scope 0 at ui/coercion/issue-88097.rs:21:14: 21:15
    let mut _0: u8;                      // return place in scope 0 at ui/coercion/issue-88097.rs:21:17: 21:17
    let mut _3: u8;                      // in scope 0 at ui/coercion/issue-88097.rs:21:17: 21:18
    let mut _4: (u8, bool);              // in scope 0 at ui/coercion/issue-88097.rs:21:17: 21:22

    bb0: {
        _3 = _2;                         // scope 0 at ui/coercion/issue-88097.rs:21:17: 21:18
        _4 = CheckedAdd(_3, const 1_u8); // scope 0 at ui/coercion/issue-88097.rs:21:17: 21:22
        assert(!move (_4.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3, const 1_u8) -> bb1; // scope 0 at ui/coercion/issue-88097.rs:21:17: 21:22
    }

    bb1: {
        _0 = move (_4.0: u8);            // scope 0 at ui/coercion/issue-88097.rs:21:17: 21:22
        return;                          // scope 0 at ui/coercion/issue-88097.rs:21:22: 21:22
    }
}

fn peculiar5() -> impl Fn(u8) -> u8 {
    let mut _0: impl Fn(u8) -> u8;       // return place in scope 0 at ui/coercion/issue-88097.rs:25:19: 25:36
    let _1: [closure@ui/coercion/issue-88097.rs:26:13: 26:16]; // in scope 0 at ui/coercion/issue-88097.rs:26:9: 26:10
    let mut _3: [closure@ui/coercion/issue-88097.rs:26:13: 26:16]; // in scope 0 at ui/coercion/issue-88097.rs:28:20: 28:25
    scope 1 {
        debug f => _1;                   // in scope 1 at ui/coercion/issue-88097.rs:26:9: 26:10
        let _2: [closure@ui/coercion/issue-88097.rs:27:13: 27:16]; // in scope 1 at ui/coercion/issue-88097.rs:27:9: 27:10
        scope 2 {
            debug g => _2;               // in scope 2 at ui/coercion/issue-88097.rs:27:9: 27:10
        }
    }

    bb0: {
        _0 = move _3 as fn(u8) -> u8 (Pointer(ClosureFnPointer(Normal))); // scope 2 at ui/coercion/issue-88097.rs:28:20: 28:25
        return;                          // scope 0 at ui/coercion/issue-88097.rs:29:2: 29:2
    }
}

fn peculiar5::{closure#0}(_1: &[closure@ui/coercion/issue-88097.rs:26:13: 26:16], _2: u8) -> u8 {
    debug x => _2;                       // in scope 0 at ui/coercion/issue-88097.rs:26:14: 26:15
    let mut _0: u8;                      // return place in scope 0 at ui/coercion/issue-88097.rs:26:17: 26:17
    let mut _3: u8;                      // in scope 0 at ui/coercion/issue-88097.rs:26:17: 26:18
    let mut _4: (u8, bool);              // in scope 0 at ui/coercion/issue-88097.rs:26:17: 26:22

    bb0: {
        _3 = _2;                         // scope 0 at ui/coercion/issue-88097.rs:26:17: 26:18
        _4 = CheckedAdd(_3, const 1_u8); // scope 0 at ui/coercion/issue-88097.rs:26:17: 26:22
        assert(!move (_4.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3, const 1_u8) -> bb1; // scope 0 at ui/coercion/issue-88097.rs:26:17: 26:22
    }

    bb1: {
        _0 = move (_4.0: u8);            // scope 0 at ui/coercion/issue-88097.rs:26:17: 26:22
        return;                          // scope 0 at ui/coercion/issue-88097.rs:26:22: 26:22
    }
}

fn peculiar5::{closure#1}(_1: &[closure@ui/coercion/issue-88097.rs:27:13: 27:16], _2: u8) -> u8 {
    debug x => _2;                       // in scope 0 at ui/coercion/issue-88097.rs:27:14: 27:15
    let mut _0: u8;                      // return place in scope 0 at ui/coercion/issue-88097.rs:27:17: 27:17
    let mut _3: u8;                      // in scope 0 at ui/coercion/issue-88097.rs:27:17: 27:18
    let mut _4: (u8, bool);              // in scope 0 at ui/coercion/issue-88097.rs:27:17: 27:22

    bb0: {
        _3 = _2;                         // scope 0 at ui/coercion/issue-88097.rs:27:17: 27:18
        _4 = CheckedAdd(_3, const 2_u8); // scope 0 at ui/coercion/issue-88097.rs:27:17: 27:22
        assert(!move (_4.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3, const 2_u8) -> bb1; // scope 0 at ui/coercion/issue-88097.rs:27:17: 27:22
    }

    bb1: {
        _0 = move (_4.0: u8);            // scope 0 at ui/coercion/issue-88097.rs:27:17: 27:22
        return;                          // scope 0 at ui/coercion/issue-88097.rs:27:22: 27:22
    }
}

fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/coercion/issue-88097.rs:31:11: 31:11

    bb0: {
        return;                          // scope 0 at ui/coercion/issue-88097.rs:31:13: 31:13
    }
}
