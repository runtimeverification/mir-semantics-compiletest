// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/packed/packed-struct-vec.rs:7:16: 7:21>::clone(_1: &Foo1) -> Foo1 {
    debug self => _1;
    let mut _0: Foo1;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn <impl at ui/packed/packed-struct-vec.rs:13:1: 13:24>::eq(_1: &Foo1, _2: &Foo1) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: u8;
    let mut _5: u8;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        _4 = ((*_1).0: u8);
        _5 = ((*_2).0: u8);
        _3 = Eq(move _4, move _5);
        switchInt(move _3) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const false;
        goto -> bb3;
    }

    bb2: {
        _7 = ((*_1).1: u64);
        _8 = ((*_2).1: u64);
        _6 = Eq(move _7, move _8);
        _0 = move _6;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn <impl at ui/packed/packed-struct-vec.rs:19:1: 19:25>::fmt(_1: &Foo1, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: u8;
    let mut _5: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _6: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _7: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _8: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _9: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _10: std::fmt::DebugStruct<'_, '_>;
    let _11: &str;
    let _12: &str;
    let mut _13: &dyn std::fmt::Debug;
    let _14: &u8;
    let _15: &str;
    let mut _16: &dyn std::fmt::Debug;
    let _17: &u64;
    scope 1 {
        debug bar => _3;
        let _4: u64;
        scope 2 {
            debug baz => _4;
        }
    }

    bb0: {
        _3 = ((*_1).0: u8);
        _4 = ((*_1).1: u64);
        _11 = const "Foo1";
        _10 = Formatter::<'_>::debug_struct(_2, _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = &mut _10;
        _12 = const "bar";
        _14 = &_3;
        _13 = _14 as &dyn std::fmt::Debug (Pointer(Unsize));
        _8 = DebugStruct::<'_, '_>::field(move _9, _12, move _13) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = _8;
        _15 = const "baz";
        _17 = &_4;
        _16 = _17 as &dyn std::fmt::Debug (Pointer(Unsize));
        _6 = DebugStruct::<'_, '_>::field(move _7, _15, move _16) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = _6;
        _0 = DebugStruct::<'_, '_>::finish(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn <impl at ui/packed/packed-struct-vec.rs:32:16: 32:21>::clone(_1: &Foo2) -> Foo2 {
    debug self => _1;
    let mut _0: Foo2;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn <impl at ui/packed/packed-struct-vec.rs:38:1: 38:24>::eq(_1: &Foo2, _2: &Foo2) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: u8;
    let mut _5: u8;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        _4 = ((*_1).0: u8);
        _5 = ((*_2).0: u8);
        _3 = Eq(move _4, move _5);
        switchInt(move _3) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const false;
        goto -> bb3;
    }

    bb2: {
        _7 = ((*_1).1: u64);
        _8 = ((*_2).1: u64);
        _6 = Eq(move _7, move _8);
        _0 = move _6;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn <impl at ui/packed/packed-struct-vec.rs:44:1: 44:25>::fmt(_1: &Foo2, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: u8;
    let mut _5: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _6: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _7: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _8: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _9: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _10: std::fmt::DebugStruct<'_, '_>;
    let _11: &str;
    let _12: &str;
    let mut _13: &dyn std::fmt::Debug;
    let _14: &u8;
    let _15: &str;
    let mut _16: &dyn std::fmt::Debug;
    let _17: &u64;
    scope 1 {
        debug bar => _3;
        let _4: u64;
        scope 2 {
            debug baz => _4;
        }
    }

    bb0: {
        _3 = ((*_1).0: u8);
        _4 = ((*_1).1: u64);
        _11 = const "Foo2";
        _10 = Formatter::<'_>::debug_struct(_2, _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = &mut _10;
        _12 = const "bar";
        _14 = &_3;
        _13 = _14 as &dyn std::fmt::Debug (Pointer(Unsize));
        _8 = DebugStruct::<'_, '_>::field(move _9, _12, move _13) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = _8;
        _15 = const "baz";
        _17 = &_4;
        _16 = _17 as &dyn std::fmt::Debug (Pointer(Unsize));
        _6 = DebugStruct::<'_, '_>::field(move _7, _15, move _16) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = _6;
        _0 = DebugStruct::<'_, '_>::finish(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn <impl at ui/packed/packed-struct-vec.rs:57:16: 57:21>::clone(_1: &Foo4C) -> Foo4C {
    debug self => _1;
    let mut _0: Foo4C;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn <impl at ui/packed/packed-struct-vec.rs:63:1: 63:25>::eq(_1: &Foo4C, _2: &Foo4C) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: u8;
    let mut _5: u8;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        _4 = ((*_1).0: u8);
        _5 = ((*_2).0: u8);
        _3 = Eq(move _4, move _5);
        switchInt(move _3) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const false;
        goto -> bb3;
    }

    bb2: {
        _7 = ((*_1).1: u64);
        _8 = ((*_2).1: u64);
        _6 = Eq(move _7, move _8);
        _0 = move _6;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn <impl at ui/packed/packed-struct-vec.rs:69:1: 69:26>::fmt(_1: &Foo4C, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: u8;
    let mut _5: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _6: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _7: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _8: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _9: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _10: std::fmt::DebugStruct<'_, '_>;
    let _11: &str;
    let _12: &str;
    let mut _13: &dyn std::fmt::Debug;
    let _14: &u8;
    let _15: &str;
    let mut _16: &dyn std::fmt::Debug;
    let _17: &u64;
    scope 1 {
        debug bar => _3;
        let _4: u64;
        scope 2 {
            debug baz => _4;
        }
    }

    bb0: {
        _3 = ((*_1).0: u8);
        _4 = ((*_1).1: u64);
        _11 = const "Foo4C";
        _10 = Formatter::<'_>::debug_struct(_2, _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = &mut _10;
        _12 = const "bar";
        _14 = &_3;
        _13 = _14 as &dyn std::fmt::Debug (Pointer(Unsize));
        _8 = DebugStruct::<'_, '_>::field(move _9, _12, move _13) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = _8;
        _15 = const "baz";
        _17 = &_4;
        _16 = _17 as &dyn std::fmt::Debug (Pointer(Unsize));
        _6 = DebugStruct::<'_, '_>::field(move _7, _15, move _16) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = _6;
        _0 = DebugStruct::<'_, '_>::finish(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: [Foo1; 10];
    let mut _2: Foo1;
    let mut _3: (&usize, &usize);
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: usize;
    let mut _9: usize;
    let _11: !;
    let mut _12: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _13: (&usize, &usize);
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: usize;
    let mut _19: usize;
    let _21: !;
    let mut _22: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _23: std::ops::Range<usize>;
    let mut _24: std::ops::Range<usize>;
    let mut _26: std::option::Option<usize>;
    let mut _27: &mut std::ops::Range<usize>;
    let mut _28: isize;
    let mut _30: (&Foo1, &Foo1);
    let mut _31: &Foo1;
    let mut _32: usize;
    let mut _33: bool;
    let mut _36: bool;
    let mut _37: bool;
    let _39: !;
    let mut _40: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _41: std::slice::Iter<'_, Foo1>;
    let mut _42: &[Foo1; 10];
    let mut _44: std::option::Option<&Foo1>;
    let mut _45: &mut std::slice::Iter<'_, Foo1>;
    let mut _46: isize;
    let mut _48: (&Foo1, &Foo1);
    let mut _49: &Foo1;
    let mut _52: bool;
    let mut _53: bool;
    let _55: !;
    let mut _56: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _58: Foo2;
    let mut _59: (&usize, &usize);
    let mut _62: bool;
    let mut _63: bool;
    let mut _64: usize;
    let mut _65: usize;
    let _67: !;
    let mut _68: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _69: (&usize, &usize);
    let mut _72: bool;
    let mut _73: bool;
    let mut _74: usize;
    let mut _75: usize;
    let _77: !;
    let mut _78: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _79: std::ops::Range<usize>;
    let mut _80: std::ops::Range<usize>;
    let mut _82: std::option::Option<usize>;
    let mut _83: &mut std::ops::Range<usize>;
    let mut _84: isize;
    let mut _86: (&Foo2, &Foo2);
    let mut _87: &Foo2;
    let mut _88: usize;
    let mut _89: bool;
    let mut _92: bool;
    let mut _93: bool;
    let _95: !;
    let mut _96: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _97: std::slice::Iter<'_, Foo2>;
    let mut _98: &[Foo2; 10];
    let mut _100: std::option::Option<&Foo2>;
    let mut _101: &mut std::slice::Iter<'_, Foo2>;
    let mut _102: isize;
    let mut _104: (&Foo2, &Foo2);
    let mut _105: &Foo2;
    let mut _108: bool;
    let mut _109: bool;
    let _111: !;
    let mut _112: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _114: Foo4C;
    let mut _115: (&usize, &usize);
    let mut _118: bool;
    let mut _119: bool;
    let mut _120: usize;
    let mut _121: usize;
    let _123: !;
    let mut _124: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _125: (&usize, &usize);
    let mut _128: bool;
    let mut _129: bool;
    let mut _130: usize;
    let mut _131: usize;
    let _133: !;
    let mut _134: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _135: std::ops::Range<usize>;
    let mut _136: std::ops::Range<usize>;
    let mut _138: std::option::Option<usize>;
    let mut _139: &mut std::ops::Range<usize>;
    let mut _140: isize;
    let mut _142: (&Foo4C, &Foo4C);
    let mut _143: &Foo4C;
    let mut _144: usize;
    let mut _145: bool;
    let mut _148: bool;
    let mut _149: bool;
    let _151: !;
    let mut _152: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _153: std::slice::Iter<'_, Foo4C>;
    let mut _154: &[Foo4C; 10];
    let mut _156: std::option::Option<&Foo4C>;
    let mut _157: &mut std::slice::Iter<'_, Foo4C>;
    let mut _158: isize;
    let mut _160: (&Foo4C, &Foo4C);
    let mut _161: &Foo4C;
    let mut _164: bool;
    let mut _165: bool;
    let _167: !;
    let mut _168: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _187: &Foo1;
    let mut _188: &Foo2;
    let mut _189: &Foo4C;
    scope 1 {
        debug foo1s => _1;
        let _4: &usize;
        let _5: &usize;
        let _14: &usize;
        let _15: &usize;
        let mut _25: std::ops::Range<usize>;
        let mut _43: std::slice::Iter<'_, Foo1>;
        let _57: [Foo2; 10];
        let mut _183: &usize;
        let mut _184: &usize;
        let mut _185: &usize;
        let mut _186: &usize;
        scope 2 {
            debug left_val => _4;
            debug right_val => _5;
            let _10: core::panicking::AssertKind;
            scope 3 {
                debug kind => _10;
            }
        }
        scope 4 {
            debug left_val => _14;
            debug right_val => _15;
            let _20: core::panicking::AssertKind;
            scope 5 {
                debug kind => _20;
            }
        }
        scope 6 {
            debug iter => _25;
            let _29: usize;
            scope 7 {
                debug i => _29;
                let _34: &Foo1;
                let _35: &Foo1;
                let mut _169: &Foo1;
                scope 8 {
                    debug left_val => _34;
                    debug right_val => _35;
                    let _38: core::panicking::AssertKind;
                    scope 9 {
                        debug kind => _38;
                    }
                }
            }
        }
        scope 10 {
            debug iter => _43;
            let _47: Foo1;
            scope 11 {
                debug foo => _47;
                let _50: &Foo1;
                let _51: &Foo1;
                let mut _170: &Foo1;
                scope 12 {
                    debug left_val => _50;
                    debug right_val => _51;
                    let _54: core::panicking::AssertKind;
                    scope 13 {
                        debug kind => _54;
                    }
                }
            }
        }
        scope 14 {
            debug foo2s => _57;
            let _60: &usize;
            let _61: &usize;
            let _70: &usize;
            let _71: &usize;
            let mut _81: std::ops::Range<usize>;
            let mut _99: std::slice::Iter<'_, Foo2>;
            let _113: [Foo4C; 10];
            let mut _179: &usize;
            let mut _180: &usize;
            let mut _181: &usize;
            let mut _182: &usize;
            scope 15 {
                debug left_val => _60;
                debug right_val => _61;
                let _66: core::panicking::AssertKind;
                scope 16 {
                    debug kind => _66;
                }
            }
            scope 17 {
                debug left_val => _70;
                debug right_val => _71;
                let _76: core::panicking::AssertKind;
                scope 18 {
                    debug kind => _76;
                }
            }
            scope 19 {
                debug iter => _81;
                let _85: usize;
                scope 20 {
                    debug i => _85;
                    let _90: &Foo2;
                    let _91: &Foo2;
                    let mut _171: &Foo2;
                    scope 21 {
                        debug left_val => _90;
                        debug right_val => _91;
                        let _94: core::panicking::AssertKind;
                        scope 22 {
                            debug kind => _94;
                        }
                    }
                }
            }
            scope 23 {
                debug iter => _99;
                let _103: Foo2;
                scope 24 {
                    debug foo => _103;
                    let _106: &Foo2;
                    let _107: &Foo2;
                    let mut _172: &Foo2;
                    scope 25 {
                        debug left_val => _106;
                        debug right_val => _107;
                        let _110: core::panicking::AssertKind;
                        scope 26 {
                            debug kind => _110;
                        }
                    }
                }
            }
            scope 27 {
                debug foo4s => _113;
                let _116: &usize;
                let _117: &usize;
                let _126: &usize;
                let _127: &usize;
                let mut _137: std::ops::Range<usize>;
                let mut _155: std::slice::Iter<'_, Foo4C>;
                let mut _175: &usize;
                let mut _176: &usize;
                let mut _177: &usize;
                let mut _178: &usize;
                scope 28 {
                    debug left_val => _116;
                    debug right_val => _117;
                    let _122: core::panicking::AssertKind;
                    scope 29 {
                        debug kind => _122;
                    }
                }
                scope 30 {
                    debug left_val => _126;
                    debug right_val => _127;
                    let _132: core::panicking::AssertKind;
                    scope 31 {
                        debug kind => _132;
                    }
                }
                scope 32 {
                    debug iter => _137;
                    let _141: usize;
                    scope 33 {
                        debug i => _141;
                        let _146: &Foo4C;
                        let _147: &Foo4C;
                        let mut _173: &Foo4C;
                        scope 34 {
                            debug left_val => _146;
                            debug right_val => _147;
                            let _150: core::panicking::AssertKind;
                            scope 35 {
                                debug kind => _150;
                            }
                        }
                    }
                }
                scope 36 {
                    debug iter => _155;
                    let _159: Foo4C;
                    scope 37 {
                        debug foo => _159;
                        let _162: &Foo4C;
                        let _163: &Foo4C;
                        let mut _174: &Foo4C;
                        scope 38 {
                            debug left_val => _162;
                            debug right_val => _163;
                            let _166: core::panicking::AssertKind;
                            scope 39 {
                                debug kind => _166;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = Foo1 { bar: const 1_u8, baz: const 2_u64 };
        _1 = [move _2; 10];
        _186 = const _;
        _185 = const _;
        _3 = (_186, _185);
        _4 = (_3.0: &usize);
        _5 = (_3.1: &usize);
        _8 = (*_4);
        _9 = (*_5);
        _7 = Eq(move _8, move _9);
        _6 = Not(move _7);
        switchInt(move _6) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _10 = core::panicking::AssertKind::Eq;
        _12 = Option::<Arguments<'_>>::None;
        _11 = core::panicking::assert_failed::<usize, usize>(move _10, _4, _5, move _12) -> unwind continue;
    }

    bb2: {
        _184 = const _;
        _183 = const _;
        _13 = (_184, _183);
        _14 = (_13.0: &usize);
        _15 = (_13.1: &usize);
        _18 = (*_14);
        _19 = (*_15);
        _17 = Eq(move _18, move _19);
        _16 = Not(move _17);
        switchInt(move _16) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _20 = core::panicking::AssertKind::Eq;
        _22 = Option::<Arguments<'_>>::None;
        _21 = core::panicking::assert_failed::<usize, usize>(move _20, _14, _15, move _22) -> unwind continue;
    }

    bb4: {
        _24 = std::ops::Range::<usize> { start: const 0_usize, end: const 10_usize };
        _23 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _24) -> [return: bb5, unwind continue];
    }

    bb5: {
        _25 = move _23;
        goto -> bb6;
    }

    bb6: {
        _27 = &mut _25;
        _26 = <std::ops::Range<usize> as Iterator>::next(_27) -> [return: bb7, unwind continue];
    }

    bb7: {
        _28 = discriminant(_26);
        switchInt(move _28) -> [0: bb10, 1: bb8, otherwise: bb9];
    }

    bb8: {
        _29 = ((_26 as Some).0: usize);
        _32 = const 10_usize;
        _33 = Lt(_29, _32);
        assert(move _33, "index out of bounds: the length is {} but the index is {}", move _32, _29) -> [success: bb11, unwind continue];
    }

    bb9: {
        unreachable;
    }

    bb10: {
        _42 = &_1;
        _41 = <&[Foo1; 10] as IntoIterator>::into_iter(move _42) -> [return: bb14, unwind continue];
    }

    bb11: {
        _31 = &_1[_29];
        _169 = const _;
        _30 = (move _31, _169);
        _34 = (_30.0: &Foo1);
        _35 = (_30.1: &Foo1);
        _37 = <Foo1 as PartialEq>::eq(_34, _35) -> [return: bb12, unwind continue];
    }

    bb12: {
        _36 = Not(move _37);
        switchInt(move _36) -> [0: bb6, otherwise: bb13];
    }

    bb13: {
        _38 = core::panicking::AssertKind::Eq;
        _40 = Option::<Arguments<'_>>::None;
        _39 = core::panicking::assert_failed::<Foo1, Foo1>(move _38, _34, _35, move _40) -> unwind continue;
    }

    bb14: {
        _43 = move _41;
        goto -> bb15;
    }

    bb15: {
        _45 = &mut _43;
        _44 = <std::slice::Iter<'_, Foo1> as Iterator>::next(_45) -> [return: bb16, unwind continue];
    }

    bb16: {
        _46 = discriminant(_44);
        switchInt(move _46) -> [0: bb18, 1: bb17, otherwise: bb9];
    }

    bb17: {
        _187 = deref_copy ((_44 as Some).0: &Foo1);
        _47 = (*_187);
        _49 = &_47;
        _170 = const _;
        _48 = (move _49, _170);
        _50 = (_48.0: &Foo1);
        _51 = (_48.1: &Foo1);
        _53 = <Foo1 as PartialEq>::eq(_50, _51) -> [return: bb19, unwind continue];
    }

    bb18: {
        _58 = Foo2 { bar: const 1_u8, baz: const 2_u64 };
        _57 = [move _58; 10];
        _182 = const _;
        _181 = const _;
        _59 = (_182, _181);
        _60 = (_59.0: &usize);
        _61 = (_59.1: &usize);
        _64 = (*_60);
        _65 = (*_61);
        _63 = Eq(move _64, move _65);
        _62 = Not(move _63);
        switchInt(move _62) -> [0: bb22, otherwise: bb21];
    }

    bb19: {
        _52 = Not(move _53);
        switchInt(move _52) -> [0: bb15, otherwise: bb20];
    }

    bb20: {
        _54 = core::panicking::AssertKind::Eq;
        _56 = Option::<Arguments<'_>>::None;
        _55 = core::panicking::assert_failed::<Foo1, Foo1>(move _54, _50, _51, move _56) -> unwind continue;
    }

    bb21: {
        _66 = core::panicking::AssertKind::Eq;
        _68 = Option::<Arguments<'_>>::None;
        _67 = core::panicking::assert_failed::<usize, usize>(move _66, _60, _61, move _68) -> unwind continue;
    }

    bb22: {
        _180 = const _;
        _179 = const _;
        _69 = (_180, _179);
        _70 = (_69.0: &usize);
        _71 = (_69.1: &usize);
        _74 = (*_70);
        _75 = (*_71);
        _73 = Eq(move _74, move _75);
        _72 = Not(move _73);
        switchInt(move _72) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _76 = core::panicking::AssertKind::Eq;
        _78 = Option::<Arguments<'_>>::None;
        _77 = core::panicking::assert_failed::<usize, usize>(move _76, _70, _71, move _78) -> unwind continue;
    }

    bb24: {
        _80 = std::ops::Range::<usize> { start: const 0_usize, end: const 10_usize };
        _79 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _80) -> [return: bb25, unwind continue];
    }

    bb25: {
        _81 = move _79;
        goto -> bb26;
    }

    bb26: {
        _83 = &mut _81;
        _82 = <std::ops::Range<usize> as Iterator>::next(_83) -> [return: bb27, unwind continue];
    }

    bb27: {
        _84 = discriminant(_82);
        switchInt(move _84) -> [0: bb29, 1: bb28, otherwise: bb9];
    }

    bb28: {
        _85 = ((_82 as Some).0: usize);
        _88 = const 10_usize;
        _89 = Lt(_85, _88);
        assert(move _89, "index out of bounds: the length is {} but the index is {}", move _88, _85) -> [success: bb30, unwind continue];
    }

    bb29: {
        _98 = &_57;
        _97 = <&[Foo2; 10] as IntoIterator>::into_iter(move _98) -> [return: bb33, unwind continue];
    }

    bb30: {
        _87 = &_57[_85];
        _171 = const _;
        _86 = (move _87, _171);
        _90 = (_86.0: &Foo2);
        _91 = (_86.1: &Foo2);
        _93 = <Foo2 as PartialEq>::eq(_90, _91) -> [return: bb31, unwind continue];
    }

    bb31: {
        _92 = Not(move _93);
        switchInt(move _92) -> [0: bb26, otherwise: bb32];
    }

    bb32: {
        _94 = core::panicking::AssertKind::Eq;
        _96 = Option::<Arguments<'_>>::None;
        _95 = core::panicking::assert_failed::<Foo2, Foo2>(move _94, _90, _91, move _96) -> unwind continue;
    }

    bb33: {
        _99 = move _97;
        goto -> bb34;
    }

    bb34: {
        _101 = &mut _99;
        _100 = <std::slice::Iter<'_, Foo2> as Iterator>::next(_101) -> [return: bb35, unwind continue];
    }

    bb35: {
        _102 = discriminant(_100);
        switchInt(move _102) -> [0: bb37, 1: bb36, otherwise: bb9];
    }

    bb36: {
        _188 = deref_copy ((_100 as Some).0: &Foo2);
        _103 = (*_188);
        _105 = &_103;
        _172 = const _;
        _104 = (move _105, _172);
        _106 = (_104.0: &Foo2);
        _107 = (_104.1: &Foo2);
        _109 = <Foo2 as PartialEq>::eq(_106, _107) -> [return: bb38, unwind continue];
    }

    bb37: {
        _114 = Foo4C { bar: const 1_u8, baz: const 2_u64 };
        _113 = [move _114; 10];
        _178 = const _;
        _177 = const _;
        _115 = (_178, _177);
        _116 = (_115.0: &usize);
        _117 = (_115.1: &usize);
        _120 = (*_116);
        _121 = (*_117);
        _119 = Eq(move _120, move _121);
        _118 = Not(move _119);
        switchInt(move _118) -> [0: bb41, otherwise: bb40];
    }

    bb38: {
        _108 = Not(move _109);
        switchInt(move _108) -> [0: bb34, otherwise: bb39];
    }

    bb39: {
        _110 = core::panicking::AssertKind::Eq;
        _112 = Option::<Arguments<'_>>::None;
        _111 = core::panicking::assert_failed::<Foo2, Foo2>(move _110, _106, _107, move _112) -> unwind continue;
    }

    bb40: {
        _122 = core::panicking::AssertKind::Eq;
        _124 = Option::<Arguments<'_>>::None;
        _123 = core::panicking::assert_failed::<usize, usize>(move _122, _116, _117, move _124) -> unwind continue;
    }

    bb41: {
        _176 = const _;
        _175 = const _;
        _125 = (_176, _175);
        _126 = (_125.0: &usize);
        _127 = (_125.1: &usize);
        _130 = (*_126);
        _131 = (*_127);
        _129 = Eq(move _130, move _131);
        _128 = Not(move _129);
        switchInt(move _128) -> [0: bb43, otherwise: bb42];
    }

    bb42: {
        _132 = core::panicking::AssertKind::Eq;
        _134 = Option::<Arguments<'_>>::None;
        _133 = core::panicking::assert_failed::<usize, usize>(move _132, _126, _127, move _134) -> unwind continue;
    }

    bb43: {
        _136 = std::ops::Range::<usize> { start: const 0_usize, end: const 10_usize };
        _135 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _136) -> [return: bb44, unwind continue];
    }

    bb44: {
        _137 = move _135;
        goto -> bb45;
    }

    bb45: {
        _139 = &mut _137;
        _138 = <std::ops::Range<usize> as Iterator>::next(_139) -> [return: bb46, unwind continue];
    }

    bb46: {
        _140 = discriminant(_138);
        switchInt(move _140) -> [0: bb48, 1: bb47, otherwise: bb9];
    }

    bb47: {
        _141 = ((_138 as Some).0: usize);
        _144 = const 10_usize;
        _145 = Lt(_141, _144);
        assert(move _145, "index out of bounds: the length is {} but the index is {}", move _144, _141) -> [success: bb49, unwind continue];
    }

    bb48: {
        _154 = &_113;
        _153 = <&[Foo4C; 10] as IntoIterator>::into_iter(move _154) -> [return: bb52, unwind continue];
    }

    bb49: {
        _143 = &_113[_141];
        _173 = const _;
        _142 = (move _143, _173);
        _146 = (_142.0: &Foo4C);
        _147 = (_142.1: &Foo4C);
        _149 = <Foo4C as PartialEq>::eq(_146, _147) -> [return: bb50, unwind continue];
    }

    bb50: {
        _148 = Not(move _149);
        switchInt(move _148) -> [0: bb45, otherwise: bb51];
    }

    bb51: {
        _150 = core::panicking::AssertKind::Eq;
        _152 = Option::<Arguments<'_>>::None;
        _151 = core::panicking::assert_failed::<Foo4C, Foo4C>(move _150, _146, _147, move _152) -> unwind continue;
    }

    bb52: {
        _155 = move _153;
        goto -> bb53;
    }

    bb53: {
        _157 = &mut _155;
        _156 = <std::slice::Iter<'_, Foo4C> as Iterator>::next(_157) -> [return: bb54, unwind continue];
    }

    bb54: {
        _158 = discriminant(_156);
        switchInt(move _158) -> [0: bb56, 1: bb55, otherwise: bb9];
    }

    bb55: {
        _189 = deref_copy ((_156 as Some).0: &Foo4C);
        _159 = (*_189);
        _161 = &_159;
        _174 = const _;
        _160 = (move _161, _174);
        _162 = (_160.0: &Foo4C);
        _163 = (_160.1: &Foo4C);
        _165 = <Foo4C as PartialEq>::eq(_162, _163) -> [return: bb57, unwind continue];
    }

    bb56: {
        return;
    }

    bb57: {
        _164 = Not(move _165);
        switchInt(move _164) -> [0: bb53, otherwise: bb58];
    }

    bb58: {
        _166 = core::panicking::AssertKind::Eq;
        _168 = Option::<Arguments<'_>>::None;
        _167 = core::panicking::assert_failed::<Foo4C, Foo4C>(move _166, _162, _163, move _168) -> unwind continue;
    }
}

promoted[0] in main: &Foo1 = {
    let mut _0: &Foo1;
    let mut _1: Foo1;

    bb0: {
        _1 = Foo1 { bar: const 1_u8, baz: const 2_u64 };
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &Foo1 = {
    let mut _0: &Foo1;
    let mut _1: Foo1;

    bb0: {
        _1 = Foo1 { bar: const 1_u8, baz: const 2_u64 };
        _0 = &_1;
        return;
    }
}

promoted[2] in main: &Foo2 = {
    let mut _0: &Foo2;
    let mut _1: Foo2;

    bb0: {
        _1 = Foo2 { bar: const 1_u8, baz: const 2_u64 };
        _0 = &_1;
        return;
    }
}

promoted[3] in main: &Foo2 = {
    let mut _0: &Foo2;
    let mut _1: Foo2;

    bb0: {
        _1 = Foo2 { bar: const 1_u8, baz: const 2_u64 };
        _0 = &_1;
        return;
    }
}

promoted[4] in main: &Foo4C = {
    let mut _0: &Foo4C;
    let mut _1: Foo4C;

    bb0: {
        _1 = Foo4C { bar: const 1_u8, baz: const 2_u64 };
        _0 = &_1;
        return;
    }
}

promoted[5] in main: &Foo4C = {
    let mut _0: &Foo4C;
    let mut _1: Foo4C;

    bb0: {
        _1 = Foo4C { bar: const 1_u8, baz: const 2_u64 };
        _0 = &_1;
        return;
    }
}

promoted[6] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 120_usize;
        _0 = &_1;
        return;
    }
}

promoted[7] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = std::mem::size_of::<[Foo4C; 10]>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = &_1;
        return;
    }
}

promoted[8] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 4_usize;
        _0 = &_1;
        return;
    }
}

promoted[9] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = align_of::<[Foo4C; 10]>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = &_1;
        return;
    }
}

promoted[10] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 100_usize;
        _0 = &_1;
        return;
    }
}

promoted[11] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = std::mem::size_of::<[Foo2; 10]>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = &_1;
        return;
    }
}

promoted[12] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 2_usize;
        _0 = &_1;
        return;
    }
}

promoted[13] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = align_of::<[Foo2; 10]>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = &_1;
        return;
    }
}

promoted[14] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 90_usize;
        _0 = &_1;
        return;
    }
}

promoted[15] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = std::mem::size_of::<[Foo1; 10]>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = &_1;
        return;
    }
}

promoted[16] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 1_usize;
        _0 = &_1;
        return;
    }
}

promoted[17] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = align_of::<[Foo1; 10]>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = &_1;
        return;
    }
}

main::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 10_usize;
        return;
    }
}

main::{constant#3}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 10_usize;
        return;
    }
}

main::{constant#4}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 10_usize;
        return;
    }
}

main::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 10_usize;
        return;
    }
}

main::{constant#5}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 10_usize;
        return;
    }
}

main::{constant#6}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 10_usize;
        return;
    }
}

main::{constant#2}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 10_usize;
        return;
    }
}

main::{constant#7}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 10_usize;
        return;
    }
}

main::{constant#8}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 10_usize;
        return;
    }
}
