// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
Data::0::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/binding/match-larger-const.rs:3:22: 3:23

    bb0: {
        _0 = const 4_usize;              // scope 0 at ui/binding/match-larger-const.rs:3:22: 3:23
        return;                          // scope 0 at ui/binding/match-larger-const.rs:3:22: 3:23
    }
}

fn <impl at ui/binding/match-larger-const.rs:2:10: 2:12>::assert_receiver_is_total_eq(_1: &Data) -> () {
    debug self => _1;                    // in scope 0 at ui/binding/match-larger-const.rs:2:10: 2:12
    let mut _0: ();                      // return place in scope 0 at ui/binding/match-larger-const.rs:2:10: 2:12
    scope 1 {
    }

    bb0: {
        return;                          // scope 0 at ui/binding/match-larger-const.rs:2:12: 2:12
    }
}

<impl at ui/binding/match-larger-const.rs:2:10: 2:12>::assert_receiver_is_total_eq::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/binding/match-larger-const.rs:3:22: 3:23

    bb0: {
        _0 = const 4_usize;              // scope 0 at ui/binding/match-larger-const.rs:3:22: 3:23
        return;                          // scope 0 at ui/binding/match-larger-const.rs:3:22: 3:23
    }
}

fn <impl at ui/binding/match-larger-const.rs:2:14: 2:23>::eq(_1: &Data, _2: &Data) -> bool {
    debug self => _1;                    // in scope 0 at ui/binding/match-larger-const.rs:2:14: 2:23
    debug other => _2;                   // in scope 0 at ui/binding/match-larger-const.rs:2:14: 2:23
    let mut _0: bool;                    // return place in scope 0 at ui/binding/match-larger-const.rs:2:14: 2:23
    let mut _3: &[u8; 4];                // in scope 0 at ui/binding/match-larger-const.rs:3:17: 3:24
    let mut _4: &[u8; 4];                // in scope 0 at ui/binding/match-larger-const.rs:3:17: 3:24

    bb0: {
        _3 = &((*_1).0: [u8; 4]);        // scope 0 at ui/binding/match-larger-const.rs:3:17: 3:24
        _4 = &((*_2).0: [u8; 4]);        // scope 0 at ui/binding/match-larger-const.rs:3:17: 3:24
        _0 = <[u8; 4] as PartialEq>::eq(move _3, move _4) -> bb1; // scope 0 at ui/binding/match-larger-const.rs:3:17: 3:24
                                         // mir::Constant
                                         // + span: ui/binding/match-larger-const.rs:3:17: 3:24
                                         // + literal: Const { ty: for<'a, 'b> fn(&'a [u8; 4], &'b [u8; 4]) -> bool {<[u8; 4] as PartialEq>::eq}, val: Value(<ZST>) }
    }

    bb1: {
        return;                          // scope 0 at ui/binding/match-larger-const.rs:2:23: 2:23
    }
}

const DATA: Data = {
    let mut _0: Data;                    // return place in scope 0 at ui/binding/match-larger-const.rs:5:13: 5:17
    let mut _1: [u8; 4];                 // in scope 0 at ui/binding/match-larger-const.rs:5:25: 5:37

    bb0: {
        StorageLive(_1);                 // scope 0 at ui/binding/match-larger-const.rs:5:25: 5:37
        _1 = [const 1_u8, const 2_u8, const 3_u8, const 4_u8]; // scope 0 at ui/binding/match-larger-const.rs:5:25: 5:37
        _0 = Data(move _1);              // scope 0 at ui/binding/match-larger-const.rs:5:20: 5:38
        StorageDead(_1);                 // scope 0 at ui/binding/match-larger-const.rs:5:37: 5:38
        return;                          // scope 0 at ui/binding/match-larger-const.rs:5:1: 5:39
    }
}

fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/binding/match-larger-const.rs:7:11: 7:11

    bb0: {
        return;                          // scope 0 at ui/binding/match-larger-const.rs:12:2: 12:2
    }
}

fn Data(_1: [u8; 4]) -> Data {
    let mut _0: Data;                    // return place in scope 0 at ui/binding/match-larger-const.rs:3:1: 3:16

    bb0: {
        _0 = Data(move _1);              // scope 0 at ui/binding/match-larger-const.rs:3:1: 3:16
        return;                          // scope 0 at ui/binding/match-larger-const.rs:3:1: 3:16
    }
}

// MIR FOR CTFE
fn Data(_1: [u8; 4]) -> Data {
    let mut _0: Data;                    // return place in scope 0 at ui/binding/match-larger-const.rs:3:1: 3:16

    bb0: {
        _0 = Data(move _1);              // scope 0 at ui/binding/match-larger-const.rs:3:1: 3:16
        return;                          // scope 0 at ui/binding/match-larger-const.rs:3:1: 3:16
    }
}
