// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn test_basic() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/binding/expr-match.rs:8:17: 8:17
    let mut _1: bool;                    // in scope 0 at ui/binding/expr-match.rs:9:9: 9:15
    let mut _2: bool;                    // in scope 0 at ui/binding/expr-match.rs:10:5: 10:18
    let mut _3: bool;                    // in scope 0 at ui/binding/expr-match.rs:10:13: 10:17
    let mut _4: !;                       // in scope 0 at ui/binding/expr-match.rs:10:5: 10:18
    let mut _5: bool;                    // in scope 0 at ui/binding/expr-match.rs:11:10: 11:61
    let mut _6: bool;                    // in scope 0 at ui/binding/expr-match.rs:12:5: 12:18
    let mut _7: bool;                    // in scope 0 at ui/binding/expr-match.rs:12:13: 12:17
    let mut _8: !;                       // in scope 0 at ui/binding/expr-match.rs:12:5: 12:18
    scope 1 {
        debug rs => _1;                  // in scope 1 at ui/binding/expr-match.rs:9:9: 9:15
    }

    bb0: {
        _1 = const true;                 // scope 0 at ui/binding/expr-match.rs:9:47: 9:51
        _3 = _1;                         // scope 1 at ui/binding/expr-match.rs:10:13: 10:17
        _2 = Not(move _3);               // scope 1 at ui/binding/expr-match.rs:10:5: 10:18
        switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 1 at ui/binding/expr-match.rs:10:5: 10:18
    }

    bb1: {
        _4 = core::panicking::panic(const "assertion failed: (rs)"); // scope 1 at ui/binding/expr-match.rs:10:5: 10:18
                                         // mir::Constant
                                         // + span: ui/binding/expr-match.rs:10:5: 10:18
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(<ZST>) }
                                         // mir::Constant
                                         // + span: no-location
                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }
    }

    bb2: {
        _5 = const true;                 // scope 1 at ui/binding/expr-match.rs:11:53: 11:57
        _1 = move _5;                    // scope 1 at ui/binding/expr-match.rs:11:5: 11:61
        _7 = _1;                         // scope 1 at ui/binding/expr-match.rs:12:13: 12:17
        _6 = Not(move _7);               // scope 1 at ui/binding/expr-match.rs:12:5: 12:18
        switchInt(move _6) -> [0: bb4, otherwise: bb3]; // scope 1 at ui/binding/expr-match.rs:12:5: 12:18
    }

    bb3: {
        _8 = core::panicking::panic(const "assertion failed: (rs)"); // scope 1 at ui/binding/expr-match.rs:12:5: 12:18
                                         // mir::Constant
                                         // + span: ui/binding/expr-match.rs:12:5: 12:18
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(<ZST>) }
                                         // mir::Constant
                                         // + span: no-location
                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }
    }

    bb4: {
        return;                          // scope 0 at ui/binding/expr-match.rs:13:2: 13:2
    }
}

fn test_inferrence() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/binding/expr-match.rs:15:22: 15:22
    let _1: bool;                        // in scope 0 at ui/binding/expr-match.rs:16:9: 16:11
    let mut _2: bool;                    // in scope 0 at ui/binding/expr-match.rs:17:5: 17:18
    let mut _3: bool;                    // in scope 0 at ui/binding/expr-match.rs:17:13: 17:17
    let mut _4: !;                       // in scope 0 at ui/binding/expr-match.rs:17:5: 17:18
    scope 1 {
        debug rs => _1;                  // in scope 1 at ui/binding/expr-match.rs:16:9: 16:11
    }

    bb0: {
        _1 = const true;                 // scope 0 at ui/binding/expr-match.rs:16:37: 16:41
        _3 = _1;                         // scope 1 at ui/binding/expr-match.rs:17:13: 17:17
        _2 = Not(move _3);               // scope 1 at ui/binding/expr-match.rs:17:5: 17:18
        switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 1 at ui/binding/expr-match.rs:17:5: 17:18
    }

    bb1: {
        _4 = core::panicking::panic(const "assertion failed: (rs)"); // scope 1 at ui/binding/expr-match.rs:17:5: 17:18
                                         // mir::Constant
                                         // + span: ui/binding/expr-match.rs:17:5: 17:18
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(<ZST>) }
                                         // mir::Constant
                                         // + span: no-location
                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }
    }

    bb2: {
        return;                          // scope 0 at ui/binding/expr-match.rs:18:2: 18:2
    }
}

fn test_alt_as_alt_head() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/binding/expr-match.rs:20:27: 20:27
    let _1: bool;                        // in scope 0 at ui/binding/expr-match.rs:23:9: 23:11
    let mut _2: bool;                    // in scope 0 at ui/binding/expr-match.rs:24:15: 24:66
    let mut _3: bool;                    // in scope 0 at ui/binding/expr-match.rs:28:5: 28:18
    let mut _4: bool;                    // in scope 0 at ui/binding/expr-match.rs:28:13: 28:17
    let mut _5: !;                       // in scope 0 at ui/binding/expr-match.rs:28:5: 28:18
    scope 1 {
        debug rs => _1;                  // in scope 1 at ui/binding/expr-match.rs:23:9: 23:11
    }

    bb0: {
        _2 = const false;                // scope 0 at ui/binding/expr-match.rs:24:57: 24:62
        switchInt(_2) -> [0: bb1, otherwise: bb2]; // scope 0 at ui/binding/expr-match.rs:24:9: 24:66
    }

    bb1: {
        _1 = const true;                 // scope 0 at ui/binding/expr-match.rs:26:22: 26:26
        goto -> bb3;                     // scope 0 at ui/binding/expr-match.rs:26:22: 26:26
    }

    bb2: {
        _1 = const false;                // scope 0 at ui/binding/expr-match.rs:25:21: 25:26
        goto -> bb3;                     // scope 0 at ui/binding/expr-match.rs:25:21: 25:26
    }

    bb3: {
        _4 = _1;                         // scope 1 at ui/binding/expr-match.rs:28:13: 28:17
        _3 = Not(move _4);               // scope 1 at ui/binding/expr-match.rs:28:5: 28:18
        switchInt(move _3) -> [0: bb5, otherwise: bb4]; // scope 1 at ui/binding/expr-match.rs:28:5: 28:18
    }

    bb4: {
        _5 = core::panicking::panic(const "assertion failed: (rs)"); // scope 1 at ui/binding/expr-match.rs:28:5: 28:18
                                         // mir::Constant
                                         // + span: ui/binding/expr-match.rs:28:5: 28:18
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(<ZST>) }
                                         // mir::Constant
                                         // + span: no-location
                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }
    }

    bb5: {
        return;                          // scope 0 at ui/binding/expr-match.rs:29:2: 29:2
    }
}

fn test_alt_as_block_result() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/binding/expr-match.rs:31:31: 31:31
    let _1: bool;                        // in scope 0 at ui/binding/expr-match.rs:32:9: 32:11
    let mut _2: bool;                    // in scope 0 at ui/binding/expr-match.rs:37:5: 37:18
    let mut _3: bool;                    // in scope 0 at ui/binding/expr-match.rs:37:13: 37:17
    let mut _4: !;                       // in scope 0 at ui/binding/expr-match.rs:37:5: 37:18
    scope 1 {
        debug rs => _1;                  // in scope 1 at ui/binding/expr-match.rs:32:9: 32:11
    }

    bb0: {
        _1 = const true;                 // scope 0 at ui/binding/expr-match.rs:35:45: 35:49
        _3 = _1;                         // scope 1 at ui/binding/expr-match.rs:37:13: 37:17
        _2 = Not(move _3);               // scope 1 at ui/binding/expr-match.rs:37:5: 37:18
        switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 1 at ui/binding/expr-match.rs:37:5: 37:18
    }

    bb1: {
        _4 = core::panicking::panic(const "assertion failed: (rs)"); // scope 1 at ui/binding/expr-match.rs:37:5: 37:18
                                         // mir::Constant
                                         // + span: ui/binding/expr-match.rs:37:5: 37:18
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(<ZST>) }
                                         // mir::Constant
                                         // + span: no-location
                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }
    }

    bb2: {
        return;                          // scope 0 at ui/binding/expr-match.rs:38:2: 38:2
    }
}

fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/binding/expr-match.rs:40:15: 40:15
    let _1: ();                          // in scope 0 at ui/binding/expr-match.rs:41:5: 41:17
    let _2: ();                          // in scope 0 at ui/binding/expr-match.rs:42:5: 42:22
    let _3: ();                          // in scope 0 at ui/binding/expr-match.rs:43:5: 43:27
    let _4: ();                          // in scope 0 at ui/binding/expr-match.rs:44:5: 44:31

    bb0: {
        _1 = test_basic() -> bb1;        // scope 0 at ui/binding/expr-match.rs:41:5: 41:17
                                         // mir::Constant
                                         // + span: ui/binding/expr-match.rs:41:5: 41:15
                                         // + literal: Const { ty: fn() {test_basic}, val: Value(<ZST>) }
    }

    bb1: {
        _2 = test_inferrence() -> bb2;   // scope 0 at ui/binding/expr-match.rs:42:5: 42:22
                                         // mir::Constant
                                         // + span: ui/binding/expr-match.rs:42:5: 42:20
                                         // + literal: Const { ty: fn() {test_inferrence}, val: Value(<ZST>) }
    }

    bb2: {
        _3 = test_alt_as_alt_head() -> bb3; // scope 0 at ui/binding/expr-match.rs:43:5: 43:27
                                         // mir::Constant
                                         // + span: ui/binding/expr-match.rs:43:5: 43:25
                                         // + literal: Const { ty: fn() {test_alt_as_alt_head}, val: Value(<ZST>) }
    }

    bb3: {
        _4 = test_alt_as_block_result() -> bb4; // scope 0 at ui/binding/expr-match.rs:44:5: 44:31
                                         // mir::Constant
                                         // + span: ui/binding/expr-match.rs:44:5: 44:29
                                         // + literal: Const { ty: fn() {test_alt_as_block_result}, val: Value(<ZST>) }
    }

    bb4: {
        return;                          // scope 0 at ui/binding/expr-match.rs:45:2: 45:2
    }
}
