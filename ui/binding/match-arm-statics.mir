// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/binding/match-arm-statics.rs:6:10: 6:19>::eq(_1: &NewBool, _2: &NewBool) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: bool;

    bb0: {
        _3 = ((*_1).0: bool);
        _4 = ((*_2).0: bool);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn <impl at ui/binding/match-arm-statics.rs:6:21: 6:23>::assert_receiver_is_total_eq(_1: &NewBool) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn <impl at ui/binding/match-arm-statics.rs:9:10: 9:19>::eq(_1: &Direction, _2: &Direction) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn <impl at ui/binding/match-arm-statics.rs:9:21: 9:23>::assert_receiver_is_total_eq(_1: &Direction) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn <impl at ui/binding/match-arm-statics.rs:17:10: 17:19>::eq(_1: &Foo, _2: &Foo) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &std::option::Option<Direction>;
    let mut _5: &std::option::Option<Direction>;
    let mut _6: bool;
    let mut _7: &NewBool;
    let mut _8: &NewBool;

    bb0: {
        _4 = &((*_1).0: std::option::Option<Direction>);
        _5 = &((*_2).0: std::option::Option<Direction>);
        _3 = <Option<Direction> as PartialEq>::eq(move _4, move _5) -> [return: bb4, unwind continue];
    }

    bb1: {
        _0 = const false;
        goto -> bb3;
    }

    bb2: {
        _7 = &((*_1).1: NewBool);
        _8 = &((*_2).1: NewBool);
        _6 = <NewBool as PartialEq>::eq(move _7, move _8) -> [return: bb5, unwind continue];
    }

    bb3: {
        return;
    }

    bb4: {
        switchInt(move _3) -> [0: bb1, otherwise: bb2];
    }

    bb5: {
        _0 = move _6;
        goto -> bb3;
    }
}

fn <impl at ui/binding/match-arm-statics.rs:17:21: 17:23>::assert_receiver_is_total_eq(_1: &Foo) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        return;
    }
}

fn <impl at ui/binding/match-arm-statics.rs:23:10: 23:19>::eq(_1: &EnumWithStructVariants, _2: &EnumWithStructVariants) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: (&EnumWithStructVariants, &EnumWithStructVariants);
    let mut _8: isize;
    let mut _9: isize;
    let mut _10: isize;
    let mut _13: bool;
    let mut _14: bool;
    let mut _17: &EnumWithStructVariants;
    let mut _18: &EnumWithStructVariants;
    let mut _19: &EnumWithStructVariants;
    let mut _20: &EnumWithStructVariants;
    let mut _21: &EnumWithStructVariants;
    let mut _22: &EnumWithStructVariants;
    let mut _23: &EnumWithStructVariants;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
            let _11: &bool;
            let _12: &bool;
            let _15: &Direction;
            let _16: &Direction;
            scope 3 {
                debug __self_0 => _11;
                debug __arg1_0 => _12;
            }
            scope 4 {
                debug __self_0 => _15;
                debug __arg1_0 => _16;
            }
            scope 5 {
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = Eq(_3, _4);
        switchInt(move _5) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const false;
        goto -> bb3;
    }

    bb2: {
        _7 = (_1, _2);
        _17 = deref_copy (_7.0: &EnumWithStructVariants);
        _10 = discriminant((*_17));
        switchInt(move _10) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb3: {
        return;
    }

    bb4: {
        _18 = deref_copy (_7.1: &EnumWithStructVariants);
        _8 = discriminant((*_18));
        switchInt(move _8) -> [0: bb7, otherwise: bb5];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _19 = deref_copy (_7.1: &EnumWithStructVariants);
        _9 = discriminant((*_19));
        switchInt(move _9) -> [1: bb8, otherwise: bb5];
    }

    bb7: {
        _20 = deref_copy (_7.0: &EnumWithStructVariants);
        _11 = &(((*_20) as Variant1).0: bool);
        _21 = deref_copy (_7.1: &EnumWithStructVariants);
        _12 = &(((*_21) as Variant1).0: bool);
        _13 = (*_11);
        _14 = (*_12);
        _6 = Eq(move _13, move _14);
        goto -> bb9;
    }

    bb8: {
        _22 = deref_copy (_7.0: &EnumWithStructVariants);
        _15 = &(((*_22) as Variant2).0: Direction);
        _23 = deref_copy (_7.1: &EnumWithStructVariants);
        _16 = &(((*_23) as Variant2).0: Direction);
        _6 = <Direction as PartialEq>::eq(_15, _16) -> [return: bb9, unwind continue];
    }

    bb9: {
        _0 = move _6;
        goto -> bb3;
    }
}

fn <impl at ui/binding/match-arm-statics.rs:23:21: 23:23>::assert_receiver_is_total_eq(_1: &EnumWithStructVariants) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        return;
    }
}

const TRUE_TRUE: (bool, bool) = {
    let mut _0: (bool, bool);

    bb0: {
        _0 = (const true, const true);
        return;
    }
}

const NONE: Option<Direction> = {
    let mut _0: std::option::Option<Direction>;

    bb0: {
        _0 = Option::<Direction>::None;
        return;
    }
}

const EAST: Direction = {
    let mut _0: Direction;

    bb0: {
        _0 = Direction::East;
        return;
    }
}

const NEW_FALSE: NewBool = {
    let mut _0: NewBool;

    bb0: {
        _0 = NewBool(const false);
        return;
    }
}

const STATIC_FOO: Foo = {
    let mut _0: Foo;
    let mut _1: std::option::Option<Direction>;
    let mut _2: Direction;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _2 = Direction::South;
        _1 = Option::<Direction>::Some(move _2);
        StorageDead(_2);
        _0 = Foo { bar: move _1, baz: const _ };
        StorageDead(_1);
        return;
    }
}

const VARIANT2_NORTH: EnumWithStructVariants = {
    let mut _0: EnumWithStructVariants;
    let mut _1: Direction;

    bb0: {
        StorageLive(_1);
        _1 = Direction::North;
        _0 = EnumWithStructVariants::Variant2 { dir: move _1 };
        StorageDead(_1);
        return;
    }
}

fn glfw::<impl at ui/binding/match-arm-statics.rs:40:20: 40:25>::clone(_1: &InputState) -> InputState {
    debug self => _1;
    let mut _0: glfw::InputState;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn glfw::<impl at ui/binding/match-arm-statics.rs:40:27: 40:36>::eq(_1: &InputState, _2: &InputState) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: usize;
    let mut _4: usize;

    bb0: {
        _3 = ((*_1).0: usize);
        _4 = ((*_2).0: usize);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn glfw::<impl at ui/binding/match-arm-statics.rs:40:38: 40:40>::assert_receiver_is_total_eq(_1: &InputState) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

const RELEASE: InputState = {
    let mut _0: glfw::InputState;

    bb0: {
        _0 = InputState(const 0_usize);
        return;
    }
}

const PRESS: InputState = {
    let mut _0: glfw::InputState;

    bb0: {
        _0 = InputState(const 1_usize);
        return;
    }
}

const REPEAT: InputState = {
    let mut _0: glfw::InputState;

    bb0: {
        _0 = InputState(const 2_usize);
        return;
    }
}

fn issue_6533() -> () {
    let mut _0: ();
    let mut _1: (&&str, &&str);
    let mut _2: &&str;
    let _3: &str;
    let _4: &&str;
    let _5: &&str;
    let mut _6: bool;
    let mut _7: bool;
    let _9: !;
    let mut _10: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _11: (&&str, &&str);
    let mut _12: &&str;
    let _13: &str;
    let _14: &&str;
    let _15: &&str;
    let mut _16: bool;
    let mut _17: bool;
    let _19: !;
    let mut _20: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _21: (&&str, &&str);
    let mut _22: &&str;
    let _23: &str;
    let _24: &&str;
    let _25: &&str;
    let mut _26: bool;
    let mut _27: bool;
    let _29: !;
    let mut _30: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _31: &&str;
    let mut _32: &&str;
    let mut _33: &&str;
    scope 1 {
        debug left_val => _4;
        debug right_val => _5;
        let _8: core::panicking::AssertKind;
        scope 2 {
            debug kind => _8;
        }
    }
    scope 3 {
        debug left_val => _14;
        debug right_val => _15;
        let _18: core::panicking::AssertKind;
        scope 4 {
            debug kind => _18;
        }
    }
    scope 5 {
        debug left_val => _24;
        debug right_val => _25;
        let _28: core::panicking::AssertKind;
        scope 6 {
            debug kind => _28;
        }
    }

    bb0: {
        _3 = action_to_str(const _) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = &_3;
        _33 = const _;
        _1 = (move _2, _33);
        _4 = (_1.0: &&str);
        _5 = (_1.1: &&str);
        _7 = <&str as PartialEq>::eq(_4, _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = Not(move _7);
        switchInt(move _6) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _8 = core::panicking::AssertKind::Eq;
        _10 = Option::<Arguments<'_>>::None;
        _9 = core::panicking::assert_failed::<&str, &str>(move _8, _4, _5, move _10) -> unwind continue;
    }

    bb4: {
        _13 = action_to_str(const _) -> [return: bb5, unwind continue];
    }

    bb5: {
        _12 = &_13;
        _32 = const _;
        _11 = (move _12, _32);
        _14 = (_11.0: &&str);
        _15 = (_11.1: &&str);
        _17 = <&str as PartialEq>::eq(_14, _15) -> [return: bb6, unwind continue];
    }

    bb6: {
        _16 = Not(move _17);
        switchInt(move _16) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _18 = core::panicking::AssertKind::Eq;
        _20 = Option::<Arguments<'_>>::None;
        _19 = core::panicking::assert_failed::<&str, &str>(move _18, _14, _15, move _20) -> unwind continue;
    }

    bb8: {
        _23 = action_to_str(const _) -> [return: bb9, unwind continue];
    }

    bb9: {
        _22 = &_23;
        _31 = const _;
        _21 = (move _22, _31);
        _24 = (_21.0: &&str);
        _25 = (_21.1: &&str);
        _27 = <&str as PartialEq>::eq(_24, _25) -> [return: bb10, unwind continue];
    }

    bb10: {
        _26 = Not(move _27);
        switchInt(move _26) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _28 = core::panicking::AssertKind::Eq;
        _30 = Option::<Arguments<'_>>::None;
        _29 = core::panicking::assert_failed::<&str, &str>(move _28, _24, _25, move _30) -> unwind continue;
    }

    bb12: {
        return;
    }
}

promoted[0] in issue_6533: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "Repeated";
        _0 = &_1;
        return;
    }
}

promoted[1] in issue_6533: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "Pressed";
        _0 = &_1;
        return;
    }
}

promoted[2] in issue_6533: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "Released";
        _0 = &_1;
        return;
    }
}

fn action_to_str(_1: InputState) -> &str {
    debug state => _1;
    let mut _0: &str;

    bb0: {
        switchInt((_1.0: usize)) -> [0: bb2, 1: bb3, 2: bb4, otherwise: bb1];
    }

    bb1: {
        _0 = const "Unknown";
        goto -> bb5;
    }

    bb2: {
        _0 = const "Released";
        goto -> bb5;
    }

    bb3: {
        _0 = const "Pressed";
        goto -> bb5;
    }

    bb4: {
        _0 = const "Repeated";
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn issue_13626() -> () {
    let mut _0: ();
    let mut _1: [u8; 1];
    let mut _2: !;

    bb0: {
        _1 = [const 1_u8];
        switchInt(_1[0 of 1]) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        return;
    }

    bb2: {
        _2 = core::panicking::panic(const "internal error: entered unreachable code") -> unwind continue;
    }
}

const VAL: [u8; 1] = {
    let mut _0: [u8; 1];

    bb0: {
        _0 = [const 0_u8];
        return;
    }
}

VAL::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn issue_14576() -> () {
    let mut _0: ();
    let mut _1: (i32, i32);
    let mut _2: !;
    let mut _3: !;
    let mut _4: (&i32, &i32);
    let mut _5: &i32;
    let _6: i32;
    let mut _7: issue_14576::C;
    let mut _8: isize;
    let _9: &i32;
    let _10: &i32;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: i32;
    let mut _14: i32;
    let _16: !;
    let mut _17: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _18: (&i32, &i32);
    let mut _19: &i32;
    let _20: i32;
    let mut _21: issue_14576::G;
    let mut _22: isize;
    let _23: &i32;
    let _24: &i32;
    let mut _25: bool;
    let mut _26: bool;
    let mut _27: i32;
    let mut _28: i32;
    let _30: !;
    let mut _31: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _32: &i32;
    let mut _33: &i32;
    scope 1 {
        debug left_val => _9;
        debug right_val => _10;
        let _15: core::panicking::AssertKind;
        scope 2 {
            debug kind => _15;
        }
    }
    scope 3 {
        debug left_val => _23;
        debug right_val => _24;
        let _29: core::panicking::AssertKind;
        scope 4 {
            debug kind => _29;
        }
    }

    bb0: {
        _1 = (const 1_i32, const 1_i32);
        switchInt((_1.0: i32)) -> [0: bb1, 1: bb3, otherwise: bb2];
    }

    bb1: {
        switchInt((_1.1: i32)) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _3 = core::panicking::panic(const "internal error: entered unreachable code") -> unwind continue;
    }

    bb3: {
        switchInt((_1.1: i32)) -> [1: bb5, otherwise: bb2];
    }

    bb4: {
        _2 = core::panicking::panic(const "internal error: entered unreachable code") -> unwind continue;
    }

    bb5: {
        _7 = C::D;
        _8 = discriminant(_7);
        switchInt(move _8) -> [3: bb7, otherwise: bb6];
    }

    bb6: {
        _6 = const 2_i32;
        goto -> bb8;
    }

    bb7: {
        _6 = const 1_i32;
        goto -> bb8;
    }

    bb8: {
        _5 = &_6;
        _33 = const _;
        _4 = (move _5, _33);
        _9 = (_4.0: &i32);
        _10 = (_4.1: &i32);
        _13 = (*_9);
        _14 = (*_10);
        _12 = Eq(move _13, move _14);
        _11 = Not(move _12);
        switchInt(move _11) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _15 = core::panicking::AssertKind::Eq;
        _17 = Option::<Arguments<'_>>::None;
        _16 = core::panicking::assert_failed::<i32, i32>(move _15, _9, _10, move _17) -> unwind continue;
    }

    bb10: {
        _21 = G::I;
        _22 = discriminant(_21);
        switchInt(move _22) -> [5: bb12, otherwise: bb11];
    }

    bb11: {
        _20 = const 2_i32;
        goto -> bb13;
    }

    bb12: {
        _20 = const 1_i32;
        goto -> bb13;
    }

    bb13: {
        _19 = &_20;
        _32 = const _;
        _18 = (move _19, _32);
        _23 = (_18.0: &i32);
        _24 = (_18.1: &i32);
        _27 = (*_23);
        _28 = (*_24);
        _26 = Eq(move _27, move _28);
        _25 = Not(move _26);
        switchInt(move _25) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _29 = core::panicking::AssertKind::Eq;
        _31 = Option::<Arguments<'_>>::None;
        _30 = core::panicking::assert_failed::<i32, i32>(move _29, _23, _24, move _31) -> unwind continue;
    }

    bb15: {
        return;
    }
}

promoted[0] in issue_14576: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 1_i32;
        _0 = &_1;
        return;
    }
}

promoted[1] in issue_14576: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 1_i32;
        _0 = &_1;
        return;
    }
}

const ON: (i32, i32) = {
    let mut _0: (i32, i32);

    bb0: {
        _0 = (const 1_i32, const 1_i32);
        return;
    }
}

const OFF: (i32, i32) = {
    let mut _0: (i32, i32);

    bb0: {
        _0 = (const 0_i32, const 0_i32);
        return;
    }
}

C::D::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const 3_isize;
        return;
    }
}

C::E::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const 4_isize;
        return;
    }
}

fn issue_14576::<impl at ui/binding/match-arm-statics.rs:83:14: 83:23>::eq(_1: &C, _2: &C) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn issue_14576::<impl at ui/binding/match-arm-statics.rs:83:25: 83:27>::assert_receiver_is_total_eq(_1: &C) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

const F: C = {
    let mut _0: issue_14576::C;

    bb0: {
        _0 = C::D;
        return;
    }
}

G::H::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const 3_isize;
        return;
    }
}

G::I::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const 5_isize;
        return;
    }
}

fn issue_14576::<impl at ui/binding/match-arm-statics.rs:90:14: 90:23>::eq(_1: &G, _2: &G) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn issue_14576::<impl at ui/binding/match-arm-statics.rs:90:25: 90:27>::assert_receiver_is_total_eq(_1: &G) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

const K: G = {
    let mut _0: issue_14576::G;

    bb0: {
        _0 = G::I;
        return;
    }
}

fn issue_13731() -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}

fn issue_13731::<impl at ui/binding/match-arm-statics.rs:98:14: 98:23>::eq(_1: &A, _2: &A) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: (&issue_13731::A, &issue_13731::A);
    let _4: &();
    let _5: &();
    let mut _6: &issue_13731::A;
    let mut _7: &issue_13731::A;
    scope 1 {
        debug __self_0 => _4;
        debug __arg1_0 => _5;
    }

    bb0: {
        _3 = (_1, _2);
        _6 = deref_copy (_3.0: &issue_13731::A);
        _4 = &(((*_6) as AA).0: ());
        _7 = deref_copy (_3.1: &issue_13731::A);
        _5 = &(((*_7) as AA).0: ());
        _0 = <() as PartialEq>::eq(_4, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn issue_13731::<impl at ui/binding/match-arm-statics.rs:98:25: 98:27>::assert_receiver_is_total_eq(_1: &A) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

const B: A = {
    let mut _0: issue_13731::A;
    let mut _1: ();

    bb0: {
        StorageLive(_1);
        _1 = ();
        _0 = A::AA(move _1);
        StorageDead(_1);
        return;
    }
}

fn issue_15393() -> () {
    let mut _0: ();
    let mut _1: issue_15393::Flags;
    let mut _2: !;
    let mut _3: !;

    bb0: {
        _1 = Flags { bits: const 2_usize };
        switchInt((_1.0: usize)) -> [1: bb2, 2: bb3, otherwise: bb1];
    }

    bb1: {
        _3 = core::panicking::panic(const "internal error: entered unreachable code") -> unwind continue;
    }

    bb2: {
        _2 = core::panicking::panic(const "internal error: entered unreachable code") -> unwind continue;
    }

    bb3: {
        return;
    }
}

fn issue_15393::<impl at ui/binding/match-arm-statics.rs:109:14: 109:23>::eq(_1: &Flags, _2: &Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: usize;
    let mut _4: usize;

    bb0: {
        _3 = ((*_1).0: usize);
        _4 = ((*_2).0: usize);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn issue_15393::<impl at ui/binding/match-arm-statics.rs:109:25: 109:27>::assert_receiver_is_total_eq(_1: &Flags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

const FOO: Flags = {
    let mut _0: issue_15393::Flags;

    bb0: {
        _0 = Flags { bits: const 1_usize };
        return;
    }
}

const BAR: Flags = {
    let mut _0: issue_15393::Flags;

    bb0: {
        _0 = Flags { bits: const 2_usize };
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let mut _1: (&i32, &i32);
    let mut _2: &i32;
    let _3: i32;
    let mut _4: (bool, bool);
    let _5: &i32;
    let _6: &i32;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: i32;
    let mut _10: i32;
    let _12: !;
    let mut _13: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _14: (&i32, &i32);
    let mut _15: &i32;
    let _16: i32;
    let mut _17: std::option::Option<std::option::Option<Direction>>;
    let mut _18: std::option::Option<Direction>;
    let mut _19: Direction;
    let mut _20: isize;
    let mut _21: isize;
    let mut _22: isize;
    let _23: &i32;
    let _24: &i32;
    let mut _25: bool;
    let mut _26: bool;
    let mut _27: i32;
    let mut _28: i32;
    let _30: !;
    let mut _31: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _32: (&i32, &i32);
    let mut _33: &i32;
    let _34: i32;
    let mut _35: Foo;
    let mut _36: std::option::Option<Direction>;
    let mut _37: Direction;
    let mut _38: NewBool;
    let mut _39: isize;
    let mut _40: isize;
    let mut _41: isize;
    let mut _42: isize;
    let mut _43: isize;
    let mut _44: isize;
    let _45: &i32;
    let _46: &i32;
    let mut _47: bool;
    let mut _48: bool;
    let mut _49: i32;
    let mut _50: i32;
    let _52: !;
    let mut _53: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _54: (&i32, &i32);
    let mut _55: &i32;
    let _56: i32;
    let mut _57: EnumWithStructVariants;
    let mut _58: Direction;
    let mut _59: isize;
    let mut _60: isize;
    let _61: &i32;
    let _62: &i32;
    let mut _63: bool;
    let mut _64: bool;
    let mut _65: i32;
    let mut _66: i32;
    let _68: !;
    let mut _69: std::option::Option<std::fmt::Arguments<'_>>;
    let _70: ();
    let _71: ();
    let _72: ();
    let _73: ();
    let _74: ();
    let mut _75: &i32;
    let mut _76: &i32;
    let mut _77: &i32;
    let mut _78: &i32;
    scope 1 {
        debug left_val => _5;
        debug right_val => _6;
        let _11: core::panicking::AssertKind;
        scope 2 {
            debug kind => _11;
        }
    }
    scope 3 {
        debug left_val => _23;
        debug right_val => _24;
        let _29: core::panicking::AssertKind;
        scope 4 {
            debug kind => _29;
        }
    }
    scope 5 {
        debug left_val => _45;
        debug right_val => _46;
        let _51: core::panicking::AssertKind;
        scope 6 {
            debug kind => _51;
        }
    }
    scope 7 {
        debug left_val => _61;
        debug right_val => _62;
        let _67: core::panicking::AssertKind;
        scope 8 {
            debug kind => _67;
        }
    }

    bb0: {
        _4 = (const true, const false);
        switchInt((_4.0: bool)) -> [0: bb3, otherwise: bb1];
    }

    bb1: {
        switchInt((_4.1: bool)) -> [0: bb2, otherwise: bb4];
    }

    bb2: {
        _3 = const 4_i32;
        goto -> bb7;
    }

    bb3: {
        switchInt((_4.1: bool)) -> [0: bb5, otherwise: bb6];
    }

    bb4: {
        _3 = const 1_i32;
        goto -> bb7;
    }

    bb5: {
        _3 = const 2_i32;
        goto -> bb7;
    }

    bb6: {
        _3 = const 3_i32;
        goto -> bb7;
    }

    bb7: {
        _2 = &_3;
        _78 = const _;
        _1 = (move _2, _78);
        _5 = (_1.0: &i32);
        _6 = (_1.1: &i32);
        _9 = (*_5);
        _10 = (*_6);
        _8 = Eq(move _9, move _10);
        _7 = Not(move _8);
        switchInt(move _7) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _11 = core::panicking::AssertKind::Eq;
        _13 = Option::<Arguments<'_>>::None;
        _12 = core::panicking::assert_failed::<i32, i32>(move _11, _5, _6, move _13) -> unwind continue;
    }

    bb9: {
        _19 = Direction::North;
        _18 = Option::<Direction>::Some(move _19);
        _17 = Option::<Option<Direction>>::Some(move _18);
        _22 = discriminant(_17);
        switchInt(move _22) -> [0: bb10, 1: bb11, otherwise: bb13];
    }

    bb10: {
        _16 = const 6_i32;
        goto -> bb19;
    }

    bb11: {
        _21 = discriminant(((_17 as Some).0: std::option::Option<Direction>));
        switchInt(move _21) -> [0: bb14, 1: bb12, otherwise: bb13];
    }

    bb12: {
        _20 = discriminant(((((_17 as Some).0: std::option::Option<Direction>) as Some).0: Direction));
        switchInt(move _20) -> [0: bb15, 1: bb16, 2: bb17, 3: bb18, otherwise: bb13];
    }

    bb13: {
        unreachable;
    }

    bb14: {
        _16 = const 1_i32;
        goto -> bb19;
    }

    bb15: {
        _16 = const 2_i32;
        goto -> bb19;
    }

    bb16: {
        _16 = const 3_i32;
        goto -> bb19;
    }

    bb17: {
        _16 = const 4_i32;
        goto -> bb19;
    }

    bb18: {
        _16 = const 5_i32;
        goto -> bb19;
    }

    bb19: {
        _15 = &_16;
        _77 = const _;
        _14 = (move _15, _77);
        _23 = (_14.0: &i32);
        _24 = (_14.1: &i32);
        _27 = (*_23);
        _28 = (*_24);
        _26 = Eq(move _27, move _28);
        _25 = Not(move _26);
        switchInt(move _25) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _29 = core::panicking::AssertKind::Eq;
        _31 = Option::<Arguments<'_>>::None;
        _30 = core::panicking::assert_failed::<i32, i32>(move _29, _23, _24, move _31) -> unwind continue;
    }

    bb21: {
        _37 = Direction::West;
        _36 = Option::<Direction>::Some(move _37);
        _38 = NewBool(const true);
        _35 = Foo { bar: move _36, baz: move _38 };
        _44 = discriminant((_35.0: std::option::Option<Direction>));
        switchInt(move _44) -> [0: bb22, 1: bb23, otherwise: bb13];
    }

    bb22: {
        switchInt(((_35.1: NewBool).0: bool)) -> [0: bb33, otherwise: bb32];
    }

    bb23: {
        switchInt(((_35.1: NewBool).0: bool)) -> [0: bb24, otherwise: bb25];
    }

    bb24: {
        _39 = discriminant((((_35.0: std::option::Option<Direction>) as Some).0: Direction));
        switchInt(move _39) -> [2: bb34, otherwise: bb25];
    }

    bb25: {
        switchInt(((_35.1: NewBool).0: bool)) -> [0: bb35, otherwise: bb26];
    }

    bb26: {
        _41 = discriminant((_35.0: std::option::Option<Direction>));
        switchInt(move _41) -> [1: bb28, otherwise: bb27];
    }

    bb27: {
        _43 = discriminant((_35.0: std::option::Option<Direction>));
        switchInt(move _43) -> [1: bb29, otherwise: bb13];
    }

    bb28: {
        _40 = discriminant((((_35.0: std::option::Option<Direction>) as Some).0: Direction));
        switchInt(move _40) -> [2: bb37, 3: bb36, otherwise: bb27];
    }

    bb29: {
        _42 = discriminant((((_35.0: std::option::Option<Direction>) as Some).0: Direction));
        switchInt(move _42) -> [0: bb30, 1: bb38, otherwise: bb13];
    }

    bb30: {
        switchInt(((_35.1: NewBool).0: bool)) -> [0: bb13, otherwise: bb31];
    }

    bb31: {
        _34 = const 8_i32;
        goto -> bb39;
    }

    bb32: {
        _34 = const 1_i32;
        goto -> bb39;
    }

    bb33: {
        _34 = const 2_i32;
        goto -> bb39;
    }

    bb34: {
        _34 = const 3_i32;
        goto -> bb39;
    }

    bb35: {
        _34 = const 4_i32;
        goto -> bb39;
    }

    bb36: {
        _34 = const 5_i32;
        goto -> bb39;
    }

    bb37: {
        _34 = const 6_i32;
        goto -> bb39;
    }

    bb38: {
        _34 = const 7_i32;
        goto -> bb39;
    }

    bb39: {
        _33 = &_34;
        _76 = const _;
        _32 = (move _33, _76);
        _45 = (_32.0: &i32);
        _46 = (_32.1: &i32);
        _49 = (*_45);
        _50 = (*_46);
        _48 = Eq(move _49, move _50);
        _47 = Not(move _48);
        switchInt(move _47) -> [0: bb41, otherwise: bb40];
    }

    bb40: {
        _51 = core::panicking::AssertKind::Eq;
        _53 = Option::<Arguments<'_>>::None;
        _52 = core::panicking::assert_failed::<i32, i32>(move _51, _45, _46, move _53) -> unwind continue;
    }

    bb41: {
        _58 = Direction::North;
        _57 = EnumWithStructVariants::Variant2 { dir: move _58 };
        _60 = discriminant(_57);
        switchInt(move _60) -> [0: bb42, 1: bb43, otherwise: bb13];
    }

    bb42: {
        switchInt(((_57 as Variant1).0: bool)) -> [0: bb46, otherwise: bb45];
    }

    bb43: {
        _59 = discriminant(((_57 as Variant2).0: Direction));
        switchInt(move _59) -> [0: bb48, 1: bb44, 2: bb49, 3: bb47, otherwise: bb13];
    }

    bb44: {
        _56 = const 6_i32;
        goto -> bb50;
    }

    bb45: {
        _56 = const 1_i32;
        goto -> bb50;
    }

    bb46: {
        _56 = const 2_i32;
        goto -> bb50;
    }

    bb47: {
        _56 = const 3_i32;
        goto -> bb50;
    }

    bb48: {
        _56 = const 4_i32;
        goto -> bb50;
    }

    bb49: {
        _56 = const 5_i32;
        goto -> bb50;
    }

    bb50: {
        _55 = &_56;
        _75 = const _;
        _54 = (move _55, _75);
        _61 = (_54.0: &i32);
        _62 = (_54.1: &i32);
        _65 = (*_61);
        _66 = (*_62);
        _64 = Eq(move _65, move _66);
        _63 = Not(move _64);
        switchInt(move _63) -> [0: bb52, otherwise: bb51];
    }

    bb51: {
        _67 = core::panicking::AssertKind::Eq;
        _69 = Option::<Arguments<'_>>::None;
        _68 = core::panicking::assert_failed::<i32, i32>(move _67, _61, _62, move _69) -> unwind continue;
    }

    bb52: {
        _70 = issue_6533() -> [return: bb53, unwind continue];
    }

    bb53: {
        _71 = issue_13626() -> [return: bb54, unwind continue];
    }

    bb54: {
        _72 = issue_13731() -> [return: bb55, unwind continue];
    }

    bb55: {
        _73 = issue_14576() -> [return: bb56, unwind continue];
    }

    bb56: {
        _74 = issue_15393() -> [return: bb57, unwind continue];
    }

    bb57: {
        return;
    }
}

promoted[0] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 4_i32;
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 5_i32;
        _0 = &_1;
        return;
    }
}

promoted[2] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 2_i32;
        _0 = &_1;
        return;
    }
}

promoted[3] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 4_i32;
        _0 = &_1;
        return;
    }
}

fn NewBool(_1: bool) -> NewBool {
    let mut _0: NewBool;

    bb0: {
        _0 = NewBool(move _1);
        return;
    }
}

// MIR FOR CTFE
fn NewBool(_1: bool) -> NewBool {
    let mut _0: NewBool;

    bb0: {
        _0 = NewBool(move _1);
        return;
    }
}

fn EnumWithStructVariants::Variant1(_1: bool) -> EnumWithStructVariants {
    let mut _0: EnumWithStructVariants;

    bb0: {
        _0 = EnumWithStructVariants::Variant1(move _1);
        return;
    }
}

// MIR FOR CTFE
fn EnumWithStructVariants::Variant1(_1: bool) -> EnumWithStructVariants {
    let mut _0: EnumWithStructVariants;

    bb0: {
        _0 = EnumWithStructVariants::Variant1(move _1);
        return;
    }
}

fn InputState(_1: usize) -> InputState {
    let mut _0: glfw::InputState;

    bb0: {
        _0 = InputState(move _1);
        return;
    }
}

// MIR FOR CTFE
fn InputState(_1: usize) -> InputState {
    let mut _0: glfw::InputState;

    bb0: {
        _0 = InputState(move _1);
        return;
    }
}

fn A::AA(_1: ()) -> A {
    let mut _0: issue_13731::A;

    bb0: {
        _0 = A::AA(move _1);
        return;
    }
}

// MIR FOR CTFE
fn A::AA(_1: ()) -> A {
    let mut _0: issue_13731::A;

    bb0: {
        _0 = A::AA(move _1);
        return;
    }
}
