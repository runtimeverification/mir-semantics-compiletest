// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();
    let mut _1: std::vec::Vec<i32>;
    let mut _2: std::boxed::Box<[i32]>;
    let mut _3: usize;
    let mut _4: usize;
    let mut _5: *mut u8;
    let mut _6: std::boxed::Box<[i32; 1]>;
    let mut _7: std::slice::Iter<'_, i32>;
    let mut _8: &std::vec::Vec<i32>;
    let mut _10: std::option::Option<&i32>;
    let mut _11: &mut std::slice::Iter<'_, i32>;
    let mut _12: isize;
    let mut _14: (&&i32, &&i32);
    let mut _15: &&i32;
    let mut _18: bool;
    let mut _19: bool;
    let _21: !;
    let mut _22: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _23: std::slice::IterMut<'_, i32>;
    let mut _24: &mut std::vec::Vec<i32>;
    let mut _26: std::option::Option<&mut i32>;
    let mut _27: &mut std::slice::IterMut<'_, i32>;
    let mut _28: isize;
    let mut _30: (&&mut i32, &&mut i32);
    let mut _31: &&mut i32;
    let mut _32: &&mut i32;
    let _33: &mut i32;
    let mut _34: i32;
    let mut _37: bool;
    let mut _38: bool;
    let _40: !;
    let mut _41: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _42: std::vec::IntoIter<i32>;
    let mut _43: std::vec::Vec<i32>;
    let mut _45: std::option::Option<i32>;
    let mut _46: &mut std::vec::IntoIter<i32>;
    let mut _47: isize;
    let mut _49: (&i32, &i32);
    let mut _50: &i32;
    let mut _53: bool;
    let mut _54: bool;
    let mut _55: i32;
    let mut _56: i32;
    let _58: !;
    let mut _59: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _62: bool;
    let mut _63: *const [i32; 1];
    let mut _64: *const ();
    let mut _65: usize;
    let mut _66: usize;
    let mut _67: usize;
    let mut _68: usize;
    let mut _69: bool;
    scope 1 {
        debug v => _1;
        let mut _9: std::slice::Iter<'_, i32>;
        let mut _25: std::slice::IterMut<'_, i32>;
        let mut _44: std::vec::IntoIter<i32>;
        scope 3 {
            debug iter => _9;
            let _13: &i32;
            scope 4 {
                debug x => _13;
                let _16: &&i32;
                let _17: &&i32;
                let mut _60: &&i32;
                scope 5 {
                    debug left_val => _16;
                    debug right_val => _17;
                    let _20: core::panicking::AssertKind;
                    scope 6 {
                        debug kind => _20;
                    }
                }
            }
        }
        scope 7 {
            debug iter => _25;
            let _29: &mut i32;
            scope 8 {
                debug x => _29;
                let _35: &&mut i32;
                let _36: &&mut i32;
                scope 9 {
                    debug left_val => _35;
                    debug right_val => _36;
                    let _39: core::panicking::AssertKind;
                    scope 10 {
                        debug kind => _39;
                    }
                }
            }
        }
        scope 11 {
            debug iter => _44;
            let _48: i32;
            scope 12 {
                debug x => _48;
                let _51: &i32;
                let _52: &i32;
                let mut _61: &i32;
                scope 13 {
                    debug left_val => _51;
                    debug right_val => _52;
                    let _57: core::panicking::AssertKind;
                    scope 14 {
                        debug kind => _57;
                    }
                }
            }
        }
    }
    scope 2 {
    }

    bb0: {
        _62 = const false;
        _3 = SizeOf([i32; 1]);
        _4 = AlignOf([i32; 1]);
        _5 = alloc::alloc::exchange_malloc(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = ShallowInitBox(move _5, [i32; 1]);
        _63 = (((_6.0: std::ptr::Unique<[i32; 1]>).0: std::ptr::NonNull<[i32; 1]>).0: *const [i32; 1]);
        _64 = _63 as *const () (PtrToPtr);
        _65 = _64 as usize (Transmute);
        _66 = AlignOf(i32);
        _67 = Sub(_66, const 1_usize);
        _68 = BitAnd(_65, _67);
        _69 = Eq(_68, const 0_usize);
        assert(_69, "misaligned pointer dereference: address must be a multiple of {} but is {}", _66, _65) -> [success: bb29, unwind unreachable];
    }

    bb2: {
        _62 = const true;
        _8 = &_1;
        _7 = <&Vec<i32> as IntoIterator>::into_iter(move _8) -> [return: bb3, unwind: bb28];
    }

    bb3: {
        _9 = move _7;
        goto -> bb4;
    }

    bb4: {
        _11 = &mut _9;
        _10 = <std::slice::Iter<'_, i32> as Iterator>::next(_11) -> [return: bb5, unwind: bb28];
    }

    bb5: {
        _12 = discriminant(_10);
        switchInt(move _12) -> [0: bb8, 1: bb6, otherwise: bb7];
    }

    bb6: {
        _13 = ((_10 as Some).0: &i32);
        _15 = &_13;
        _60 = const _;
        _14 = (move _15, _60);
        _16 = (_14.0: &&i32);
        _17 = (_14.1: &&i32);
        _19 = <&i32 as PartialEq>::eq(_16, _17) -> [return: bb9, unwind: bb28];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _24 = &mut _1;
        _23 = <&mut Vec<i32> as IntoIterator>::into_iter(move _24) -> [return: bb11, unwind: bb28];
    }

    bb9: {
        _18 = Not(move _19);
        switchInt(move _18) -> [0: bb4, otherwise: bb10];
    }

    bb10: {
        _20 = core::panicking::AssertKind::Eq;
        _22 = Option::<Arguments<'_>>::None;
        _21 = core::panicking::assert_failed::<&i32, &i32>(move _20, _16, _17, move _22) -> bb28;
    }

    bb11: {
        _25 = move _23;
        goto -> bb12;
    }

    bb12: {
        _27 = &mut _25;
        _26 = <std::slice::IterMut<'_, i32> as Iterator>::next(_27) -> [return: bb13, unwind: bb28];
    }

    bb13: {
        _28 = discriminant(_26);
        switchInt(move _28) -> [0: bb15, 1: bb14, otherwise: bb7];
    }

    bb14: {
        _29 = move ((_26 as Some).0: &mut i32);
        _31 = &_29;
        _34 = const 1_i32;
        _33 = &mut _34;
        _32 = &_33;
        _30 = (move _31, move _32);
        _35 = (_30.0: &&mut i32);
        _36 = (_30.1: &&mut i32);
        _38 = <&mut i32 as PartialEq>::eq(_35, _36) -> [return: bb16, unwind: bb28];
    }

    bb15: {
        _62 = const false;
        _43 = move _1;
        _42 = <Vec<i32> as IntoIterator>::into_iter(move _43) -> [return: bb18, unwind: bb28];
    }

    bb16: {
        _37 = Not(move _38);
        switchInt(move _37) -> [0: bb12, otherwise: bb17];
    }

    bb17: {
        _39 = core::panicking::AssertKind::Eq;
        _41 = Option::<Arguments<'_>>::None;
        _40 = core::panicking::assert_failed::<&mut i32, &mut i32>(move _39, _35, _36, move _41) -> bb28;
    }

    bb18: {
        _44 = move _42;
        goto -> bb19;
    }

    bb19: {
        _46 = &mut _44;
        _45 = <std::vec::IntoIter<i32> as Iterator>::next(_46) -> [return: bb20, unwind: bb25];
    }

    bb20: {
        _47 = discriminant(_45);
        switchInt(move _47) -> [0: bb22, 1: bb21, otherwise: bb7];
    }

    bb21: {
        _48 = ((_45 as Some).0: i32);
        _50 = &_48;
        _61 = const _;
        _49 = (move _50, _61);
        _51 = (_49.0: &i32);
        _52 = (_49.1: &i32);
        _55 = (*_51);
        _56 = (*_52);
        _54 = Eq(move _55, move _56);
        _53 = Not(move _54);
        switchInt(move _53) -> [0: bb19, otherwise: bb23];
    }

    bb22: {
        drop(_44) -> [return: bb24, unwind: bb28];
    }

    bb23: {
        _57 = core::panicking::AssertKind::Eq;
        _59 = Option::<Arguments<'_>>::None;
        _58 = core::panicking::assert_failed::<i32, i32>(move _57, _51, _52, move _59) -> bb25;
    }

    bb24: {
        _62 = const false;
        return;
    }

    bb25 (cleanup): {
        drop(_44) -> [return: bb28, unwind terminate];
    }

    bb26 (cleanup): {
        resume;
    }

    bb27 (cleanup): {
        drop(_1) -> [return: bb26, unwind terminate];
    }

    bb28 (cleanup): {
        switchInt(_62) -> [0: bb26, otherwise: bb27];
    }

    bb29: {
        (*_63) = [const 1_i32];
        _2 = move _6 as std::boxed::Box<[i32]> (Pointer(Unsize));
        _1 = slice::<impl [i32]>::into_vec::<std::alloc::Global>(move _2) -> [return: bb2, unwind continue];
    }
}

promoted[0] in main: &&i32 = {
    let mut _0: &&i32;
    let mut _1: &i32;
    let mut _2: i32;

    bb0: {
        _2 = const 1_i32;
        _1 = &_2;
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 1_i32;
        _0 = &_1;
        return;
    }
}
