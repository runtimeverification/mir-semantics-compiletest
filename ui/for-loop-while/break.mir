// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();
    let mut _1: i32;
    let mut _2: bool;
    let mut _3: i32;
    let mut _4: i32;
    let mut _5: (&i32, &i32);
    let mut _6: &i32;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: i32;
    let mut _12: i32;
    let _14: !;
    let mut _15: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _16: i32;
    let mut _17: (&i32, &i32);
    let mut _18: &i32;
    let mut _21: bool;
    let mut _22: bool;
    let mut _23: i32;
    let mut _24: i32;
    let _26: !;
    let mut _27: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _29: std::slice::Iter<'_, i32>;
    let mut _30: &[i32; 6];
    let mut _32: std::option::Option<&i32>;
    let mut _33: &mut std::slice::Iter<'_, i32>;
    let mut _34: isize;
    let mut _36: i32;
    let mut _37: bool;
    let mut _38: bool;
    let mut _39: i32;
    let mut _40: !;
    let mut _41: bool;
    let mut _42: i32;
    let mut _43: i32;
    let mut _44: i32;
    let mut _45: bool;
    let mut _46: bool;
    let mut _47: bool;
    let mut _48: bool;
    let mut _49: bool;
    let mut _50: bool;
    let mut _51: i32;
    let mut _52: i32;
    let mut _53: bool;
    let mut _54: bool;
    let mut _55: bool;
    let mut _56: bool;
    let mut _57: !;
    let mut _58: i32;
    let mut _59: i32;
    let mut _60: bool;
    let mut _61: bool;
    let mut _62: bool;
    let mut _63: bool;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: i32;
    let mut _67: i32;
    let mut _68: bool;
    let mut _69: bool;
    let mut _70: bool;
    let mut _71: bool;
    let mut _72: !;
    let mut _73: bool;
    let mut _74: i32;
    let mut _76: std::boxed::Box<[i32]>;
    let mut _77: usize;
    let mut _78: usize;
    let mut _79: *mut u8;
    let mut _80: std::boxed::Box<[i32; 6]>;
    let mut _81: std::slice::Iter<'_, i32>;
    let mut _82: &std::vec::Vec<i32>;
    let mut _84: std::option::Option<&i32>;
    let mut _85: &mut std::slice::Iter<'_, i32>;
    let mut _86: isize;
    let mut _88: i32;
    let mut _89: i32;
    let mut _90: bool;
    let mut _91: bool;
    let mut _92: bool;
    let mut _93: bool;
    let mut _94: bool;
    let mut _95: bool;
    let mut _96: i32;
    let mut _97: i32;
    let mut _98: bool;
    let mut _99: bool;
    let mut _100: bool;
    let mut _101: bool;
    let mut _102: !;
    let mut _105: *const [i32; 6];
    scope 1 {
        debug i => _1;
        let _7: &i32;
        let _8: &i32;
        let _19: &i32;
        let _20: &i32;
        let _28: [i32; 6];
        let mut _103: &i32;
        let mut _104: &i32;
        scope 2 {
            debug left_val => _7;
            debug right_val => _8;
            let _13: core::panicking::AssertKind;
            scope 3 {
                debug kind => _13;
            }
        }
        scope 4 {
            debug left_val => _19;
            debug right_val => _20;
            let _25: core::panicking::AssertKind;
            scope 5 {
                debug kind => _25;
            }
        }
        scope 6 {
            debug xs => _28;
            let mut _31: std::slice::Iter<'_, i32>;
            let _75: std::vec::Vec<i32>;
            let mut _106: *const ();
            let mut _107: usize;
            let mut _108: usize;
            let mut _109: usize;
            let mut _110: usize;
            let mut _111: bool;
            scope 7 {
                debug iter => _31;
                let _35: &i32;
                scope 8 {
                    debug x => _35;
                }
            }
            scope 9 {
                debug ys => _75;
                let mut _83: std::slice::Iter<'_, i32>;
                scope 11 {
                    debug iter => _83;
                    let _87: &i32;
                    scope 12 {
                        debug x => _87;
                    }
                }
            }
            scope 10 {
            }
        }
    }

    bb0: {
        _1 = const 0_i32;
        goto -> bb1;
    }

    bb1: {
        _3 = _1;
        _2 = Lt(move _3, const 20_i32);
        switchInt(move _2) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _1 = Add(_1, const 1_i32);
        _4 = _1;
        switchInt(move _4) -> [10: bb4, otherwise: bb1];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _6 = &_1;
        _104 = const _;
        _5 = (move _6, _104);
        _7 = (_5.0: &i32);
        _8 = (_5.1: &i32);
        _11 = (*_7);
        _12 = (*_8);
        _10 = Eq(move _11, move _12);
        _9 = Not(move _10);
        switchInt(move _9) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _13 = core::panicking::AssertKind::Eq;
        _15 = Option::<Arguments<'_>>::None;
        _14 = core::panicking::assert_failed::<i32, i32>(move _13, _7, _8, move _15) -> unwind continue;
    }

    bb6: {
        _1 = Add(_1, const 1_i32);
        _16 = _1;
        switchInt(move _16) -> [20: bb7, otherwise: bb6];
    }

    bb7: {
        _18 = &_1;
        _103 = const _;
        _17 = (move _18, _103);
        _19 = (_17.0: &i32);
        _20 = (_17.1: &i32);
        _23 = (*_19);
        _24 = (*_20);
        _22 = Eq(move _23, move _24);
        _21 = Not(move _22);
        switchInt(move _21) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _25 = core::panicking::AssertKind::Eq;
        _27 = Option::<Arguments<'_>>::None;
        _26 = core::panicking::assert_failed::<i32, i32>(move _25, _19, _20, move _27) -> unwind continue;
    }

    bb9: {
        _28 = [const 1_i32, const 2_i32, const 3_i32, const 4_i32, const 5_i32, const 6_i32];
        _30 = &_28;
        _29 = <&[i32; 6] as IntoIterator>::into_iter(move _30) -> [return: bb10, unwind continue];
    }

    bb10: {
        _31 = move _29;
        goto -> bb11;
    }

    bb11: {
        _33 = &mut _31;
        _32 = <std::slice::Iter<'_, i32> as Iterator>::next(_33) -> [return: bb12, unwind continue];
    }

    bb12: {
        _34 = discriminant(_32);
        switchInt(move _34) -> [0: bb16, 1: bb13, otherwise: bb3];
    }

    bb13: {
        _35 = ((_32 as Some).0: &i32);
        _36 = (*_35);
        switchInt(move _36) -> [3: bb16, otherwise: bb14];
    }

    bb14: {
        _39 = (*_35);
        _38 = Le(move _39, const 3_i32);
        _37 = Not(move _38);
        switchInt(move _37) -> [0: bb11, otherwise: bb15];
    }

    bb15: {
        _40 = core::panicking::panic(const "assertion failed: (*x <= 3)") -> unwind continue;
    }

    bb16: {
        _1 = const 0_i32;
        goto -> bb17;
    }

    bb17: {
        _42 = _1;
        _41 = Lt(move _42, const 10_i32);
        switchInt(move _41) -> [0: bb25, otherwise: bb18];
    }

    bb18: {
        _1 = Add(_1, const 1_i32);
        _44 = _1;
        _45 = Eq(const 2_i32, const 0_i32);
        assert(!move _45, "attempt to calculate the remainder of `{}` with a divisor of zero", _44) -> [success: bb19, unwind continue];
    }

    bb19: {
        _46 = Eq(const 2_i32, const -1_i32);
        _47 = Eq(_44, const i32::MIN);
        _48 = BitAnd(move _46, move _47);
        assert(!move _48, "attempt to compute the remainder of `{} % {}`, which would overflow", _44, const 2_i32) -> [success: bb20, unwind continue];
    }

    bb20: {
        _43 = Rem(move _44, const 2_i32);
        switchInt(move _43) -> [0: bb17, otherwise: bb21];
    }

    bb21: {
        _52 = _1;
        _53 = Eq(const 2_i32, const 0_i32);
        assert(!move _53, "attempt to calculate the remainder of `{}` with a divisor of zero", _52) -> [success: bb22, unwind continue];
    }

    bb22: {
        _54 = Eq(const 2_i32, const -1_i32);
        _55 = Eq(_52, const i32::MIN);
        _56 = BitAnd(move _54, move _55);
        assert(!move _56, "attempt to compute the remainder of `{} % {}`, which would overflow", _52, const 2_i32) -> [success: bb23, unwind continue];
    }

    bb23: {
        _51 = Rem(move _52, const 2_i32);
        _50 = Ne(move _51, const 0_i32);
        _49 = Not(move _50);
        switchInt(move _49) -> [0: bb17, otherwise: bb24];
    }

    bb24: {
        _57 = core::panicking::panic(const "assertion failed: (i % 2 != 0)") -> unwind continue;
    }

    bb25: {
        _1 = const 0_i32;
        goto -> bb26;
    }

    bb26: {
        _1 = Add(_1, const 1_i32);
        _59 = _1;
        _60 = Eq(const 2_i32, const 0_i32);
        assert(!move _60, "attempt to calculate the remainder of `{}` with a divisor of zero", _59) -> [success: bb27, unwind continue];
    }

    bb27: {
        _61 = Eq(const 2_i32, const -1_i32);
        _62 = Eq(_59, const i32::MIN);
        _63 = BitAnd(move _61, move _62);
        assert(!move _63, "attempt to compute the remainder of `{} % {}`, which would overflow", _59, const 2_i32) -> [success: bb28, unwind continue];
    }

    bb28: {
        _58 = Rem(move _59, const 2_i32);
        switchInt(move _58) -> [0: bb26, otherwise: bb29];
    }

    bb29: {
        _67 = _1;
        _68 = Eq(const 2_i32, const 0_i32);
        assert(!move _68, "attempt to calculate the remainder of `{}` with a divisor of zero", _67) -> [success: bb30, unwind continue];
    }

    bb30: {
        _69 = Eq(const 2_i32, const -1_i32);
        _70 = Eq(_67, const i32::MIN);
        _71 = BitAnd(move _69, move _70);
        assert(!move _71, "attempt to compute the remainder of `{} % {}`, which would overflow", _67, const 2_i32) -> [success: bb31, unwind continue];
    }

    bb31: {
        _66 = Rem(move _67, const 2_i32);
        _65 = Ne(move _66, const 0_i32);
        _64 = Not(move _65);
        switchInt(move _64) -> [0: bb33, otherwise: bb32];
    }

    bb32: {
        _72 = core::panicking::panic(const "assertion failed: (i % 2 != 0)") -> unwind continue;
    }

    bb33: {
        _74 = _1;
        _73 = Ge(move _74, const 10_i32);
        switchInt(move _73) -> [0: bb26, otherwise: bb34];
    }

    bb34: {
        _77 = SizeOf([i32; 6]);
        _78 = AlignOf([i32; 6]);
        _79 = alloc::alloc::exchange_malloc(move _77, move _78) -> [return: bb35, unwind continue];
    }

    bb35: {
        _80 = ShallowInitBox(move _79, [i32; 6]);
        _105 = (((_80.0: std::ptr::Unique<[i32; 6]>).0: std::ptr::NonNull<[i32; 6]>).0: *const [i32; 6]);
        _106 = _105 as *const () (PtrToPtr);
        _107 = _106 as usize (Transmute);
        _108 = AlignOf(i32);
        _109 = Sub(_108, const 1_usize);
        _110 = BitAnd(_107, _109);
        _111 = Eq(_110, const 0_usize);
        assert(_111, "misaligned pointer dereference: address must be a multiple of {} but is {}", _108, _107) -> [success: bb51, unwind unreachable];
    }

    bb36: {
        _82 = &_75;
        _81 = <&Vec<i32> as IntoIterator>::into_iter(move _82) -> [return: bb37, unwind: bb49];
    }

    bb37: {
        _83 = move _81;
        goto -> bb38;
    }

    bb38: {
        _85 = &mut _83;
        _84 = <std::slice::Iter<'_, i32> as Iterator>::next(_85) -> [return: bb39, unwind: bb49];
    }

    bb39: {
        _86 = discriminant(_84);
        switchInt(move _86) -> [0: bb41, 1: bb40, otherwise: bb3];
    }

    bb40: {
        _87 = ((_84 as Some).0: &i32);
        _89 = (*_87);
        _90 = Eq(const 2_i32, const 0_i32);
        assert(!move _90, "attempt to calculate the remainder of `{}` with a divisor of zero", _89) -> [success: bb42, unwind: bb49];
    }

    bb41: {
        drop(_75) -> [return: bb48, unwind continue];
    }

    bb42: {
        _91 = Eq(const 2_i32, const -1_i32);
        _92 = Eq(_89, const i32::MIN);
        _93 = BitAnd(move _91, move _92);
        assert(!move _93, "attempt to compute the remainder of `{} % {}`, which would overflow", _89, const 2_i32) -> [success: bb43, unwind: bb49];
    }

    bb43: {
        _88 = Rem(move _89, const 2_i32);
        switchInt(move _88) -> [0: bb38, otherwise: bb44];
    }

    bb44: {
        _97 = (*_87);
        _98 = Eq(const 2_i32, const 0_i32);
        assert(!move _98, "attempt to calculate the remainder of `{}` with a divisor of zero", _97) -> [success: bb45, unwind: bb49];
    }

    bb45: {
        _99 = Eq(const 2_i32, const -1_i32);
        _100 = Eq(_97, const i32::MIN);
        _101 = BitAnd(move _99, move _100);
        assert(!move _101, "attempt to compute the remainder of `{} % {}`, which would overflow", _97, const 2_i32) -> [success: bb46, unwind: bb49];
    }

    bb46: {
        _96 = Rem(move _97, const 2_i32);
        _95 = Ne(move _96, const 0_i32);
        _94 = Not(move _95);
        switchInt(move _94) -> [0: bb38, otherwise: bb47];
    }

    bb47: {
        _102 = core::panicking::panic(const "assertion failed: (*x % 2 != 0)") -> bb49;
    }

    bb48: {
        return;
    }

    bb49 (cleanup): {
        drop(_75) -> [return: bb50, unwind terminate];
    }

    bb50 (cleanup): {
        resume;
    }

    bb51: {
        (*_105) = [const 1_i32, const 2_i32, const 3_i32, const 4_i32, const 5_i32, const 6_i32];
        _76 = move _80 as std::boxed::Box<[i32]> (Pointer(Unsize));
        _75 = slice::<impl [i32]>::into_vec::<std::alloc::Global>(move _76) -> [return: bb36, unwind continue];
    }
}

promoted[0] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 20_i32;
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 10_i32;
        _0 = &_1;
        return;
    }
}
