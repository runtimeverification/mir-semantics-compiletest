// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/methods/method-argument-inference-associated-type.rs:12:1: 12:27>::call(_1: &ClientMap, _2: S<Box<dyn Fn(i32)>>) -> () {
    debug self => _1;
    debug _req => _2;
    let mut _0: ();

    bb0: {
        drop(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/methods/method-argument-inference-associated-type.rs:18:1: 18:28>::call(_1: &ClientMap2, _2: (Box<dyn Fn(i32)>,)) -> () {
    debug self => _1;
    debug _req => _2;
    let mut _0: ();

    bb0: {
        drop(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: ();
    let mut _2: S<std::boxed::Box<dyn std::ops::Fn(i32)>>;
    let mut _3: std::boxed::Box<dyn std::ops::Fn(i32)>;
    let mut _4: std::boxed::Box<[closure@ui/methods/method-argument-inference-associated-type.rs:25:36: 25:44]>;
    let _5: ();
    let mut _6: S<std::boxed::Box<dyn std::ops::Fn(i32)>>;
    let mut _7: std::boxed::Box<dyn std::ops::Fn(i32)>;
    let mut _8: std::boxed::Box<[closure@ui/methods/method-argument-inference-associated-type.rs:26:31: 26:39]>;
    let _9: ();
    let mut _10: (std::boxed::Box<dyn std::ops::Fn(i32)>,);
    let mut _11: std::boxed::Box<dyn std::ops::Fn(i32)>;
    let mut _12: std::boxed::Box<[closure@ui/methods/method-argument-inference-associated-type.rs:27:31: 27:39]>;
    let mut _13: &ClientMap2;
    let mut _14: &ClientMap;
    let mut _15: &ClientMap;

    bb0: {
        _15 = const _;
        _4 = Box::<[closure@ui/methods/method-argument-inference-associated-type.rs:25:36: 25:44]>::new(const ZeroSized: [closure@ui/methods/method-argument-inference-associated-type.rs:25:36: 25:44]) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = move _4 as std::boxed::Box<dyn std::ops::Fn(i32)> (Pointer(Unsize));
        _2 = S::<Box<dyn Fn(i32)>>(move _3);
        _1 = <ClientMap as Service>::call(_15, move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        _14 = const _;
        _8 = Box::<[closure@ui/methods/method-argument-inference-associated-type.rs:26:31: 26:39]>::new(const ZeroSized: [closure@ui/methods/method-argument-inference-associated-type.rs:26:31: 26:39]) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = move _8 as std::boxed::Box<dyn std::ops::Fn(i32)> (Pointer(Unsize));
        _6 = S::<Box<dyn Fn(i32)>>(move _7);
        _5 = <ClientMap as Service>::call(_14, move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _13 = const _;
        _12 = Box::<[closure@ui/methods/method-argument-inference-associated-type.rs:27:31: 27:39]>::new(const ZeroSized: [closure@ui/methods/method-argument-inference-associated-type.rs:27:31: 27:39]) -> [return: bb5, unwind continue];
    }

    bb5: {
        _11 = move _12 as std::boxed::Box<dyn std::ops::Fn(i32)> (Pointer(Unsize));
        _10 = (move _11,);
        _9 = <ClientMap2 as Service>::call(_13, move _10) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

promoted[0] in main: &ClientMap2 = {
    let mut _0: &ClientMap2;
    let mut _1: ClientMap2;

    bb0: {
        _1 = ClientMap2;
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &ClientMap = {
    let mut _0: &ClientMap;
    let mut _1: ClientMap;

    bb0: {
        _1 = ClientMap;
        _0 = &_1;
        return;
    }
}

promoted[2] in main: &ClientMap = {
    let mut _0: &ClientMap;
    let mut _1: ClientMap;

    bb0: {
        _1 = ClientMap;
        _0 = &_1;
        return;
    }
}

fn main::{closure#0}(_1: &[closure@ui/methods/method-argument-inference-associated-type.rs:25:36: 25:44], _2: i32) -> () {
    debug _msgid => _2;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn main::{closure#1}(_1: &[closure@ui/methods/method-argument-inference-associated-type.rs:26:31: 26:39], _2: i32) -> () {
    debug _msgid => _2;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn main::{closure#2}(_1: &[closure@ui/methods/method-argument-inference-associated-type.rs:27:31: 27:39], _2: i32) -> () {
    debug _msgid => _2;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn S(_1: T) -> S<T> {
    let mut _0: S<T>;

    bb0: {
        _0 = S::<T>(move _1);
        return;
    }
}

// MIR FOR CTFE
fn S(_1: T) -> S<T> {
    let mut _0: S<T>;

    bb0: {
        _0 = S::<T>(move _1);
        return;
    }
}
