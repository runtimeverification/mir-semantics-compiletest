// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn evaluate_reborrow_before_assign() -> () {
    let mut _0: ();
    let mut _1: &i32;
    let mut _3: &i32;
    let mut _4: &i32;
    let mut _5: (&i32, &i32);
    let mut _6: &i32;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: i32;
    let mut _12: i32;
    let _14: !;
    let mut _15: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _16: (&i32, &i32);
    let mut _19: bool;
    let mut _20: bool;
    let mut _21: i32;
    let mut _22: i32;
    let _24: !;
    let mut _25: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _30: &i32;
    let mut _31: &i32;
    scope 1 {
        debug x => _1;
        let _2: &mut &i32;
        let mut _29: &i32;
        scope 2 {
            debug y => _2;
            let mut _28: &i32;
            scope 3 {
                debug z => const _;
                let _7: &i32;
                let _8: &i32;
                let _17: &i32;
                let _18: &i32;
                let mut _26: &i32;
                let mut _27: &i32;
                scope 4 {
                    debug left_val => _7;
                    debug right_val => _8;
                    let _13: core::panicking::AssertKind;
                    scope 5 {
                        debug kind => _13;
                    }
                }
                scope 6 {
                    debug left_val => _17;
                    debug right_val => _18;
                    let _23: core::panicking::AssertKind;
                    scope 7 {
                        debug kind => _23;
                    }
                }
            }
        }
    }

    bb0: {
        _30 = const _;
        _1 = _30;
        _29 = const _;
        _3 = _29;
        _2 = &mut _3;
        _28 = const _;
        _4 = _1;
        _1 = _28;
        (*_2) = move _4;
        _6 = _1;
        _27 = const _;
        _5 = (move _6, _27);
        _7 = (_5.0: &i32);
        _8 = (_5.1: &i32);
        _11 = (*_7);
        _12 = (*_8);
        _10 = Eq(move _11, move _12);
        _9 = Not(move _10);
        switchInt(move _9) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _13 = core::panicking::AssertKind::Eq;
        _15 = Option::<Arguments<'_>>::None;
        _14 = core::panicking::assert_failed::<i32, i32>(move _13, _7, _8, move _15) -> unwind continue;
    }

    bb2: {
        _31 = deref_copy (*_2);
        _26 = const _;
        _16 = (_31, _26);
        _17 = (_16.0: &i32);
        _18 = (_16.1: &i32);
        _21 = (*_17);
        _22 = (*_18);
        _20 = Eq(move _21, move _22);
        _19 = Not(move _20);
        switchInt(move _19) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _23 = core::panicking::AssertKind::Eq;
        _25 = Option::<Arguments<'_>>::None;
        _24 = core::panicking::assert_failed::<i32, i32>(move _23, _17, _18, move _25) -> unwind continue;
    }

    bb4: {
        return;
    }
}

promoted[0] in evaluate_reborrow_before_assign: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 1_i32;
        _0 = &_1;
        return;
    }
}

promoted[1] in evaluate_reborrow_before_assign: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 3_i32;
        _0 = &_1;
        return;
    }
}

promoted[2] in evaluate_reborrow_before_assign: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 3_i32;
        _0 = &_1;
        return;
    }
}

promoted[3] in evaluate_reborrow_before_assign: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 2_i32;
        _0 = &_1;
        return;
    }
}

promoted[4] in evaluate_reborrow_before_assign: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 1_i32;
        _0 = &_1;
        return;
    }
}

fn evaluate_mut_reborrow_before_assign() -> () {
    let mut _0: ();
    let mut _1: &mut i32;
    let mut _2: i32;
    let mut _4: &mut i32;
    let mut _5: i32;
    let mut _7: i32;
    let mut _8: &mut i32;
    let mut _9: (&i32, &i32);
    let mut _10: &i32;
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: i32;
    let mut _16: i32;
    let _18: !;
    let mut _19: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _20: (&i32, &i32);
    let mut _21: &i32;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: i32;
    let mut _27: i32;
    let _29: !;
    let mut _30: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _33: &mut i32;
    scope 1 {
        debug x => _1;
        let _3: &mut &mut i32;
        scope 2 {
            debug y => _3;
            let _6: &mut i32;
            scope 3 {
                debug z => _6;
                let _11: &i32;
                let _12: &i32;
                let _22: &i32;
                let _23: &i32;
                let mut _31: &i32;
                let mut _32: &i32;
                scope 4 {
                    debug left_val => _11;
                    debug right_val => _12;
                    let _17: core::panicking::AssertKind;
                    scope 5 {
                        debug kind => _17;
                    }
                }
                scope 6 {
                    debug left_val => _22;
                    debug right_val => _23;
                    let _28: core::panicking::AssertKind;
                    scope 7 {
                        debug kind => _28;
                    }
                }
            }
        }
    }

    bb0: {
        _2 = const 1_i32;
        _1 = &mut _2;
        _5 = const 2_i32;
        _4 = &mut _5;
        _3 = &mut _4;
        _7 = const 3_i32;
        _6 = &mut _7;
        _8 = _1;
        _1 = _6;
        (*_3) = move _8;
        _10 = &(*_1);
        _32 = const _;
        _9 = (move _10, _32);
        _11 = (_9.0: &i32);
        _12 = (_9.1: &i32);
        _15 = (*_11);
        _16 = (*_12);
        _14 = Eq(move _15, move _16);
        _13 = Not(move _14);
        switchInt(move _13) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _17 = core::panicking::AssertKind::Eq;
        _19 = Option::<Arguments<'_>>::None;
        _18 = core::panicking::assert_failed::<i32, i32>(move _17, _11, _12, move _19) -> unwind continue;
    }

    bb2: {
        _33 = deref_copy (*_3);
        _21 = &(*_33);
        _31 = const _;
        _20 = (move _21, _31);
        _22 = (_20.0: &i32);
        _23 = (_20.1: &i32);
        _26 = (*_22);
        _27 = (*_23);
        _25 = Eq(move _26, move _27);
        _24 = Not(move _25);
        switchInt(move _24) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _28 = core::panicking::AssertKind::Eq;
        _30 = Option::<Arguments<'_>>::None;
        _29 = core::panicking::assert_failed::<i32, i32>(move _28, _22, _23, move _30) -> unwind continue;
    }

    bb4: {
        return;
    }
}

promoted[0] in evaluate_mut_reborrow_before_assign: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 1_i32;
        _0 = &_1;
        return;
    }
}

promoted[1] in evaluate_mut_reborrow_before_assign: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 3_i32;
        _0 = &_1;
        return;
    }
}

fn evaluate_ref_to_temp_before_assign_slice() -> () {
    let mut _0: ();
    let mut _1: &[S];
    let _2: &[S];
    let mut _4: &S;
    let _5: &S;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _9: (&i32, &i32);
    let mut _10: &i32;
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: i32;
    let mut _16: i32;
    let _18: !;
    let mut _19: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _20: (&i32, &i32);
    let mut _21: &i32;
    let _22: usize;
    let mut _23: usize;
    let mut _24: bool;
    let mut _27: bool;
    let mut _28: bool;
    let mut _29: i32;
    let mut _30: i32;
    let _32: !;
    let mut _33: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _38: &[S; 3];
    let mut _39: &S;
    scope 1 {
        debug x => _1;
        let _3: &mut &S;
        let mut _37: &S;
        scope 2 {
            debug y => _3;
            let _11: &i32;
            let _12: &i32;
            let _25: &i32;
            let _26: &i32;
            let mut _34: &i32;
            let mut _35: &i32;
            let mut _36: &[S; 3];
            scope 3 {
                debug left_val => _11;
                debug right_val => _12;
                let _17: core::panicking::AssertKind;
                scope 4 {
                    debug kind => _17;
                }
            }
            scope 5 {
                debug left_val => _25;
                debug right_val => _26;
                let _31: core::panicking::AssertKind;
                scope 6 {
                    debug kind => _31;
                }
            }
        }
    }

    bb0: {
        _38 = const _;
        _2 = <[S; 3] as Index<RangeFull>>::index(_38, const RangeFull) -> [return: bb1, unwind continue];
    }

    bb1: {
        _1 = _2;
        _37 = const _;
        _4 = _37;
        _3 = &mut _4;
        _6 = const 2_usize;
        _7 = Len((*_1));
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> [success: bb2, unwind continue];
    }

    bb2: {
        _5 = &(*_1)[_6];
        _36 = const _;
        _1 = _36 as &[S] (Pointer(Unsize));
        (*_3) = _5;
        _35 = const _;
        _39 = deref_copy (*_3);
        _10 = &((*_39).0: i32);
        _9 = (_35, move _10);
        _11 = (_9.0: &i32);
        _12 = (_9.1: &i32);
        _15 = (*_11);
        _16 = (*_12);
        _14 = Eq(move _15, move _16);
        _13 = Not(move _14);
        switchInt(move _13) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _17 = core::panicking::AssertKind::Eq;
        _19 = Option::<Arguments<'_>>::None;
        _18 = core::panicking::assert_failed::<i32, i32>(move _17, _11, _12, move _19) -> unwind continue;
    }

    bb4: {
        _34 = const _;
        _22 = const 2_usize;
        _23 = Len((*_1));
        _24 = Lt(_22, _23);
        assert(move _24, "index out of bounds: the length is {} but the index is {}", move _23, _22) -> [success: bb5, unwind continue];
    }

    bb5: {
        _21 = &((*_1)[_22].0: i32);
        _20 = (_34, move _21);
        _25 = (_20.0: &i32);
        _26 = (_20.1: &i32);
        _29 = (*_25);
        _30 = (*_26);
        _28 = Eq(move _29, move _30);
        _27 = Not(move _28);
        switchInt(move _27) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _31 = core::panicking::AssertKind::Eq;
        _33 = Option::<Arguments<'_>>::None;
        _32 = core::panicking::assert_failed::<i32, i32>(move _31, _25, _26, move _33) -> unwind continue;
    }

    bb7: {
        return;
    }
}

promoted[0] in evaluate_ref_to_temp_before_assign_slice: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 5_i32;
        _0 = &_1;
        return;
    }
}

promoted[1] in evaluate_ref_to_temp_before_assign_slice: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 2_i32;
        _0 = &_1;
        return;
    }
}

promoted[2] in evaluate_ref_to_temp_before_assign_slice: &[S; 3] = {
    let mut _0: &[S; 3];
    let mut _1: [S; 3];
    let mut _2: S;
    let mut _3: S;
    let mut _4: S;

    bb0: {
        _2 = S(const 3_i32);
        _3 = S(const 4_i32);
        _4 = S(const 5_i32);
        _1 = [move _2, move _3, move _4];
        _0 = &_1;
        return;
    }
}

promoted[3] in evaluate_ref_to_temp_before_assign_slice: &S = {
    let mut _0: &S;
    let mut _1: S;

    bb0: {
        _1 = S(const 7_i32);
        _0 = &_1;
        return;
    }
}

promoted[4] in evaluate_ref_to_temp_before_assign_slice: &[S; 3] = {
    let mut _0: &[S; 3];
    let mut _1: [S; 3];
    let mut _2: S;
    let mut _3: S;
    let mut _4: S;

    bb0: {
        _2 = S(const 0_i32);
        _3 = S(const 1_i32);
        _4 = S(const 2_i32);
        _1 = [move _2, move _3, move _4];
        _0 = &_1;
        return;
    }
}

fn evaluate_fru_to_temp_before_assign_slice() -> () {
    let mut _0: ();
    let mut _1: &[S];
    let _2: &[S];
    let mut _4: S;
    let mut _5: S;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _9: (&i32, &i32);
    let mut _10: &i32;
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: i32;
    let mut _16: i32;
    let _18: !;
    let mut _19: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _20: (&i32, &i32);
    let mut _21: &i32;
    let _22: usize;
    let mut _23: usize;
    let mut _24: bool;
    let mut _27: bool;
    let mut _28: bool;
    let mut _29: i32;
    let mut _30: i32;
    let _32: !;
    let mut _33: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _37: &[S; 3];
    scope 1 {
        debug x => _1;
        let _3: &mut S;
        scope 2 {
            debug y => _3;
            let _11: &i32;
            let _12: &i32;
            let _25: &i32;
            let _26: &i32;
            let mut _34: &i32;
            let mut _35: &i32;
            let mut _36: &[S; 3];
            scope 3 {
                debug left_val => _11;
                debug right_val => _12;
                let _17: core::panicking::AssertKind;
                scope 4 {
                    debug kind => _17;
                }
            }
            scope 5 {
                debug left_val => _25;
                debug right_val => _26;
                let _31: core::panicking::AssertKind;
                scope 6 {
                    debug kind => _31;
                }
            }
        }
    }

    bb0: {
        _37 = const _;
        _2 = <[S; 3] as Index<RangeFull>>::index(_37, const RangeFull) -> [return: bb1, unwind continue];
    }

    bb1: {
        _1 = _2;
        _4 = S(const 7_i32);
        _3 = &mut _4;
        _6 = const 2_usize;
        _7 = Len((*_1));
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> [success: bb2, unwind continue];
    }

    bb2: {
        _5 = S(((*_1)[_6].0: i32));
        _36 = const _;
        _1 = _36 as &[S] (Pointer(Unsize));
        (*_3) = move _5;
        _35 = const _;
        _10 = &((*_3).0: i32);
        _9 = (_35, move _10);
        _11 = (_9.0: &i32);
        _12 = (_9.1: &i32);
        _15 = (*_11);
        _16 = (*_12);
        _14 = Eq(move _15, move _16);
        _13 = Not(move _14);
        switchInt(move _13) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _17 = core::panicking::AssertKind::Eq;
        _19 = Option::<Arguments<'_>>::None;
        _18 = core::panicking::assert_failed::<i32, i32>(move _17, _11, _12, move _19) -> unwind continue;
    }

    bb4: {
        _34 = const _;
        _22 = const 2_usize;
        _23 = Len((*_1));
        _24 = Lt(_22, _23);
        assert(move _24, "index out of bounds: the length is {} but the index is {}", move _23, _22) -> [success: bb5, unwind continue];
    }

    bb5: {
        _21 = &((*_1)[_22].0: i32);
        _20 = (_34, move _21);
        _25 = (_20.0: &i32);
        _26 = (_20.1: &i32);
        _29 = (*_25);
        _30 = (*_26);
        _28 = Eq(move _29, move _30);
        _27 = Not(move _28);
        switchInt(move _27) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _31 = core::panicking::AssertKind::Eq;
        _33 = Option::<Arguments<'_>>::None;
        _32 = core::panicking::assert_failed::<i32, i32>(move _31, _25, _26, move _33) -> unwind continue;
    }

    bb7: {
        return;
    }
}

promoted[0] in evaluate_fru_to_temp_before_assign_slice: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 5_i32;
        _0 = &_1;
        return;
    }
}

promoted[1] in evaluate_fru_to_temp_before_assign_slice: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 2_i32;
        _0 = &_1;
        return;
    }
}

promoted[2] in evaluate_fru_to_temp_before_assign_slice: &[S; 3] = {
    let mut _0: &[S; 3];
    let mut _1: [S; 3];
    let mut _2: S;
    let mut _3: S;
    let mut _4: S;

    bb0: {
        _2 = S(const 3_i32);
        _3 = S(const 4_i32);
        _4 = S(const 5_i32);
        _1 = [move _2, move _3, move _4];
        _0 = &_1;
        return;
    }
}

promoted[3] in evaluate_fru_to_temp_before_assign_slice: &[S; 3] = {
    let mut _0: &[S; 3];
    let mut _1: [S; 3];
    let mut _2: S;
    let mut _3: S;
    let mut _4: S;

    bb0: {
        _2 = S(const 0_i32);
        _3 = S(const 1_i32);
        _4 = S(const 2_i32);
        _1 = [move _2, move _3, move _4];
        _0 = &_1;
        return;
    }
}

fn evaluate_fru_to_temp_before_assign_box() -> () {
    let mut _0: ();
    let _1: std::boxed::Box<S>;
    let mut _2: S;
    let mut _4: S;
    let mut _5: S;
    let _6: ();
    let mut _7: std::boxed::Box<S>;
    let mut _8: (&i32, &i32);
    let mut _9: &i32;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: i32;
    let mut _15: i32;
    let _17: !;
    let mut _18: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _20: *const S;
    scope 1 {
        debug x => _1;
        let _3: &mut S;
        scope 2 {
            debug y => _3;
            let _10: &i32;
            let _11: &i32;
            let mut _19: &i32;
            let mut _21: *const ();
            let mut _22: usize;
            let mut _23: usize;
            let mut _24: usize;
            let mut _25: usize;
            let mut _26: bool;
            scope 3 {
                debug left_val => _10;
                debug right_val => _11;
                let _16: core::panicking::AssertKind;
                scope 4 {
                    debug kind => _16;
                }
            }
        }
    }

    bb0: {
        _2 = S(const 0_i32);
        _1 = Box::<S>::new(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = S(const 1_i32);
        _3 = &mut _4;
        _20 = (((_1.0: std::ptr::Unique<S>).0: std::ptr::NonNull<S>).0: *const S);
        _21 = _20 as *const () (PtrToPtr);
        _22 = _21 as usize (Transmute);
        _23 = AlignOf(S);
        _24 = Sub(_23, const 1_usize);
        _25 = BitAnd(_22, _24);
        _26 = Eq(_25, const 0_usize);
        assert(_26, "misaligned pointer dereference: address must be a multiple of {} but is {}", _23, _22) -> [success: bb5, unwind unreachable];
    }

    bb2: {
        (*_3) = move _5;
        _19 = const _;
        _9 = &((*_3).0: i32);
        _8 = (_19, move _9);
        _10 = (_8.0: &i32);
        _11 = (_8.1: &i32);
        _14 = (*_10);
        _15 = (*_11);
        _13 = Eq(move _14, move _15);
        _12 = Not(move _13);
        switchInt(move _12) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _16 = core::panicking::AssertKind::Eq;
        _18 = Option::<Arguments<'_>>::None;
        _17 = core::panicking::assert_failed::<i32, i32>(move _16, _10, _11, move _18) -> unwind continue;
    }

    bb4: {
        return;
    }

    bb5: {
        _5 = S(((*_20).0: i32));
        _7 = move _1;
        _6 = std::mem::drop::<Box<S>>(move _7) -> [return: bb2, unwind continue];
    }
}

promoted[0] in evaluate_fru_to_temp_before_assign_box: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 0_i32;
        _0 = &_1;
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: ();
    let _2: ();
    let _3: ();
    let _4: ();
    let _5: ();

    bb0: {
        _1 = evaluate_reborrow_before_assign() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = evaluate_mut_reborrow_before_assign() -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = evaluate_ref_to_temp_before_assign_slice() -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = evaluate_fru_to_temp_before_assign_slice() -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = evaluate_fru_to_temp_before_assign_box() -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn S(_1: i32) -> S {
    let mut _0: S;

    bb0: {
        _0 = S(move _1);
        return;
    }
}

// MIR FOR CTFE
fn S(_1: i32) -> S {
    let mut _0: S;

    bb0: {
        _0 = S(move _1);
        return;
    }
}
