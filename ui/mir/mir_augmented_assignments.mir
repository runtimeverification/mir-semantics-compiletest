// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/mir/mir_augmented_assignments.rs:8:10: 8:15>::fmt(_1: &Int, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&i32;
    let _6: &i32;

    bb0: {
        _3 = const "Int";
        _6 = &((*_1).0: i32);
        _5 = &_6;
        _4 = _5 as &dyn std::fmt::Debug (Pointer(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/mir/mir_augmented_assignments.rs:8:17: 8:26>::eq(_1: &Int, _2: &Int) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: i32;
    let mut _4: i32;

    bb0: {
        _3 = ((*_1).0: i32);
        _4 = ((*_2).0: i32);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn <impl at ui/mir/mir_augmented_assignments.rs:13:1: 13:11>::new(_1: &mut [i32]) -> &mut Slice {
    debug slice => _1;
    let mut _0: &mut Slice;
    scope 1 {
    }

    bb0: {
        _0 = move _1 as &mut Slice (Transmute);
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: ();

    bb0: {
        _1 = main_mir() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn main_mir() -> () {
    let mut _0: ();
    let mut _1: Int;
    let _2: ();
    let mut _3: &mut Int;
    let mut _4: Int;
    let mut _5: (&Int, &Int);
    let mut _6: &Int;
    let mut _9: bool;
    let mut _10: bool;
    let _12: !;
    let mut _13: std::option::Option<std::fmt::Arguments<'_>>;
    let _14: ();
    let mut _15: &mut Int;
    let mut _16: Int;
    let mut _17: (&Int, &Int);
    let mut _18: &Int;
    let mut _21: bool;
    let mut _22: bool;
    let _24: !;
    let mut _25: std::option::Option<std::fmt::Arguments<'_>>;
    let _26: ();
    let mut _27: &mut Int;
    let mut _28: Int;
    let mut _29: (&Int, &Int);
    let mut _30: &Int;
    let mut _33: bool;
    let mut _34: bool;
    let _36: !;
    let mut _37: std::option::Option<std::fmt::Arguments<'_>>;
    let _38: ();
    let mut _39: &mut Int;
    let mut _40: Int;
    let mut _41: (&Int, &Int);
    let mut _42: &Int;
    let mut _45: bool;
    let mut _46: bool;
    let _48: !;
    let mut _49: std::option::Option<std::fmt::Arguments<'_>>;
    let _50: ();
    let mut _51: &mut Int;
    let mut _52: Int;
    let mut _53: (&Int, &Int);
    let mut _54: &Int;
    let mut _57: bool;
    let mut _58: bool;
    let _60: !;
    let mut _61: std::option::Option<std::fmt::Arguments<'_>>;
    let _62: ();
    let mut _63: &mut Int;
    let mut _64: Int;
    let mut _65: (&Int, &Int);
    let mut _66: &Int;
    let mut _69: bool;
    let mut _70: bool;
    let _72: !;
    let mut _73: std::option::Option<std::fmt::Arguments<'_>>;
    let _74: ();
    let mut _75: &mut Int;
    let mut _76: Int;
    let mut _77: (&Int, &Int);
    let mut _78: &Int;
    let mut _81: bool;
    let mut _82: bool;
    let _84: !;
    let mut _85: std::option::Option<std::fmt::Arguments<'_>>;
    let _86: ();
    let mut _87: &mut Int;
    let mut _88: (&Int, &Int);
    let mut _89: &Int;
    let mut _92: bool;
    let mut _93: bool;
    let _95: !;
    let mut _96: std::option::Option<std::fmt::Arguments<'_>>;
    let _97: ();
    let mut _98: &mut Int;
    let mut _99: (&Int, &Int);
    let mut _100: &Int;
    let mut _103: bool;
    let mut _104: bool;
    let _106: !;
    let mut _107: std::option::Option<std::fmt::Arguments<'_>>;
    let _108: ();
    let mut _109: &mut Int;
    let mut _110: (&Int, &Int);
    let mut _111: &Int;
    let mut _114: bool;
    let mut _115: bool;
    let _117: !;
    let mut _118: std::option::Option<std::fmt::Arguments<'_>>;
    let _119: ();
    let mut _120: &mut Int;
    let mut _121: (&Int, &Int);
    let mut _122: &Int;
    let mut _125: bool;
    let mut _126: bool;
    let _128: !;
    let mut _129: std::option::Option<std::fmt::Arguments<'_>>;
    let _130: ();
    let mut _131: &mut Int;
    let mut _132: Int;
    let mut _133: (&Int, &Int);
    let mut _134: &Int;
    let mut _137: bool;
    let mut _138: bool;
    let _140: !;
    let mut _141: std::option::Option<std::fmt::Arguments<'_>>;
    let _143: ();
    let mut _144: &mut std::vec::Vec<Int>;
    let mut _145: Int;
    let _146: ();
    let mut _147: &mut std::vec::Vec<Int>;
    let mut _148: Int;
    let _149: ();
    let mut _150: &mut Int;
    let mut _151: &mut Int;
    let mut _152: &mut std::vec::Vec<Int>;
    let mut _153: Int;
    let mut _154: (&Int, &Int);
    let mut _155: &Int;
    let _156: &Int;
    let mut _157: &std::vec::Vec<Int>;
    let mut _160: bool;
    let mut _161: bool;
    let _163: !;
    let mut _164: std::option::Option<std::fmt::Arguments<'_>>;
    let _166: ();
    let mut _167: &mut Slice;
    let mut _168: &mut Slice;
    let mut _169: &mut [i32];
    let mut _170: &mut [i32; 3];
    let mut _171: (&i32, &i32);
    let mut _172: &i32;
    let _173: usize;
    let mut _174: usize;
    let mut _175: bool;
    let mut _178: bool;
    let mut _179: bool;
    let mut _180: i32;
    let mut _181: i32;
    let _183: !;
    let mut _184: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _185: (&i32, &i32);
    let mut _186: &i32;
    let _187: usize;
    let mut _188: usize;
    let mut _189: bool;
    let mut _192: bool;
    let mut _193: bool;
    let mut _194: i32;
    let mut _195: i32;
    let _197: !;
    let mut _198: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _199: (&i32, &i32);
    let mut _200: &i32;
    let _201: usize;
    let mut _202: usize;
    let mut _203: bool;
    let mut _206: bool;
    let mut _207: bool;
    let mut _208: i32;
    let mut _209: i32;
    let _211: !;
    let mut _212: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug x => _1;
        let _7: &Int;
        let _8: &Int;
        let _19: &Int;
        let _20: &Int;
        let _31: &Int;
        let _32: &Int;
        let _43: &Int;
        let _44: &Int;
        let _55: &Int;
        let _56: &Int;
        let _67: &Int;
        let _68: &Int;
        let _79: &Int;
        let _80: &Int;
        let _90: &Int;
        let _91: &Int;
        let _101: &Int;
        let _102: &Int;
        let _112: &Int;
        let _113: &Int;
        let _123: &Int;
        let _124: &Int;
        let _135: &Int;
        let _136: &Int;
        let mut _142: std::vec::Vec<Int>;
        let mut _217: &Int;
        let mut _218: &Int;
        let mut _219: &Int;
        let mut _220: &Int;
        let mut _221: &Int;
        let mut _222: &Int;
        let mut _223: &Int;
        let mut _224: &Int;
        let mut _225: &Int;
        let mut _226: &Int;
        let mut _227: &Int;
        let mut _228: &Int;
        scope 2 {
            debug left_val => _7;
            debug right_val => _8;
            let _11: core::panicking::AssertKind;
            scope 3 {
                debug kind => _11;
            }
        }
        scope 4 {
            debug left_val => _19;
            debug right_val => _20;
            let _23: core::panicking::AssertKind;
            scope 5 {
                debug kind => _23;
            }
        }
        scope 6 {
            debug left_val => _31;
            debug right_val => _32;
            let _35: core::panicking::AssertKind;
            scope 7 {
                debug kind => _35;
            }
        }
        scope 8 {
            debug left_val => _43;
            debug right_val => _44;
            let _47: core::panicking::AssertKind;
            scope 9 {
                debug kind => _47;
            }
        }
        scope 10 {
            debug left_val => _55;
            debug right_val => _56;
            let _59: core::panicking::AssertKind;
            scope 11 {
                debug kind => _59;
            }
        }
        scope 12 {
            debug left_val => _67;
            debug right_val => _68;
            let _71: core::panicking::AssertKind;
            scope 13 {
                debug kind => _71;
            }
        }
        scope 14 {
            debug left_val => _79;
            debug right_val => _80;
            let _83: core::panicking::AssertKind;
            scope 15 {
                debug kind => _83;
            }
        }
        scope 16 {
            debug left_val => _90;
            debug right_val => _91;
            let _94: core::panicking::AssertKind;
            scope 17 {
                debug kind => _94;
            }
        }
        scope 18 {
            debug left_val => _101;
            debug right_val => _102;
            let _105: core::panicking::AssertKind;
            scope 19 {
                debug kind => _105;
            }
        }
        scope 20 {
            debug left_val => _112;
            debug right_val => _113;
            let _116: core::panicking::AssertKind;
            scope 21 {
                debug kind => _116;
            }
        }
        scope 22 {
            debug left_val => _123;
            debug right_val => _124;
            let _127: core::panicking::AssertKind;
            scope 23 {
                debug kind => _127;
            }
        }
        scope 24 {
            debug left_val => _135;
            debug right_val => _136;
            let _139: core::panicking::AssertKind;
            scope 25 {
                debug kind => _139;
            }
        }
        scope 26 {
            debug v => _142;
            let _158: &Int;
            let _159: &Int;
            let mut _165: [i32; 3];
            let mut _216: &Int;
            scope 27 {
                debug left_val => _158;
                debug right_val => _159;
                let _162: core::panicking::AssertKind;
                scope 28 {
                    debug kind => _162;
                }
            }
            scope 29 {
                debug array => _165;
                let _176: &i32;
                let _177: &i32;
                let _190: &i32;
                let _191: &i32;
                let _204: &i32;
                let _205: &i32;
                let mut _213: &i32;
                let mut _214: &i32;
                let mut _215: &i32;
                scope 30 {
                    debug left_val => _176;
                    debug right_val => _177;
                    let _182: core::panicking::AssertKind;
                    scope 31 {
                        debug kind => _182;
                    }
                }
                scope 32 {
                    debug left_val => _190;
                    debug right_val => _191;
                    let _196: core::panicking::AssertKind;
                    scope 33 {
                        debug kind => _196;
                    }
                }
                scope 34 {
                    debug left_val => _204;
                    debug right_val => _205;
                    let _210: core::panicking::AssertKind;
                    scope 35 {
                        debug kind => _210;
                    }
                }
            }
        }
    }

    bb0: {
        _1 = Int(const 1_i32);
        _3 = &mut _1;
        _4 = Int(const 2_i32);
        _2 = <Int as AddAssign>::add_assign(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &_1;
        _228 = const _;
        _5 = (move _6, _228);
        _7 = (_5.0: &Int);
        _8 = (_5.1: &Int);
        _10 = <Int as PartialEq>::eq(_7, _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = Not(move _10);
        switchInt(move _9) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _11 = core::panicking::AssertKind::Eq;
        _13 = Option::<Arguments<'_>>::None;
        _12 = core::panicking::assert_failed::<Int, Int>(move _11, _7, _8, move _13) -> unwind continue;
    }

    bb4: {
        _15 = &mut _1;
        _16 = Int(const 1_i32);
        _14 = <Int as BitAndAssign>::bitand_assign(move _15, move _16) -> [return: bb5, unwind continue];
    }

    bb5: {
        _18 = &_1;
        _227 = const _;
        _17 = (move _18, _227);
        _19 = (_17.0: &Int);
        _20 = (_17.1: &Int);
        _22 = <Int as PartialEq>::eq(_19, _20) -> [return: bb6, unwind continue];
    }

    bb6: {
        _21 = Not(move _22);
        switchInt(move _21) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _23 = core::panicking::AssertKind::Eq;
        _25 = Option::<Arguments<'_>>::None;
        _24 = core::panicking::assert_failed::<Int, Int>(move _23, _19, _20, move _25) -> unwind continue;
    }

    bb8: {
        _27 = &mut _1;
        _28 = Int(const 2_i32);
        _26 = <Int as BitOrAssign>::bitor_assign(move _27, move _28) -> [return: bb9, unwind continue];
    }

    bb9: {
        _30 = &_1;
        _226 = const _;
        _29 = (move _30, _226);
        _31 = (_29.0: &Int);
        _32 = (_29.1: &Int);
        _34 = <Int as PartialEq>::eq(_31, _32) -> [return: bb10, unwind continue];
    }

    bb10: {
        _33 = Not(move _34);
        switchInt(move _33) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _35 = core::panicking::AssertKind::Eq;
        _37 = Option::<Arguments<'_>>::None;
        _36 = core::panicking::assert_failed::<Int, Int>(move _35, _31, _32, move _37) -> unwind continue;
    }

    bb12: {
        _39 = &mut _1;
        _40 = Int(const 1_i32);
        _38 = <Int as BitXorAssign>::bitxor_assign(move _39, move _40) -> [return: bb13, unwind continue];
    }

    bb13: {
        _42 = &_1;
        _225 = const _;
        _41 = (move _42, _225);
        _43 = (_41.0: &Int);
        _44 = (_41.1: &Int);
        _46 = <Int as PartialEq>::eq(_43, _44) -> [return: bb14, unwind continue];
    }

    bb14: {
        _45 = Not(move _46);
        switchInt(move _45) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _47 = core::panicking::AssertKind::Eq;
        _49 = Option::<Arguments<'_>>::None;
        _48 = core::panicking::assert_failed::<Int, Int>(move _47, _43, _44, move _49) -> unwind continue;
    }

    bb16: {
        _51 = &mut _1;
        _52 = Int(const 2_i32);
        _50 = <Int as DivAssign>::div_assign(move _51, move _52) -> [return: bb17, unwind continue];
    }

    bb17: {
        _54 = &_1;
        _224 = const _;
        _53 = (move _54, _224);
        _55 = (_53.0: &Int);
        _56 = (_53.1: &Int);
        _58 = <Int as PartialEq>::eq(_55, _56) -> [return: bb18, unwind continue];
    }

    bb18: {
        _57 = Not(move _58);
        switchInt(move _57) -> [0: bb20, otherwise: bb19];
    }

    bb19: {
        _59 = core::panicking::AssertKind::Eq;
        _61 = Option::<Arguments<'_>>::None;
        _60 = core::panicking::assert_failed::<Int, Int>(move _59, _55, _56, move _61) -> unwind continue;
    }

    bb20: {
        _63 = &mut _1;
        _64 = Int(const 3_i32);
        _62 = <Int as MulAssign>::mul_assign(move _63, move _64) -> [return: bb21, unwind continue];
    }

    bb21: {
        _66 = &_1;
        _223 = const _;
        _65 = (move _66, _223);
        _67 = (_65.0: &Int);
        _68 = (_65.1: &Int);
        _70 = <Int as PartialEq>::eq(_67, _68) -> [return: bb22, unwind continue];
    }

    bb22: {
        _69 = Not(move _70);
        switchInt(move _69) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _71 = core::panicking::AssertKind::Eq;
        _73 = Option::<Arguments<'_>>::None;
        _72 = core::panicking::assert_failed::<Int, Int>(move _71, _67, _68, move _73) -> unwind continue;
    }

    bb24: {
        _75 = &mut _1;
        _76 = Int(const 2_i32);
        _74 = <Int as RemAssign>::rem_assign(move _75, move _76) -> [return: bb25, unwind continue];
    }

    bb25: {
        _78 = &_1;
        _222 = const _;
        _77 = (move _78, _222);
        _79 = (_77.0: &Int);
        _80 = (_77.1: &Int);
        _82 = <Int as PartialEq>::eq(_79, _80) -> [return: bb26, unwind continue];
    }

    bb26: {
        _81 = Not(move _82);
        switchInt(move _81) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        _83 = core::panicking::AssertKind::Eq;
        _85 = Option::<Arguments<'_>>::None;
        _84 = core::panicking::assert_failed::<Int, Int>(move _83, _79, _80, move _85) -> unwind continue;
    }

    bb28: {
        _87 = &mut _1;
        _86 = <Int as ShlAssign<u8>>::shl_assign(move _87, const 1_u8) -> [return: bb29, unwind continue];
    }

    bb29: {
        _89 = &_1;
        _221 = const _;
        _88 = (move _89, _221);
        _90 = (_88.0: &Int);
        _91 = (_88.1: &Int);
        _93 = <Int as PartialEq>::eq(_90, _91) -> [return: bb30, unwind continue];
    }

    bb30: {
        _92 = Not(move _93);
        switchInt(move _92) -> [0: bb32, otherwise: bb31];
    }

    bb31: {
        _94 = core::panicking::AssertKind::Eq;
        _96 = Option::<Arguments<'_>>::None;
        _95 = core::panicking::assert_failed::<Int, Int>(move _94, _90, _91, move _96) -> unwind continue;
    }

    bb32: {
        _98 = &mut _1;
        _97 = <Int as ShlAssign<u16>>::shl_assign(move _98, const 1_u16) -> [return: bb33, unwind continue];
    }

    bb33: {
        _100 = &_1;
        _220 = const _;
        _99 = (move _100, _220);
        _101 = (_99.0: &Int);
        _102 = (_99.1: &Int);
        _104 = <Int as PartialEq>::eq(_101, _102) -> [return: bb34, unwind continue];
    }

    bb34: {
        _103 = Not(move _104);
        switchInt(move _103) -> [0: bb36, otherwise: bb35];
    }

    bb35: {
        _105 = core::panicking::AssertKind::Eq;
        _107 = Option::<Arguments<'_>>::None;
        _106 = core::panicking::assert_failed::<Int, Int>(move _105, _101, _102, move _107) -> unwind continue;
    }

    bb36: {
        _109 = &mut _1;
        _108 = <Int as ShrAssign<u8>>::shr_assign(move _109, const 1_u8) -> [return: bb37, unwind continue];
    }

    bb37: {
        _111 = &_1;
        _219 = const _;
        _110 = (move _111, _219);
        _112 = (_110.0: &Int);
        _113 = (_110.1: &Int);
        _115 = <Int as PartialEq>::eq(_112, _113) -> [return: bb38, unwind continue];
    }

    bb38: {
        _114 = Not(move _115);
        switchInt(move _114) -> [0: bb40, otherwise: bb39];
    }

    bb39: {
        _116 = core::panicking::AssertKind::Eq;
        _118 = Option::<Arguments<'_>>::None;
        _117 = core::panicking::assert_failed::<Int, Int>(move _116, _112, _113, move _118) -> unwind continue;
    }

    bb40: {
        _120 = &mut _1;
        _119 = <Int as ShrAssign<u16>>::shr_assign(move _120, const 1_u16) -> [return: bb41, unwind continue];
    }

    bb41: {
        _122 = &_1;
        _218 = const _;
        _121 = (move _122, _218);
        _123 = (_121.0: &Int);
        _124 = (_121.1: &Int);
        _126 = <Int as PartialEq>::eq(_123, _124) -> [return: bb42, unwind continue];
    }

    bb42: {
        _125 = Not(move _126);
        switchInt(move _125) -> [0: bb44, otherwise: bb43];
    }

    bb43: {
        _127 = core::panicking::AssertKind::Eq;
        _129 = Option::<Arguments<'_>>::None;
        _128 = core::panicking::assert_failed::<Int, Int>(move _127, _123, _124, move _129) -> unwind continue;
    }

    bb44: {
        _131 = &mut _1;
        _132 = Int(const 1_i32);
        _130 = <Int as SubAssign>::sub_assign(move _131, move _132) -> [return: bb45, unwind continue];
    }

    bb45: {
        _134 = &_1;
        _217 = const _;
        _133 = (move _134, _217);
        _135 = (_133.0: &Int);
        _136 = (_133.1: &Int);
        _138 = <Int as PartialEq>::eq(_135, _136) -> [return: bb46, unwind continue];
    }

    bb46: {
        _137 = Not(move _138);
        switchInt(move _137) -> [0: bb48, otherwise: bb47];
    }

    bb47: {
        _139 = core::panicking::AssertKind::Eq;
        _141 = Option::<Arguments<'_>>::None;
        _140 = core::panicking::assert_failed::<Int, Int>(move _139, _135, _136, move _141) -> unwind continue;
    }

    bb48: {
        _142 = Vec::<Int>::new() -> [return: bb49, unwind continue];
    }

    bb49: {
        _144 = &mut _142;
        _145 = Int(const 1_i32);
        _143 = Vec::<Int>::push(move _144, move _145) -> [return: bb50, unwind: bb70];
    }

    bb50: {
        _147 = &mut _142;
        _148 = Int(const 2_i32);
        _146 = Vec::<Int>::push(move _147, move _148) -> [return: bb51, unwind: bb70];
    }

    bb51: {
        _152 = &mut _142;
        _151 = <Vec<Int> as IndexMut<usize>>::index_mut(move _152, const 0_usize) -> [return: bb52, unwind: bb70];
    }

    bb52: {
        _150 = _151;
        _153 = Int(const 2_i32);
        _149 = <Int as AddAssign>::add_assign(move _150, move _153) -> [return: bb53, unwind: bb70];
    }

    bb53: {
        _157 = &_142;
        _156 = <Vec<Int> as Index<usize>>::index(move _157, const 0_usize) -> [return: bb54, unwind: bb70];
    }

    bb54: {
        _155 = _156;
        _216 = const _;
        _154 = (move _155, _216);
        _158 = (_154.0: &Int);
        _159 = (_154.1: &Int);
        _161 = <Int as PartialEq>::eq(_158, _159) -> [return: bb55, unwind: bb70];
    }

    bb55: {
        _160 = Not(move _161);
        switchInt(move _160) -> [0: bb57, otherwise: bb56];
    }

    bb56: {
        _162 = core::panicking::AssertKind::Eq;
        _164 = Option::<Arguments<'_>>::None;
        _163 = core::panicking::assert_failed::<Int, Int>(move _162, _158, _159, move _164) -> bb70;
    }

    bb57: {
        _165 = [const 0_i32, const 1_i32, const 2_i32];
        _170 = &mut _165;
        _169 = _170 as &mut [i32] (Pointer(Unsize));
        _168 = Slice::new(move _169) -> [return: bb58, unwind: bb70];
    }

    bb58: {
        _167 = _168;
        _166 = <Slice as AddAssign<i32>>::add_assign(move _167, const 1_i32) -> [return: bb59, unwind: bb70];
    }

    bb59: {
        _173 = const 0_usize;
        _174 = const 3_usize;
        _175 = Lt(_173, _174);
        assert(move _175, "index out of bounds: the length is {} but the index is {}", move _174, _173) -> [success: bb60, unwind: bb70];
    }

    bb60: {
        _172 = &_165[_173];
        _215 = const _;
        _171 = (move _172, _215);
        _176 = (_171.0: &i32);
        _177 = (_171.1: &i32);
        _180 = (*_176);
        _181 = (*_177);
        _179 = Eq(move _180, move _181);
        _178 = Not(move _179);
        switchInt(move _178) -> [0: bb62, otherwise: bb61];
    }

    bb61: {
        _182 = core::panicking::AssertKind::Eq;
        _184 = Option::<Arguments<'_>>::None;
        _183 = core::panicking::assert_failed::<i32, i32>(move _182, _176, _177, move _184) -> bb70;
    }

    bb62: {
        _187 = const 1_usize;
        _188 = const 3_usize;
        _189 = Lt(_187, _188);
        assert(move _189, "index out of bounds: the length is {} but the index is {}", move _188, _187) -> [success: bb63, unwind: bb70];
    }

    bb63: {
        _186 = &_165[_187];
        _214 = const _;
        _185 = (move _186, _214);
        _190 = (_185.0: &i32);
        _191 = (_185.1: &i32);
        _194 = (*_190);
        _195 = (*_191);
        _193 = Eq(move _194, move _195);
        _192 = Not(move _193);
        switchInt(move _192) -> [0: bb65, otherwise: bb64];
    }

    bb64: {
        _196 = core::panicking::AssertKind::Eq;
        _198 = Option::<Arguments<'_>>::None;
        _197 = core::panicking::assert_failed::<i32, i32>(move _196, _190, _191, move _198) -> bb70;
    }

    bb65: {
        _201 = const 2_usize;
        _202 = const 3_usize;
        _203 = Lt(_201, _202);
        assert(move _203, "index out of bounds: the length is {} but the index is {}", move _202, _201) -> [success: bb66, unwind: bb70];
    }

    bb66: {
        _200 = &_165[_201];
        _213 = const _;
        _199 = (move _200, _213);
        _204 = (_199.0: &i32);
        _205 = (_199.1: &i32);
        _208 = (*_204);
        _209 = (*_205);
        _207 = Eq(move _208, move _209);
        _206 = Not(move _207);
        switchInt(move _206) -> [0: bb68, otherwise: bb67];
    }

    bb67: {
        _210 = core::panicking::AssertKind::Eq;
        _212 = Option::<Arguments<'_>>::None;
        _211 = core::panicking::assert_failed::<i32, i32>(move _210, _204, _205, move _212) -> bb70;
    }

    bb68: {
        drop(_142) -> [return: bb69, unwind continue];
    }

    bb69: {
        return;
    }

    bb70 (cleanup): {
        drop(_142) -> [return: bb71, unwind terminate];
    }

    bb71 (cleanup): {
        resume;
    }
}

promoted[0] in main_mir: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 3_i32;
        _0 = &_1;
        return;
    }
}

promoted[1] in main_mir: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 2_i32;
        _0 = &_1;
        return;
    }
}

promoted[2] in main_mir: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 1_i32;
        _0 = &_1;
        return;
    }
}

promoted[3] in main_mir: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 3_i32);
        _0 = &_1;
        return;
    }
}

promoted[4] in main_mir: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 0_i32);
        _0 = &_1;
        return;
    }
}

promoted[5] in main_mir: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 1_i32);
        _0 = &_1;
        return;
    }
}

promoted[6] in main_mir: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 2_i32);
        _0 = &_1;
        return;
    }
}

promoted[7] in main_mir: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 4_i32);
        _0 = &_1;
        return;
    }
}

promoted[8] in main_mir: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 2_i32);
        _0 = &_1;
        return;
    }
}

promoted[9] in main_mir: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 1_i32);
        _0 = &_1;
        return;
    }
}

promoted[10] in main_mir: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 3_i32);
        _0 = &_1;
        return;
    }
}

promoted[11] in main_mir: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 1_i32);
        _0 = &_1;
        return;
    }
}

promoted[12] in main_mir: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 2_i32);
        _0 = &_1;
        return;
    }
}

promoted[13] in main_mir: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 3_i32);
        _0 = &_1;
        return;
    }
}

promoted[14] in main_mir: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 1_i32);
        _0 = &_1;
        return;
    }
}

promoted[15] in main_mir: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 3_i32);
        _0 = &_1;
        return;
    }
}

fn <impl at ui/mir/mir_augmented_assignments.rs:82:1: 82:23>::add_assign(_1: &mut Int, _2: Int) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: i32;

    bb0: {
        _3 = (_2.0: i32);
        ((*_1).0: i32) = Add(((*_1).0: i32), move _3);
        return;
    }
}

fn <impl at ui/mir/mir_augmented_assignments.rs:88:1: 88:26>::bitand_assign(_1: &mut Int, _2: Int) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: i32;

    bb0: {
        _3 = (_2.0: i32);
        ((*_1).0: i32) = BitAnd(((*_1).0: i32), move _3);
        return;
    }
}

fn <impl at ui/mir/mir_augmented_assignments.rs:94:1: 94:25>::bitor_assign(_1: &mut Int, _2: Int) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: i32;

    bb0: {
        _3 = (_2.0: i32);
        ((*_1).0: i32) = BitOr(((*_1).0: i32), move _3);
        return;
    }
}

fn <impl at ui/mir/mir_augmented_assignments.rs:100:1: 100:26>::bitxor_assign(_1: &mut Int, _2: Int) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: i32;

    bb0: {
        _3 = (_2.0: i32);
        ((*_1).0: i32) = BitXor(((*_1).0: i32), move _3);
        return;
    }
}

fn <impl at ui/mir/mir_augmented_assignments.rs:106:1: 106:23>::div_assign(_1: &mut Int, _2: Int) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: i32;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;

    bb0: {
        _3 = (_2.0: i32);
        _4 = Eq(_3, const 0_i32);
        assert(!move _4, "attempt to divide `{}` by zero", ((*_1).0: i32)) -> [success: bb1, unwind continue];
    }

    bb1: {
        _5 = Eq(_3, const -1_i32);
        _6 = Eq(((*_1).0: i32), const i32::MIN);
        _7 = BitAnd(move _5, move _6);
        assert(!move _7, "attempt to compute `{} / {}`, which would overflow", ((*_1).0: i32), _3) -> [success: bb2, unwind continue];
    }

    bb2: {
        ((*_1).0: i32) = Div(((*_1).0: i32), move _3);
        return;
    }
}

fn <impl at ui/mir/mir_augmented_assignments.rs:112:1: 112:23>::mul_assign(_1: &mut Int, _2: Int) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: i32;

    bb0: {
        _3 = (_2.0: i32);
        ((*_1).0: i32) = Mul(((*_1).0: i32), move _3);
        return;
    }
}

fn <impl at ui/mir/mir_augmented_assignments.rs:118:1: 118:23>::rem_assign(_1: &mut Int, _2: Int) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: i32;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;

    bb0: {
        _3 = (_2.0: i32);
        _4 = Eq(_3, const 0_i32);
        assert(!move _4, "attempt to calculate the remainder of `{}` with a divisor of zero", ((*_1).0: i32)) -> [success: bb1, unwind continue];
    }

    bb1: {
        _5 = Eq(_3, const -1_i32);
        _6 = Eq(((*_1).0: i32), const i32::MIN);
        _7 = BitAnd(move _5, move _6);
        assert(!move _7, "attempt to compute the remainder of `{} % {}`, which would overflow", ((*_1).0: i32), _3) -> [success: bb2, unwind continue];
    }

    bb2: {
        ((*_1).0: i32) = Rem(((*_1).0: i32), move _3);
        return;
    }
}

fn <impl at ui/mir/mir_augmented_assignments.rs:124:1: 124:27>::shl_assign(_1: &mut Int, _2: u8) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();

    bb0: {
        ((*_1).0: i32) = Shl(((*_1).0: i32), _2);
        return;
    }
}

fn <impl at ui/mir/mir_augmented_assignments.rs:130:1: 130:28>::shl_assign(_1: &mut Int, _2: u16) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();

    bb0: {
        ((*_1).0: i32) = Shl(((*_1).0: i32), _2);
        return;
    }
}

fn <impl at ui/mir/mir_augmented_assignments.rs:136:1: 136:27>::shr_assign(_1: &mut Int, _2: u8) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();

    bb0: {
        ((*_1).0: i32) = Shr(((*_1).0: i32), _2);
        return;
    }
}

fn <impl at ui/mir/mir_augmented_assignments.rs:142:1: 142:28>::shr_assign(_1: &mut Int, _2: u16) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();

    bb0: {
        ((*_1).0: i32) = Shr(((*_1).0: i32), _2);
        return;
    }
}

fn <impl at ui/mir/mir_augmented_assignments.rs:148:1: 148:23>::sub_assign(_1: &mut Int, _2: Int) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: i32;

    bb0: {
        _3 = (_2.0: i32);
        ((*_1).0: i32) = Sub(((*_1).0: i32), move _3);
        return;
    }
}

fn <impl at ui/mir/mir_augmented_assignments.rs:154:1: 154:30>::add_assign(_1: &mut Slice, _2: i32) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: std::slice::IterMut<'_, i32>;
    let mut _4: &mut [i32];
    let mut _5: std::slice::IterMut<'_, i32>;
    let mut _6: std::option::Option<&mut i32>;
    let mut _7: &mut std::slice::IterMut<'_, i32>;
    let mut _8: isize;
    scope 1 {
        debug iter => _5;
        let _9: &mut i32;
        scope 2 {
            debug lhs => _9;
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: [i32]);
        _3 = <&mut [i32] as IntoIterator>::into_iter(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _5;
        _6 = <std::slice::IterMut<'_, i32> as Iterator>::next(_7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _9 = move ((_6 as Some).0: &mut i32);
        (*_9) = Add((*_9), _2);
        goto -> bb2;
    }

    bb5: {
        unreachable;
    }

    bb6: {
        return;
    }
}

fn Int(_1: i32) -> Int {
    let mut _0: Int;

    bb0: {
        _0 = Int(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Int(_1: i32) -> Int {
    let mut _0: Int;

    bb0: {
        _0 = Int(move _1);
        return;
    }
}

fn Slice(_1: [i32]) -> Slice {
    let mut _0: Slice;

    bb0: {
        _0 = Slice(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Slice(_1: [i32]) -> Slice {
    let mut _0: Slice;

    bb0: {
        _0 = Slice(move _1);
        return;
    }
}
