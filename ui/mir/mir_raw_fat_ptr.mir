// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/mir/mir_raw_fat_ptr.rs:8:10: 8:15>::fmt(_1: &ComparisonResults, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _4: &[&dyn std::fmt::Debug; 6];
    let _5: [&dyn std::fmt::Debug; 6];
    let mut _6: &dyn std::fmt::Debug;
    let _7: &bool;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &bool;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &bool;
    let mut _12: &dyn std::fmt::Debug;
    let _13: &bool;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &bool;
    let mut _16: &dyn std::fmt::Debug;
    let _17: &&bool;
    let _18: &bool;
    let _19: &str;
    let mut _20: &[&str];
    let mut _21: &[&str; 6];
    scope 1 {
        debug names => const _;
        let _3: &[&dyn std::fmt::Debug];
        scope 2 {
            debug values => _3;
        }
    }

    bb0: {
        _21 = const _;
        _7 = &((*_1).0: bool);
        _6 = _7 as &dyn std::fmt::Debug (Pointer(Unsize));
        _9 = &((*_1).1: bool);
        _8 = _9 as &dyn std::fmt::Debug (Pointer(Unsize));
        _11 = &((*_1).2: bool);
        _10 = _11 as &dyn std::fmt::Debug (Pointer(Unsize));
        _13 = &((*_1).3: bool);
        _12 = _13 as &dyn std::fmt::Debug (Pointer(Unsize));
        _15 = &((*_1).4: bool);
        _14 = _15 as &dyn std::fmt::Debug (Pointer(Unsize));
        _18 = &((*_1).5: bool);
        _17 = &_18;
        _16 = _17 as &dyn std::fmt::Debug (Pointer(Unsize));
        _5 = [move _6, move _8, move _10, move _12, move _14, move _16];
        _4 = &_5;
        _3 = _4 as &[&dyn std::fmt::Debug] (Pointer(Unsize));
        _19 = const "ComparisonResults";
        _20 = _21 as &[&str] (Pointer(Unsize));
        _0 = Formatter::<'_>::debug_struct_fields_finish(_2, _19, move _20, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in <impl at ui/mir/mir_raw_fat_ptr.rs:8:10: 8:15>::fmt: &[&str; 6] = {
    let mut _0: &[&str; 6];
    let mut _1: [&str; 6];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;

    bb0: {
        _3 = const "le";
        _2 = &(*_3);
        _5 = const "gt";
        _4 = &(*_5);
        _7 = const "ge";
        _6 = &(*_7);
        _9 = const "eq";
        _8 = &(*_9);
        _11 = const "ne";
        _10 = &(*_11);
        _1 = [const "lt", move _2, move _4, move _6, move _8, move _10];
        _0 = &_1;
        return;
    }
}

fn <impl at ui/mir/mir_raw_fat_ptr.rs:8:17: 8:26>::eq(_1: &ComparisonResults, _2: &ComparisonResults) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: bool;
    let mut _19: bool;
    let mut _20: bool;
    let mut _21: bool;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: bool;

    bb0: {
        _8 = ((*_1).0: bool);
        _9 = ((*_2).0: bool);
        _7 = Eq(move _8, move _9);
        switchInt(move _7) -> [0: bb13, otherwise: bb14];
    }

    bb1: {
        _0 = const false;
        goto -> bb3;
    }

    bb2: {
        _23 = ((*_1).5: bool);
        _24 = ((*_2).5: bool);
        _22 = Eq(move _23, move _24);
        _0 = move _22;
        goto -> bb3;
    }

    bb3: {
        return;
    }

    bb4: {
        _3 = const false;
        goto -> bb6;
    }

    bb5: {
        _20 = ((*_1).4: bool);
        _21 = ((*_2).4: bool);
        _19 = Eq(move _20, move _21);
        _3 = move _19;
        goto -> bb6;
    }

    bb6: {
        switchInt(move _3) -> [0: bb1, otherwise: bb2];
    }

    bb7: {
        _4 = const false;
        goto -> bb9;
    }

    bb8: {
        _17 = ((*_1).3: bool);
        _18 = ((*_2).3: bool);
        _16 = Eq(move _17, move _18);
        _4 = move _16;
        goto -> bb9;
    }

    bb9: {
        switchInt(move _4) -> [0: bb4, otherwise: bb5];
    }

    bb10: {
        _5 = const false;
        goto -> bb12;
    }

    bb11: {
        _14 = ((*_1).2: bool);
        _15 = ((*_2).2: bool);
        _13 = Eq(move _14, move _15);
        _5 = move _13;
        goto -> bb12;
    }

    bb12: {
        switchInt(move _5) -> [0: bb7, otherwise: bb8];
    }

    bb13: {
        _6 = const false;
        goto -> bb15;
    }

    bb14: {
        _11 = ((*_1).1: bool);
        _12 = ((*_2).1: bool);
        _10 = Eq(move _11, move _12);
        _6 = move _10;
        goto -> bb15;
    }

    bb15: {
        switchInt(move _6) -> [0: bb10, otherwise: bb11];
    }
}

fn <impl at ui/mir/mir_raw_fat_ptr.rs:8:28: 8:30>::assert_receiver_is_total_eq(_1: &ComparisonResults) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

const LT: ComparisonResults = {
    let mut _0: ComparisonResults;

    bb0: {
        _0 = ComparisonResults { lt: const true, le: const true, gt: const false, ge: const false, eq: const false, ne: const true };
        return;
    }
}

const EQ: ComparisonResults = {
    let mut _0: ComparisonResults;

    bb0: {
        _0 = ComparisonResults { lt: const false, le: const true, gt: const false, ge: const true, eq: const true, ne: const false };
        return;
    }
}

const GT: ComparisonResults = {
    let mut _0: ComparisonResults;

    bb0: {
        _0 = ComparisonResults { lt: const false, le: const false, gt: const true, ge: const true, eq: const false, ne: const true };
        return;
    }
}

fn compare_su8(_1: *const S<[u8]>, _2: *const S<[u8]>) -> ComparisonResults {
    debug a => _1;
    debug b => _2;
    let mut _0: ComparisonResults;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;

    bb0: {
        _3 = Lt(_1, _2);
        _4 = Le(_1, _2);
        _5 = Gt(_1, _2);
        _6 = Ge(_1, _2);
        _7 = Eq(_1, _2);
        _8 = Ne(_1, _2);
        _0 = ComparisonResults { lt: move _3, le: move _4, gt: move _5, ge: move _6, eq: move _7, ne: move _8 };
        return;
    }
}

fn compare_au8(_1: *const [u8], _2: *const [u8]) -> ComparisonResults {
    debug a => _1;
    debug b => _2;
    let mut _0: ComparisonResults;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;

    bb0: {
        _3 = Lt(_1, _2);
        _4 = Le(_1, _2);
        _5 = Gt(_1, _2);
        _6 = Ge(_1, _2);
        _7 = Eq(_1, _2);
        _8 = Ne(_1, _2);
        _0 = ComparisonResults { lt: move _3, le: move _4, gt: move _5, ge: move _6, eq: move _7, ne: move _8 };
        return;
    }
}

fn compare_foo(_1: *const dyn Foo, _2: *const dyn Foo) -> ComparisonResults {
    debug a => _1;
    debug b => _2;
    let mut _0: ComparisonResults;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;

    bb0: {
        _3 = Lt(_1, _2);
        _4 = Le(_1, _2);
        _5 = Gt(_1, _2);
        _6 = Ge(_1, _2);
        _7 = Eq(_1, _2);
        _8 = Ne(_1, _2);
        _0 = ComparisonResults { lt: move _3, le: move _4, gt: move _5, ge: move _6, eq: move _7, ne: move _8 };
        return;
    }
}

fn simple_eq(_1: *const dyn Foo, _2: *const dyn Foo) -> bool {
    debug a => _1;
    debug b => _2;
    let mut _0: bool;
    scope 1 {
        debug result => _0;
    }

    bb0: {
        _0 = Eq(_1, _2);
        return;
    }
}

fn assert_inorder(_1: &[T], _2: fn(T, T) -> ComparisonResults) -> () {
    debug a => _1;
    debug compare => _2;
    let mut _0: ();
    let mut _3: std::ops::Range<usize>;
    let mut _4: std::ops::Range<usize>;
    let mut _5: usize;
    let mut _6: std::ops::Range<usize>;
    let mut _7: std::option::Option<usize>;
    let mut _8: &mut std::ops::Range<usize>;
    let mut _9: isize;
    let mut _11: std::ops::Range<usize>;
    let mut _12: std::ops::Range<usize>;
    let mut _13: usize;
    let mut _15: std::option::Option<usize>;
    let mut _16: &mut std::ops::Range<usize>;
    let mut _17: isize;
    let mut _20: T;
    let mut _21: usize;
    let mut _22: bool;
    let mut _23: T;
    let mut _24: usize;
    let mut _25: bool;
    let mut _26: bool;
    let mut _27: (&ComparisonResults, &ComparisonResults);
    let mut _28: &ComparisonResults;
    let mut _31: bool;
    let mut _32: bool;
    let _34: !;
    let mut _35: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _36: bool;
    let mut _37: (&ComparisonResults, &ComparisonResults);
    let mut _38: &ComparisonResults;
    let mut _41: bool;
    let mut _42: bool;
    let _44: !;
    let mut _45: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _46: (&ComparisonResults, &ComparisonResults);
    let mut _47: &ComparisonResults;
    let mut _50: bool;
    let mut _51: bool;
    let _53: !;
    let mut _54: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug iter => _6;
        let _10: usize;
        scope 2 {
            debug i => _10;
            let mut _14: std::ops::Range<usize>;
            scope 3 {
                debug iter => _14;
                let _18: usize;
                scope 4 {
                    debug j => _18;
                    let _19: ComparisonResults;
                    scope 5 {
                        debug cres => _19;
                        let _29: &ComparisonResults;
                        let _30: &ComparisonResults;
                        let _39: &ComparisonResults;
                        let _40: &ComparisonResults;
                        let _48: &ComparisonResults;
                        let _49: &ComparisonResults;
                        let mut _55: &ComparisonResults;
                        let mut _56: &ComparisonResults;
                        let mut _57: &ComparisonResults;
                        scope 6 {
                            debug left_val => _29;
                            debug right_val => _30;
                            let _33: core::panicking::AssertKind;
                            scope 7 {
                                debug kind => _33;
                            }
                        }
                        scope 8 {
                            debug left_val => _39;
                            debug right_val => _40;
                            let _43: core::panicking::AssertKind;
                            scope 9 {
                                debug kind => _43;
                            }
                        }
                        scope 10 {
                            debug left_val => _48;
                            debug right_val => _49;
                            let _52: core::panicking::AssertKind;
                            scope 11 {
                                debug kind => _52;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _5 = Len((*_1));
        _4 = std::ops::Range::<usize> { start: const 0_usize, end: move _5 };
        _3 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = move _3;
        goto -> bb2;
    }

    bb2: {
        _8 = &mut _6;
        _7 = <std::ops::Range<usize> as Iterator>::next(_8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _10 = ((_7 as Some).0: usize);
        _13 = Len((*_1));
        _12 = std::ops::Range::<usize> { start: const 0_usize, end: move _13 };
        _11 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _12) -> [return: bb7, unwind continue];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        return;
    }

    bb7: {
        _14 = move _11;
        goto -> bb8;
    }

    bb8: {
        _16 = &mut _14;
        _15 = <std::ops::Range<usize> as Iterator>::next(_16) -> [return: bb9, unwind continue];
    }

    bb9: {
        _17 = discriminant(_15);
        switchInt(move _17) -> [0: bb2, 1: bb10, otherwise: bb5];
    }

    bb10: {
        _18 = ((_15 as Some).0: usize);
        _21 = Len((*_1));
        _22 = Lt(_10, _21);
        assert(move _22, "index out of bounds: the length is {} but the index is {}", move _21, _10) -> [success: bb11, unwind continue];
    }

    bb11: {
        _20 = (*_1)[_10];
        _24 = Len((*_1));
        _25 = Lt(_18, _24);
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _18) -> [success: bb12, unwind continue];
    }

    bb12: {
        _23 = (*_1)[_18];
        _19 = _2(move _20, move _23) -> [return: bb13, unwind continue];
    }

    bb13: {
        _26 = Lt(_10, _18);
        switchInt(move _26) -> [0: bb17, otherwise: bb14];
    }

    bb14: {
        _28 = &_19;
        _55 = const _;
        _27 = (move _28, _55);
        _29 = (_27.0: &ComparisonResults);
        _30 = (_27.1: &ComparisonResults);
        _32 = <ComparisonResults as PartialEq>::eq(_29, _30) -> [return: bb15, unwind continue];
    }

    bb15: {
        _31 = Not(move _32);
        switchInt(move _31) -> [0: bb8, otherwise: bb16];
    }

    bb16: {
        _33 = core::panicking::AssertKind::Eq;
        _35 = Option::<Arguments<'_>>::None;
        _34 = core::panicking::assert_failed::<ComparisonResults, ComparisonResults>(move _33, _29, _30, move _35) -> unwind continue;
    }

    bb17: {
        _36 = Eq(_10, _18);
        switchInt(move _36) -> [0: bb21, otherwise: bb18];
    }

    bb18: {
        _38 = &_19;
        _56 = const _;
        _37 = (move _38, _56);
        _39 = (_37.0: &ComparisonResults);
        _40 = (_37.1: &ComparisonResults);
        _42 = <ComparisonResults as PartialEq>::eq(_39, _40) -> [return: bb19, unwind continue];
    }

    bb19: {
        _41 = Not(move _42);
        switchInt(move _41) -> [0: bb8, otherwise: bb20];
    }

    bb20: {
        _43 = core::panicking::AssertKind::Eq;
        _45 = Option::<Arguments<'_>>::None;
        _44 = core::panicking::assert_failed::<ComparisonResults, ComparisonResults>(move _43, _39, _40, move _45) -> unwind continue;
    }

    bb21: {
        _47 = &_19;
        _57 = const _;
        _46 = (move _47, _57);
        _48 = (_46.0: &ComparisonResults);
        _49 = (_46.1: &ComparisonResults);
        _51 = <ComparisonResults as PartialEq>::eq(_48, _49) -> [return: bb22, unwind continue];
    }

    bb22: {
        _50 = Not(move _51);
        switchInt(move _50) -> [0: bb8, otherwise: bb23];
    }

    bb23: {
        _52 = core::panicking::AssertKind::Eq;
        _54 = Option::<Arguments<'_>>::None;
        _53 = core::panicking::assert_failed::<ComparisonResults, ComparisonResults>(move _52, _48, _49, move _54) -> unwind continue;
    }
}

promoted[0] in assert_inorder: &ComparisonResults = {
    let mut _0: &ComparisonResults;
    let mut _1: ComparisonResults;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in assert_inorder: &ComparisonResults = {
    let mut _0: &ComparisonResults;
    let mut _1: ComparisonResults;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in assert_inorder: &ComparisonResults = {
    let mut _0: &ComparisonResults;
    let mut _1: ComparisonResults;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn <impl at ui/mir/mir_raw_fat_ptr.rs:100:1: 100:18>::foo(_1: &T) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = std::mem::size_of::<T>() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn main_ref() -> () {
    let mut _0: ();
    let _1: [u8; 5];
    let mut _4: std::boxed::Box<[*const [u8]]>;
    let mut _5: std::boxed::Box<[*const [u8]; 4]>;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: *mut u8;
    let mut _9: std::boxed::Box<[*const [u8]; 4]>;
    let mut _10: *const [u8];
    let _11: &[u8];
    let _12: &[u8];
    let mut _13: &[u8; 5];
    let mut _14: std::ops::Range<usize>;
    let mut _15: *const [u8];
    let _16: &[u8];
    let _17: &[u8];
    let mut _18: &[u8; 5];
    let mut _19: std::ops::Range<usize>;
    let mut _20: *const [u8];
    let mut _21: *const [u8; 5];
    let _22: &[u8; 5];
    let mut _23: *const [u8];
    let _24: &[u8];
    let _25: &[u8];
    let mut _26: &[u8; 5];
    let mut _27: std::ops::RangeFrom<usize>;
    let mut _29: *const u8;
    let mut _30: *const [u8];
    let mut _31: *const [u8; 5];
    let _32: &[u8; 5];
    let mut _34: *const u8;
    let mut _35: *const [u8];
    let mut _36: *const [u8; 5];
    let _37: &[u8; 5];
    let mut _38: bool;
    let _39: ();
    let mut _40: &mut std::vec::Vec<*const [u8]>;
    let mut _41: *const [u8];
    let mut _42: *const [u8; 5];
    let _43: &[u8; 5];
    let _44: ();
    let mut _45: &mut std::vec::Vec<*const [u8]>;
    let mut _46: *const [u8];
    let mut _47: *const [u8; 5];
    let _48: &[u8; 5];
    let _49: ();
    let mut _50: &[*const [u8]];
    let _51: &[*const [u8]];
    let _52: &std::vec::Vec<*const [u8]>;
    let mut _53: fn(*const [u8], *const [u8]) -> ComparisonResults;
    let mut _57: &mut [*const dyn Foo; 4];
    let mut _58: [*const dyn Foo; 4];
    let mut _59: *const dyn Foo;
    let mut _60: *const (u8, u8);
    let _61: &(u8, u8);
    let mut _62: *const dyn Foo;
    let mut _63: *const u8;
    let _64: &u8;
    let mut _65: *const dyn Foo;
    let mut _66: *const (u32, u32);
    let _67: &(u32, u32);
    let mut _68: *const dyn Foo;
    let mut _69: *const u32;
    let _70: &u32;
    let _71: ();
    let _72: ();
    let mut _73: &[*const dyn Foo];
    let mut _74: for<'a> fn(*const (dyn Foo + 'a), *const (dyn Foo + 'a)) -> ComparisonResults;
    let mut _76: S<[u8; 2]>;
    let mut _77: [u8; 2];
    let mut _78: S<[u8; 3]>;
    let mut _79: [u8; 3];
    let mut _80: S<[u8; 2]>;
    let mut _81: [u8; 2];
    let _82: ();
    let mut _83: &[*const S<[u8]>];
    let _84: &[*const S<[u8]>; 3];
    let _85: [*const S<[u8]>; 3];
    let mut _86: *const S<[u8]>;
    let mut _87: *const S<[u8; 2]>;
    let _88: &S<[u8; 2]>;
    let mut _89: *const S<[u8]>;
    let mut _90: *const S<[u8; 3]>;
    let _91: &S<[u8; 3]>;
    let mut _92: *const S<[u8]>;
    let mut _93: *const S<[u8; 2]>;
    let _94: &S<[u8; 2]>;
    let mut _95: fn(*const S<[u8]>, *const S<[u8]>) -> ComparisonResults;
    let mut _96: bool;
    let mut _97: bool;
    let mut _98: *const dyn Foo;
    let mut _99: *const u8;
    let mut _100: *const dyn Foo;
    let mut _101: *const u8;
    let mut _102: !;
    let mut _103: bool;
    let mut _104: bool;
    let mut _105: bool;
    let mut _106: *const dyn Foo;
    let mut _107: *const u8;
    let mut _108: *const dyn Foo;
    let mut _109: *const u8;
    let mut _110: !;
    let mut _115: &mut std::boxed::Box<[*const [u8]; 4]>;
    let mut _116: ();
    let mut _117: *const [*const [u8]; 4];
    scope 1 {
        debug array => _1;
        let _2: [u8; 5];
        scope 2 {
            debug array2 => _2;
            let mut _3: std::vec::Vec<*const [u8]>;
            let mut _118: *const ();
            let mut _119: usize;
            let mut _120: usize;
            let mut _121: usize;
            let mut _122: usize;
            let mut _123: bool;
            scope 3 {
                debug ptrs => _3;
                let _28: usize;
                scope 5 {
                    debug array_addr => _28;
                    let _33: usize;
                    scope 6 {
                        debug array2_addr => _33;
                        let _54: (u8, u8);
                        scope 7 {
                            debug u8_ => _54;
                            let _55: (u32, u32);
                            scope 8 {
                                debug u32_ => _55;
                                let _56: &mut [*const dyn Foo];
                                scope 9 {
                                    debug buf => _56;
                                    let _75: (S<[u8; 2]>, S<[u8; 3]>, S<[u8; 2]>);
                                    scope 10 {
                                        debug ss => _75;
                                        let mut _111: &u8;
                                        let mut _112: &u8;
                                        let mut _113: &u8;
                                        let mut _114: &u8;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            scope 4 {
            }
        }
    }

    bb0: {
        _1 = [const 0_u8, const 1_u8, const 2_u8, const 3_u8, const 4_u8];
        _2 = [const 5_u8, const 6_u8, const 7_u8, const 8_u8, const 9_u8];
        _6 = SizeOf([*const [u8]; 4]);
        _7 = AlignOf([*const [u8]; 4]);
        _8 = alloc::alloc::exchange_malloc(move _6, move _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = ShallowInitBox(move _8, [*const [u8]; 4]);
        _13 = &_1;
        _14 = std::ops::Range::<usize> { start: const 0_usize, end: const 0_usize };
        _12 = <[u8; 5] as Index<std::ops::Range<usize>>>::index(move _13, move _14) -> [return: bb2, unwind: bb23];
    }

    bb2: {
        _11 = _12;
        _10 = &raw const (*_11);
        _18 = &_1;
        _19 = std::ops::Range::<usize> { start: const 0_usize, end: const 1_usize };
        _17 = <[u8; 5] as Index<std::ops::Range<usize>>>::index(move _18, move _19) -> [return: bb3, unwind: bb23];
    }

    bb3: {
        _16 = _17;
        _15 = &raw const (*_16);
        _22 = &_1;
        _21 = &raw const (*_22);
        _20 = move _21 as *const [u8] (Pointer(Unsize));
        _26 = &_1;
        _27 = RangeFrom::<usize> { start: const 1_usize };
        _25 = <[u8; 5] as Index<RangeFrom<usize>>>::index(move _26, move _27) -> [return: bb4, unwind: bb23];
    }

    bb4: {
        _24 = _25;
        _23 = &raw const (*_24);
        _117 = (((_9.0: std::ptr::Unique<[*const [u8]; 4]>).0: std::ptr::NonNull<[*const [u8]; 4]>).0: *const [*const [u8]; 4]);
        _118 = _117 as *const () (PtrToPtr);
        _119 = _118 as usize (Transmute);
        _120 = AlignOf(*const [u8]);
        _121 = Sub(_120, const 1_usize);
        _122 = BitAnd(_119, _121);
        _123 = Eq(_122, const 0_usize);
        assert(_123, "misaligned pointer dereference: address must be a multiple of {} but is {}", _120, _119) -> [success: bb24, unwind unreachable];
    }

    bb5: {
        _32 = &_1;
        _31 = &raw const (*_32);
        _30 = move _31 as *const [u8] (Pointer(Unsize));
        _29 = move _30 as *const u8 (PtrToPtr);
        _28 = move _29 as usize (PointerExposeAddress);
        _37 = &_2;
        _36 = &raw const (*_37);
        _35 = move _36 as *const [u8] (Pointer(Unsize));
        _34 = move _35 as *const u8 (PtrToPtr);
        _33 = move _34 as usize (PointerExposeAddress);
        _38 = Lt(_33, _28);
        switchInt(move _38) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _40 = &mut _3;
        _43 = &_2;
        _42 = &raw const (*_43);
        _41 = move _42 as *const [u8] (Pointer(Unsize));
        _39 = Vec::<*const [u8]>::insert(move _40, const 0_usize, move _41) -> [return: bb25, unwind: bb21];
    }

    bb7: {
        _45 = &mut _3;
        _48 = &_2;
        _47 = &raw const (*_48);
        _46 = move _47 as *const [u8] (Pointer(Unsize));
        _44 = Vec::<*const [u8]>::push(move _45, move _46) -> [return: bb26, unwind: bb21];
    }

    bb8: {
        _52 = &_3;
        _51 = <Vec<*const [u8]> as Deref>::deref(_52) -> [return: bb9, unwind: bb21];
    }

    bb9: {
        _50 = _51;
        _53 = compare_au8 as fn(*const [u8], *const [u8]) -> ComparisonResults (Pointer(ReifyFnPointer));
        _49 = assert_inorder::<*const [u8]>(move _50, move _53) -> [return: bb10, unwind: bb21];
    }

    bb10: {
        _54 = (const 0_u8, const 1_u8);
        _55 = (const 4_u32, const 5_u32);
        _61 = &_54;
        _60 = &raw const (*_61);
        _59 = move _60 as *const dyn Foo (Pointer(Unsize));
        _64 = &(_54.0: u8);
        _63 = &raw const (*_64);
        _62 = move _63 as *const dyn Foo (Pointer(Unsize));
        _67 = &_55;
        _66 = &raw const (*_67);
        _65 = move _66 as *const dyn Foo (Pointer(Unsize));
        _70 = &(_55.0: u32);
        _69 = &raw const (*_70);
        _68 = move _69 as *const dyn Foo (Pointer(Unsize));
        _58 = [move _59, move _62, move _65, move _68];
        _57 = &mut _58;
        _56 = _57 as &mut [*const dyn Foo] (Pointer(Unsize));
        _71 = slice::<impl [*const dyn Foo]>::sort_by::<[closure@ui/mir/mir_raw_fat_ptr.rs:137:17: 137:22]>(_56, const ZeroSized: [closure@ui/mir/mir_raw_fat_ptr.rs:137:17: 137:22]) -> [return: bb11, unwind: bb21];
    }

    bb11: {
        _73 = &(*_56);
        _74 = compare_foo as for<'a> fn(*const (dyn Foo + 'a), *const (dyn Foo + 'a)) -> ComparisonResults (Pointer(ReifyFnPointer));
        _72 = assert_inorder::<*const dyn Foo>(move _73, move _74) -> [return: bb12, unwind: bb21];
    }

    bb12: {
        _77 = [const 8_u8, const 9_u8];
        _76 = S::<[u8; 2]>(const 7_u32, move _77);
        _79 = [const 11_u8, const 12_u8, const 13_u8];
        _78 = S::<[u8; 3]>(const 10_u32, move _79);
        _81 = [const 5_u8, const 6_u8];
        _80 = S::<[u8; 2]>(const 4_u32, move _81);
        _75 = (move _76, move _78, move _80);
        _88 = &(_75.0: S<[u8; 2]>);
        _87 = &raw const (*_88);
        _86 = move _87 as *const S<[u8]> (Pointer(Unsize));
        _91 = &(_75.1: S<[u8; 3]>);
        _90 = &raw const (*_91);
        _89 = move _90 as *const S<[u8]> (Pointer(Unsize));
        _94 = &(_75.2: S<[u8; 2]>);
        _93 = &raw const (*_94);
        _92 = move _93 as *const S<[u8]> (Pointer(Unsize));
        _85 = [move _86, move _89, move _92];
        _84 = &_85;
        _83 = _84 as &[*const S<[u8]>] (Pointer(Unsize));
        _95 = compare_su8 as fn(*const S<[u8]>, *const S<[u8]>) -> ComparisonResults (Pointer(ReifyFnPointer));
        _82 = assert_inorder::<*const S<[u8]>>(move _83, move _95) -> [return: bb13, unwind: bb21];
    }

    bb13: {
        _114 = const _;
        _99 = &raw const (*_114);
        _98 = move _99 as *const dyn Foo (Pointer(Unsize));
        _113 = const _;
        _101 = &raw const (*_113);
        _100 = move _101 as *const dyn Foo (Pointer(Unsize));
        _97 = simple_eq(_98, _100) -> [return: bb14, unwind: bb21];
    }

    bb14: {
        _96 = Not(move _97);
        switchInt(move _96) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _102 = core::panicking::panic(const "assertion failed: simple_eq(&0u8 as *const _, &0u8 as *const _)") -> bb21;
    }

    bb16: {
        _112 = const _;
        _107 = &raw const (*_112);
        _106 = move _107 as *const dyn Foo (Pointer(Unsize));
        _111 = const _;
        _109 = &raw const (*_111);
        _108 = move _109 as *const dyn Foo (Pointer(Unsize));
        _105 = simple_eq(_106, _108) -> [return: bb17, unwind: bb21];
    }

    bb17: {
        _104 = Not(move _105);
        _103 = Not(move _104);
        switchInt(move _103) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _110 = core::panicking::panic(const "assertion failed: !simple_eq(&0u8 as *const _, &1u8 as *const _)") -> bb21;
    }

    bb19: {
        drop(_3) -> [return: bb20, unwind continue];
    }

    bb20: {
        return;
    }

    bb21 (cleanup): {
        drop(_3) -> [return: bb22, unwind terminate];
    }

    bb22 (cleanup): {
        resume;
    }

    bb23 (cleanup): {
        _115 = &mut _9;
        _116 = <Box<[*const [u8]; 4]> as Drop>::drop(move _115) -> [return: bb27, unwind terminate];
    }

    bb24: {
        (*_117) = [move _10, move _15, move _20, move _23];
        _5 = move _9;
        _4 = move _5 as std::boxed::Box<[*const [u8]]> (Pointer(Unsize));
        _3 = slice::<impl [*const [u8]]>::into_vec::<std::alloc::Global>(move _4) -> [return: bb5, unwind continue];
    }

    bb25: {
        goto -> bb8;
    }

    bb26: {
        goto -> bb8;
    }

    bb27 (cleanup): {
        goto -> bb22;
    }
}

promoted[0] in main_ref: &u8 = {
    let mut _0: &u8;
    let mut _1: u8;

    bb0: {
        _1 = const 1_u8;
        _0 = &_1;
        return;
    }
}

promoted[1] in main_ref: &u8 = {
    let mut _0: &u8;
    let mut _1: u8;

    bb0: {
        _1 = const 0_u8;
        _0 = &_1;
        return;
    }
}

promoted[2] in main_ref: &u8 = {
    let mut _0: &u8;
    let mut _1: u8;

    bb0: {
        _1 = const 0_u8;
        _0 = &_1;
        return;
    }
}

promoted[3] in main_ref: &u8 = {
    let mut _0: &u8;
    let mut _1: u8;

    bb0: {
        _1 = const 0_u8;
        _0 = &_1;
        return;
    }
}

fn main_ref::{closure#0}(_1: &mut [closure@ui/mir/mir_raw_fat_ptr.rs:137:17: 137:22], _2: &*const dyn Foo, _3: &*const dyn Foo) -> std::cmp::Ordering {
    debug u => _2;
    debug v => _3;
    let mut _0: std::cmp::Ordering;
    let _4: [*const (); 2];
    let mut _5: *const dyn Foo;
    let mut _7: *const dyn Foo;
    let mut _8: &[*const (); 2];
    let _9: &[*const (); 2];
    scope 1 {
        debug u => _4;
        let _6: [*const (); 2];
        scope 3 {
            debug v => _6;
        }
        scope 4 {
        }
    }
    scope 2 {
    }

    bb0: {
        _5 = (*_2);
        _4 = move _5 as [*const (); 2] (Transmute);
        _7 = (*_3);
        _6 = move _7 as [*const (); 2] (Transmute);
        _8 = &_4;
        _9 = &_6;
        _0 = <[*const (); 2] as Ord>::cmp(move _8, _9) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

main_ref::{closure#0}::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

main_ref::{closure#0}::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

main_ref::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

main_ref::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 3_usize;
        return;
    }
}

main_ref::{constant#2}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

fn main_raw() -> () {
    let mut _0: ();
    let _1: [u8; 5];
    let mut _4: std::boxed::Box<[*const [u8]]>;
    let mut _5: std::boxed::Box<[*const [u8]; 4]>;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: *mut u8;
    let mut _9: std::boxed::Box<[*const [u8]; 4]>;
    let mut _10: *const [u8];
    let _11: &[u8];
    let mut _12: &[u8; 5];
    let mut _13: std::ops::Range<usize>;
    let mut _14: *const [u8];
    let _15: &[u8];
    let mut _16: &[u8; 5];
    let mut _17: std::ops::Range<usize>;
    let mut _18: *const [u8];
    let mut _19: *const [u8; 5];
    let mut _20: *const [u8];
    let _21: &[u8];
    let mut _22: &[u8; 5];
    let mut _23: std::ops::RangeFrom<usize>;
    let mut _25: *const u8;
    let mut _26: *const [u8; 5];
    let mut _28: *const u8;
    let mut _29: *const [u8; 5];
    let mut _30: bool;
    let _31: ();
    let mut _32: &mut std::vec::Vec<*const [u8]>;
    let mut _33: *const [u8];
    let mut _34: *const [u8; 5];
    let _35: ();
    let mut _36: &mut std::vec::Vec<*const [u8]>;
    let mut _37: *const [u8];
    let mut _38: *const [u8; 5];
    let _39: ();
    let mut _40: &[*const [u8]];
    let _41: &[*const [u8]];
    let _42: &std::vec::Vec<*const [u8]>;
    let mut _43: fn(*const [u8], *const [u8]) -> ComparisonResults;
    let mut _47: &mut [*const dyn Foo; 4];
    let mut _48: [*const dyn Foo; 4];
    let mut _49: *const dyn Foo;
    let mut _50: *const (u8, u8);
    let mut _51: *const dyn Foo;
    let mut _52: *const u8;
    let mut _53: *const dyn Foo;
    let mut _54: *const (u32, u32);
    let mut _55: *const dyn Foo;
    let mut _56: *const u32;
    let _57: ();
    let _58: ();
    let mut _59: &[*const dyn Foo];
    let mut _60: for<'a> fn(*const (dyn Foo + 'a), *const (dyn Foo + 'a)) -> ComparisonResults;
    let mut _62: S<[u8; 2]>;
    let mut _63: [u8; 2];
    let mut _64: S<[u8; 3]>;
    let mut _65: [u8; 3];
    let mut _66: S<[u8; 2]>;
    let mut _67: [u8; 2];
    let _68: ();
    let mut _69: &[*const S<[u8]>];
    let _70: &[*const S<[u8]>; 3];
    let _71: [*const S<[u8]>; 3];
    let mut _72: *const S<[u8]>;
    let mut _73: *const S<[u8; 2]>;
    let mut _74: *const S<[u8]>;
    let mut _75: *const S<[u8; 3]>;
    let mut _76: *const S<[u8]>;
    let mut _77: *const S<[u8; 2]>;
    let mut _78: fn(*const S<[u8]>, *const S<[u8]>) -> ComparisonResults;
    let mut _79: &mut std::boxed::Box<[*const [u8]; 4]>;
    let mut _80: ();
    let mut _81: *const [*const [u8]; 4];
    scope 1 {
        debug array => _1;
        let _2: [u8; 5];
        scope 2 {
            debug array2 => _2;
            let mut _3: std::vec::Vec<*const [u8]>;
            let mut _82: *const ();
            let mut _83: usize;
            let mut _84: usize;
            let mut _85: usize;
            let mut _86: usize;
            let mut _87: bool;
            scope 3 {
                debug ptrs => _3;
                let _24: usize;
                scope 5 {
                    debug array_addr => _24;
                    let _27: usize;
                    scope 6 {
                        debug array2_addr => _27;
                        let _44: (u8, u8);
                        scope 7 {
                            debug u8_ => _44;
                            let _45: (u32, u32);
                            scope 8 {
                                debug u32_ => _45;
                                let _46: &mut [*const dyn Foo];
                                scope 9 {
                                    debug buf => _46;
                                    let _61: (S<[u8; 2]>, S<[u8; 3]>, S<[u8; 2]>);
                                    scope 10 {
                                        debug ss => _61;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            scope 4 {
            }
        }
    }

    bb0: {
        _1 = [const 0_u8, const 1_u8, const 2_u8, const 3_u8, const 4_u8];
        _2 = [const 5_u8, const 6_u8, const 7_u8, const 8_u8, const 9_u8];
        _6 = SizeOf([*const [u8]; 4]);
        _7 = AlignOf([*const [u8]; 4]);
        _8 = alloc::alloc::exchange_malloc(move _6, move _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = ShallowInitBox(move _8, [*const [u8]; 4]);
        _12 = &_1;
        _13 = std::ops::Range::<usize> { start: const 0_usize, end: const 0_usize };
        _11 = <[u8; 5] as Index<std::ops::Range<usize>>>::index(move _12, move _13) -> [return: bb2, unwind: bb17];
    }

    bb2: {
        _10 = &raw const (*_11);
        _16 = &_1;
        _17 = std::ops::Range::<usize> { start: const 0_usize, end: const 1_usize };
        _15 = <[u8; 5] as Index<std::ops::Range<usize>>>::index(move _16, move _17) -> [return: bb3, unwind: bb17];
    }

    bb3: {
        _14 = &raw const (*_15);
        _19 = &raw const _1;
        _18 = move _19 as *const [u8] (Pointer(Unsize));
        _22 = &_1;
        _23 = RangeFrom::<usize> { start: const 1_usize };
        _21 = <[u8; 5] as Index<RangeFrom<usize>>>::index(move _22, move _23) -> [return: bb4, unwind: bb17];
    }

    bb4: {
        _20 = &raw const (*_21);
        _81 = (((_9.0: std::ptr::Unique<[*const [u8]; 4]>).0: std::ptr::NonNull<[*const [u8]; 4]>).0: *const [*const [u8]; 4]);
        _82 = _81 as *const () (PtrToPtr);
        _83 = _82 as usize (Transmute);
        _84 = AlignOf(*const [u8]);
        _85 = Sub(_84, const 1_usize);
        _86 = BitAnd(_83, _85);
        _87 = Eq(_86, const 0_usize);
        assert(_87, "misaligned pointer dereference: address must be a multiple of {} but is {}", _84, _83) -> [success: bb18, unwind unreachable];
    }

    bb5: {
        _26 = &raw const _1;
        _25 = move _26 as *const u8 (PtrToPtr);
        _24 = move _25 as usize (PointerExposeAddress);
        _29 = &raw const _2;
        _28 = move _29 as *const u8 (PtrToPtr);
        _27 = move _28 as usize (PointerExposeAddress);
        _30 = Lt(_27, _24);
        switchInt(move _30) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _32 = &mut _3;
        _34 = &raw const _2;
        _33 = move _34 as *const [u8] (Pointer(Unsize));
        _31 = Vec::<*const [u8]>::insert(move _32, const 0_usize, move _33) -> [return: bb19, unwind: bb15];
    }

    bb7: {
        _36 = &mut _3;
        _38 = &raw const _2;
        _37 = move _38 as *const [u8] (Pointer(Unsize));
        _35 = Vec::<*const [u8]>::push(move _36, move _37) -> [return: bb20, unwind: bb15];
    }

    bb8: {
        _42 = &_3;
        _41 = <Vec<*const [u8]> as Deref>::deref(_42) -> [return: bb9, unwind: bb15];
    }

    bb9: {
        _40 = _41;
        _43 = compare_au8 as fn(*const [u8], *const [u8]) -> ComparisonResults (Pointer(ReifyFnPointer));
        _39 = assert_inorder::<*const [u8]>(move _40, move _43) -> [return: bb10, unwind: bb15];
    }

    bb10: {
        _44 = (const 0_u8, const 1_u8);
        _45 = (const 4_u32, const 5_u32);
        _50 = &raw const _44;
        _49 = move _50 as *const dyn Foo (Pointer(Unsize));
        _52 = &raw const (_44.0: u8);
        _51 = move _52 as *const dyn Foo (Pointer(Unsize));
        _54 = &raw const _45;
        _53 = move _54 as *const dyn Foo (Pointer(Unsize));
        _56 = &raw const (_45.0: u32);
        _55 = move _56 as *const dyn Foo (Pointer(Unsize));
        _48 = [move _49, move _51, move _53, move _55];
        _47 = &mut _48;
        _46 = _47 as &mut [*const dyn Foo] (Pointer(Unsize));
        _57 = slice::<impl [*const dyn Foo]>::sort_by::<[closure@ui/mir/mir_raw_fat_ptr.rs:191:17: 191:22]>(_46, const ZeroSized: [closure@ui/mir/mir_raw_fat_ptr.rs:191:17: 191:22]) -> [return: bb11, unwind: bb15];
    }

    bb11: {
        _59 = &(*_46);
        _60 = compare_foo as for<'a> fn(*const (dyn Foo + 'a), *const (dyn Foo + 'a)) -> ComparisonResults (Pointer(ReifyFnPointer));
        _58 = assert_inorder::<*const dyn Foo>(move _59, move _60) -> [return: bb12, unwind: bb15];
    }

    bb12: {
        _63 = [const 8_u8, const 9_u8];
        _62 = S::<[u8; 2]>(const 7_u32, move _63);
        _65 = [const 11_u8, const 12_u8, const 13_u8];
        _64 = S::<[u8; 3]>(const 10_u32, move _65);
        _67 = [const 5_u8, const 6_u8];
        _66 = S::<[u8; 2]>(const 4_u32, move _67);
        _61 = (move _62, move _64, move _66);
        _73 = &raw const (_61.0: S<[u8; 2]>);
        _72 = move _73 as *const S<[u8]> (Pointer(Unsize));
        _75 = &raw const (_61.1: S<[u8; 3]>);
        _74 = move _75 as *const S<[u8]> (Pointer(Unsize));
        _77 = &raw const (_61.2: S<[u8; 2]>);
        _76 = move _77 as *const S<[u8]> (Pointer(Unsize));
        _71 = [move _72, move _74, move _76];
        _70 = &_71;
        _69 = _70 as &[*const S<[u8]>] (Pointer(Unsize));
        _78 = compare_su8 as fn(*const S<[u8]>, *const S<[u8]>) -> ComparisonResults (Pointer(ReifyFnPointer));
        _68 = assert_inorder::<*const S<[u8]>>(move _69, move _78) -> [return: bb13, unwind: bb15];
    }

    bb13: {
        drop(_3) -> [return: bb14, unwind continue];
    }

    bb14: {
        return;
    }

    bb15 (cleanup): {
        drop(_3) -> [return: bb16, unwind terminate];
    }

    bb16 (cleanup): {
        resume;
    }

    bb17 (cleanup): {
        _79 = &mut _9;
        _80 = <Box<[*const [u8]; 4]> as Drop>::drop(move _79) -> [return: bb21, unwind terminate];
    }

    bb18: {
        (*_81) = [move _10, move _14, move _18, move _20];
        _5 = move _9;
        _4 = move _5 as std::boxed::Box<[*const [u8]]> (Pointer(Unsize));
        _3 = slice::<impl [*const [u8]]>::into_vec::<std::alloc::Global>(move _4) -> [return: bb5, unwind continue];
    }

    bb19: {
        goto -> bb8;
    }

    bb20: {
        goto -> bb8;
    }

    bb21 (cleanup): {
        goto -> bb16;
    }
}

fn main_raw::{closure#0}(_1: &mut [closure@ui/mir/mir_raw_fat_ptr.rs:191:17: 191:22], _2: &*const dyn Foo, _3: &*const dyn Foo) -> std::cmp::Ordering {
    debug u => _2;
    debug v => _3;
    let mut _0: std::cmp::Ordering;
    let _4: [*const (); 2];
    let mut _5: *const dyn Foo;
    let mut _7: *const dyn Foo;
    let mut _8: &[*const (); 2];
    let _9: &[*const (); 2];
    scope 1 {
        debug u => _4;
        let _6: [*const (); 2];
        scope 3 {
            debug v => _6;
        }
        scope 4 {
        }
    }
    scope 2 {
    }

    bb0: {
        _5 = (*_2);
        _4 = move _5 as [*const (); 2] (Transmute);
        _7 = (*_3);
        _6 = move _7 as [*const (); 2] (Transmute);
        _8 = &_4;
        _9 = &_6;
        _0 = <[*const (); 2] as Ord>::cmp(move _8, _9) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

main_raw::{closure#0}::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

main_raw::{closure#0}::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

main_raw::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

main_raw::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 3_usize;
        return;
    }
}

main_raw::{constant#2}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: ();
    let _2: ();

    bb0: {
        _1 = main_ref() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = main_raw() -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn S(_1: u32, _2: T) -> S<T> {
    let mut _0: S<T>;

    bb0: {
        _0 = S::<T>(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn S(_1: u32, _2: T) -> S<T> {
    let mut _0: S<T>;

    bb0: {
        _0 = S::<T>(move _1, move _2);
        return;
    }
}
