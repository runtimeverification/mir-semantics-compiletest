// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/borrowck/borrowck-mut-uniq.rs:5:10: 5:15>::fmt(_1: &Ints, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &std::boxed::Box<isize>;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&std::vec::Vec<isize>;
    let _10: &std::vec::Vec<isize>;

    bb0: {
        _3 = const "Ints";
        _4 = const "sum";
        _6 = &((*_1).0: std::boxed::Box<isize>);
        _5 = _6 as &dyn std::fmt::Debug (Pointer(Unsize));
        _7 = const "values";
        _10 = &((*_1).1: std::vec::Vec<isize>);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (Pointer(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn add_int(_1: &mut Ints, _2: isize) -> () {
    debug x => _1;
    debug v => _2;
    let mut _0: ();
    let mut _3: std::vec::Vec<isize>;
    let _4: ();
    let mut _5: &mut std::vec::Vec<isize>;
    let mut _6: &mut std::vec::Vec<isize>;
    let _7: ();
    let mut _8: &mut std::vec::Vec<isize>;
    let _9: ();
    let mut _10: &mut std::vec::Vec<isize>;
    let mut _11: &mut std::vec::Vec<isize>;
    let mut _12: std::boxed::Box<isize>;
    let mut _13: std::boxed::Box<isize>;
    let mut _14: *const isize;
    let mut _15: *const isize;
    let mut _16: *const ();
    let mut _17: usize;
    let mut _18: usize;
    let mut _19: usize;
    let mut _20: usize;
    let mut _21: bool;
    let mut _22: *const ();
    let mut _23: usize;
    let mut _24: usize;
    let mut _25: usize;
    let mut _26: usize;
    let mut _27: bool;
    scope 1 {
        debug values => _3;
    }

    bb0: {
        _12 = deref_copy ((*_1).0: std::boxed::Box<isize>);
        _13 = deref_copy ((*_1).0: std::boxed::Box<isize>);
        _14 = (((_12.0: std::ptr::Unique<isize>).0: std::ptr::NonNull<isize>).0: *const isize);
        _15 = (((_13.0: std::ptr::Unique<isize>).0: std::ptr::NonNull<isize>).0: *const isize);
        _22 = _15 as *const () (PtrToPtr);
        _23 = _22 as usize (Transmute);
        _24 = AlignOf(isize);
        _25 = Sub(_24, const 1_usize);
        _26 = BitAnd(_23, _25);
        _27 = Eq(_26, const 0_usize);
        assert(_27, "misaligned pointer dereference: address must be a multiple of {} but is {}", _24, _23) -> [success: bb9, unwind unreachable];
    }

    bb1: {
        _5 = &mut _3;
        _6 = &mut ((*_1).1: std::vec::Vec<isize>);
        _4 = std::mem::swap::<Vec<isize>>(_5, _6) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _8 = &mut _3;
        _7 = Vec::<isize>::push(move _8, _2) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _10 = &mut _3;
        _11 = &mut ((*_1).1: std::vec::Vec<isize>);
        _9 = std::mem::swap::<Vec<isize>>(_10, _11) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        drop(_3) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_3) -> [return: bb7, unwind terminate];
    }

    bb7 (cleanup): {
        resume;
    }

    bb8: {
        (*_14) = Add((*_15), _2);
        _3 = Vec::<isize>::new() -> [return: bb1, unwind continue];
    }

    bb9: {
        _16 = _14 as *const () (PtrToPtr);
        _17 = _16 as usize (Transmute);
        _18 = AlignOf(isize);
        _19 = Sub(_18, const 1_usize);
        _20 = BitAnd(_17, _19);
        _21 = Eq(_20, const 0_usize);
        assert(_21, "misaligned pointer dereference: address must be a multiple of {} but is {}", _18, _17) -> [success: bb8, unwind unreachable];
    }
}

fn iter_ints(_1: &Ints, _2: F) -> bool {
    debug x => _1;
    debug f => _2;
    let mut _0: bool;
    let _3: usize;
    let mut _4: &std::vec::Vec<isize>;
    let mut _5: &mut std::ops::Range<usize>;
    let mut _6: std::ops::Range<usize>;
    let mut _7: usize;
    let mut _8: [closure@ui/borrowck/borrowck-mut-uniq.rs:18:16: 18:19];
    let mut _9: &mut F;
    let mut _10: &&Ints;
    scope 1 {
        debug l => _3;
    }

    bb0: {
        _4 = &((*_1).1: std::vec::Vec<isize>);
        _3 = Vec::<isize>::len(move _4) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        _7 = _3;
        _6 = std::ops::Range::<usize> { start: const 0_usize, end: move _7 };
        _5 = &mut _6;
        _9 = &mut _2;
        _10 = &_1;
        _8 = [closure@ui/borrowck/borrowck-mut-uniq.rs:18:16: 18:19] { f: move _9, x: move _10 };
        _0 = <std::ops::Range<usize> as Iterator>::all::<[closure@ui/borrowck/borrowck-mut-uniq.rs:18:16: 18:19]>(move _5, move _8) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_2) -> [return: bb5, unwind terminate];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn iter_ints::{closure#0}(_1: &mut [closure@ui/borrowck/borrowck-mut-uniq.rs:18:16: 18:19], _2: usize) -> bool {
    debug i => _2;
    debug f => (*((*_1).0: &mut F));
    debug x => (*((*_1).1: &&Ints));
    let mut _0: bool;
    let mut _3: (&isize,);
    let _4: &isize;
    let _5: &isize;
    let mut _6: &std::vec::Vec<isize>;
    let mut _7: &mut F;
    let mut _8: &&Ints;
    let mut _9: &Ints;

    bb0: {
        _7 = deref_copy ((*_1).0: &mut F);
        _8 = deref_copy ((*_1).1: &&Ints);
        _9 = deref_copy (*_8);
        _6 = &((*_9).1: std::vec::Vec<isize>);
        _5 = <Vec<isize> as Index<usize>>::index(move _6, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = _5;
        _3 = (_4,);
        _0 = <F as FnMut<(&isize,)>>::call_mut(_7, move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let mut _1: std::boxed::Box<Ints>;
    let mut _2: Ints;
    let mut _3: std::boxed::Box<isize>;
    let mut _4: std::vec::Vec<isize>;
    let _5: ();
    let mut _6: &mut Ints;
    let _7: ();
    let mut _8: &mut Ints;
    let _9: bool;
    let _10: &Ints;
    let _11: ();
    let mut _12: std::fmt::Arguments<'_>;
    let mut _13: &[&str];
    let mut _14: &[core::fmt::rt::Argument<'_>];
    let _15: &[core::fmt::rt::Argument<'_>; 1];
    let _16: [core::fmt::rt::Argument<'_>; 1];
    let mut _17: core::fmt::rt::Argument<'_>;
    let _18: &std::boxed::Box<Ints>;
    let mut _20: *const Ints;
    let mut _21: *const Ints;
    let mut _22: *const Ints;
    scope 1 {
        debug ints => _1;
        let mut _19: &[&str; 2];
        let mut _23: *const ();
        let mut _24: usize;
        let mut _25: usize;
        let mut _26: usize;
        let mut _27: usize;
        let mut _28: bool;
        let mut _29: *const ();
        let mut _30: usize;
        let mut _31: usize;
        let mut _32: usize;
        let mut _33: usize;
        let mut _34: bool;
        let mut _35: *const ();
        let mut _36: usize;
        let mut _37: usize;
        let mut _38: usize;
        let mut _39: usize;
        let mut _40: bool;
    }

    bb0: {
        _3 = Box::<isize>::new(const 0_isize) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = Vec::<isize>::new() -> [return: bb2, unwind: bb12];
    }

    bb2: {
        _2 = Ints { sum: move _3, values: move _4 };
        _1 = Box::<Ints>::new(move _2) -> [return: bb3, unwind continue];
    }

    bb3: {
        _20 = (((_1.0: std::ptr::Unique<Ints>).0: std::ptr::NonNull<Ints>).0: *const Ints);
        _35 = _20 as *const () (PtrToPtr);
        _36 = _35 as usize (Transmute);
        _37 = AlignOf(Ints);
        _38 = Sub(_37, const 1_usize);
        _39 = BitAnd(_36, _38);
        _40 = Eq(_39, const 0_usize);
        assert(_40, "misaligned pointer dereference: address must be a multiple of {} but is {}", _37, _36) -> [success: bb16, unwind unreachable];
    }

    bb4: {
        _21 = (((_1.0: std::ptr::Unique<Ints>).0: std::ptr::NonNull<Ints>).0: *const Ints);
        _29 = _21 as *const () (PtrToPtr);
        _30 = _29 as usize (Transmute);
        _31 = AlignOf(Ints);
        _32 = Sub(_31, const 1_usize);
        _33 = BitAnd(_30, _32);
        _34 = Eq(_33, const 0_usize);
        assert(_34, "misaligned pointer dereference: address must be a multiple of {} but is {}", _31, _30) -> [success: bb15, unwind unreachable];
    }

    bb5: {
        _22 = (((_1.0: std::ptr::Unique<Ints>).0: std::ptr::NonNull<Ints>).0: *const Ints);
        _23 = _22 as *const () (PtrToPtr);
        _24 = _23 as usize (Transmute);
        _25 = AlignOf(Ints);
        _26 = Sub(_25, const 1_usize);
        _27 = BitAnd(_24, _26);
        _28 = Eq(_27, const 0_usize);
        assert(_28, "misaligned pointer dereference: address must be a multiple of {} but is {}", _25, _24) -> [success: bb14, unwind unreachable];
    }

    bb6: {
        _19 = const _;
        _13 = _19 as &[&str] (Pointer(Unsize));
        _18 = &_1;
        _17 = core::fmt::rt::Argument::<'_>::new_debug::<Box<Ints>>(_18) -> [return: bb7, unwind: bb11];
    }

    bb7: {
        _16 = [move _17];
        _15 = &_16;
        _14 = _15 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _12 = Arguments::<'_>::new_v1(move _13, move _14) -> [return: bb8, unwind: bb11];
    }

    bb8: {
        _11 = _print(move _12) -> [return: bb9, unwind: bb11];
    }

    bb9: {
        drop(_1) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        drop(_1) -> [return: bb13, unwind terminate];
    }

    bb12 (cleanup): {
        drop(_3) -> [return: bb13, unwind terminate];
    }

    bb13 (cleanup): {
        resume;
    }

    bb14: {
        _10 = &(*_22);
        _9 = iter_ints::<[closure@ui/borrowck/borrowck-mut-uniq.rs:26:23: 26:26]>(_10, const ZeroSized: [closure@ui/borrowck/borrowck-mut-uniq.rs:26:23: 26:26]) -> [return: bb6, unwind: bb11];
    }

    bb15: {
        _8 = &mut (*_21);
        _7 = add_int(_8, const 44_isize) -> [return: bb5, unwind: bb11];
    }

    bb16: {
        _6 = &mut (*_20);
        _5 = add_int(_6, const 22_isize) -> [return: bb4, unwind: bb11];
    }
}

promoted[0] in main: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "ints=", const "\n"];
        _0 = &_1;
        return;
    }
}

fn main::{closure#0}(_1: &mut [closure@ui/borrowck/borrowck-mut-uniq.rs:26:23: 26:26], _2: &isize) -> bool {
    debug i => _2;
    let mut _0: bool;
    let _3: ();
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 1];
    let _8: [core::fmt::rt::Argument<'_>; 1];
    let mut _9: core::fmt::rt::Argument<'_>;
    let mut _10: &[&str; 2];

    bb0: {
        _10 = const _;
        _5 = _10 as &[&str] (Pointer(Unsize));
        _9 = core::fmt::rt::Argument::<'_>::new_debug::<isize>(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = [move _9];
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _4 = Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = _print(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = const true;
        return;
    }
}

promoted[0] in main::{closure#0}: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "isize = ", const "\n"];
        _0 = &_1;
        return;
    }
}
