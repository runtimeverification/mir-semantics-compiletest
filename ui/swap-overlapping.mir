// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/swap-overlapping.rs:10:15: 10:15
    let mut _1: TestDescAndFn;           // in scope 0 at ui/swap-overlapping.rs:11:9: 11:17
    let mut _2: TestDesc;                // in scope 0 at ui/swap-overlapping.rs:12:15: 15:10
    let mut _3: TestName;                // in scope 0 at ui/swap-overlapping.rs:13:19: 13:60
    let mut _4: std::string::String;     // in scope 0 at ui/swap-overlapping.rs:13:41: 13:59
    let mut _5: &str;                    // in scope 0 at ui/swap-overlapping.rs:13:41: 13:59
    let _6: &str;                        // in scope 0 at ui/swap-overlapping.rs:13:41: 13:47
    let mut _7: TestFn;                  // in scope 0 at ui/swap-overlapping.rs:16:17: 16:38
    let _8: ();                          // in scope 0 at ui/swap-overlapping.rs:18:5: 18:23
    let mut _9: &mut TestDescAndFn;      // in scope 0 at ui/swap-overlapping.rs:18:13: 18:22
    let mut _10: &mut TestDescAndFn;     // in scope 0 at ui/swap-overlapping.rs:18:13: 18:22
    scope 1 {
        debug test => _1;                // in scope 1 at ui/swap-overlapping.rs:11:9: 11:17
    }

    bb0: {
        _6 = const "test";               // scope 0 at ui/swap-overlapping.rs:13:41: 13:47
                                         // mir::Constant
                                         // + span: ui/swap-overlapping.rs:13:41: 13:47
                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }
        _5 = _6;                         // scope 0 at ui/swap-overlapping.rs:13:41: 13:59
        _4 = <str as ToString>::to_string(move _5) -> bb1; // scope 0 at ui/swap-overlapping.rs:13:41: 13:59
                                         // mir::Constant
                                         // + span: ui/swap-overlapping.rs:13:48: 13:57
                                         // + literal: Const { ty: for<'a> fn(&'a str) -> String {<str as ToString>::to_string}, val: Value(<ZST>) }
    }

    bb1: {
        _3 = TestName::DynTestName(move _4); // scope 0 at ui/swap-overlapping.rs:13:19: 13:60
        _2 = TestDesc { name: move _3, should_fail: const false }; // scope 0 at ui/swap-overlapping.rs:12:15: 15:10
        _7 = TestFn::DynTestFn(const 22_isize); // scope 0 at ui/swap-overlapping.rs:16:17: 16:38
        _1 = TestDescAndFn { desc: move _2, testfn: move _7 }; // scope 0 at ui/swap-overlapping.rs:11:20: 17:6
        _10 = &mut _1;                   // scope 1 at ui/swap-overlapping.rs:18:13: 18:22
        _9 = &mut (*_10);                // scope 1 at ui/swap-overlapping.rs:18:13: 18:22
        _8 = do_swap(move _9) -> [return: bb2, unwind: bb4]; // scope 1 at ui/swap-overlapping.rs:18:5: 18:23
                                         // mir::Constant
                                         // + span: ui/swap-overlapping.rs:18:5: 18:12
                                         // + literal: Const { ty: for<'a> fn(&'a mut TestDescAndFn) {do_swap}, val: Value(<ZST>) }
    }

    bb2: {
        drop(_1) -> bb3;                 // scope 0 at ui/swap-overlapping.rs:19:1: 19:2
    }

    bb3: {
        return;                          // scope 0 at ui/swap-overlapping.rs:19:2: 19:2
    }

    bb4 (cleanup): {
        drop(_1) -> bb5;                 // scope 0 at ui/swap-overlapping.rs:19:1: 19:2
    }

    bb5 (cleanup): {
        resume;                          // scope 0 at ui/swap-overlapping.rs:10:1: 19:2
    }
}

fn do_swap(_1: &mut TestDescAndFn) -> () {
    debug test => _1;                    // in scope 0 at ui/swap-overlapping.rs:21:12: 21:16
    let mut _0: ();                      // return place in scope 0 at ui/swap-overlapping.rs:21:38: 21:38
    let _2: ();                          // in scope 0 at ui/swap-overlapping.rs:23:9: 23:30
    let mut _3: *mut TestDescAndFn;      // in scope 0 at ui/swap-overlapping.rs:23:19: 23:23
    let mut _4: *mut TestDescAndFn;      // in scope 0 at ui/swap-overlapping.rs:23:25: 23:29
    scope 1 {
    }

    bb0: {
        _3 = &raw mut (*_1);             // scope 1 at ui/swap-overlapping.rs:23:19: 23:23
        _4 = &raw mut (*_1);             // scope 1 at ui/swap-overlapping.rs:23:25: 23:29
        _2 = std::ptr::swap::<TestDescAndFn>(move _3, move _4) -> bb1; // scope 1 at ui/swap-overlapping.rs:23:9: 23:30
                                         // mir::Constant
                                         // + span: ui/swap-overlapping.rs:23:9: 23:18
                                         // + literal: Const { ty: unsafe fn(*mut TestDescAndFn, *mut TestDescAndFn) {std::ptr::swap::<TestDescAndFn>}, val: Value(<ZST>) }
    }

    bb1: {
        return;                          // scope 0 at ui/swap-overlapping.rs:25:2: 25:2
    }
}

fn TestName::DynTestName(_1: String) -> TestName {
    let mut _0: TestName;                // return place in scope 0 at ui/swap-overlapping.rs:28:5: 28:16

    bb0: {
        _0 = TestName::DynTestName(move _1); // scope 0 at ui/swap-overlapping.rs:28:5: 28:16
        return;                          // scope 0 at ui/swap-overlapping.rs:28:5: 28:16
    }
}

// MIR FOR CTFE
fn TestName::DynTestName(_1: String) -> TestName {
    let mut _0: TestName;                // return place in scope 0 at ui/swap-overlapping.rs:28:5: 28:16

    bb0: {
        _0 = TestName::DynTestName(move _1); // scope 0 at ui/swap-overlapping.rs:28:5: 28:16
        return;                          // scope 0 at ui/swap-overlapping.rs:28:5: 28:16
    }
}

fn TestFn::DynTestFn(_1: isize) -> TestFn {
    let mut _0: TestFn;                  // return place in scope 0 at ui/swap-overlapping.rs:32:5: 32:14

    bb0: {
        _0 = TestFn::DynTestFn(move _1); // scope 0 at ui/swap-overlapping.rs:32:5: 32:14
        return;                          // scope 0 at ui/swap-overlapping.rs:32:5: 32:14
    }
}

// MIR FOR CTFE
fn TestFn::DynTestFn(_1: isize) -> TestFn {
    let mut _0: TestFn;                  // return place in scope 0 at ui/swap-overlapping.rs:32:5: 32:14

    bb0: {
        _0 = TestFn::DynTestFn(move _1); // scope 0 at ui/swap-overlapping.rs:32:5: 32:14
        return;                          // scope 0 at ui/swap-overlapping.rs:32:5: 32:14
    }
}

fn TestFn::DynBenchFn(_1: isize) -> TestFn {
    let mut _0: TestFn;                  // return place in scope 0 at ui/swap-overlapping.rs:33:5: 33:15

    bb0: {
        _0 = TestFn::DynBenchFn(move _1); // scope 0 at ui/swap-overlapping.rs:33:5: 33:15
        return;                          // scope 0 at ui/swap-overlapping.rs:33:5: 33:15
    }
}

// MIR FOR CTFE
fn TestFn::DynBenchFn(_1: isize) -> TestFn {
    let mut _0: TestFn;                  // return place in scope 0 at ui/swap-overlapping.rs:33:5: 33:15

    bb0: {
        _0 = TestFn::DynBenchFn(move _1); // scope 0 at ui/swap-overlapping.rs:33:5: 33:15
        return;                          // scope 0 at ui/swap-overlapping.rs:33:5: 33:15
    }
}
