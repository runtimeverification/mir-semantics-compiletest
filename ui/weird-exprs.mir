// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn strange() -> bool {
    let mut _0: bool;
    let _1: bool;
    scope 1 {
        debug _x => _1;
    }

    bb0: {
        _0 = const true;
        return;
    }
}

fn funny() -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}

fn f(_1: ()) -> () {
    debug _x => const ();
    let mut _0: ();

    bb0: {
        return;
    }
}

fn what() -> () {
    let mut _0: ();
    let _1: &std::cell::Cell<bool>;
    let _2: std::cell::Cell<bool>;
    let mut _4: &&std::cell::Cell<bool>;
    let _5: ();
    let mut _6: &[closure@ui/weird-exprs.rs:35:17: 35:19];
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: &std::cell::Cell<bool>;
    let mut _10: !;
    scope 1 {
        debug i => _1;
        let _3: [closure@ui/weird-exprs.rs:35:17: 35:19];
        scope 2 {
            debug dont => _3;
        }
    }

    bb0: {
        _2 = Cell::<bool>::new(const false) -> [return: bb1, unwind continue];
    }

    bb1: {
        _1 = &_2;
        _4 = &_1;
        _3 = [closure@ui/weird-exprs.rs:35:17: 35:19] { i: move _4 };
        _6 = &_3;
        _5 = <[closure@ui/weird-exprs.rs:35:17: 35:19] as Fn<()>>::call(move _6, const ()) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = _1;
        _8 = Cell::<bool>::get(move _9) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = Not(move _8);
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _10 = panic(const "assertion failed: (i.get())") -> unwind continue;
    }

    bb5: {
        return;
    }
}

fn the(_1: &Cell<bool>) -> () {
    debug x => _1;
    let mut _0: ();
    let mut _2: bool;
    let mut _3: bool;
    let _4: ();

    bb0: {
        goto -> bb1;
    }

    bb1: {
        _3 = Cell::<bool>::get(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = Not(move _3);
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _4 = Cell::<bool>::set(_1, const true) -> [return: bb1, unwind continue];
    }

    bb4: {
        return;
    }
}

fn what::{closure#0}(_1: &[closure@ui/weird-exprs.rs:35:17: 35:19]) -> () {
    debug i => (*((*_1).0: &&std::cell::Cell<bool>));
    let mut _0: ();
    let mut _2: &&std::cell::Cell<bool>;
    let mut _3: &std::cell::Cell<bool>;

    bb0: {
        _2 = deref_copy ((*_1).0: &&std::cell::Cell<bool>);
        _3 = deref_copy (*_2);
        _0 = the(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn zombiejesus() -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}

fn notsure() -> () {
    let mut _0: ();
    let mut _1: isize;
    let mut _6: &();
    let _7: ();
    let mut _8: &mut bool;
    let mut _9: &mut bool;
    let mut _10: &();
    let _11: ();
    let mut _12: &mut bool;
    let mut _13: &mut bool;
    scope 1 {
        debug _x => _1;
        let mut _2: bool;
        let mut _18: &();
        let mut _19: &();
        scope 2 {
            debug _y => _2;
            let mut _3: bool;
            let mut _16: &();
            let mut _17: &();
            scope 3 {
                debug _z => _3;
                let _4: bool;
                let mut _14: &();
                let mut _15: &();
                scope 4 {
                    debug _a => _4;
                    let _5: bool;
                    scope 5 {
                        debug _b => _5;
                    }
                }
            }
        }
    }

    bb0: {
        _1 = const 0_isize;
        _19 = const _;
        _1 = const 0_isize;
        _18 = const _;
        _2 = <() as PartialEq>::eq(_19, _18) -> [return: bb1, unwind continue];
    }

    bb1: {
        _1 = const 0_isize;
        _17 = const _;
        _1 = const 0_isize;
        _16 = const _;
        _3 = <() as PartialOrd>::lt(_17, _16) -> [return: bb2, unwind continue];
    }

    bb2: {
        _1 = Add(_1, const 0_isize);
        _15 = const _;
        _1 = const 0_isize;
        _14 = const _;
        _4 = <() as PartialEq>::eq(_15, _14) -> [return: bb3, unwind continue];
    }

    bb3: {
        _8 = &mut _2;
        _9 = &mut _3;
        _7 = std::mem::swap::<bool>(_8, _9) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = &_7;
        _12 = &mut _2;
        _13 = &mut _3;
        _11 = std::mem::swap::<bool>(_12, _13) -> [return: bb5, unwind continue];
    }

    bb5: {
        _10 = &_11;
        _5 = <() as PartialEq>::eq(move _6, move _10) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

promoted[0] in notsure: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

promoted[1] in notsure: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

promoted[2] in notsure: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

promoted[3] in notsure: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

promoted[4] in notsure: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

promoted[5] in notsure: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

fn canttouchthis() -> usize {
    let mut _0: usize;
    let _1: bool;
    let mut _2: bool;
    let mut _3: !;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: !;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: !;
    let _12: ();
    let mut _13: std::fmt::Arguments<'_>;
    let mut _14: &[&str];
    let mut _15: &[core::fmt::rt::Argument<'_>];
    let _16: &[core::fmt::rt::Argument<'_>; 0];
    let _17: [core::fmt::rt::Argument<'_>; 0];
    let mut _21: &();
    let mut _22: &();
    scope 1 {
        debug _a => _1;
        let _7: bool;
        let mut _19: &();
        let mut _20: &();
        scope 2 {
            debug _c => _7;
            let _11: bool;
            let mut _18: &[&str; 1];
            scope 3 {
                debug _b => _11;
            }
        }
    }

    bb0: {
        _2 = Not(const true);
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _3 = panic(const "assertion failed: (true)") -> unwind continue;
    }

    bb2: {
        _22 = const _;
        _5 = p() -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = Not(move _5);
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _6 = panic(const "assertion failed: p()") -> unwind continue;
    }

    bb5: {
        _21 = const _;
        _1 = <() as PartialEq>::eq(_22, _21) -> [return: bb6, unwind continue];
    }

    bb6: {
        _9 = p() -> [return: bb7, unwind continue];
    }

    bb7: {
        _8 = Not(move _9);
        switchInt(move _8) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _10 = panic(const "assertion failed: (p())") -> unwind continue;
    }

    bb9: {
        _20 = const _;
        _19 = const _;
        _7 = <() as PartialEq>::eq(_20, _19) -> [return: bb10, unwind continue];
    }

    bb10: {
        _18 = const _;
        _14 = _18 as &[&str] (Pointer(Unsize));
        _17 = core::fmt::rt::Argument::<'_>::none() -> [return: bb11, unwind continue];
    }

    bb11: {
        _16 = &_17;
        _15 = _16 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _13 = Arguments::<'_>::new_v1(move _14, move _15) -> [return: bb12, unwind continue];
    }

    bb12: {
        _12 = _print(move _13) -> [return: bb13, unwind continue];
    }

    bb13: {
        _0 = const 0_usize;
        return;
    }
}

promoted[0] in canttouchthis: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

promoted[1] in canttouchthis: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "0\n"];
        _0 = &_1;
        return;
    }
}

promoted[2] in canttouchthis: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = ();
        _0 = &_1;
        return;
    }
}

promoted[3] in canttouchthis: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

promoted[4] in canttouchthis: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

promoted[5] in canttouchthis: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

fn p() -> bool {
    let mut _0: bool;

    bb0: {
        _0 = const true;
        return;
    }
}

fn angrydome() -> () {
    let mut _0: ();
    let mut _1: i32;
    let mut _2: i32;
    scope 1 {
        debug i => _1;
    }

    bb0: {
        _1 = const 0_i32;
        goto -> bb1;
    }

    bb1: {
        _1 = Add(_1, const 1_i32);
        _2 = _1;
        switchInt(move _2) -> [1: bb1, otherwise: bb2];
    }

    bb2: {
        return;
    }
}

fn evil_lincoln() -> () {
    let mut _0: ();
    let _1: ();
    let mut _2: std::fmt::Arguments<'_>;
    let mut _3: &[&str];
    let mut _4: &[&str; 1];
    scope 1 {
        debug _evil => const ();
    }

    bb0: {
        _4 = const _;
        _3 = _4 as &[&str] (Pointer(Unsize));
        _2 = Arguments::<'_>::new_const(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _1 = _print(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

promoted[0] in evil_lincoln: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "lincoln\n"];
        _0 = &_1;
        return;
    }
}

fn dots() -> () {
    let mut _0: ();
    let mut _1: (&std::string::String, &std::string::String);
    let mut _2: &std::string::String;
    let _3: std::string::String;
    let mut _4: &std::string::String;
    let _5: std::string::String;
    let _6: std::string::String;
    let mut _7: std::fmt::Arguments<'_>;
    let mut _8: &[&str];
    let mut _9: &[core::fmt::rt::Argument<'_>];
    let _10: &[core::fmt::rt::Argument<'_>; 1];
    let _11: [core::fmt::rt::Argument<'_>; 1];
    let mut _12: core::fmt::rt::Argument<'_>;
    let _13: &std::string::String;
    let _14: &std::string::String;
    let mut _15: bool;
    let mut _16: bool;
    let _18: !;
    let mut _19: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _20: &std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>>>>>>>>>>>>>>>>>>>;
    let mut _21: &[&str; 1];
    scope 1 {
        debug res => _6;
    }
    scope 2 {
        debug left_val => _13;
        debug right_val => _14;
        let _17: core::panicking::AssertKind;
        scope 3 {
            debug kind => _17;
        }
    }

    bb0: {
        _3 = <String as From<&str>>::from(const "..................................................") -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = &_3;
        _21 = const _;
        _8 = _21 as &[&str] (Pointer(Unsize));
        _20 = const _;
        _12 = core::fmt::rt::Argument::<'_>::new_debug::<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>>>>>>>>>>>>>>>>>>>>>(_20) -> [return: bb2, unwind: bb11];
    }

    bb2: {
        _11 = [move _12];
        _10 = &_11;
        _9 = _10 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _7 = Arguments::<'_>::new_v1(move _8, move _9) -> [return: bb3, unwind: bb11];
    }

    bb3: {
        _6 = format(move _7) -> [return: bb4, unwind: bb11];
    }

    bb4: {
        _5 = move _6;
        _4 = &_5;
        _1 = (move _2, move _4);
        _13 = (_1.0: &std::string::String);
        _14 = (_1.1: &std::string::String);
        _16 = <String as PartialEq>::eq(_13, _14) -> [return: bb5, unwind: bb10];
    }

    bb5: {
        _15 = Not(move _16);
        switchInt(move _15) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _17 = core::panicking::AssertKind::Eq;
        _19 = Option::<Arguments<'_>>::None;
        _18 = assert_failed::<String, String>(move _17, _13, _14, move _19) -> bb10;
    }

    bb7: {
        drop(_5) -> [return: bb8, unwind: bb11];
    }

    bb8: {
        drop(_3) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }

    bb10 (cleanup): {
        drop(_5) -> [return: bb11, unwind terminate];
    }

    bb11 (cleanup): {
        drop(_3) -> [return: bb12, unwind terminate];
    }

    bb12 (cleanup): {
        resume;
    }
}

promoted[0] in dots: &RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>>>>>>>>>>>>>>>>>>>> = {
    let mut _0: &std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>>>>>>>>>>>>>>>>>>>;
    let mut _1: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>>>>>>>>>>>>>>>>>>>;
    let mut _2: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>>>>>>>>>>>>>>>>>>;
    let mut _3: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>>>>>>>>>>>>>>>>>;
    let mut _4: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>>>>>>>>>>>>>>>>;
    let mut _5: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>>>>>>>>>>>>>>>;
    let mut _6: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>>>>>>>>>>>>>>;
    let mut _7: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>>>>>>>>>>>>>;
    let mut _8: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>>>>>>>>>>>>;
    let mut _9: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>>>>>>>>>>>;
    let mut _10: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>>>>>>>>>>;
    let mut _11: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>>>>>>>>>;
    let mut _12: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>>>>>>>>;
    let mut _13: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>>>>>>>;
    let mut _14: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>>>>>>;
    let mut _15: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>>>>>;
    let mut _16: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>>>>;
    let mut _17: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>>>;
    let mut _18: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>>;
    let mut _19: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>>;
    let mut _20: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>>;
    let mut _21: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>>;
    let mut _22: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>>;
    let mut _23: std::ops::RangeTo<std::ops::RangeTo<std::ops::RangeFull>>;
    let mut _24: std::ops::RangeTo<std::ops::RangeFull>;
    let mut _25: std::ops::RangeFull;

    bb0: {
        _25 = RangeFull;
        _24 = RangeTo::<RangeFull> { end: move _25 };
        _23 = RangeTo::<RangeTo<RangeFull>> { end: move _24 };
        _22 = RangeTo::<RangeTo<RangeTo<RangeFull>>> { end: move _23 };
        _21 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeFull>>>> { end: move _22 };
        _20 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>> { end: move _21 };
        _19 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>> { end: move _20 };
        _18 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>>> { end: move _19 };
        _17 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>>>> { end: move _18 };
        _16 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>>>>> { end: move _17 };
        _15 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>>>>>> { end: move _16 };
        _14 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>>>>>>> { end: move _15 };
        _13 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>>>>>>>> { end: move _14 };
        _12 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>>>>>>>>> { end: move _13 };
        _11 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>>>>>>>>>> { end: move _12 };
        _10 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>>>>>>>>>>> { end: move _11 };
        _9 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>>>>>>>>>>>> { end: move _10 };
        _8 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>>>>>>>>>>>>> { end: move _9 };
        _7 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>>>>>>>>>>>>>> { end: move _8 };
        _6 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>>>>>>>>>>>>>>> { end: move _7 };
        _5 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>>>>>>>>>>>>>>>> { end: move _6 };
        _4 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>>>>>>>>>>>>>>>>> { end: move _5 };
        _3 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>>>>>>>>>>>>>>>>>> { end: move _4 };
        _2 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>>>>>>>>>>>>>>>>>>> { end: move _3 };
        _1 = RangeTo::<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeTo<RangeFull>>>>>>>>>>>>>>>>>>>>>>>> { end: move _2 };
        _0 = &_1;
        return;
    }
}

promoted[1] in dots: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn u8(_1: u8) -> () {
    debug u8 => _1;
    let mut _0: ();
    let mut _2: (&u8, &u8);
    let mut _3: &u8;
    let _4: u8;
    let _5: u8;
    let mut _6: &u8;
    let _7: &u8;
    let _8: ();
    let _9: &u8;
    let _10: &u8;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: u8;
    let mut _14: u8;
    let _16: !;
    let mut _17: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _18: &u8;
    let mut _19: &u8;
    scope 1 {
        debug u8 => _5;
    }
    scope 2 {
        debug left_val => _9;
        debug right_val => _10;
        let _15: core::panicking::AssertKind;
        scope 3 {
            debug kind => _15;
        }
    }

    bb0: {
        switchInt(move _1) -> [0: bb5, otherwise: bb1];
    }

    bb1: {
        _19 = const _;
        _18 = const _;
        _7 = u8::u8::u8::<'_>(_18) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = _7;
        _5 = (*_6);
        _8 = u8(const 0_u8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = _5;
        _3 = &_4;
        _2 = (_19, move _3);
        _9 = (_2.0: &u8);
        _10 = (_2.1: &u8);
        _13 = (*_9);
        _14 = (*_10);
        _12 = Eq(move _13, move _14);
        _11 = Not(move _12);
        switchInt(move _11) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _15 = core::panicking::AssertKind::Eq;
        _17 = Option::<Arguments<'_>>::None;
        _16 = assert_failed::<u8, u8>(move _15, _9, _10, move _17) -> unwind continue;
    }

    bb5: {
        return;
    }
}

promoted[0] in u8: &u8 = {
    let mut _0: &u8;
    let mut _1: u8;

    bb0: {
        _1 = const 8_u8;
        _0 = &_1;
        return;
    }
}

promoted[1] in u8: &u8 = {
    let mut _0: &u8;
    let mut _1: u8;

    bb0: {
        _1 = const 8_u8;
        _0 = &_1;
        return;
    }
}

fn u8::u8::u8(_1: &u8) -> &u8 {
    debug u8 => _1;
    let mut _0: &u8;

    bb0: {
        _0 = _1;
        return;
    }
}

fn fishy() -> () {
    let mut _0: ();
    let mut _1: (&std::string::String, &std::string::String);
    let mut _2: &std::string::String;
    let _3: std::string::String;
    let mut _4: &std::string::String;
    let _5: std::string::String;
    let mut _6: std::iter::Rev<std::str::Chars<'_>>;
    let mut _7: std::str::Chars<'_>;
    let mut _8: &str;
    let _9: &str;
    let mut _10: &std::string::String;
    let _11: std::string::String;
    let _12: &std::string::String;
    let _13: &std::string::String;
    let mut _14: bool;
    let mut _15: bool;
    let _17: !;
    let mut _18: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug left_val => _12;
        debug right_val => _13;
        let _16: core::panicking::AssertKind;
        scope 2 {
            debug kind => _16;
        }
    }

    bb0: {
        _3 = <String as From<&str>>::from(const "><>") -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = &_3;
        _11 = <String as From<&str>>::from(const "><>") -> [return: bb2, unwind: bb15];
    }

    bb2: {
        _10 = &_11;
        _9 = <String as Deref>::deref(move _10) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        _8 = _9;
        _7 = core::str::<impl str>::chars(move _8) -> [return: bb4, unwind: bb14];
    }

    bb4: {
        _6 = <Chars<'_> as Iterator>::rev(move _7) -> [return: bb5, unwind: bb14];
    }

    bb5: {
        _5 = <Rev<Chars<'_>> as Iterator>::collect::<String>(move _6) -> [return: bb6, unwind: bb14];
    }

    bb6: {
        _4 = &_5;
        _1 = (move _2, move _4);
        _12 = (_1.0: &std::string::String);
        _13 = (_1.1: &std::string::String);
        _15 = <String as PartialEq>::eq(_12, _13) -> [return: bb7, unwind: bb13];
    }

    bb7: {
        _14 = Not(move _15);
        switchInt(move _14) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _16 = core::panicking::AssertKind::Eq;
        _18 = Option::<Arguments<'_>>::None;
        _17 = assert_failed::<String, String>(move _16, _12, _13, move _18) -> bb13;
    }

    bb9: {
        drop(_5) -> [return: bb10, unwind: bb14];
    }

    bb10: {
        drop(_11) -> [return: bb11, unwind: bb15];
    }

    bb11: {
        drop(_3) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        drop(_5) -> [return: bb14, unwind terminate];
    }

    bb14 (cleanup): {
        drop(_11) -> [return: bb15, unwind terminate];
    }

    bb15 (cleanup): {
        drop(_3) -> [return: bb16, unwind terminate];
    }

    bb16 (cleanup): {
        resume;
    }
}

fn union() -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}

fn special_characters() -> () {
    let mut _0: ();
    let _1: bool;
    let mut _2: bool;
    let mut _3: &();
    let _4: ();
    let mut _5: ((&str, char), ());
    let mut _6: (&str, char);
    let _7: &str;
    let _8: &[std::ops::RangeToInclusive<std::ops::RangeFull>];
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: !;
    let mut _12: &();
    let mut _13: &[std::ops::RangeToInclusive<std::ops::RangeFull>; 1];
    let mut _14: &[closure@ui/weird-exprs.rs:124:18: 124:41];
    scope 1 {
        debug val => _1;
    }

    bb0: {
        _14 = const _;
        _7 = const "\\";
        _6 = (_7, const 'ðŸ¤”');
        _5 = (move _6, const ());
        _4 = <[closure@ui/weird-exprs.rs:124:18: 124:41] as Fn<((&str, char), ())>>::call(_14, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = &_4;
        _13 = const _;
        _8 = <[RangeToInclusive<RangeFull>; 1] as Index<RangeFull>>::index(_13, const RangeFull) -> [return: bb2, unwind continue];
    }

    bb2: {
        _12 = const _;
        _2 = <() as PartialEq>::eq(move _3, _12) -> [return: bb3, unwind continue];
    }

    bb3: {
        _1 = Not(move _2);
        _10 = Not(_1);
        _9 = Not(move _10);
        switchInt(move _9) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _11 = panic(const "assertion failed: !val") -> unwind continue;
    }

    bb5: {
        return;
    }
}

promoted[0] in special_characters: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

promoted[1] in special_characters: &[RangeToInclusive<RangeFull>; 1] = {
    let mut _0: &[std::ops::RangeToInclusive<std::ops::RangeFull>; 1];
    let mut _1: [std::ops::RangeToInclusive<std::ops::RangeFull>; 1];
    let mut _2: std::ops::RangeToInclusive<std::ops::RangeFull>;
    let mut _3: std::ops::RangeFull;

    bb0: {
        _3 = RangeFull;
        _2 = RangeToInclusive::<RangeFull> { end: move _3 };
        _1 = [move _2];
        _0 = &_1;
        return;
    }
}

promoted[2] in special_characters: &[closure@ui/weird-exprs.rs:124:18: 124:41] = {
    let mut _0: &[closure@ui/weird-exprs.rs:124:18: 124:41];
    let mut _1: [closure@ui/weird-exprs.rs:124:18: 124:41];

    bb0: {
        _1 = [closure@ui/weird-exprs.rs:124:18: 124:41];
        _0 = &_1;
        return;
    }
}

fn special_characters::{closure#0}(_1: &[closure@ui/weird-exprs.rs:124:18: 124:41], _2: (&str, char), _3: ()) -> () {
    let mut _0: ();
    scope 1 {
        debug __ => const ();
    }

    bb0: {
        return;
    }
}

fn punch_card() -> impl Debug {
    let mut _0: impl std::fmt::Debug;

    bb0: {
        return;
    }
}

fn r#match() -> () {
    let mut _0: ();
    let _1: ();
    let mut _2: (&(), &());
    let mut _3: &();
    let mut _6: bool;
    let mut _7: bool;
    let _9: !;
    let mut _10: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug val => const ();
        let _4: &();
        let _5: &();
        let mut _11: &();
        scope 2 {
            debug left_val => _4;
            debug right_val => _5;
            let _8: core::panicking::AssertKind;
            scope 3 {
                debug kind => _8;
            }
        }
    }

    bb0: {
        _3 = &_1;
        _11 = const _;
        _2 = (move _3, _11);
        _4 = (_2.0: &());
        _5 = (_2.1: &());
        _7 = <() as PartialEq>::eq(_4, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = Not(move _7);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _8 = core::panicking::AssertKind::Eq;
        _10 = Option::<Arguments<'_>>::None;
        _9 = assert_failed::<(), ()>(move _8, _4, _5, move _10) -> unwind continue;
    }

    bb3: {
        return;
    }
}

promoted[0] in r#match: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = ();
        _0 = &_1;
        return;
    }
}

fn i_yield() -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}

fn i_yield::{closure#0}(_1: Pin<&mut [static generator@ui/weird-exprs.rs:155:5: 155:14]>, _2: ()) -> GeneratorState<(), ()> {
    let mut _0: std::ops::GeneratorState<(), ()>;
    let mut _3: ();
    let mut _4: ();
    let mut _5: u32;
    let mut _6: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14];
    let mut _7: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14];
    let mut _8: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14];
    let mut _9: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14];
    let mut _10: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14];
    let mut _11: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14];
    let mut _12: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14];
    let mut _13: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14];
    let mut _14: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14];
    let mut _15: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14];
    let mut _16: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14];

    bb0: {
        _6 = deref_copy (_1.0: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14]);
        _5 = discriminant((*_6));
        switchInt(move _5) -> [0: bb1, 1: bb11, 3: bb2, 4: bb3, 5: bb4, 6: bb5, 7: bb6, 8: bb7, 9: bb8, 10: bb9, 11: bb10, otherwise: bb12];
    }

    bb1: {
        _3 = ();
        _0 = GeneratorState::<(), ()>::Yielded(move _3);
        _7 = deref_copy (_1.0: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14]);
        discriminant((*_7)) = 3;
        return;
    }

    bb2: {
        _0 = GeneratorState::<(), ()>::Yielded(move _2);
        _8 = deref_copy (_1.0: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14]);
        discriminant((*_8)) = 4;
        return;
    }

    bb3: {
        _0 = GeneratorState::<(), ()>::Yielded(move _2);
        _9 = deref_copy (_1.0: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14]);
        discriminant((*_9)) = 5;
        return;
    }

    bb4: {
        _0 = GeneratorState::<(), ()>::Yielded(move _2);
        _10 = deref_copy (_1.0: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14]);
        discriminant((*_10)) = 6;
        return;
    }

    bb5: {
        _0 = GeneratorState::<(), ()>::Yielded(move _2);
        _11 = deref_copy (_1.0: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14]);
        discriminant((*_11)) = 7;
        return;
    }

    bb6: {
        _0 = GeneratorState::<(), ()>::Yielded(move _2);
        _12 = deref_copy (_1.0: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14]);
        discriminant((*_12)) = 8;
        return;
    }

    bb7: {
        _0 = GeneratorState::<(), ()>::Yielded(move _2);
        _13 = deref_copy (_1.0: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14]);
        discriminant((*_13)) = 9;
        return;
    }

    bb8: {
        _0 = GeneratorState::<(), ()>::Yielded(move _2);
        _14 = deref_copy (_1.0: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14]);
        discriminant((*_14)) = 10;
        return;
    }

    bb9: {
        _0 = GeneratorState::<(), ()>::Yielded(move _2);
        _15 = deref_copy (_1.0: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14]);
        discriminant((*_15)) = 11;
        return;
    }

    bb10: {
        _4 = const ();
        _0 = GeneratorState::<(), ()>::Complete(move _4);
        _16 = deref_copy (_1.0: &mut [static generator@ui/weird-exprs.rs:155:5: 155:14]);
        discriminant((*_16)) = 1;
        return;
    }

    bb11: {
        assert(const false, "generator resumed after completion") -> [success: bb11, unwind continue];
    }

    bb12: {
        unreachable;
    }
}

fn match_nested_if() -> () {
    let mut _0: ();
    let mut _1: bool;
    let mut _2: bool;
    let mut _3: !;
    scope 1 {
        debug val => const true;
    }

    bb0: {
        _1 = const true;
        _2 = Not(_1);
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _3 = panic(const "assertion failed: val") -> unwind continue;
    }

    bb2: {
        return;
    }
}

fn monkey_barrel() -> () {
    let mut _0: ();
    let _1: ();
    let mut _2: (&(), &());
    let mut _3: &();
    let mut _6: bool;
    let mut _7: bool;
    let _9: !;
    let mut _10: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug val => const ();
        let _4: &();
        let _5: &();
        let mut _11: &();
        scope 26 {
            debug left_val => _4;
            debug right_val => _5;
            let _8: core::panicking::AssertKind;
            scope 27 {
                debug kind => _8;
            }
        }
    }
    scope 2 {
    }
    scope 3 {
    }
    scope 4 {
    }
    scope 5 {
    }
    scope 6 {
    }
    scope 7 {
    }
    scope 8 {
    }
    scope 9 {
    }
    scope 10 {
    }
    scope 11 {
    }
    scope 12 {
    }
    scope 13 {
    }
    scope 14 {
    }
    scope 15 {
    }
    scope 16 {
    }
    scope 17 {
    }
    scope 18 {
    }
    scope 19 {
    }
    scope 20 {
    }
    scope 21 {
    }
    scope 22 {
    }
    scope 23 {
    }
    scope 24 {
    }
    scope 25 {
    }

    bb0: {
        _3 = &_1;
        _11 = const _;
        _2 = (move _3, _11);
        _4 = (_2.0: &());
        _5 = (_2.1: &());
        _7 = <() as PartialEq>::eq(_4, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = Not(move _7);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _8 = core::panicking::AssertKind::Eq;
        _10 = Option::<Arguments<'_>>::None;
        _9 = assert_failed::<(), ()>(move _8, _4, _5, move _10) -> unwind continue;
    }

    bb3: {
        return;
    }
}

promoted[0] in monkey_barrel: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = ();
        _0 = &_1;
        return;
    }
}

fn ðšŒðš˜ðš—ðšðš’ðš—ðšžðšŽ() -> () {
    let mut _0: ();
    let mut _1: (&i32, &i32);
    let mut _2: &i32;
    let _3: i32;
    let _4: &i32;
    let _5: &i32;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: i32;
    let mut _9: i32;
    let _11: !;
    let mut _12: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _13: &i32;
    scope 1 {
        debug left_val => _4;
        debug right_val => _5;
        let _10: core::panicking::AssertKind;
        scope 2 {
            debug kind => _10;
        }
    }

    bb0: {
        _3 = ðš‹ðš›ðšŽðšŠðš”() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = &_3;
        _13 = const _;
        _1 = (move _2, _13);
        _4 = (_1.0: &i32);
        _5 = (_1.1: &i32);
        _8 = (*_4);
        _9 = (*_5);
        _7 = Eq(move _8, move _9);
        _6 = Not(move _7);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _10 = core::panicking::AssertKind::Eq;
        _12 = Option::<Arguments<'_>>::None;
        _11 = assert_failed::<i32, i32>(move _10, _4, _5, move _12) -> unwind continue;
    }

    bb3: {
        return;
    }
}

promoted[0] in ðšŒðš˜ðš—ðšðš’ðš—ðšžðšŽ: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 42_i32;
        _0 = &_1;
        return;
    }
}

fn ðš‹ðš›ðšŽðšŠðš”() -> i32 {
    let mut _0: i32;
    scope 1 {
        debug ðš›ðšŽðšðšžðš›ðš— => const 42_i32;
    }

    bb0: {
        _0 = const 42_i32;
        return;
    }
}

fn function() -> () {
    let mut _0: ();
    let mut _1: function::foo;
    let mut _2: fn() -> function::foo;
    let mut _3: &fn() -> function::foo;
    let mut _4: &function::foo;
    let _5: function::foo;
    let mut _6: fn() -> function::foo;
    let mut _7: &fn() -> function::foo;
    let mut _8: &function::foo;
    let _9: function::foo;
    let mut _10: fn() -> function::foo;
    let mut _11: &fn() -> function::foo;
    let mut _12: &function::foo;
    let _13: function::foo;
    let mut _14: fn() -> function::foo;
    let mut _15: &fn() -> function::foo;
    let mut _16: &function::foo;
    let _17: function::foo;
    let mut _18: fn() -> function::foo;
    let mut _19: &fn() -> function::foo;
    let mut _20: &function::foo;
    let _21: function::foo;
    let mut _22: fn() -> function::foo;
    let mut _23: &fn() -> function::foo;
    let mut _24: &function::foo;
    let _25: function::foo;
    let mut _26: fn() -> function::foo;
    let mut _27: &fn() -> function::foo;
    let mut _28: &function::foo;
    let _29: function::foo;
    let mut _30: fn() -> function::foo;
    let mut _31: &fn() -> function::foo;
    let mut _32: &function::foo;
    let _33: function::foo;
    let mut _34: fn() -> function::foo;
    let mut _35: &fn() -> function::foo;
    let mut _36: &function::foo;
    let _37: function::foo;
    let mut _38: fn() -> function::foo;
    let mut _39: &fn() -> function::foo;
    let mut _40: &function::foo;
    let _41: function::foo;
    let mut _42: fn() -> function::foo;
    let mut _43: &fn() -> function::foo;
    let mut _44: &function::foo;
    let _45: function::foo;
    let mut _46: fn() -> function::foo;
    let mut _47: &fn() -> function::foo;
    let mut _48: &function::foo;
    let _49: function::foo;
    let mut _50: fn() -> function::foo;
    let mut _51: &fn() -> function::foo;
    let mut _52: &function::foo;
    let _53: function::foo;
    let mut _54: fn() -> function::foo;
    let mut _55: &fn() -> function::foo;
    let mut _56: &function::foo;
    let _57: function::foo;
    let mut _58: fn() -> function::foo;
    let mut _59: &fn() -> function::foo;
    let mut _60: &function::foo;
    scope 1 {
    }

    bb0: {
        _60 = const _;
        _59 = <foo as Deref>::deref(_60) -> [return: bb1, unwind continue];
    }

    bb1: {
        _58 = (*_59);
        _57 = move _58() -> [return: bb2, unwind continue];
    }

    bb2: {
        _56 = &_57;
        _55 = <foo as Deref>::deref(move _56) -> [return: bb3, unwind continue];
    }

    bb3: {
        _54 = (*_55);
        _53 = move _54() -> [return: bb4, unwind continue];
    }

    bb4: {
        _52 = &_53;
        _51 = <foo as Deref>::deref(move _52) -> [return: bb5, unwind continue];
    }

    bb5: {
        _50 = (*_51);
        _49 = move _50() -> [return: bb6, unwind continue];
    }

    bb6: {
        _48 = &_49;
        _47 = <foo as Deref>::deref(move _48) -> [return: bb7, unwind continue];
    }

    bb7: {
        _46 = (*_47);
        _45 = move _46() -> [return: bb8, unwind continue];
    }

    bb8: {
        _44 = &_45;
        _43 = <foo as Deref>::deref(move _44) -> [return: bb9, unwind continue];
    }

    bb9: {
        _42 = (*_43);
        _41 = move _42() -> [return: bb10, unwind continue];
    }

    bb10: {
        _40 = &_41;
        _39 = <foo as Deref>::deref(move _40) -> [return: bb11, unwind continue];
    }

    bb11: {
        _38 = (*_39);
        _37 = move _38() -> [return: bb12, unwind continue];
    }

    bb12: {
        _36 = &_37;
        _35 = <foo as Deref>::deref(move _36) -> [return: bb13, unwind continue];
    }

    bb13: {
        _34 = (*_35);
        _33 = move _34() -> [return: bb14, unwind continue];
    }

    bb14: {
        _32 = &_33;
        _31 = <foo as Deref>::deref(move _32) -> [return: bb15, unwind continue];
    }

    bb15: {
        _30 = (*_31);
        _29 = move _30() -> [return: bb16, unwind continue];
    }

    bb16: {
        _28 = &_29;
        _27 = <foo as Deref>::deref(move _28) -> [return: bb17, unwind continue];
    }

    bb17: {
        _26 = (*_27);
        _25 = move _26() -> [return: bb18, unwind continue];
    }

    bb18: {
        _24 = &_25;
        _23 = <foo as Deref>::deref(move _24) -> [return: bb19, unwind continue];
    }

    bb19: {
        _22 = (*_23);
        _21 = move _22() -> [return: bb20, unwind continue];
    }

    bb20: {
        _20 = &_21;
        _19 = <foo as Deref>::deref(move _20) -> [return: bb21, unwind continue];
    }

    bb21: {
        _18 = (*_19);
        _17 = move _18() -> [return: bb22, unwind continue];
    }

    bb22: {
        _16 = &_17;
        _15 = <foo as Deref>::deref(move _16) -> [return: bb23, unwind continue];
    }

    bb23: {
        _14 = (*_15);
        _13 = move _14() -> [return: bb24, unwind continue];
    }

    bb24: {
        _12 = &_13;
        _11 = <foo as Deref>::deref(move _12) -> [return: bb25, unwind continue];
    }

    bb25: {
        _10 = (*_11);
        _9 = move _10() -> [return: bb26, unwind continue];
    }

    bb26: {
        _8 = &_9;
        _7 = <foo as Deref>::deref(move _8) -> [return: bb27, unwind continue];
    }

    bb27: {
        _6 = (*_7);
        _5 = move _6() -> [return: bb28, unwind continue];
    }

    bb28: {
        _4 = &_5;
        _3 = <foo as Deref>::deref(move _4) -> [return: bb29, unwind continue];
    }

    bb29: {
        _2 = (*_3);
        _1 = move _2() -> [return: bb30, unwind continue];
    }

    bb30: {
        return;
    }
}

promoted[0] in function: &foo = {
    let mut _0: &function::foo;
    let mut _1: function::foo;

    bb0: {
        _1 = foo;
        _0 = &_1;
        return;
    }
}

fn function::<impl at ui/weird-exprs.rs:186:5: 186:23>::deref(_1: &foo) -> &fn() -> foo {
    debug self => _1;
    let mut _0: &fn() -> function::foo;

    bb0: {
        _0 = const _;
        return;
    }
}

promoted[0] in function::<impl at ui/weird-exprs.rs:186:5: 186:23>::deref: &fn() -> foo = {
    let mut _0: &fn() -> function::foo;
    let mut _1: fn() -> function::foo;
    let mut _2: [closure@ui/weird-exprs.rs:189:16: 189:18];

    bb0: {
        _2 = [closure@ui/weird-exprs.rs:189:16: 189:18];
        _1 = move _2 as fn() -> function::foo (Pointer(ClosureFnPointer(Normal)));
        _0 = &_1;
        return;
    }
}

fn function::<impl at ui/weird-exprs.rs:186:5: 186:23>::deref::{closure#0}(_1: &[closure@ui/weird-exprs.rs:189:16: 189:18]) -> foo {
    let mut _0: function::foo;

    bb0: {
        return;
    }
}

fn bathroom_stall() -> () {
    let mut _0: ();
    let mut _1: i32;
    let mut _2: bool;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: (&i32, &i32);
    let mut _9: &i32;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: i32;
    let mut _15: i32;
    let _17: !;
    let mut _18: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug i => _1;
        let _10: &i32;
        let _11: &i32;
        let mut _19: &i32;
        let mut _20: &();
        let mut _21: &();
        let mut _22: &();
        let mut _23: &();
        let mut _24: &();
        let mut _25: &();
        let mut _26: &();
        let mut _27: &();
        let mut _28: &();
        let mut _29: &();
        let mut _30: &();
        let mut _31: &();
        scope 2 {
            debug left_val => _10;
            debug right_val => _11;
            let _16: core::panicking::AssertKind;
            scope 3 {
                debug kind => _16;
            }
        }
    }

    bb0: {
        _1 = const 1_i32;
        _1 = Add(_1, const 1_i32);
        _31 = const _;
        _1 = Add(_1, const 1_i32);
        _30 = const _;
        _2 = <() as PartialEq>::ne(_31, _30) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb2, otherwise: bb11];
    }

    bb2: {
        _1 = Add(_1, const 1_i32);
        _29 = const _;
        _1 = Add(_1, const 1_i32);
        _28 = const _;
        _3 = <() as PartialEq>::ne(_29, _28) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _3) -> [0: bb4, otherwise: bb11];
    }

    bb4: {
        _1 = Add(_1, const 1_i32);
        _27 = const _;
        _1 = Add(_1, const 1_i32);
        _26 = const _;
        _4 = <() as PartialEq>::ne(_27, _26) -> [return: bb5, unwind continue];
    }

    bb5: {
        switchInt(move _4) -> [0: bb6, otherwise: bb11];
    }

    bb6: {
        _1 = Add(_1, const 1_i32);
        _25 = const _;
        _1 = Add(_1, const 1_i32);
        _24 = const _;
        _5 = <() as PartialEq>::ne(_25, _24) -> [return: bb7, unwind continue];
    }

    bb7: {
        switchInt(move _5) -> [0: bb8, otherwise: bb11];
    }

    bb8: {
        _1 = Add(_1, const 1_i32);
        _23 = const _;
        _1 = Add(_1, const 1_i32);
        _22 = const _;
        _6 = <() as PartialEq>::ne(_23, _22) -> [return: bb9, unwind continue];
    }

    bb9: {
        switchInt(move _6) -> [0: bb10, otherwise: bb11];
    }

    bb10: {
        _1 = Add(_1, const 1_i32);
        _21 = const _;
        _1 = Add(_1, const 1_i32);
        _20 = const _;
        _7 = <() as PartialEq>::ne(_21, _20) -> [return: bb11, unwind continue];
    }

    bb11: {
        _9 = &_1;
        _19 = const _;
        _8 = (move _9, _19);
        _10 = (_8.0: &i32);
        _11 = (_8.1: &i32);
        _14 = (*_10);
        _15 = (*_11);
        _13 = Eq(move _14, move _15);
        _12 = Not(move _13);
        switchInt(move _12) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _16 = core::panicking::AssertKind::Eq;
        _18 = Option::<Arguments<'_>>::None;
        _17 = assert_failed::<i32, i32>(move _16, _10, _11, move _18) -> unwind continue;
    }

    bb13: {
        return;
    }
}

promoted[0] in bathroom_stall: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 13_i32;
        _0 = &_1;
        return;
    }
}

promoted[1] in bathroom_stall: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

promoted[2] in bathroom_stall: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

promoted[3] in bathroom_stall: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

promoted[4] in bathroom_stall: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

promoted[5] in bathroom_stall: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

promoted[6] in bathroom_stall: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

promoted[7] in bathroom_stall: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

promoted[8] in bathroom_stall: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

promoted[9] in bathroom_stall: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

promoted[10] in bathroom_stall: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

promoted[11] in bathroom_stall: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

promoted[12] in bathroom_stall: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = const ();
        _0 = &_1;
        return;
    }
}

fn closure_matching() -> () {
    let mut _0: ();
    let _1: [closure@ui/weird-exprs.rs:202:13: 202:16];
    let mut _3: std::option::Option<i32>;
    let mut _4: &[closure@ui/weird-exprs.rs:202:13: 202:16];
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: std::option::Option<i32>;
    let mut _8: &[closure@ui/weird-exprs.rs:204:24: 204:27];
    let mut _9: !;
    scope 1 {
        debug x => const ZeroSized: [closure@ui/weird-exprs.rs:202:13: 202:16];
        let _2: [closure@ui/weird-exprs.rs:204:24: 204:27];
        scope 2 {
            debug x => const ZeroSized: [closure@ui/weird-exprs.rs:204:24: 204:27];
        }
    }

    bb0: {
        _4 = &_1;
        _3 = <[closure@ui/weird-exprs.rs:202:13: 202:16] as Fn<(RangeFull,)>>::call(move _4, const (RangeFull,)) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = &_2;
        _7 = <[closure@ui/weird-exprs.rs:204:24: 204:27] as Fn<(RangeFull,)>>::call(move _8, const (RangeFull,)) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = const true;
        _5 = Not(move _6);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _9 = panic(const "assertion failed: matches!(x(..), | _ | Some(4))") -> unwind continue;
    }

    bb4: {
        return;
    }
}

fn closure_matching::{closure#0}(_1: &[closure@ui/weird-exprs.rs:202:13: 202:16], _2: RangeFull) -> Option<i32> {
    let mut _0: std::option::Option<i32>;

    bb0: {
        _0 = Option::<i32>::Some(const 1_i32);
        return;
    }
}

fn closure_matching::{closure#1}(_1: &[closure@ui/weird-exprs.rs:204:24: 204:27], _2: RangeFull) -> Option<i32> {
    let mut _0: std::option::Option<i32>;

    bb0: {
        _0 = Option::<i32>::Some(const 3_i32);
        return;
    }
}

fn semisemisemisemisemi() -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}

fn useful_syntax() -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}

fn infcx() -> () {
    let mut _0: ();
    scope 1 {
        debug _cx => const Cx;
    }

    bb0: {
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: bool;
    let _2: ();
    let _3: ();
    let _4: ();
    let _5: ();
    let _6: usize;
    let _7: ();
    let _8: ();
    let _9: ();
    let _10: ();
    let _11: ();
    let _12: ();
    let _13: ();
    let _14: impl std::fmt::Debug;
    let _15: ();
    let _16: ();
    let _17: ();
    let _18: ();
    let _19: ();
    let _20: ();
    let _21: ();
    let _22: ();
    let _23: ();
    let _24: ();
    let _25: ();

    bb0: {
        _1 = strange() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = funny() -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = what() -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = zombiejesus() -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = notsure() -> [return: bb5, unwind continue];
    }

    bb5: {
        _6 = canttouchthis() -> [return: bb6, unwind continue];
    }

    bb6: {
        _7 = angrydome() -> [return: bb7, unwind continue];
    }

    bb7: {
        _8 = evil_lincoln() -> [return: bb8, unwind continue];
    }

    bb8: {
        _9 = dots() -> [return: bb9, unwind continue];
    }

    bb9: {
        _10 = u8(const 8_u8) -> [return: bb10, unwind continue];
    }

    bb10: {
        _11 = fishy() -> [return: bb11, unwind continue];
    }

    bb11: {
        _12 = union() -> [return: bb12, unwind continue];
    }

    bb12: {
        _13 = special_characters() -> [return: bb13, unwind continue];
    }

    bb13: {
        _14 = punch_card() -> [return: bb14, unwind continue];
    }

    bb14: {
        _15 = r#match() -> [return: bb15, unwind continue];
    }

    bb15: {
        _16 = i_yield() -> [return: bb16, unwind continue];
    }

    bb16: {
        _17 = match_nested_if() -> [return: bb17, unwind continue];
    }

    bb17: {
        _18 = monkey_barrel() -> [return: bb18, unwind continue];
    }

    bb18: {
        _19 = ðšŒðš˜ðš—ðšðš’ðš—ðšžðšŽ() -> [return: bb19, unwind continue];
    }

    bb19: {
        _20 = function() -> [return: bb20, unwind continue];
    }

    bb20: {
        _21 = bathroom_stall() -> [return: bb21, unwind continue];
    }

    bb21: {
        _22 = closure_matching() -> [return: bb22, unwind continue];
    }

    bb22: {
        _23 = semisemisemisemisemi() -> [return: bb23, unwind continue];
    }

    bb23: {
        _24 = useful_syntax() -> [return: bb24, unwind continue];
    }

    bb24: {
        _25 = infcx() -> [return: bb25, unwind continue];
    }

    bb25: {
        return;
    }
}
