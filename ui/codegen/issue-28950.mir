// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
const LEN: usize = {
    let mut _0: usize;
    let mut _1: u32;
    let mut _2: bool;

    bb0: {
        _1 = const 15_i32 as u32 (IntToInt);
        _2 = Lt(move _1, const 64_u32);
        assert(move _2, "attempt to shift left by `{}`, which would overflow", const 15_i32) -> [success: bb1, unwind continue];
    }

    bb1: {
        _0 = Shl(const 1_usize, const 15_i32);
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let mut _1: bool;
    let mut _2: bool;
    let mut _3: &std::result::Result<(), std::boxed::Box<dyn std::any::Any + std::marker::Send>>;
    let _4: std::result::Result<(), std::boxed::Box<dyn std::any::Any + std::marker::Send>>;
    let mut _5: std::thread::JoinHandle<()>;
    let mut _6: std::result::Result<std::thread::JoinHandle<()>, std::io::Error>;
    let mut _7: std::thread::Builder;
    let mut _8: std::thread::Builder;
    let mut _9: usize;
    let mut _10: bool;
    let mut _11: !;
    let mut _12: bool;

    bb0: {
        _12 = const false;
        _12 = const true;
        _8 = Builder::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _10 = Eq(const 2_usize, const 0_usize);
        assert(!move _10, "attempt to divide `{}` by zero", const _) -> [success: bb2, unwind: bb14];
    }

    bb2: {
        _9 = Div(const _, const 2_usize);
        _12 = const false;
        _7 = Builder::stack_size(move _8, move _9) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        _12 = const false;
        _6 = Builder::spawn::<[closure@ui/codegen/issue-28950.rs:16:54: 16:56], ()>(move _7, const ZeroSized: [closure@ui/codegen/issue-28950.rs:16:54: 16:56]) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = Result::<JoinHandle<()>, std::io::Error>::unwrap(move _6) -> [return: bb5, unwind continue];
    }

    bb5: {
        _4 = JoinHandle::<()>::join(move _5) -> [return: bb6, unwind continue];
    }

    bb6: {
        _3 = &_4;
        _2 = Result::<(), Box<dyn Any + Send>>::is_ok(move _3) -> [return: bb7, unwind: bb11];
    }

    bb7: {
        _1 = Not(move _2);
        drop(_4) -> [return: bb8, unwind continue];
    }

    bb8: {
        switchInt(move _1) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _11 = core::panicking::panic(const "assertion failed: Builder::new().stack_size(LEN /\\n                        2).spawn(||\\n                    {\\n                        let vec =\\n                            vec![unsafe { std :: mem :: zeroed :: < [u8 ; LEN] > () }];\\n                        assert_eq!(vec.len(), 1);\\n                    }).unwrap().join().is_ok()") -> unwind continue;
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        drop(_4) -> [return: bb12, unwind terminate];
    }

    bb12 (cleanup): {
        resume;
    }

    bb13 (cleanup): {
        drop(_8) -> [return: bb12, unwind terminate];
    }

    bb14 (cleanup): {
        switchInt(_12) -> [0: bb12, otherwise: bb13];
    }
}

fn main::{closure#0}(_1: [closure@ui/codegen/issue-28950.rs:16:54: 16:56]) -> () {
    let mut _0: ();
    let _2: std::vec::Vec<[u8; 32768]>;
    let mut _3: std::boxed::Box<[[u8; 32768]]>;
    let mut _4: std::boxed::Box<[[u8; 32768]; 1]>;
    let mut _5: usize;
    let mut _6: usize;
    let mut _7: *mut u8;
    let mut _8: std::boxed::Box<[[u8; 32768]; 1]>;
    let mut _9: [u8; 32768];
    let mut _10: (&usize, &usize);
    let mut _11: &usize;
    let _12: usize;
    let mut _13: &std::vec::Vec<[u8; 32768]>;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: usize;
    let mut _19: usize;
    let _21: !;
    let mut _22: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _24: &mut std::boxed::Box<[[u8; 32768]; 1]>;
    let mut _25: ();
    let mut _26: *const [[u8; 32768]; 1];
    let mut _27: *const ();
    let mut _28: usize;
    let mut _29: usize;
    let mut _30: usize;
    let mut _31: usize;
    let mut _32: bool;
    scope 1 {
        debug vec => _2;
        let _14: &usize;
        let _15: &usize;
        let mut _23: &usize;
        scope 4 {
            debug left_val => _14;
            debug right_val => _15;
            let _20: core::panicking::AssertKind;
            scope 5 {
                debug kind => _20;
            }
        }
    }
    scope 2 {
    }
    scope 3 {
    }

    bb0: {
        _5 = SizeOf([[u8; 32768]; 1]);
        _6 = AlignOf([[u8; 32768]; 1]);
        _7 = alloc::alloc::exchange_malloc(move _5, move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = ShallowInitBox(move _7, [[u8; 32768]; 1]);
        _9 = zeroed::<[u8; 32768]>() -> [return: bb2, unwind: bb10];
    }

    bb2: {
        _26 = (((_8.0: std::ptr::Unique<[[u8; 32768]; 1]>).0: std::ptr::NonNull<[[u8; 32768]; 1]>).0: *const [[u8; 32768]; 1]);
        _27 = _26 as *const () (PtrToPtr);
        _28 = _27 as usize (Transmute);
        _29 = AlignOf([u8; 32768]);
        _30 = Sub(_29, const 1_usize);
        _31 = BitAnd(_28, _30);
        _32 = Eq(_31, const 0_usize);
        assert(_32, "misaligned pointer dereference: address must be a multiple of {} but is {}", _29, _28) -> [success: bb11, unwind unreachable];
    }

    bb3: {
        _13 = &_2;
        _12 = Vec::<[u8; 32768]>::len(move _13) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _11 = &_12;
        _23 = const _;
        _10 = (move _11, _23);
        _14 = (_10.0: &usize);
        _15 = (_10.1: &usize);
        _18 = (*_14);
        _19 = (*_15);
        _17 = Eq(move _18, move _19);
        _16 = Not(move _17);
        switchInt(move _16) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _20 = core::panicking::AssertKind::Eq;
        _22 = Option::<Arguments<'_>>::None;
        _21 = core::panicking::assert_failed::<usize, usize>(move _20, _14, _15, move _22) -> bb8;
    }

    bb6: {
        drop(_2) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_2) -> [return: bb9, unwind terminate];
    }

    bb9 (cleanup): {
        resume;
    }

    bb10 (cleanup): {
        _24 = &mut _8;
        _25 = <Box<[[u8; 32768]; 1]> as Drop>::drop(move _24) -> [return: bb12, unwind terminate];
    }

    bb11: {
        (*_26) = [move _9];
        _4 = move _8;
        _3 = move _4 as std::boxed::Box<[[u8; 32768]]> (Pointer(Unsize));
        _2 = slice::<impl [[u8; 32768]]>::into_vec::<std::alloc::Global>(move _3) -> [return: bb3, unwind continue];
    }

    bb12 (cleanup): {
        goto -> bb9;
    }
}

promoted[0] in main::{closure#0}: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 1_usize;
        _0 = &_1;
        return;
    }
}

main::{closure#0}::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const _;
        return;
    }
}
