// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn foo(_1: usize) -> usize {
    let mut _0: usize;

    bb0: {
        _0 = const 0_usize;
        return;
    }
}

fn bar(_1: usize) -> usize {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn add(_1: i32, _2: i32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;

    bb0: {
        _0 = Add(_1, _2);
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let mut _2: (&usize, &usize);
    let mut _3: &usize;
    let _4: usize;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: usize;
    let mut _10: usize;
    let _12: !;
    let mut _13: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _15: i32;
    let mut _16: !;
    let mut _17: (&usize, &usize);
    let mut _18: &usize;
    let _19: usize;
    let mut _20: fn(usize) -> usize;
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: usize;
    let mut _26: usize;
    let _28: !;
    let mut _29: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _31: i32;
    let mut _32: !;
    let mut _33: (&usize, &usize);
    let mut _34: &usize;
    let _35: usize;
    let mut _36: fn(usize) -> usize;
    let mut _39: bool;
    let mut _40: bool;
    let mut _41: usize;
    let mut _42: usize;
    let _44: !;
    let mut _45: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _47: i32;
    let mut _48: !;
    let mut _49: (&usize, &usize);
    let mut _50: &usize;
    let _51: usize;
    let mut _52: fn(usize) -> usize;
    let mut _55: bool;
    let mut _56: bool;
    let mut _57: usize;
    let mut _58: usize;
    let _60: !;
    let mut _61: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _63: i32;
    let mut _64: !;
    let mut _65: (&i32, &i32);
    let mut _66: &i32;
    let _67: i32;
    let mut _68: fn(usize) -> i32;
    let mut _71: bool;
    let mut _72: bool;
    let mut _73: i32;
    let mut _74: i32;
    let _76: !;
    let mut _77: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _79: fn(i32, i32) -> i32;
    let mut _80: fn(i32, i32) -> i32;
    let mut _81: (&[i32; 2], &[i32; 2]);
    let mut _82: &[i32; 2];
    let _83: [i32; 2];
    let mut _84: i32;
    let mut _85: fn(i32, i32) -> i32;
    let _86: usize;
    let mut _87: usize;
    let mut _88: bool;
    let mut _89: i32;
    let mut _90: fn(i32, i32) -> i32;
    let _91: usize;
    let mut _92: usize;
    let mut _93: bool;
    let mut _96: bool;
    let mut _97: bool;
    let _99: !;
    let mut _100: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug c => const ZeroSized: [closure@ui/closures/closure_no_cap_coerce_many_run_pass.rs:20:13: 20:16];
        let _1: fn(usize) -> usize;
        scope 2 {
            debug c_pointer => _1;
            let _5: &usize;
            let _6: &usize;
            let _14: fn(usize) -> usize;
            let mut _106: &usize;
            scope 3 {
                debug left_val => _5;
                debug right_val => _6;
                let _11: core::panicking::AssertKind;
                scope 4 {
                    debug kind => _11;
                }
            }
            scope 5 {
                debug f => _14;
                let _21: &usize;
                let _22: &usize;
                let _30: fn(usize) -> usize;
                let mut _105: &usize;
                scope 6 {
                    debug left_val => _21;
                    debug right_val => _22;
                    let _27: core::panicking::AssertKind;
                    scope 7 {
                        debug kind => _27;
                    }
                }
                scope 8 {
                    debug f => _30;
                    let _37: &usize;
                    let _38: &usize;
                    let _46: fn(usize) -> usize;
                    let mut _104: &usize;
                    scope 9 {
                        debug left_val => _37;
                        debug right_val => _38;
                        let _43: core::panicking::AssertKind;
                        scope 10 {
                            debug kind => _43;
                        }
                    }
                    scope 11 {
                        debug f => _46;
                        let _53: &usize;
                        let _54: &usize;
                        let mut _103: &usize;
                        scope 12 {
                            debug left_val => _53;
                            debug right_val => _54;
                            let _59: core::panicking::AssertKind;
                            scope 13 {
                                debug kind => _59;
                            }
                        }
                        scope 14 {
                            debug clo0 => const ZeroSized: [closure@ui/closures/closure_no_cap_coerce_many_run_pass.rs:46:16: 46:26];
                            scope 15 {
                                debug clo1 => const ZeroSized: [closure@ui/closures/closure_no_cap_coerce_many_run_pass.rs:47:16: 47:19];
                                scope 16 {
                                    debug clo2 => const ZeroSized: [closure@ui/closures/closure_no_cap_coerce_many_run_pass.rs:48:16: 48:19];
                                    let _62: fn(usize) -> i32;
                                    scope 17 {
                                        debug f => _62;
                                        let _69: &i32;
                                        let _70: &i32;
                                        let _78: [fn(i32, i32) -> i32; 2];
                                        let mut _102: &i32;
                                        scope 18 {
                                            debug left_val => _69;
                                            debug right_val => _70;
                                            let _75: core::panicking::AssertKind;
                                            scope 19 {
                                                debug kind => _75;
                                            }
                                        }
                                        scope 20 {
                                            debug funcs => _78;
                                            let _94: &[i32; 2];
                                            let _95: &[i32; 2];
                                            let mut _101: &[i32; 2];
                                            scope 21 {
                                                debug left_val => _94;
                                                debug right_val => _95;
                                                let _98: core::panicking::AssertKind;
                                                scope 22 {
                                                    debug kind => _98;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _1 = const ZeroSized: [closure@ui/closures/closure_no_cap_coerce_many_run_pass.rs:20:13: 20:16] as fn(usize) -> usize (Pointer(ClosureFnPointer(Normal)));
        _4 = _1(const 42_usize) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = &_4;
        _106 = const _;
        _2 = (move _3, _106);
        _5 = (_2.0: &usize);
        _6 = (_2.1: &usize);
        _9 = (*_5);
        _10 = (*_6);
        _8 = Eq(move _9, move _10);
        _7 = Not(move _8);
        switchInt(move _7) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _11 = core::panicking::AssertKind::Eq;
        _13 = Option::<Arguments<'_>>::None;
        _12 = core::panicking::assert_failed::<usize, usize>(move _11, _5, _6, move _13) -> unwind continue;
    }

    bb3: {
        _15 = const 0_i32;
        switchInt(_15) -> [0: bb5, 1: bb6, otherwise: bb4];
    }

    bb4: {
        _16 = core::panicking::panic(const "not implemented") -> unwind continue;
    }

    bb5: {
        _14 = foo as fn(usize) -> usize (Pointer(ReifyFnPointer));
        goto -> bb7;
    }

    bb6: {
        _14 = const ZeroSized: [closure@ui/closures/closure_no_cap_coerce_many_run_pass.rs:26:14: 26:17] as fn(usize) -> usize (Pointer(ClosureFnPointer(Normal)));
        goto -> bb7;
    }

    bb7: {
        _20 = _14;
        _19 = move _20(const 42_usize) -> [return: bb8, unwind continue];
    }

    bb8: {
        _18 = &_19;
        _105 = const _;
        _17 = (move _18, _105);
        _21 = (_17.0: &usize);
        _22 = (_17.1: &usize);
        _25 = (*_21);
        _26 = (*_22);
        _24 = Eq(move _25, move _26);
        _23 = Not(move _24);
        switchInt(move _23) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _27 = core::panicking::AssertKind::Eq;
        _29 = Option::<Arguments<'_>>::None;
        _28 = core::panicking::assert_failed::<usize, usize>(move _27, _21, _22, move _29) -> unwind continue;
    }

    bb10: {
        _31 = const 2_i32;
        switchInt(_31) -> [2: bb12, 0: bb13, otherwise: bb11];
    }

    bb11: {
        _32 = core::panicking::panic(const "not implemented") -> unwind continue;
    }

    bb12: {
        _30 = const ZeroSized: [closure@ui/closures/closure_no_cap_coerce_many_run_pass.rs:32:14: 32:17] as fn(usize) -> usize (Pointer(ClosureFnPointer(Normal)));
        goto -> bb14;
    }

    bb13: {
        _30 = foo as fn(usize) -> usize (Pointer(ReifyFnPointer));
        goto -> bb14;
    }

    bb14: {
        _36 = _30;
        _35 = move _36(const 42_usize) -> [return: bb15, unwind continue];
    }

    bb15: {
        _34 = &_35;
        _104 = const _;
        _33 = (move _34, _104);
        _37 = (_33.0: &usize);
        _38 = (_33.1: &usize);
        _41 = (*_37);
        _42 = (*_38);
        _40 = Eq(move _41, move _42);
        _39 = Not(move _40);
        switchInt(move _39) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _43 = core::panicking::AssertKind::Eq;
        _45 = Option::<Arguments<'_>>::None;
        _44 = core::panicking::assert_failed::<usize, usize>(move _43, _37, _38, move _45) -> unwind continue;
    }

    bb17: {
        _47 = const 1_i32;
        switchInt(_47) -> [0: bb19, 1: bb20, 2: bb21, otherwise: bb18];
    }

    bb18: {
        _48 = core::panicking::panic(const "not implemented") -> unwind continue;
    }

    bb19: {
        _46 = foo as fn(usize) -> usize (Pointer(ReifyFnPointer));
        goto -> bb22;
    }

    bb20: {
        _46 = bar as fn(usize) -> usize (Pointer(ReifyFnPointer));
        goto -> bb22;
    }

    bb21: {
        _46 = const ZeroSized: [closure@ui/closures/closure_no_cap_coerce_many_run_pass.rs:41:14: 41:17] as fn(usize) -> usize (Pointer(ClosureFnPointer(Normal)));
        goto -> bb22;
    }

    bb22: {
        _52 = _46;
        _51 = move _52(const 42_usize) -> [return: bb23, unwind continue];
    }

    bb23: {
        _50 = &_51;
        _103 = const _;
        _49 = (move _50, _103);
        _53 = (_49.0: &usize);
        _54 = (_49.1: &usize);
        _57 = (*_53);
        _58 = (*_54);
        _56 = Eq(move _57, move _58);
        _55 = Not(move _56);
        switchInt(move _55) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _59 = core::panicking::AssertKind::Eq;
        _61 = Option::<Arguments<'_>>::None;
        _60 = core::panicking::assert_failed::<usize, usize>(move _59, _53, _54, move _61) -> unwind continue;
    }

    bb25: {
        _63 = const 0_i32;
        switchInt(_63) -> [0: bb27, 1: bb28, 2: bb29, otherwise: bb26];
    }

    bb26: {
        _64 = core::panicking::panic(const "not implemented") -> unwind continue;
    }

    bb27: {
        _62 = const ZeroSized: [closure@ui/closures/closure_no_cap_coerce_many_run_pass.rs:46:16: 46:26] as fn(usize) -> i32 (Pointer(ClosureFnPointer(Normal)));
        goto -> bb30;
    }

    bb28: {
        _62 = const ZeroSized: [closure@ui/closures/closure_no_cap_coerce_many_run_pass.rs:47:16: 47:19] as fn(usize) -> i32 (Pointer(ClosureFnPointer(Normal)));
        goto -> bb30;
    }

    bb29: {
        _62 = const ZeroSized: [closure@ui/closures/closure_no_cap_coerce_many_run_pass.rs:48:16: 48:19] as fn(usize) -> i32 (Pointer(ClosureFnPointer(Normal)));
        goto -> bb30;
    }

    bb30: {
        _68 = _62;
        _67 = move _68(const 42_usize) -> [return: bb31, unwind continue];
    }

    bb31: {
        _66 = &_67;
        _102 = const _;
        _65 = (move _66, _102);
        _69 = (_65.0: &i32);
        _70 = (_65.1: &i32);
        _73 = (*_69);
        _74 = (*_70);
        _72 = Eq(move _73, move _74);
        _71 = Not(move _72);
        switchInt(move _71) -> [0: bb33, otherwise: bb32];
    }

    bb32: {
        _75 = core::panicking::AssertKind::Eq;
        _77 = Option::<Arguments<'_>>::None;
        _76 = core::panicking::assert_failed::<i32, i32>(move _75, _69, _70, move _77) -> unwind continue;
    }

    bb33: {
        _79 = add as fn(i32, i32) -> i32 (Pointer(ReifyFnPointer));
        _80 = const ZeroSized: [closure@ui/closures/closure_no_cap_coerce_many_run_pass.rs:57:23: 57:29] as fn(i32, i32) -> i32 (Pointer(ClosureFnPointer(Normal)));
        _78 = [move _79, move _80];
        _86 = const 0_usize;
        _87 = const 2_usize;
        _88 = Lt(_86, _87);
        assert(move _88, "index out of bounds: the length is {} but the index is {}", move _87, _86) -> [success: bb34, unwind continue];
    }

    bb34: {
        _85 = _78[_86];
        _84 = move _85(const 5_i32, const 5_i32) -> [return: bb35, unwind continue];
    }

    bb35: {
        _91 = const 1_usize;
        _92 = const 2_usize;
        _93 = Lt(_91, _92);
        assert(move _93, "index out of bounds: the length is {} but the index is {}", move _92, _91) -> [success: bb36, unwind continue];
    }

    bb36: {
        _90 = _78[_91];
        _89 = move _90(const 5_i32, const 5_i32) -> [return: bb37, unwind continue];
    }

    bb37: {
        _83 = [move _84, move _89];
        _82 = &_83;
        _101 = const _;
        _81 = (move _82, _101);
        _94 = (_81.0: &[i32; 2]);
        _95 = (_81.1: &[i32; 2]);
        _97 = <[i32; 2] as PartialEq>::eq(_94, _95) -> [return: bb38, unwind continue];
    }

    bb38: {
        _96 = Not(move _97);
        switchInt(move _96) -> [0: bb40, otherwise: bb39];
    }

    bb39: {
        _98 = core::panicking::AssertKind::Eq;
        _100 = Option::<Arguments<'_>>::None;
        _99 = core::panicking::assert_failed::<[i32; 2], [i32; 2]>(move _98, _94, _95, move _100) -> unwind continue;
    }

    bb40: {
        return;
    }
}

promoted[0] in main: &[i32; 2] = {
    let mut _0: &[i32; 2];
    let mut _1: [i32; 2];

    bb0: {
        _1 = [const 10_i32, const 0_i32];
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 0_i32;
        _0 = &_1;
        return;
    }
}

promoted[2] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 1_usize;
        _0 = &_1;
        return;
    }
}

promoted[3] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 2_usize;
        _0 = &_1;
        return;
    }
}

promoted[4] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 0_usize;
        _0 = &_1;
        return;
    }
}

promoted[5] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 42_usize;
        _0 = &_1;
        return;
    }
}

fn main::{closure#0}(_1: &[closure@ui/closures/closure_no_cap_coerce_many_run_pass.rs:20:13: 20:16], _2: usize) -> usize {
    debug x => _2;
    let mut _0: usize;

    bb0: {
        _0 = _2;
        return;
    }
}

fn main::{closure#1}(_1: &[closure@ui/closures/closure_no_cap_coerce_many_run_pass.rs:26:14: 26:17], _2: usize) -> usize {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn main::{closure#2}(_1: &[closure@ui/closures/closure_no_cap_coerce_many_run_pass.rs:32:14: 32:17], _2: usize) -> usize {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

fn main::{closure#3}(_1: &[closure@ui/closures/closure_no_cap_coerce_many_run_pass.rs:41:14: 41:17], _2: usize) -> usize {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

fn main::{closure#4}(_1: &[closure@ui/closures/closure_no_cap_coerce_many_run_pass.rs:46:16: 46:26], _2: usize) -> i32 {
    let mut _0: i32;

    bb0: {
        _0 = const 0_i32;
        return;
    }
}

fn main::{closure#5}(_1: &[closure@ui/closures/closure_no_cap_coerce_many_run_pass.rs:47:16: 47:19], _2: usize) -> i32 {
    let mut _0: i32;

    bb0: {
        _0 = const 1_i32;
        return;
    }
}

fn main::{closure#6}(_1: &[closure@ui/closures/closure_no_cap_coerce_many_run_pass.rs:48:16: 48:19], _2: usize) -> i32 {
    let mut _0: i32;

    bb0: {
        _0 = const 2_i32;
        return;
    }
}

fn main::{closure#7}(_1: &[closure@ui/closures/closure_no_cap_coerce_many_run_pass.rs:57:23: 57:29], _2: i32, _3: i32) -> i32 {
    debug a => _2;
    debug b => _3;
    let mut _0: i32;

    bb0: {
        _0 = Sub(_2, _3);
        return;
    }
}
