// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/dynamically-sized-types/dst-trait-tuple.rs:9:16: 9:21>::clone(_1: &Bar) -> Bar {
    debug self => _1;
    let mut _0: Bar;

    bb0: {
        return;
    }
}

fn <impl at ui/dynamically-sized-types/dst-trait-tuple.rs:9:23: 9:32>::eq(_1: &Bar, _2: &Bar) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;

    bb0: {
        _0 = const true;
        return;
    }
}

fn <impl at ui/dynamically-sized-types/dst-trait-tuple.rs:9:34: 9:36>::assert_receiver_is_total_eq(_1: &Bar) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn <impl at ui/dynamically-sized-types/dst-trait-tuple.rs:9:38: 9:43>::fmt(_1: &Bar, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Bar";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/dynamically-sized-types/dst-trait-tuple.rs:12:16: 12:21>::clone(_1: &Bar1) -> Bar1 {
    debug self => _1;
    let mut _0: Bar1;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn <impl at ui/dynamically-sized-types/dst-trait-tuple.rs:12:23: 12:32>::eq(_1: &Bar1, _2: &Bar1) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: isize;
    let mut _4: isize;

    bb0: {
        _3 = ((*_1).0: isize);
        _4 = ((*_2).0: isize);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn <impl at ui/dynamically-sized-types/dst-trait-tuple.rs:12:34: 12:36>::assert_receiver_is_total_eq(_1: &Bar1) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn <impl at ui/dynamically-sized-types/dst-trait-tuple.rs:22:1: 22:19>::to_bar(_1: &Bar) -> Bar {
    debug self => _1;
    let mut _0: Bar;

    bb0: {
        return;
    }
}

fn <impl at ui/dynamically-sized-types/dst-trait-tuple.rs:22:1: 22:19>::to_val(_1: &Bar) -> isize {
    debug self => _1;
    let mut _0: isize;

    bb0: {
        _0 = const 0_isize;
        return;
    }
}

fn <impl at ui/dynamically-sized-types/dst-trait-tuple.rs:30:1: 30:20>::to_bar(_1: &Bar1) -> Bar {
    debug self => _1;
    let mut _0: Bar;

    bb0: {
        return;
    }
}

fn <impl at ui/dynamically-sized-types/dst-trait-tuple.rs:30:1: 30:20>::to_val(_1: &Bar1) -> isize {
    debug self => _1;
    let mut _0: isize;

    bb0: {
        _0 = ((*_1).0: isize);
        return;
    }
}

fn foo(_1: &(isize, &str, dyn ToBar)) -> () {
    debug x => _1;
    let mut _0: ();
    let mut _2: (&isize, &isize);
    let mut _3: &isize;
    let _4: &isize;
    let _5: &isize;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: isize;
    let mut _9: isize;
    let _11: !;
    let mut _12: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _13: (&&str, &&str);
    let mut _14: &&str;
    let _15: &&str;
    let _16: &&str;
    let mut _17: bool;
    let mut _18: bool;
    let _20: !;
    let mut _21: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _22: (&Bar, &Bar);
    let mut _23: &Bar;
    let _24: Bar;
    let mut _25: &dyn ToBar;
    let _26: &Bar;
    let _27: &Bar;
    let mut _28: bool;
    let mut _29: bool;
    let _31: !;
    let mut _32: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _33: (&isize, &isize);
    let mut _34: &isize;
    let _35: isize;
    let mut _36: &dyn ToBar;
    let _37: &isize;
    let _38: &isize;
    let mut _39: bool;
    let mut _40: bool;
    let mut _41: isize;
    let mut _42: isize;
    let _44: !;
    let mut _45: std::option::Option<std::fmt::Arguments<'_>>;
    let _46: &dyn ToBar;
    let mut _47: (&Bar, &Bar);
    let mut _48: &Bar;
    let _49: Bar;
    let mut _52: bool;
    let mut _53: bool;
    let _55: !;
    let mut _56: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _57: (&isize, &isize);
    let mut _58: &isize;
    let _59: isize;
    let mut _62: bool;
    let mut _63: bool;
    let mut _64: isize;
    let mut _65: isize;
    let _67: !;
    let mut _68: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _71: &isize;
    let mut _72: &Bar;
    let mut _73: &&str;
    let mut _74: &isize;
    scope 1 {
        debug left_val => _4;
        debug right_val => _5;
        let _10: core::panicking::AssertKind;
        scope 2 {
            debug kind => _10;
        }
    }
    scope 3 {
        debug left_val => _15;
        debug right_val => _16;
        let _19: core::panicking::AssertKind;
        scope 4 {
            debug kind => _19;
        }
    }
    scope 5 {
        debug left_val => _26;
        debug right_val => _27;
        let _30: core::panicking::AssertKind;
        scope 6 {
            debug kind => _30;
        }
    }
    scope 7 {
        debug left_val => _37;
        debug right_val => _38;
        let _43: core::panicking::AssertKind;
        scope 8 {
            debug kind => _43;
        }
    }
    scope 9 {
        debug y => _46;
        let _50: &Bar;
        let _51: &Bar;
        let _60: &isize;
        let _61: &isize;
        let mut _69: &isize;
        let mut _70: &Bar;
        scope 10 {
            debug left_val => _50;
            debug right_val => _51;
            let _54: core::panicking::AssertKind;
            scope 11 {
                debug kind => _54;
            }
        }
        scope 12 {
            debug left_val => _60;
            debug right_val => _61;
            let _66: core::panicking::AssertKind;
            scope 13 {
                debug kind => _66;
            }
        }
    }

    bb0: {
        _3 = &((*_1).0: isize);
        _74 = const _;
        _2 = (move _3, _74);
        _4 = (_2.0: &isize);
        _5 = (_2.1: &isize);
        _8 = (*_4);
        _9 = (*_5);
        _7 = Eq(move _8, move _9);
        _6 = Not(move _7);
        switchInt(move _6) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _10 = core::panicking::AssertKind::Eq;
        _12 = Option::<Arguments<'_>>::None;
        _11 = core::panicking::assert_failed::<isize, isize>(move _10, _4, _5, move _12) -> unwind continue;
    }

    bb2: {
        _14 = &((*_1).1: &str);
        _73 = const _;
        _13 = (move _14, _73);
        _15 = (_13.0: &&str);
        _16 = (_13.1: &&str);
        _18 = <&str as PartialEq>::eq(_15, _16) -> [return: bb3, unwind continue];
    }

    bb3: {
        _17 = Not(move _18);
        switchInt(move _17) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _19 = core::panicking::AssertKind::Eq;
        _21 = Option::<Arguments<'_>>::None;
        _20 = core::panicking::assert_failed::<&str, &str>(move _19, _15, _16, move _21) -> unwind continue;
    }

    bb5: {
        _25 = &((*_1).2: dyn ToBar);
        _24 = <dyn ToBar as ToBar>::to_bar(move _25) -> [return: bb6, unwind continue];
    }

    bb6: {
        _23 = &_24;
        _72 = const _;
        _22 = (move _23, _72);
        _26 = (_22.0: &Bar);
        _27 = (_22.1: &Bar);
        _29 = <Bar as PartialEq>::eq(_26, _27) -> [return: bb7, unwind continue];
    }

    bb7: {
        _28 = Not(move _29);
        switchInt(move _28) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _30 = core::panicking::AssertKind::Eq;
        _32 = Option::<Arguments<'_>>::None;
        _31 = core::panicking::assert_failed::<Bar, Bar>(move _30, _26, _27, move _32) -> unwind continue;
    }

    bb9: {
        _36 = &((*_1).2: dyn ToBar);
        _35 = <dyn ToBar as ToBar>::to_val(move _36) -> [return: bb10, unwind continue];
    }

    bb10: {
        _34 = &_35;
        _71 = const _;
        _33 = (move _34, _71);
        _37 = (_33.0: &isize);
        _38 = (_33.1: &isize);
        _41 = (*_37);
        _42 = (*_38);
        _40 = Eq(move _41, move _42);
        _39 = Not(move _40);
        switchInt(move _39) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _43 = core::panicking::AssertKind::Eq;
        _45 = Option::<Arguments<'_>>::None;
        _44 = core::panicking::assert_failed::<isize, isize>(move _43, _37, _38, move _45) -> unwind continue;
    }

    bb12: {
        _46 = &((*_1).2: dyn ToBar);
        _49 = <dyn ToBar as ToBar>::to_bar(_46) -> [return: bb13, unwind continue];
    }

    bb13: {
        _48 = &_49;
        _70 = const _;
        _47 = (move _48, _70);
        _50 = (_47.0: &Bar);
        _51 = (_47.1: &Bar);
        _53 = <Bar as PartialEq>::eq(_50, _51) -> [return: bb14, unwind continue];
    }

    bb14: {
        _52 = Not(move _53);
        switchInt(move _52) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _54 = core::panicking::AssertKind::Eq;
        _56 = Option::<Arguments<'_>>::None;
        _55 = core::panicking::assert_failed::<Bar, Bar>(move _54, _50, _51, move _56) -> unwind continue;
    }

    bb16: {
        _59 = <dyn ToBar as ToBar>::to_val(_46) -> [return: bb17, unwind continue];
    }

    bb17: {
        _58 = &_59;
        _69 = const _;
        _57 = (move _58, _69);
        _60 = (_57.0: &isize);
        _61 = (_57.1: &isize);
        _64 = (*_60);
        _65 = (*_61);
        _63 = Eq(move _64, move _65);
        _62 = Not(move _63);
        switchInt(move _62) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _66 = core::panicking::AssertKind::Eq;
        _68 = Option::<Arguments<'_>>::None;
        _67 = core::panicking::assert_failed::<isize, isize>(move _66, _60, _61, move _68) -> unwind continue;
    }

    bb19: {
        return;
    }
}

promoted[0] in foo: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 42_isize;
        _0 = &_1;
        return;
    }
}

promoted[1] in foo: &Bar = {
    let mut _0: &Bar;
    let mut _1: Bar;

    bb0: {
        _1 = Bar;
        _0 = &_1;
        return;
    }
}

promoted[2] in foo: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 42_isize;
        _0 = &_1;
        return;
    }
}

promoted[3] in foo: &Bar = {
    let mut _0: &Bar;
    let mut _1: Bar;

    bb0: {
        _1 = Bar;
        _0 = &_1;
        return;
    }
}

promoted[4] in foo: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "some str";
        _0 = &_1;
        return;
    }
}

promoted[5] in foo: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 5_isize;
        _0 = &_1;
        return;
    }
}

fn bar(_1: &dyn ToBar) -> () {
    debug x => _1;
    let mut _0: ();
    let mut _2: (&Bar, &Bar);
    let mut _3: &Bar;
    let _4: Bar;
    let _5: &Bar;
    let _6: &Bar;
    let mut _7: bool;
    let mut _8: bool;
    let _10: !;
    let mut _11: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _12: (&isize, &isize);
    let mut _13: &isize;
    let _14: isize;
    let _15: &isize;
    let _16: &isize;
    let mut _17: bool;
    let mut _18: bool;
    let mut _19: isize;
    let mut _20: isize;
    let _22: !;
    let mut _23: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _24: &isize;
    let mut _25: &Bar;
    scope 1 {
        debug left_val => _5;
        debug right_val => _6;
        let _9: core::panicking::AssertKind;
        scope 2 {
            debug kind => _9;
        }
    }
    scope 3 {
        debug left_val => _15;
        debug right_val => _16;
        let _21: core::panicking::AssertKind;
        scope 4 {
            debug kind => _21;
        }
    }

    bb0: {
        _4 = <dyn ToBar as ToBar>::to_bar(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = &_4;
        _25 = const _;
        _2 = (move _3, _25);
        _5 = (_2.0: &Bar);
        _6 = (_2.1: &Bar);
        _8 = <Bar as PartialEq>::eq(_5, _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = Not(move _8);
        switchInt(move _7) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _9 = core::panicking::AssertKind::Eq;
        _11 = Option::<Arguments<'_>>::None;
        _10 = core::panicking::assert_failed::<Bar, Bar>(move _9, _5, _6, move _11) -> unwind continue;
    }

    bb4: {
        _14 = <dyn ToBar as ToBar>::to_val(_1) -> [return: bb5, unwind continue];
    }

    bb5: {
        _13 = &_14;
        _24 = const _;
        _12 = (move _13, _24);
        _15 = (_12.0: &isize);
        _16 = (_12.1: &isize);
        _19 = (*_15);
        _20 = (*_16);
        _18 = Eq(move _19, move _20);
        _17 = Not(move _18);
        switchInt(move _17) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _21 = core::panicking::AssertKind::Eq;
        _23 = Option::<Arguments<'_>>::None;
        _22 = core::panicking::assert_failed::<isize, isize>(move _21, _15, _16, move _23) -> unwind continue;
    }

    bb7: {
        return;
    }
}

promoted[0] in bar: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 42_isize;
        _0 = &_1;
        return;
    }
}

promoted[1] in bar: &Bar = {
    let mut _0: &Bar;
    let mut _1: Bar;

    bb0: {
        _1 = Bar;
        _0 = &_1;
        return;
    }
}

fn baz(_1: &(isize, &str, (isize, &str, dyn ToBar))) -> () {
    debug x => _1;
    let mut _0: ();
    let mut _2: (&isize, &isize);
    let mut _3: &isize;
    let _4: &isize;
    let _5: &isize;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: isize;
    let mut _9: isize;
    let _11: !;
    let mut _12: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _13: (&&str, &&str);
    let mut _14: &&str;
    let _15: &&str;
    let _16: &&str;
    let mut _17: bool;
    let mut _18: bool;
    let _20: !;
    let mut _21: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _22: (&isize, &isize);
    let mut _23: &isize;
    let _24: &isize;
    let _25: &isize;
    let mut _26: bool;
    let mut _27: bool;
    let mut _28: isize;
    let mut _29: isize;
    let _31: !;
    let mut _32: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _33: (&&str, &&str);
    let mut _34: &&str;
    let _35: &&str;
    let _36: &&str;
    let mut _37: bool;
    let mut _38: bool;
    let _40: !;
    let mut _41: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _42: (&Bar, &Bar);
    let mut _43: &Bar;
    let _44: Bar;
    let mut _45: &dyn ToBar;
    let _46: &Bar;
    let _47: &Bar;
    let mut _48: bool;
    let mut _49: bool;
    let _51: !;
    let mut _52: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _53: (&isize, &isize);
    let mut _54: &isize;
    let _55: isize;
    let mut _56: &dyn ToBar;
    let _57: &isize;
    let _58: &isize;
    let mut _59: bool;
    let mut _60: bool;
    let mut _61: isize;
    let mut _62: isize;
    let _64: !;
    let mut _65: std::option::Option<std::fmt::Arguments<'_>>;
    let _66: &dyn ToBar;
    let mut _67: (&Bar, &Bar);
    let mut _68: &Bar;
    let _69: Bar;
    let mut _72: bool;
    let mut _73: bool;
    let _75: !;
    let mut _76: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _77: (&isize, &isize);
    let mut _78: &isize;
    let _79: isize;
    let mut _82: bool;
    let mut _83: bool;
    let mut _84: isize;
    let mut _85: isize;
    let _87: !;
    let mut _88: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _91: &isize;
    let mut _92: &Bar;
    let mut _93: &&str;
    let mut _94: &isize;
    let mut _95: &&str;
    let mut _96: &isize;
    scope 1 {
        debug left_val => _4;
        debug right_val => _5;
        let _10: core::panicking::AssertKind;
        scope 2 {
            debug kind => _10;
        }
    }
    scope 3 {
        debug left_val => _15;
        debug right_val => _16;
        let _19: core::panicking::AssertKind;
        scope 4 {
            debug kind => _19;
        }
    }
    scope 5 {
        debug left_val => _24;
        debug right_val => _25;
        let _30: core::panicking::AssertKind;
        scope 6 {
            debug kind => _30;
        }
    }
    scope 7 {
        debug left_val => _35;
        debug right_val => _36;
        let _39: core::panicking::AssertKind;
        scope 8 {
            debug kind => _39;
        }
    }
    scope 9 {
        debug left_val => _46;
        debug right_val => _47;
        let _50: core::panicking::AssertKind;
        scope 10 {
            debug kind => _50;
        }
    }
    scope 11 {
        debug left_val => _57;
        debug right_val => _58;
        let _63: core::panicking::AssertKind;
        scope 12 {
            debug kind => _63;
        }
    }
    scope 13 {
        debug y => _66;
        let _70: &Bar;
        let _71: &Bar;
        let _80: &isize;
        let _81: &isize;
        let mut _89: &isize;
        let mut _90: &Bar;
        scope 14 {
            debug left_val => _70;
            debug right_val => _71;
            let _74: core::panicking::AssertKind;
            scope 15 {
                debug kind => _74;
            }
        }
        scope 16 {
            debug left_val => _80;
            debug right_val => _81;
            let _86: core::panicking::AssertKind;
            scope 17 {
                debug kind => _86;
            }
        }
    }

    bb0: {
        _3 = &((*_1).0: isize);
        _96 = const _;
        _2 = (move _3, _96);
        _4 = (_2.0: &isize);
        _5 = (_2.1: &isize);
        _8 = (*_4);
        _9 = (*_5);
        _7 = Eq(move _8, move _9);
        _6 = Not(move _7);
        switchInt(move _6) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _10 = core::panicking::AssertKind::Eq;
        _12 = Option::<Arguments<'_>>::None;
        _11 = core::panicking::assert_failed::<isize, isize>(move _10, _4, _5, move _12) -> unwind continue;
    }

    bb2: {
        _14 = &((*_1).1: &str);
        _95 = const _;
        _13 = (move _14, _95);
        _15 = (_13.0: &&str);
        _16 = (_13.1: &&str);
        _18 = <&str as PartialEq>::eq(_15, _16) -> [return: bb3, unwind continue];
    }

    bb3: {
        _17 = Not(move _18);
        switchInt(move _17) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _19 = core::panicking::AssertKind::Eq;
        _21 = Option::<Arguments<'_>>::None;
        _20 = core::panicking::assert_failed::<&str, &str>(move _19, _15, _16, move _21) -> unwind continue;
    }

    bb5: {
        _23 = &(((*_1).2: (isize, &str, dyn ToBar)).0: isize);
        _94 = const _;
        _22 = (move _23, _94);
        _24 = (_22.0: &isize);
        _25 = (_22.1: &isize);
        _28 = (*_24);
        _29 = (*_25);
        _27 = Eq(move _28, move _29);
        _26 = Not(move _27);
        switchInt(move _26) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _30 = core::panicking::AssertKind::Eq;
        _32 = Option::<Arguments<'_>>::None;
        _31 = core::panicking::assert_failed::<isize, isize>(move _30, _24, _25, move _32) -> unwind continue;
    }

    bb7: {
        _34 = &(((*_1).2: (isize, &str, dyn ToBar)).1: &str);
        _93 = const _;
        _33 = (move _34, _93);
        _35 = (_33.0: &&str);
        _36 = (_33.1: &&str);
        _38 = <&str as PartialEq>::eq(_35, _36) -> [return: bb8, unwind continue];
    }

    bb8: {
        _37 = Not(move _38);
        switchInt(move _37) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _39 = core::panicking::AssertKind::Eq;
        _41 = Option::<Arguments<'_>>::None;
        _40 = core::panicking::assert_failed::<&str, &str>(move _39, _35, _36, move _41) -> unwind continue;
    }

    bb10: {
        _45 = &(((*_1).2: (isize, &str, dyn ToBar)).2: dyn ToBar);
        _44 = <dyn ToBar as ToBar>::to_bar(move _45) -> [return: bb11, unwind continue];
    }

    bb11: {
        _43 = &_44;
        _92 = const _;
        _42 = (move _43, _92);
        _46 = (_42.0: &Bar);
        _47 = (_42.1: &Bar);
        _49 = <Bar as PartialEq>::eq(_46, _47) -> [return: bb12, unwind continue];
    }

    bb12: {
        _48 = Not(move _49);
        switchInt(move _48) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _50 = core::panicking::AssertKind::Eq;
        _52 = Option::<Arguments<'_>>::None;
        _51 = core::panicking::assert_failed::<Bar, Bar>(move _50, _46, _47, move _52) -> unwind continue;
    }

    bb14: {
        _56 = &(((*_1).2: (isize, &str, dyn ToBar)).2: dyn ToBar);
        _55 = <dyn ToBar as ToBar>::to_val(move _56) -> [return: bb15, unwind continue];
    }

    bb15: {
        _54 = &_55;
        _91 = const _;
        _53 = (move _54, _91);
        _57 = (_53.0: &isize);
        _58 = (_53.1: &isize);
        _61 = (*_57);
        _62 = (*_58);
        _60 = Eq(move _61, move _62);
        _59 = Not(move _60);
        switchInt(move _59) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _63 = core::panicking::AssertKind::Eq;
        _65 = Option::<Arguments<'_>>::None;
        _64 = core::panicking::assert_failed::<isize, isize>(move _63, _57, _58, move _65) -> unwind continue;
    }

    bb17: {
        _66 = &(((*_1).2: (isize, &str, dyn ToBar)).2: dyn ToBar);
        _69 = <dyn ToBar as ToBar>::to_bar(_66) -> [return: bb18, unwind continue];
    }

    bb18: {
        _68 = &_69;
        _90 = const _;
        _67 = (move _68, _90);
        _70 = (_67.0: &Bar);
        _71 = (_67.1: &Bar);
        _73 = <Bar as PartialEq>::eq(_70, _71) -> [return: bb19, unwind continue];
    }

    bb19: {
        _72 = Not(move _73);
        switchInt(move _72) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _74 = core::panicking::AssertKind::Eq;
        _76 = Option::<Arguments<'_>>::None;
        _75 = core::panicking::assert_failed::<Bar, Bar>(move _74, _70, _71, move _76) -> unwind continue;
    }

    bb21: {
        _79 = <dyn ToBar as ToBar>::to_val(_66) -> [return: bb22, unwind continue];
    }

    bb22: {
        _78 = &_79;
        _89 = const _;
        _77 = (move _78, _89);
        _80 = (_77.0: &isize);
        _81 = (_77.1: &isize);
        _84 = (*_80);
        _85 = (*_81);
        _83 = Eq(move _84, move _85);
        _82 = Not(move _83);
        switchInt(move _82) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _86 = core::panicking::AssertKind::Eq;
        _88 = Option::<Arguments<'_>>::None;
        _87 = core::panicking::assert_failed::<isize, isize>(move _86, _80, _81, move _88) -> unwind continue;
    }

    bb24: {
        return;
    }
}

promoted[0] in baz: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 42_isize;
        _0 = &_1;
        return;
    }
}

promoted[1] in baz: &Bar = {
    let mut _0: &Bar;
    let mut _1: Bar;

    bb0: {
        _1 = Bar;
        _0 = &_1;
        return;
    }
}

promoted[2] in baz: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 42_isize;
        _0 = &_1;
        return;
    }
}

promoted[3] in baz: &Bar = {
    let mut _0: &Bar;
    let mut _1: Bar;

    bb0: {
        _1 = Bar;
        _0 = &_1;
        return;
    }
}

promoted[4] in baz: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "deep str";
        _0 = &_1;
        return;
    }
}

promoted[5] in baz: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 8_isize;
        _0 = &_1;
        return;
    }
}

promoted[6] in baz: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "some str";
        _0 = &_1;
        return;
    }
}

promoted[7] in baz: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 5_isize;
        _0 = &_1;
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: (isize, &str, Bar1);
    let mut _2: Bar1;
    let _3: ();
    let mut _4: &(isize, &str, dyn ToBar);
    let _5: &(isize, &str, Bar1);
    let _7: ();
    let mut _8: &(isize, &str, dyn ToBar);
    let _10: ();
    let _12: &(isize, &str, Bar1);
    let _13: ();
    let _15: ();
    let mut _17: (&Bar, &Bar);
    let mut _18: &Bar;
    let _19: Bar;
    let mut _20: &dyn ToBar;
    let mut _23: bool;
    let mut _24: bool;
    let _26: !;
    let mut _27: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _29: std::boxed::Box<Bar1>;
    let mut _30: Bar1;
    let _31: ();
    let _32: &dyn ToBar;
    let mut _34: (isize, &str, Bar1);
    let mut _35: Bar1;
    let _36: ();
    let mut _37: &(isize, &str, (isize, &str, dyn ToBar));
    let _38: &(isize, &str, (isize, &str, Bar1));
    let _40: ();
    let mut _41: &(isize, &str, (isize, &str, dyn ToBar));
    let _43: ();
    let _45: &(isize, &str, (isize, &str, Bar1));
    let _46: ();
    let _48: ();
    let mut _53: *const dyn ToBar;
    scope 1 {
        debug f1 => _1;
        let _6: &(isize, &str, Bar1);
        scope 2 {
            debug f2 => _6;
            let _9: &(isize, &str, dyn ToBar);
            scope 3 {
                debug f3 => _9;
                let _11: &(isize, &str, dyn ToBar);
                scope 4 {
                    debug f4 => _11;
                    let _14: &(isize, &str, dyn ToBar);
                    let mut _52: &(isize, &str, Bar1);
                    scope 5 {
                        debug f5 => _14;
                        let _16: &(isize, &str, dyn ToBar);
                        let mut _51: &(isize, &str, Bar);
                        scope 6 {
                            debug f6 => _16;
                            let _21: &Bar;
                            let _22: &Bar;
                            let _28: std::boxed::Box<dyn ToBar>;
                            let mut _50: &Bar;
                            scope 7 {
                                debug left_val => _21;
                                debug right_val => _22;
                                let _25: core::panicking::AssertKind;
                                scope 8 {
                                    debug kind => _25;
                                }
                            }
                            scope 9 {
                                debug f7 => _28;
                                let _33: (isize, &str, (isize, &str, Bar1));
                                scope 10 {
                                    debug f1 => _33;
                                    let _39: &(isize, &str, (isize, &str, Bar1));
                                    scope 11 {
                                        debug f2 => _39;
                                        let _42: &(isize, &str, (isize, &str, dyn ToBar));
                                        scope 12 {
                                            debug f3 => _42;
                                            let _44: &(isize, &str, (isize, &str, dyn ToBar));
                                            scope 13 {
                                                debug f4 => _44;
                                                let _47: &(isize, &str, (isize, &str, dyn ToBar));
                                                let mut _49: &(isize, &str, (isize, &str, Bar1));
                                                scope 14 {
                                                    debug f5 => _47;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = Bar1 { f: const 42_isize };
        _1 = (const 5_isize, const "some str", move _2);
        _5 = &_1;
        _4 = _5 as &(isize, &str, dyn ToBar) (Pointer(Unsize));
        _3 = foo(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &_1;
        _8 = _6 as &(isize, &str, dyn ToBar) (Pointer(Unsize));
        _7 = foo(move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = _6 as &(isize, &str, dyn ToBar) (Pointer(Unsize));
        _10 = foo(_9) -> [return: bb3, unwind continue];
    }

    bb3: {
        _12 = &_1;
        _11 = _12 as &(isize, &str, dyn ToBar) (Pointer(Unsize));
        _13 = foo(_11) -> [return: bb4, unwind continue];
    }

    bb4: {
        _52 = const _;
        _14 = _52 as &(isize, &str, dyn ToBar) (Pointer(Unsize));
        _15 = foo(_14) -> [return: bb5, unwind continue];
    }

    bb5: {
        _51 = const _;
        _16 = _51 as &(isize, &str, dyn ToBar) (Pointer(Unsize));
        _20 = &((*_16).2: dyn ToBar);
        _19 = <dyn ToBar as ToBar>::to_bar(move _20) -> [return: bb6, unwind continue];
    }

    bb6: {
        _18 = &_19;
        _50 = const _;
        _17 = (move _18, _50);
        _21 = (_17.0: &Bar);
        _22 = (_17.1: &Bar);
        _24 = <Bar as PartialEq>::eq(_21, _22) -> [return: bb7, unwind continue];
    }

    bb7: {
        _23 = Not(move _24);
        switchInt(move _23) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _25 = core::panicking::AssertKind::Eq;
        _27 = Option::<Arguments<'_>>::None;
        _26 = core::panicking::assert_failed::<Bar, Bar>(move _25, _21, _22, move _27) -> unwind continue;
    }

    bb9: {
        _30 = Bar1 { f: const 42_isize };
        _29 = Box::<Bar1>::new(move _30) -> [return: bb10, unwind continue];
    }

    bb10: {
        _28 = move _29 as std::boxed::Box<dyn ToBar> (Pointer(Unsize));
        _53 = (((_28.0: std::ptr::Unique<dyn ToBar>).0: std::ptr::NonNull<dyn ToBar>).0: *const dyn ToBar);
        _32 = &(*_53);
        _31 = bar(_32) -> [return: bb11, unwind: bb18];
    }

    bb11: {
        _35 = Bar1 { f: const 42_isize };
        _34 = (const 8_isize, const "deep str", move _35);
        _33 = (const 5_isize, const "some str", move _34);
        _38 = &_33;
        _37 = _38 as &(isize, &str, (isize, &str, dyn ToBar)) (Pointer(Unsize));
        _36 = baz(move _37) -> [return: bb12, unwind: bb18];
    }

    bb12: {
        _39 = &_33;
        _41 = _39 as &(isize, &str, (isize, &str, dyn ToBar)) (Pointer(Unsize));
        _40 = baz(move _41) -> [return: bb13, unwind: bb18];
    }

    bb13: {
        _42 = _39 as &(isize, &str, (isize, &str, dyn ToBar)) (Pointer(Unsize));
        _43 = baz(_42) -> [return: bb14, unwind: bb18];
    }

    bb14: {
        _45 = &_33;
        _44 = _45 as &(isize, &str, (isize, &str, dyn ToBar)) (Pointer(Unsize));
        _46 = baz(_44) -> [return: bb15, unwind: bb18];
    }

    bb15: {
        _49 = const _;
        _47 = _49 as &(isize, &str, (isize, &str, dyn ToBar)) (Pointer(Unsize));
        _48 = baz(_47) -> [return: bb16, unwind: bb18];
    }

    bb16: {
        drop(_28) -> [return: bb17, unwind continue];
    }

    bb17: {
        return;
    }

    bb18 (cleanup): {
        drop(_28) -> [return: bb19, unwind terminate];
    }

    bb19 (cleanup): {
        resume;
    }
}

promoted[0] in main: &(isize, &str, (isize, &str, Bar1)) = {
    let mut _0: &(isize, &str, (isize, &str, Bar1));
    let mut _1: (isize, &str, (isize, &str, Bar1));
    let mut _2: (isize, &str, Bar1);
    let mut _3: Bar1;

    bb0: {
        _3 = Bar1 { f: const 42_isize };
        _2 = (const 8_isize, const "deep str", move _3);
        _1 = (const 5_isize, const "some str", move _2);
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &Bar = {
    let mut _0: &Bar;
    let mut _1: Bar;

    bb0: {
        _1 = Bar;
        _0 = &_1;
        return;
    }
}

promoted[2] in main: &(isize, &str, Bar) = {
    let mut _0: &(isize, &str, Bar);
    let mut _1: (isize, &str, Bar);
    let mut _2: Bar;

    bb0: {
        _2 = Bar;
        _1 = (const 5_isize, const "some str", move _2);
        _0 = &_1;
        return;
    }
}

promoted[3] in main: &(isize, &str, Bar1) = {
    let mut _0: &(isize, &str, Bar1);
    let mut _1: (isize, &str, Bar1);
    let mut _2: Bar1;

    bb0: {
        _2 = Bar1 { f: const 42_isize };
        _1 = (const 5_isize, const "some str", move _2);
        _0 = &_1;
        return;
    }
}
