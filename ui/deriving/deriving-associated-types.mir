// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/deriving/deriving-associated-types.rs:24:10: 24:19>::eq(_1: &PrivateStruct<T>, _2: &PrivateStruct<T>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &T;
    let mut _4: &T;

    bb0: {
        _3 = &((*_1).0: T);
        _4 = &((*_2).0: T);
        _0 = <T as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/deriving/deriving-associated-types.rs:24:21: 24:26>::fmt(_1: &PrivateStruct<T>, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&T;
    let _6: &T;

    bb0: {
        _3 = const "PrivateStruct";
        _6 = &((*_1).0: T);
        _5 = &_6;
        _4 = _5 as &dyn std::fmt::Debug (Pointer(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/deriving/deriving-associated-types.rs:27:10: 27:19>::eq(_1: &TupleStruct<A, B, C>, _2: &TupleStruct<A, B, C>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: i32;
    let mut _18: i32;
    let mut _19: bool;
    let mut _20: &std::option::Option<i32>;
    let mut _21: &std::option::Option<i32>;
    let mut _22: bool;
    let mut _23: &A;
    let mut _24: &A;
    let mut _25: bool;
    let mut _26: &PrivateStruct<A>;
    let mut _27: &PrivateStruct<A>;
    let mut _28: bool;
    let mut _29: &B;
    let mut _30: &B;
    let mut _31: bool;
    let mut _32: &<B as DeclaredTrait>::Type;
    let mut _33: &<B as DeclaredTrait>::Type;
    let mut _34: bool;
    let mut _35: &std::option::Option<<B as DeclaredTrait>::Type>;
    let mut _36: &std::option::Option<<B as DeclaredTrait>::Type>;
    let mut _37: bool;
    let mut _38: &<B as DeclaredTrait>::Type;
    let mut _39: &<B as DeclaredTrait>::Type;
    let mut _40: bool;
    let mut _41: &std::option::Option<<B as DeclaredTrait>::Type>;
    let mut _42: &std::option::Option<<B as DeclaredTrait>::Type>;
    let mut _43: bool;
    let mut _44: &C;
    let mut _45: &C;
    let mut _46: bool;
    let mut _47: &<C as WhereTrait>::Type;
    let mut _48: &<C as WhereTrait>::Type;
    let mut _49: bool;
    let mut _50: &std::option::Option<<C as WhereTrait>::Type>;
    let mut _51: &std::option::Option<<C as WhereTrait>::Type>;
    let mut _52: bool;
    let mut _53: &<C as WhereTrait>::Type;
    let mut _54: &<C as WhereTrait>::Type;
    let mut _55: bool;
    let mut _56: &std::option::Option<<C as WhereTrait>::Type>;
    let mut _57: &std::option::Option<<C as WhereTrait>::Type>;
    let mut _58: bool;
    let mut _59: i32;
    let mut _60: i32;

    bb0: {
        _17 = ((*_1).0: i32);
        _18 = ((*_2).0: i32);
        _16 = Eq(move _17, move _18);
        switchInt(move _16) -> [0: bb40, otherwise: bb41];
    }

    bb1: {
        _0 = const false;
        goto -> bb3;
    }

    bb2: {
        _59 = ((*_1).14: i32);
        _60 = ((*_2).14: i32);
        _58 = Eq(move _59, move _60);
        _0 = move _58;
        goto -> bb3;
    }

    bb3: {
        return;
    }

    bb4: {
        _3 = const false;
        goto -> bb6;
    }

    bb5: {
        _56 = &((*_1).13: std::option::Option<<C as WhereTrait>::Type>);
        _57 = &((*_2).13: std::option::Option<<C as WhereTrait>::Type>);
        _55 = <Option<<C as WhereTrait>::Type> as PartialEq>::eq(move _56, move _57) -> [return: bb55, unwind continue];
    }

    bb6: {
        switchInt(move _3) -> [0: bb1, otherwise: bb2];
    }

    bb7: {
        _4 = const false;
        goto -> bb9;
    }

    bb8: {
        _53 = &((*_1).12: <C as WhereTrait>::Type);
        _54 = &((*_2).12: <C as WhereTrait>::Type);
        _52 = <<C as WhereTrait>::Type as PartialEq>::eq(move _53, move _54) -> [return: bb54, unwind continue];
    }

    bb9: {
        switchInt(move _4) -> [0: bb4, otherwise: bb5];
    }

    bb10: {
        _5 = const false;
        goto -> bb12;
    }

    bb11: {
        _50 = &((*_1).11: std::option::Option<<C as WhereTrait>::Type>);
        _51 = &((*_2).11: std::option::Option<<C as WhereTrait>::Type>);
        _49 = <Option<<C as WhereTrait>::Type> as PartialEq>::eq(move _50, move _51) -> [return: bb53, unwind continue];
    }

    bb12: {
        switchInt(move _5) -> [0: bb7, otherwise: bb8];
    }

    bb13: {
        _6 = const false;
        goto -> bb15;
    }

    bb14: {
        _47 = &((*_1).10: <C as WhereTrait>::Type);
        _48 = &((*_2).10: <C as WhereTrait>::Type);
        _46 = <<C as WhereTrait>::Type as PartialEq>::eq(move _47, move _48) -> [return: bb52, unwind continue];
    }

    bb15: {
        switchInt(move _6) -> [0: bb10, otherwise: bb11];
    }

    bb16: {
        _7 = const false;
        goto -> bb18;
    }

    bb17: {
        _44 = &((*_1).9: C);
        _45 = &((*_2).9: C);
        _43 = <C as PartialEq>::eq(move _44, move _45) -> [return: bb51, unwind continue];
    }

    bb18: {
        switchInt(move _7) -> [0: bb13, otherwise: bb14];
    }

    bb19: {
        _8 = const false;
        goto -> bb21;
    }

    bb20: {
        _41 = &((*_1).8: std::option::Option<<B as DeclaredTrait>::Type>);
        _42 = &((*_2).8: std::option::Option<<B as DeclaredTrait>::Type>);
        _40 = <Option<<B as DeclaredTrait>::Type> as PartialEq>::eq(move _41, move _42) -> [return: bb50, unwind continue];
    }

    bb21: {
        switchInt(move _8) -> [0: bb16, otherwise: bb17];
    }

    bb22: {
        _9 = const false;
        goto -> bb24;
    }

    bb23: {
        _38 = &((*_1).7: <B as DeclaredTrait>::Type);
        _39 = &((*_2).7: <B as DeclaredTrait>::Type);
        _37 = <<B as DeclaredTrait>::Type as PartialEq>::eq(move _38, move _39) -> [return: bb49, unwind continue];
    }

    bb24: {
        switchInt(move _9) -> [0: bb19, otherwise: bb20];
    }

    bb25: {
        _10 = const false;
        goto -> bb27;
    }

    bb26: {
        _35 = &((*_1).6: std::option::Option<<B as DeclaredTrait>::Type>);
        _36 = &((*_2).6: std::option::Option<<B as DeclaredTrait>::Type>);
        _34 = <Option<<B as DeclaredTrait>::Type> as PartialEq>::eq(move _35, move _36) -> [return: bb48, unwind continue];
    }

    bb27: {
        switchInt(move _10) -> [0: bb22, otherwise: bb23];
    }

    bb28: {
        _11 = const false;
        goto -> bb30;
    }

    bb29: {
        _32 = &((*_1).5: <B as DeclaredTrait>::Type);
        _33 = &((*_2).5: <B as DeclaredTrait>::Type);
        _31 = <<B as DeclaredTrait>::Type as PartialEq>::eq(move _32, move _33) -> [return: bb47, unwind continue];
    }

    bb30: {
        switchInt(move _11) -> [0: bb25, otherwise: bb26];
    }

    bb31: {
        _12 = const false;
        goto -> bb33;
    }

    bb32: {
        _29 = &((*_1).4: B);
        _30 = &((*_2).4: B);
        _28 = <B as PartialEq>::eq(move _29, move _30) -> [return: bb46, unwind continue];
    }

    bb33: {
        switchInt(move _12) -> [0: bb28, otherwise: bb29];
    }

    bb34: {
        _13 = const false;
        goto -> bb36;
    }

    bb35: {
        _26 = &((*_1).3: PrivateStruct<A>);
        _27 = &((*_2).3: PrivateStruct<A>);
        _25 = <PrivateStruct<A> as PartialEq>::eq(move _26, move _27) -> [return: bb45, unwind continue];
    }

    bb36: {
        switchInt(move _13) -> [0: bb31, otherwise: bb32];
    }

    bb37: {
        _14 = const false;
        goto -> bb39;
    }

    bb38: {
        _23 = &((*_1).2: A);
        _24 = &((*_2).2: A);
        _22 = <A as PartialEq>::eq(move _23, move _24) -> [return: bb44, unwind continue];
    }

    bb39: {
        switchInt(move _14) -> [0: bb34, otherwise: bb35];
    }

    bb40: {
        _15 = const false;
        goto -> bb42;
    }

    bb41: {
        _20 = &((*_1).1: std::option::Option<i32>);
        _21 = &((*_2).1: std::option::Option<i32>);
        _19 = <Option<i32> as PartialEq>::eq(move _20, move _21) -> [return: bb43, unwind continue];
    }

    bb42: {
        switchInt(move _15) -> [0: bb37, otherwise: bb38];
    }

    bb43: {
        _15 = move _19;
        goto -> bb42;
    }

    bb44: {
        _14 = move _22;
        goto -> bb39;
    }

    bb45: {
        _13 = move _25;
        goto -> bb36;
    }

    bb46: {
        _12 = move _28;
        goto -> bb33;
    }

    bb47: {
        _11 = move _31;
        goto -> bb30;
    }

    bb48: {
        _10 = move _34;
        goto -> bb27;
    }

    bb49: {
        _9 = move _37;
        goto -> bb24;
    }

    bb50: {
        _8 = move _40;
        goto -> bb21;
    }

    bb51: {
        _7 = move _43;
        goto -> bb18;
    }

    bb52: {
        _6 = move _46;
        goto -> bb15;
    }

    bb53: {
        _5 = move _49;
        goto -> bb12;
    }

    bb54: {
        _4 = move _52;
        goto -> bb9;
    }

    bb55: {
        _3 = move _55;
        goto -> bb6;
    }
}

fn <impl at ui/deriving/deriving-associated-types.rs:27:21: 27:26>::fmt(_1: &TupleStruct<A, B, C>, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &[&dyn std::fmt::Debug];
    let _4: &[&dyn std::fmt::Debug; 15];
    let _5: [&dyn std::fmt::Debug; 15];
    let mut _6: &dyn std::fmt::Debug;
    let _7: &i32;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &std::option::Option<i32>;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &A;
    let mut _12: &dyn std::fmt::Debug;
    let _13: &PrivateStruct<A>;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &B;
    let mut _16: &dyn std::fmt::Debug;
    let _17: &<B as DeclaredTrait>::Type;
    let mut _18: &dyn std::fmt::Debug;
    let _19: &std::option::Option<<B as DeclaredTrait>::Type>;
    let mut _20: &dyn std::fmt::Debug;
    let _21: &<B as DeclaredTrait>::Type;
    let mut _22: &dyn std::fmt::Debug;
    let _23: &std::option::Option<<B as DeclaredTrait>::Type>;
    let mut _24: &dyn std::fmt::Debug;
    let _25: &C;
    let mut _26: &dyn std::fmt::Debug;
    let _27: &<C as WhereTrait>::Type;
    let mut _28: &dyn std::fmt::Debug;
    let _29: &std::option::Option<<C as WhereTrait>::Type>;
    let mut _30: &dyn std::fmt::Debug;
    let _31: &<C as WhereTrait>::Type;
    let mut _32: &dyn std::fmt::Debug;
    let _33: &std::option::Option<<C as WhereTrait>::Type>;
    let mut _34: &dyn std::fmt::Debug;
    let _35: &&i32;
    let _36: &i32;
    let _37: &str;
    scope 1 {
        debug values => _3;
    }

    bb0: {
        _7 = &((*_1).0: i32);
        _6 = _7 as &dyn std::fmt::Debug (Pointer(Unsize));
        _9 = &((*_1).1: std::option::Option<i32>);
        _8 = _9 as &dyn std::fmt::Debug (Pointer(Unsize));
        _11 = &((*_1).2: A);
        _10 = _11 as &dyn std::fmt::Debug (Pointer(Unsize));
        _13 = &((*_1).3: PrivateStruct<A>);
        _12 = _13 as &dyn std::fmt::Debug (Pointer(Unsize));
        _15 = &((*_1).4: B);
        _14 = _15 as &dyn std::fmt::Debug (Pointer(Unsize));
        _17 = &((*_1).5: <B as DeclaredTrait>::Type);
        _16 = _17 as &dyn std::fmt::Debug (Pointer(Unsize));
        _19 = &((*_1).6: std::option::Option<<B as DeclaredTrait>::Type>);
        _18 = _19 as &dyn std::fmt::Debug (Pointer(Unsize));
        _21 = &((*_1).7: <B as DeclaredTrait>::Type);
        _20 = _21 as &dyn std::fmt::Debug (Pointer(Unsize));
        _23 = &((*_1).8: std::option::Option<<B as DeclaredTrait>::Type>);
        _22 = _23 as &dyn std::fmt::Debug (Pointer(Unsize));
        _25 = &((*_1).9: C);
        _24 = _25 as &dyn std::fmt::Debug (Pointer(Unsize));
        _27 = &((*_1).10: <C as WhereTrait>::Type);
        _26 = _27 as &dyn std::fmt::Debug (Pointer(Unsize));
        _29 = &((*_1).11: std::option::Option<<C as WhereTrait>::Type>);
        _28 = _29 as &dyn std::fmt::Debug (Pointer(Unsize));
        _31 = &((*_1).12: <C as WhereTrait>::Type);
        _30 = _31 as &dyn std::fmt::Debug (Pointer(Unsize));
        _33 = &((*_1).13: std::option::Option<<C as WhereTrait>::Type>);
        _32 = _33 as &dyn std::fmt::Debug (Pointer(Unsize));
        _36 = &((*_1).14: i32);
        _35 = &_36;
        _34 = _35 as &dyn std::fmt::Debug (Pointer(Unsize));
        _5 = [move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22, move _24, move _26, move _28, move _30, move _32, move _34];
        _4 = &_5;
        _3 = _4 as &[&dyn std::fmt::Debug] (Pointer(Unsize));
        _37 = const "TupleStruct";
        _0 = Formatter::<'_>::debug_tuple_fields_finish(_2, _37, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/deriving/deriving-associated-types.rs:46:10: 46:19>::eq(_1: &Struct<A, B, C>, _2: &Struct<A, B, C>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: i32;
    let mut _18: i32;
    let mut _19: bool;
    let mut _20: &std::option::Option<i32>;
    let mut _21: &std::option::Option<i32>;
    let mut _22: bool;
    let mut _23: &A;
    let mut _24: &A;
    let mut _25: bool;
    let mut _26: &PrivateStruct<A>;
    let mut _27: &PrivateStruct<A>;
    let mut _28: bool;
    let mut _29: &B;
    let mut _30: &B;
    let mut _31: bool;
    let mut _32: &<B as DeclaredTrait>::Type;
    let mut _33: &<B as DeclaredTrait>::Type;
    let mut _34: bool;
    let mut _35: &std::option::Option<<B as DeclaredTrait>::Type>;
    let mut _36: &std::option::Option<<B as DeclaredTrait>::Type>;
    let mut _37: bool;
    let mut _38: &<B as DeclaredTrait>::Type;
    let mut _39: &<B as DeclaredTrait>::Type;
    let mut _40: bool;
    let mut _41: &std::option::Option<<B as DeclaredTrait>::Type>;
    let mut _42: &std::option::Option<<B as DeclaredTrait>::Type>;
    let mut _43: bool;
    let mut _44: &C;
    let mut _45: &C;
    let mut _46: bool;
    let mut _47: &<C as WhereTrait>::Type;
    let mut _48: &<C as WhereTrait>::Type;
    let mut _49: bool;
    let mut _50: &std::option::Option<<C as WhereTrait>::Type>;
    let mut _51: &std::option::Option<<C as WhereTrait>::Type>;
    let mut _52: bool;
    let mut _53: &<C as WhereTrait>::Type;
    let mut _54: &<C as WhereTrait>::Type;
    let mut _55: bool;
    let mut _56: &std::option::Option<<C as WhereTrait>::Type>;
    let mut _57: &std::option::Option<<C as WhereTrait>::Type>;
    let mut _58: bool;
    let mut _59: i32;
    let mut _60: i32;

    bb0: {
        _17 = ((*_1).0: i32);
        _18 = ((*_2).0: i32);
        _16 = Eq(move _17, move _18);
        switchInt(move _16) -> [0: bb40, otherwise: bb41];
    }

    bb1: {
        _0 = const false;
        goto -> bb3;
    }

    bb2: {
        _59 = ((*_1).14: i32);
        _60 = ((*_2).14: i32);
        _58 = Eq(move _59, move _60);
        _0 = move _58;
        goto -> bb3;
    }

    bb3: {
        return;
    }

    bb4: {
        _3 = const false;
        goto -> bb6;
    }

    bb5: {
        _56 = &((*_1).13: std::option::Option<<C as WhereTrait>::Type>);
        _57 = &((*_2).13: std::option::Option<<C as WhereTrait>::Type>);
        _55 = <Option<<C as WhereTrait>::Type> as PartialEq>::eq(move _56, move _57) -> [return: bb55, unwind continue];
    }

    bb6: {
        switchInt(move _3) -> [0: bb1, otherwise: bb2];
    }

    bb7: {
        _4 = const false;
        goto -> bb9;
    }

    bb8: {
        _53 = &((*_1).12: <C as WhereTrait>::Type);
        _54 = &((*_2).12: <C as WhereTrait>::Type);
        _52 = <<C as WhereTrait>::Type as PartialEq>::eq(move _53, move _54) -> [return: bb54, unwind continue];
    }

    bb9: {
        switchInt(move _4) -> [0: bb4, otherwise: bb5];
    }

    bb10: {
        _5 = const false;
        goto -> bb12;
    }

    bb11: {
        _50 = &((*_1).11: std::option::Option<<C as WhereTrait>::Type>);
        _51 = &((*_2).11: std::option::Option<<C as WhereTrait>::Type>);
        _49 = <Option<<C as WhereTrait>::Type> as PartialEq>::eq(move _50, move _51) -> [return: bb53, unwind continue];
    }

    bb12: {
        switchInt(move _5) -> [0: bb7, otherwise: bb8];
    }

    bb13: {
        _6 = const false;
        goto -> bb15;
    }

    bb14: {
        _47 = &((*_1).10: <C as WhereTrait>::Type);
        _48 = &((*_2).10: <C as WhereTrait>::Type);
        _46 = <<C as WhereTrait>::Type as PartialEq>::eq(move _47, move _48) -> [return: bb52, unwind continue];
    }

    bb15: {
        switchInt(move _6) -> [0: bb10, otherwise: bb11];
    }

    bb16: {
        _7 = const false;
        goto -> bb18;
    }

    bb17: {
        _44 = &((*_1).9: C);
        _45 = &((*_2).9: C);
        _43 = <C as PartialEq>::eq(move _44, move _45) -> [return: bb51, unwind continue];
    }

    bb18: {
        switchInt(move _7) -> [0: bb13, otherwise: bb14];
    }

    bb19: {
        _8 = const false;
        goto -> bb21;
    }

    bb20: {
        _41 = &((*_1).8: std::option::Option<<B as DeclaredTrait>::Type>);
        _42 = &((*_2).8: std::option::Option<<B as DeclaredTrait>::Type>);
        _40 = <Option<<B as DeclaredTrait>::Type> as PartialEq>::eq(move _41, move _42) -> [return: bb50, unwind continue];
    }

    bb21: {
        switchInt(move _8) -> [0: bb16, otherwise: bb17];
    }

    bb22: {
        _9 = const false;
        goto -> bb24;
    }

    bb23: {
        _38 = &((*_1).7: <B as DeclaredTrait>::Type);
        _39 = &((*_2).7: <B as DeclaredTrait>::Type);
        _37 = <<B as DeclaredTrait>::Type as PartialEq>::eq(move _38, move _39) -> [return: bb49, unwind continue];
    }

    bb24: {
        switchInt(move _9) -> [0: bb19, otherwise: bb20];
    }

    bb25: {
        _10 = const false;
        goto -> bb27;
    }

    bb26: {
        _35 = &((*_1).6: std::option::Option<<B as DeclaredTrait>::Type>);
        _36 = &((*_2).6: std::option::Option<<B as DeclaredTrait>::Type>);
        _34 = <Option<<B as DeclaredTrait>::Type> as PartialEq>::eq(move _35, move _36) -> [return: bb48, unwind continue];
    }

    bb27: {
        switchInt(move _10) -> [0: bb22, otherwise: bb23];
    }

    bb28: {
        _11 = const false;
        goto -> bb30;
    }

    bb29: {
        _32 = &((*_1).5: <B as DeclaredTrait>::Type);
        _33 = &((*_2).5: <B as DeclaredTrait>::Type);
        _31 = <<B as DeclaredTrait>::Type as PartialEq>::eq(move _32, move _33) -> [return: bb47, unwind continue];
    }

    bb30: {
        switchInt(move _11) -> [0: bb25, otherwise: bb26];
    }

    bb31: {
        _12 = const false;
        goto -> bb33;
    }

    bb32: {
        _29 = &((*_1).4: B);
        _30 = &((*_2).4: B);
        _28 = <B as PartialEq>::eq(move _29, move _30) -> [return: bb46, unwind continue];
    }

    bb33: {
        switchInt(move _12) -> [0: bb28, otherwise: bb29];
    }

    bb34: {
        _13 = const false;
        goto -> bb36;
    }

    bb35: {
        _26 = &((*_1).3: PrivateStruct<A>);
        _27 = &((*_2).3: PrivateStruct<A>);
        _25 = <PrivateStruct<A> as PartialEq>::eq(move _26, move _27) -> [return: bb45, unwind continue];
    }

    bb36: {
        switchInt(move _13) -> [0: bb31, otherwise: bb32];
    }

    bb37: {
        _14 = const false;
        goto -> bb39;
    }

    bb38: {
        _23 = &((*_1).2: A);
        _24 = &((*_2).2: A);
        _22 = <A as PartialEq>::eq(move _23, move _24) -> [return: bb44, unwind continue];
    }

    bb39: {
        switchInt(move _14) -> [0: bb34, otherwise: bb35];
    }

    bb40: {
        _15 = const false;
        goto -> bb42;
    }

    bb41: {
        _20 = &((*_1).1: std::option::Option<i32>);
        _21 = &((*_2).1: std::option::Option<i32>);
        _19 = <Option<i32> as PartialEq>::eq(move _20, move _21) -> [return: bb43, unwind continue];
    }

    bb42: {
        switchInt(move _15) -> [0: bb37, otherwise: bb38];
    }

    bb43: {
        _15 = move _19;
        goto -> bb42;
    }

    bb44: {
        _14 = move _22;
        goto -> bb39;
    }

    bb45: {
        _13 = move _25;
        goto -> bb36;
    }

    bb46: {
        _12 = move _28;
        goto -> bb33;
    }

    bb47: {
        _11 = move _31;
        goto -> bb30;
    }

    bb48: {
        _10 = move _34;
        goto -> bb27;
    }

    bb49: {
        _9 = move _37;
        goto -> bb24;
    }

    bb50: {
        _8 = move _40;
        goto -> bb21;
    }

    bb51: {
        _7 = move _43;
        goto -> bb18;
    }

    bb52: {
        _6 = move _46;
        goto -> bb15;
    }

    bb53: {
        _5 = move _49;
        goto -> bb12;
    }

    bb54: {
        _4 = move _52;
        goto -> bb9;
    }

    bb55: {
        _3 = move _55;
        goto -> bb6;
    }
}

fn <impl at ui/deriving/deriving-associated-types.rs:46:21: 46:26>::fmt(_1: &Struct<A, B, C>, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _4: &[&dyn std::fmt::Debug; 15];
    let _5: [&dyn std::fmt::Debug; 15];
    let mut _6: &dyn std::fmt::Debug;
    let _7: &i32;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &std::option::Option<i32>;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &A;
    let mut _12: &dyn std::fmt::Debug;
    let _13: &PrivateStruct<A>;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &B;
    let mut _16: &dyn std::fmt::Debug;
    let _17: &<B as DeclaredTrait>::Type;
    let mut _18: &dyn std::fmt::Debug;
    let _19: &std::option::Option<<B as DeclaredTrait>::Type>;
    let mut _20: &dyn std::fmt::Debug;
    let _21: &<B as DeclaredTrait>::Type;
    let mut _22: &dyn std::fmt::Debug;
    let _23: &std::option::Option<<B as DeclaredTrait>::Type>;
    let mut _24: &dyn std::fmt::Debug;
    let _25: &C;
    let mut _26: &dyn std::fmt::Debug;
    let _27: &<C as WhereTrait>::Type;
    let mut _28: &dyn std::fmt::Debug;
    let _29: &std::option::Option<<C as WhereTrait>::Type>;
    let mut _30: &dyn std::fmt::Debug;
    let _31: &<C as WhereTrait>::Type;
    let mut _32: &dyn std::fmt::Debug;
    let _33: &std::option::Option<<C as WhereTrait>::Type>;
    let mut _34: &dyn std::fmt::Debug;
    let _35: &&i32;
    let _36: &i32;
    let _37: &str;
    let mut _38: &[&str];
    let mut _39: &[&str; 15];
    scope 1 {
        debug names => const _;
        let _3: &[&dyn std::fmt::Debug];
        scope 2 {
            debug values => _3;
        }
    }

    bb0: {
        _39 = const _;
        _7 = &((*_1).0: i32);
        _6 = _7 as &dyn std::fmt::Debug (Pointer(Unsize));
        _9 = &((*_1).1: std::option::Option<i32>);
        _8 = _9 as &dyn std::fmt::Debug (Pointer(Unsize));
        _11 = &((*_1).2: A);
        _10 = _11 as &dyn std::fmt::Debug (Pointer(Unsize));
        _13 = &((*_1).3: PrivateStruct<A>);
        _12 = _13 as &dyn std::fmt::Debug (Pointer(Unsize));
        _15 = &((*_1).4: B);
        _14 = _15 as &dyn std::fmt::Debug (Pointer(Unsize));
        _17 = &((*_1).5: <B as DeclaredTrait>::Type);
        _16 = _17 as &dyn std::fmt::Debug (Pointer(Unsize));
        _19 = &((*_1).6: std::option::Option<<B as DeclaredTrait>::Type>);
        _18 = _19 as &dyn std::fmt::Debug (Pointer(Unsize));
        _21 = &((*_1).7: <B as DeclaredTrait>::Type);
        _20 = _21 as &dyn std::fmt::Debug (Pointer(Unsize));
        _23 = &((*_1).8: std::option::Option<<B as DeclaredTrait>::Type>);
        _22 = _23 as &dyn std::fmt::Debug (Pointer(Unsize));
        _25 = &((*_1).9: C);
        _24 = _25 as &dyn std::fmt::Debug (Pointer(Unsize));
        _27 = &((*_1).10: <C as WhereTrait>::Type);
        _26 = _27 as &dyn std::fmt::Debug (Pointer(Unsize));
        _29 = &((*_1).11: std::option::Option<<C as WhereTrait>::Type>);
        _28 = _29 as &dyn std::fmt::Debug (Pointer(Unsize));
        _31 = &((*_1).12: <C as WhereTrait>::Type);
        _30 = _31 as &dyn std::fmt::Debug (Pointer(Unsize));
        _33 = &((*_1).13: std::option::Option<<C as WhereTrait>::Type>);
        _32 = _33 as &dyn std::fmt::Debug (Pointer(Unsize));
        _36 = &((*_1).14: i32);
        _35 = &_36;
        _34 = _35 as &dyn std::fmt::Debug (Pointer(Unsize));
        _5 = [move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22, move _24, move _26, move _28, move _30, move _32, move _34];
        _4 = &_5;
        _3 = _4 as &[&dyn std::fmt::Debug] (Pointer(Unsize));
        _37 = const "Struct";
        _38 = _39 as &[&str] (Pointer(Unsize));
        _0 = Formatter::<'_>::debug_struct_fields_finish(_2, _37, move _38, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in <impl at ui/deriving/deriving-associated-types.rs:46:21: 46:26>::fmt: &[&str; 15] = {
    let mut _0: &[&str; 15];
    let mut _1: [&str; 15];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;
    let mut _14: &str;
    let mut _15: &str;
    let mut _16: &str;
    let mut _17: &str;
    let mut _18: &str;
    let mut _19: &str;
    let mut _20: &str;
    let mut _21: &str;
    let mut _22: &str;
    let mut _23: &str;
    let mut _24: &str;
    let mut _25: &str;
    let mut _26: &str;
    let mut _27: &str;
    let mut _28: &str;
    let mut _29: &str;

    bb0: {
        _3 = const "m2";
        _2 = &(*_3);
        _5 = const "a1";
        _4 = &(*_5);
        _7 = const "a2";
        _6 = &(*_7);
        _9 = const "b";
        _8 = &(*_9);
        _11 = const "b1";
        _10 = &(*_11);
        _13 = const "b2";
        _12 = &(*_13);
        _15 = const "b3";
        _14 = &(*_15);
        _17 = const "b4";
        _16 = &(*_17);
        _19 = const "c";
        _18 = &(*_19);
        _21 = const "c1";
        _20 = &(*_21);
        _23 = const "c2";
        _22 = &(*_23);
        _25 = const "c3";
        _24 = &(*_25);
        _27 = const "c4";
        _26 = &(*_27);
        _29 = const "d";
        _28 = &(*_29);
        _1 = [const "m1", move _2, move _4, move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22, move _24, move _26, move _28];
        _0 = &_1;
        return;
    }
}

fn <impl at ui/deriving/deriving-associated-types.rs:65:10: 65:19>::eq(_1: &Enum<A, B, C>, _2: &Enum<A, B, C>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: (&Enum<A, B, C>, &Enum<A, B, C>);
    let mut _8: isize;
    let mut _9: isize;
    let mut _10: isize;
    let mut _41: bool;
    let mut _42: bool;
    let mut _43: bool;
    let mut _44: bool;
    let mut _45: bool;
    let mut _46: bool;
    let mut _47: bool;
    let mut _48: bool;
    let mut _49: bool;
    let mut _50: bool;
    let mut _51: bool;
    let mut _52: bool;
    let mut _53: bool;
    let mut _54: bool;
    let mut _55: i32;
    let mut _56: i32;
    let mut _57: bool;
    let mut _58: bool;
    let mut _59: bool;
    let mut _60: bool;
    let mut _61: bool;
    let mut _62: bool;
    let mut _63: bool;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: bool;
    let mut _67: bool;
    let mut _68: bool;
    let mut _69: bool;
    let mut _70: bool;
    let mut _71: i32;
    let mut _72: i32;
    let mut _103: bool;
    let mut _104: bool;
    let mut _105: bool;
    let mut _106: bool;
    let mut _107: bool;
    let mut _108: bool;
    let mut _109: bool;
    let mut _110: bool;
    let mut _111: bool;
    let mut _112: bool;
    let mut _113: bool;
    let mut _114: bool;
    let mut _115: bool;
    let mut _116: bool;
    let mut _117: i32;
    let mut _118: i32;
    let mut _119: bool;
    let mut _120: bool;
    let mut _121: bool;
    let mut _122: bool;
    let mut _123: bool;
    let mut _124: bool;
    let mut _125: bool;
    let mut _126: bool;
    let mut _127: bool;
    let mut _128: bool;
    let mut _129: bool;
    let mut _130: bool;
    let mut _131: bool;
    let mut _132: bool;
    let mut _133: i32;
    let mut _134: i32;
    let mut _135: &Enum<A, B, C>;
    let mut _136: &Enum<A, B, C>;
    let mut _137: &Enum<A, B, C>;
    let mut _138: &Enum<A, B, C>;
    let mut _139: &Enum<A, B, C>;
    let mut _140: &Enum<A, B, C>;
    let mut _141: &Enum<A, B, C>;
    let mut _142: &Enum<A, B, C>;
    let mut _143: &Enum<A, B, C>;
    let mut _144: &Enum<A, B, C>;
    let mut _145: &Enum<A, B, C>;
    let mut _146: &Enum<A, B, C>;
    let mut _147: &Enum<A, B, C>;
    let mut _148: &Enum<A, B, C>;
    let mut _149: &Enum<A, B, C>;
    let mut _150: &Enum<A, B, C>;
    let mut _151: &Enum<A, B, C>;
    let mut _152: &Enum<A, B, C>;
    let mut _153: &Enum<A, B, C>;
    let mut _154: &Enum<A, B, C>;
    let mut _155: &Enum<A, B, C>;
    let mut _156: &Enum<A, B, C>;
    let mut _157: &Enum<A, B, C>;
    let mut _158: &Enum<A, B, C>;
    let mut _159: &Enum<A, B, C>;
    let mut _160: &Enum<A, B, C>;
    let mut _161: &Enum<A, B, C>;
    let mut _162: &Enum<A, B, C>;
    let mut _163: &Enum<A, B, C>;
    let mut _164: &Enum<A, B, C>;
    let mut _165: &Enum<A, B, C>;
    let mut _166: &Enum<A, B, C>;
    let mut _167: &Enum<A, B, C>;
    let mut _168: &Enum<A, B, C>;
    let mut _169: &Enum<A, B, C>;
    let mut _170: &Enum<A, B, C>;
    let mut _171: &Enum<A, B, C>;
    let mut _172: &Enum<A, B, C>;
    let mut _173: &Enum<A, B, C>;
    let mut _174: &Enum<A, B, C>;
    let mut _175: &Enum<A, B, C>;
    let mut _176: &Enum<A, B, C>;
    let mut _177: &Enum<A, B, C>;
    let mut _178: &Enum<A, B, C>;
    let mut _179: &Enum<A, B, C>;
    let mut _180: &Enum<A, B, C>;
    let mut _181: &Enum<A, B, C>;
    let mut _182: &Enum<A, B, C>;
    let mut _183: &Enum<A, B, C>;
    let mut _184: &Enum<A, B, C>;
    let mut _185: &Enum<A, B, C>;
    let mut _186: &Enum<A, B, C>;
    let mut _187: &Enum<A, B, C>;
    let mut _188: &Enum<A, B, C>;
    let mut _189: &Enum<A, B, C>;
    let mut _190: &Enum<A, B, C>;
    let mut _191: &Enum<A, B, C>;
    let mut _192: &Enum<A, B, C>;
    let mut _193: &Enum<A, B, C>;
    let mut _194: &Enum<A, B, C>;
    let mut _195: &Enum<A, B, C>;
    let mut _196: &Enum<A, B, C>;
    let mut _197: &Enum<A, B, C>;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
            let _11: &i32;
            let _12: &std::option::Option<i32>;
            let _13: &A;
            let _14: &PrivateStruct<A>;
            let _15: &B;
            let _16: &<B as DeclaredTrait>::Type;
            let _17: &std::option::Option<<B as DeclaredTrait>::Type>;
            let _18: &<B as DeclaredTrait>::Type;
            let _19: &std::option::Option<<B as DeclaredTrait>::Type>;
            let _20: &C;
            let _21: &<C as WhereTrait>::Type;
            let _22: &std::option::Option<<C as WhereTrait>::Type>;
            let _23: &<C as WhereTrait>::Type;
            let _24: &std::option::Option<<C as WhereTrait>::Type>;
            let _25: &i32;
            let _26: &i32;
            let _27: &std::option::Option<i32>;
            let _28: &A;
            let _29: &PrivateStruct<A>;
            let _30: &B;
            let _31: &<B as DeclaredTrait>::Type;
            let _32: &std::option::Option<<B as DeclaredTrait>::Type>;
            let _33: &<B as DeclaredTrait>::Type;
            let _34: &std::option::Option<<B as DeclaredTrait>::Type>;
            let _35: &C;
            let _36: &<C as WhereTrait>::Type;
            let _37: &std::option::Option<<C as WhereTrait>::Type>;
            let _38: &<C as WhereTrait>::Type;
            let _39: &std::option::Option<<C as WhereTrait>::Type>;
            let _40: &i32;
            let _73: &i32;
            let _74: &std::option::Option<i32>;
            let _75: &A;
            let _76: &PrivateStruct<A>;
            let _77: &B;
            let _78: &<B as DeclaredTrait>::Type;
            let _79: &std::option::Option<<B as DeclaredTrait>::Type>;
            let _80: &<B as DeclaredTrait>::Type;
            let _81: &std::option::Option<<B as DeclaredTrait>::Type>;
            let _82: &C;
            let _83: &<C as WhereTrait>::Type;
            let _84: &std::option::Option<<C as WhereTrait>::Type>;
            let _85: &<C as WhereTrait>::Type;
            let _86: &std::option::Option<<C as WhereTrait>::Type>;
            let _87: &i32;
            let _88: &i32;
            let _89: &std::option::Option<i32>;
            let _90: &A;
            let _91: &PrivateStruct<A>;
            let _92: &B;
            let _93: &<B as DeclaredTrait>::Type;
            let _94: &std::option::Option<<B as DeclaredTrait>::Type>;
            let _95: &<B as DeclaredTrait>::Type;
            let _96: &std::option::Option<<B as DeclaredTrait>::Type>;
            let _97: &C;
            let _98: &<C as WhereTrait>::Type;
            let _99: &std::option::Option<<C as WhereTrait>::Type>;
            let _100: &<C as WhereTrait>::Type;
            let _101: &std::option::Option<<C as WhereTrait>::Type>;
            let _102: &i32;
            scope 3 {
                debug __self_0 => _11;
                debug __self_1 => _12;
                debug __self_2 => _13;
                debug __self_3 => _14;
                debug __self_4 => _15;
                debug __self_5 => _16;
                debug __self_6 => _17;
                debug __self_7 => _18;
                debug __self_8 => _19;
                debug __self_9 => _20;
                debug __self_10 => _21;
                debug __self_11 => _22;
                debug __self_12 => _23;
                debug __self_13 => _24;
                debug __self_14 => _25;
                debug __arg1_0 => _26;
                debug __arg1_1 => _27;
                debug __arg1_2 => _28;
                debug __arg1_3 => _29;
                debug __arg1_4 => _30;
                debug __arg1_5 => _31;
                debug __arg1_6 => _32;
                debug __arg1_7 => _33;
                debug __arg1_8 => _34;
                debug __arg1_9 => _35;
                debug __arg1_10 => _36;
                debug __arg1_11 => _37;
                debug __arg1_12 => _38;
                debug __arg1_13 => _39;
                debug __arg1_14 => _40;
            }
            scope 4 {
                debug __self_0 => _73;
                debug __self_1 => _74;
                debug __self_2 => _75;
                debug __self_3 => _76;
                debug __self_4 => _77;
                debug __self_5 => _78;
                debug __self_6 => _79;
                debug __self_7 => _80;
                debug __self_8 => _81;
                debug __self_9 => _82;
                debug __self_10 => _83;
                debug __self_11 => _84;
                debug __self_12 => _85;
                debug __self_13 => _86;
                debug __self_14 => _87;
                debug __arg1_0 => _88;
                debug __arg1_1 => _89;
                debug __arg1_2 => _90;
                debug __arg1_3 => _91;
                debug __arg1_4 => _92;
                debug __arg1_5 => _93;
                debug __arg1_6 => _94;
                debug __arg1_7 => _95;
                debug __arg1_8 => _96;
                debug __arg1_9 => _97;
                debug __arg1_10 => _98;
                debug __arg1_11 => _99;
                debug __arg1_12 => _100;
                debug __arg1_13 => _101;
                debug __arg1_14 => _102;
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = Eq(_3, _4);
        switchInt(move _5) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const false;
        goto -> bb3;
    }

    bb2: {
        _7 = (_1, _2);
        _135 = deref_copy (_7.0: &Enum<A, B, C>);
        _10 = discriminant((*_135));
        switchInt(move _10) -> [1: bb5, 2: bb6, otherwise: bb4];
    }

    bb3: {
        return;
    }

    bb4: {
        _6 = const true;
        goto -> bb117;
    }

    bb5: {
        _136 = deref_copy (_7.1: &Enum<A, B, C>);
        _8 = discriminant((*_136));
        switchInt(move _8) -> [1: bb7, otherwise: bb4];
    }

    bb6: {
        _137 = deref_copy (_7.1: &Enum<A, B, C>);
        _9 = discriminant((*_137));
        switchInt(move _9) -> [2: bb62, otherwise: bb4];
    }

    bb7: {
        _138 = deref_copy (_7.0: &Enum<A, B, C>);
        _11 = &(((*_138) as Seq).0: i32);
        _139 = deref_copy (_7.0: &Enum<A, B, C>);
        _12 = &(((*_139) as Seq).1: std::option::Option<i32>);
        _140 = deref_copy (_7.0: &Enum<A, B, C>);
        _13 = &(((*_140) as Seq).2: A);
        _141 = deref_copy (_7.0: &Enum<A, B, C>);
        _14 = &(((*_141) as Seq).3: PrivateStruct<A>);
        _142 = deref_copy (_7.0: &Enum<A, B, C>);
        _15 = &(((*_142) as Seq).4: B);
        _143 = deref_copy (_7.0: &Enum<A, B, C>);
        _16 = &(((*_143) as Seq).5: <B as DeclaredTrait>::Type);
        _144 = deref_copy (_7.0: &Enum<A, B, C>);
        _17 = &(((*_144) as Seq).6: std::option::Option<<B as DeclaredTrait>::Type>);
        _145 = deref_copy (_7.0: &Enum<A, B, C>);
        _18 = &(((*_145) as Seq).7: <B as DeclaredTrait>::Type);
        _146 = deref_copy (_7.0: &Enum<A, B, C>);
        _19 = &(((*_146) as Seq).8: std::option::Option<<B as DeclaredTrait>::Type>);
        _147 = deref_copy (_7.0: &Enum<A, B, C>);
        _20 = &(((*_147) as Seq).9: C);
        _148 = deref_copy (_7.0: &Enum<A, B, C>);
        _21 = &(((*_148) as Seq).10: <C as WhereTrait>::Type);
        _149 = deref_copy (_7.0: &Enum<A, B, C>);
        _22 = &(((*_149) as Seq).11: std::option::Option<<C as WhereTrait>::Type>);
        _150 = deref_copy (_7.0: &Enum<A, B, C>);
        _23 = &(((*_150) as Seq).12: <C as WhereTrait>::Type);
        _151 = deref_copy (_7.0: &Enum<A, B, C>);
        _24 = &(((*_151) as Seq).13: std::option::Option<<C as WhereTrait>::Type>);
        _152 = deref_copy (_7.0: &Enum<A, B, C>);
        _25 = &(((*_152) as Seq).14: i32);
        _153 = deref_copy (_7.1: &Enum<A, B, C>);
        _26 = &(((*_153) as Seq).0: i32);
        _154 = deref_copy (_7.1: &Enum<A, B, C>);
        _27 = &(((*_154) as Seq).1: std::option::Option<i32>);
        _155 = deref_copy (_7.1: &Enum<A, B, C>);
        _28 = &(((*_155) as Seq).2: A);
        _156 = deref_copy (_7.1: &Enum<A, B, C>);
        _29 = &(((*_156) as Seq).3: PrivateStruct<A>);
        _157 = deref_copy (_7.1: &Enum<A, B, C>);
        _30 = &(((*_157) as Seq).4: B);
        _158 = deref_copy (_7.1: &Enum<A, B, C>);
        _31 = &(((*_158) as Seq).5: <B as DeclaredTrait>::Type);
        _159 = deref_copy (_7.1: &Enum<A, B, C>);
        _32 = &(((*_159) as Seq).6: std::option::Option<<B as DeclaredTrait>::Type>);
        _160 = deref_copy (_7.1: &Enum<A, B, C>);
        _33 = &(((*_160) as Seq).7: <B as DeclaredTrait>::Type);
        _161 = deref_copy (_7.1: &Enum<A, B, C>);
        _34 = &(((*_161) as Seq).8: std::option::Option<<B as DeclaredTrait>::Type>);
        _162 = deref_copy (_7.1: &Enum<A, B, C>);
        _35 = &(((*_162) as Seq).9: C);
        _163 = deref_copy (_7.1: &Enum<A, B, C>);
        _36 = &(((*_163) as Seq).10: <C as WhereTrait>::Type);
        _164 = deref_copy (_7.1: &Enum<A, B, C>);
        _37 = &(((*_164) as Seq).11: std::option::Option<<C as WhereTrait>::Type>);
        _165 = deref_copy (_7.1: &Enum<A, B, C>);
        _38 = &(((*_165) as Seq).12: <C as WhereTrait>::Type);
        _166 = deref_copy (_7.1: &Enum<A, B, C>);
        _39 = &(((*_166) as Seq).13: std::option::Option<<C as WhereTrait>::Type>);
        _167 = deref_copy (_7.1: &Enum<A, B, C>);
        _40 = &(((*_167) as Seq).14: i32);
        _55 = (*_11);
        _56 = (*_26);
        _54 = Eq(move _55, move _56);
        switchInt(move _54) -> [0: bb46, otherwise: bb47];
    }

    bb8: {
        _6 = const false;
        goto -> bb117;
    }

    bb9: {
        _71 = (*_25);
        _72 = (*_40);
        _70 = Eq(move _71, move _72);
        _6 = move _70;
        goto -> bb117;
    }

    bb10: {
        _41 = const false;
        goto -> bb12;
    }

    bb11: {
        _69 = <Option<<C as WhereTrait>::Type> as PartialEq>::eq(_24, _39) -> [return: bb61, unwind continue];
    }

    bb12: {
        switchInt(move _41) -> [0: bb8, otherwise: bb9];
    }

    bb13: {
        _42 = const false;
        goto -> bb15;
    }

    bb14: {
        _68 = <<C as WhereTrait>::Type as PartialEq>::eq(_23, _38) -> [return: bb60, unwind continue];
    }

    bb15: {
        switchInt(move _42) -> [0: bb10, otherwise: bb11];
    }

    bb16: {
        _43 = const false;
        goto -> bb18;
    }

    bb17: {
        _67 = <Option<<C as WhereTrait>::Type> as PartialEq>::eq(_22, _37) -> [return: bb59, unwind continue];
    }

    bb18: {
        switchInt(move _43) -> [0: bb13, otherwise: bb14];
    }

    bb19: {
        _44 = const false;
        goto -> bb21;
    }

    bb20: {
        _66 = <<C as WhereTrait>::Type as PartialEq>::eq(_21, _36) -> [return: bb58, unwind continue];
    }

    bb21: {
        switchInt(move _44) -> [0: bb16, otherwise: bb17];
    }

    bb22: {
        _45 = const false;
        goto -> bb24;
    }

    bb23: {
        _65 = <C as PartialEq>::eq(_20, _35) -> [return: bb57, unwind continue];
    }

    bb24: {
        switchInt(move _45) -> [0: bb19, otherwise: bb20];
    }

    bb25: {
        _46 = const false;
        goto -> bb27;
    }

    bb26: {
        _64 = <Option<<B as DeclaredTrait>::Type> as PartialEq>::eq(_19, _34) -> [return: bb56, unwind continue];
    }

    bb27: {
        switchInt(move _46) -> [0: bb22, otherwise: bb23];
    }

    bb28: {
        _47 = const false;
        goto -> bb30;
    }

    bb29: {
        _63 = <<B as DeclaredTrait>::Type as PartialEq>::eq(_18, _33) -> [return: bb55, unwind continue];
    }

    bb30: {
        switchInt(move _47) -> [0: bb25, otherwise: bb26];
    }

    bb31: {
        _48 = const false;
        goto -> bb33;
    }

    bb32: {
        _62 = <Option<<B as DeclaredTrait>::Type> as PartialEq>::eq(_17, _32) -> [return: bb54, unwind continue];
    }

    bb33: {
        switchInt(move _48) -> [0: bb28, otherwise: bb29];
    }

    bb34: {
        _49 = const false;
        goto -> bb36;
    }

    bb35: {
        _61 = <<B as DeclaredTrait>::Type as PartialEq>::eq(_16, _31) -> [return: bb53, unwind continue];
    }

    bb36: {
        switchInt(move _49) -> [0: bb31, otherwise: bb32];
    }

    bb37: {
        _50 = const false;
        goto -> bb39;
    }

    bb38: {
        _60 = <B as PartialEq>::eq(_15, _30) -> [return: bb52, unwind continue];
    }

    bb39: {
        switchInt(move _50) -> [0: bb34, otherwise: bb35];
    }

    bb40: {
        _51 = const false;
        goto -> bb42;
    }

    bb41: {
        _59 = <PrivateStruct<A> as PartialEq>::eq(_14, _29) -> [return: bb51, unwind continue];
    }

    bb42: {
        switchInt(move _51) -> [0: bb37, otherwise: bb38];
    }

    bb43: {
        _52 = const false;
        goto -> bb45;
    }

    bb44: {
        _58 = <A as PartialEq>::eq(_13, _28) -> [return: bb50, unwind continue];
    }

    bb45: {
        switchInt(move _52) -> [0: bb40, otherwise: bb41];
    }

    bb46: {
        _53 = const false;
        goto -> bb48;
    }

    bb47: {
        _57 = <Option<i32> as PartialEq>::eq(_12, _27) -> [return: bb49, unwind continue];
    }

    bb48: {
        switchInt(move _53) -> [0: bb43, otherwise: bb44];
    }

    bb49: {
        _53 = move _57;
        goto -> bb48;
    }

    bb50: {
        _52 = move _58;
        goto -> bb45;
    }

    bb51: {
        _51 = move _59;
        goto -> bb42;
    }

    bb52: {
        _50 = move _60;
        goto -> bb39;
    }

    bb53: {
        _49 = move _61;
        goto -> bb36;
    }

    bb54: {
        _48 = move _62;
        goto -> bb33;
    }

    bb55: {
        _47 = move _63;
        goto -> bb30;
    }

    bb56: {
        _46 = move _64;
        goto -> bb27;
    }

    bb57: {
        _45 = move _65;
        goto -> bb24;
    }

    bb58: {
        _44 = move _66;
        goto -> bb21;
    }

    bb59: {
        _43 = move _67;
        goto -> bb18;
    }

    bb60: {
        _42 = move _68;
        goto -> bb15;
    }

    bb61: {
        _41 = move _69;
        goto -> bb12;
    }

    bb62: {
        _168 = deref_copy (_7.0: &Enum<A, B, C>);
        _73 = &(((*_168) as Map).0: i32);
        _169 = deref_copy (_7.0: &Enum<A, B, C>);
        _74 = &(((*_169) as Map).1: std::option::Option<i32>);
        _170 = deref_copy (_7.0: &Enum<A, B, C>);
        _75 = &(((*_170) as Map).2: A);
        _171 = deref_copy (_7.0: &Enum<A, B, C>);
        _76 = &(((*_171) as Map).3: PrivateStruct<A>);
        _172 = deref_copy (_7.0: &Enum<A, B, C>);
        _77 = &(((*_172) as Map).4: B);
        _173 = deref_copy (_7.0: &Enum<A, B, C>);
        _78 = &(((*_173) as Map).5: <B as DeclaredTrait>::Type);
        _174 = deref_copy (_7.0: &Enum<A, B, C>);
        _79 = &(((*_174) as Map).6: std::option::Option<<B as DeclaredTrait>::Type>);
        _175 = deref_copy (_7.0: &Enum<A, B, C>);
        _80 = &(((*_175) as Map).7: <B as DeclaredTrait>::Type);
        _176 = deref_copy (_7.0: &Enum<A, B, C>);
        _81 = &(((*_176) as Map).8: std::option::Option<<B as DeclaredTrait>::Type>);
        _177 = deref_copy (_7.0: &Enum<A, B, C>);
        _82 = &(((*_177) as Map).9: C);
        _178 = deref_copy (_7.0: &Enum<A, B, C>);
        _83 = &(((*_178) as Map).10: <C as WhereTrait>::Type);
        _179 = deref_copy (_7.0: &Enum<A, B, C>);
        _84 = &(((*_179) as Map).11: std::option::Option<<C as WhereTrait>::Type>);
        _180 = deref_copy (_7.0: &Enum<A, B, C>);
        _85 = &(((*_180) as Map).12: <C as WhereTrait>::Type);
        _181 = deref_copy (_7.0: &Enum<A, B, C>);
        _86 = &(((*_181) as Map).13: std::option::Option<<C as WhereTrait>::Type>);
        _182 = deref_copy (_7.0: &Enum<A, B, C>);
        _87 = &(((*_182) as Map).14: i32);
        _183 = deref_copy (_7.1: &Enum<A, B, C>);
        _88 = &(((*_183) as Map).0: i32);
        _184 = deref_copy (_7.1: &Enum<A, B, C>);
        _89 = &(((*_184) as Map).1: std::option::Option<i32>);
        _185 = deref_copy (_7.1: &Enum<A, B, C>);
        _90 = &(((*_185) as Map).2: A);
        _186 = deref_copy (_7.1: &Enum<A, B, C>);
        _91 = &(((*_186) as Map).3: PrivateStruct<A>);
        _187 = deref_copy (_7.1: &Enum<A, B, C>);
        _92 = &(((*_187) as Map).4: B);
        _188 = deref_copy (_7.1: &Enum<A, B, C>);
        _93 = &(((*_188) as Map).5: <B as DeclaredTrait>::Type);
        _189 = deref_copy (_7.1: &Enum<A, B, C>);
        _94 = &(((*_189) as Map).6: std::option::Option<<B as DeclaredTrait>::Type>);
        _190 = deref_copy (_7.1: &Enum<A, B, C>);
        _95 = &(((*_190) as Map).7: <B as DeclaredTrait>::Type);
        _191 = deref_copy (_7.1: &Enum<A, B, C>);
        _96 = &(((*_191) as Map).8: std::option::Option<<B as DeclaredTrait>::Type>);
        _192 = deref_copy (_7.1: &Enum<A, B, C>);
        _97 = &(((*_192) as Map).9: C);
        _193 = deref_copy (_7.1: &Enum<A, B, C>);
        _98 = &(((*_193) as Map).10: <C as WhereTrait>::Type);
        _194 = deref_copy (_7.1: &Enum<A, B, C>);
        _99 = &(((*_194) as Map).11: std::option::Option<<C as WhereTrait>::Type>);
        _195 = deref_copy (_7.1: &Enum<A, B, C>);
        _100 = &(((*_195) as Map).12: <C as WhereTrait>::Type);
        _196 = deref_copy (_7.1: &Enum<A, B, C>);
        _101 = &(((*_196) as Map).13: std::option::Option<<C as WhereTrait>::Type>);
        _197 = deref_copy (_7.1: &Enum<A, B, C>);
        _102 = &(((*_197) as Map).14: i32);
        _117 = (*_73);
        _118 = (*_88);
        _116 = Eq(move _117, move _118);
        switchInt(move _116) -> [0: bb101, otherwise: bb102];
    }

    bb63: {
        _6 = const false;
        goto -> bb117;
    }

    bb64: {
        _133 = (*_87);
        _134 = (*_102);
        _132 = Eq(move _133, move _134);
        _6 = move _132;
        goto -> bb117;
    }

    bb65: {
        _103 = const false;
        goto -> bb67;
    }

    bb66: {
        _131 = <Option<<C as WhereTrait>::Type> as PartialEq>::eq(_86, _101) -> [return: bb116, unwind continue];
    }

    bb67: {
        switchInt(move _103) -> [0: bb63, otherwise: bb64];
    }

    bb68: {
        _104 = const false;
        goto -> bb70;
    }

    bb69: {
        _130 = <<C as WhereTrait>::Type as PartialEq>::eq(_85, _100) -> [return: bb115, unwind continue];
    }

    bb70: {
        switchInt(move _104) -> [0: bb65, otherwise: bb66];
    }

    bb71: {
        _105 = const false;
        goto -> bb73;
    }

    bb72: {
        _129 = <Option<<C as WhereTrait>::Type> as PartialEq>::eq(_84, _99) -> [return: bb114, unwind continue];
    }

    bb73: {
        switchInt(move _105) -> [0: bb68, otherwise: bb69];
    }

    bb74: {
        _106 = const false;
        goto -> bb76;
    }

    bb75: {
        _128 = <<C as WhereTrait>::Type as PartialEq>::eq(_83, _98) -> [return: bb113, unwind continue];
    }

    bb76: {
        switchInt(move _106) -> [0: bb71, otherwise: bb72];
    }

    bb77: {
        _107 = const false;
        goto -> bb79;
    }

    bb78: {
        _127 = <C as PartialEq>::eq(_82, _97) -> [return: bb112, unwind continue];
    }

    bb79: {
        switchInt(move _107) -> [0: bb74, otherwise: bb75];
    }

    bb80: {
        _108 = const false;
        goto -> bb82;
    }

    bb81: {
        _126 = <Option<<B as DeclaredTrait>::Type> as PartialEq>::eq(_81, _96) -> [return: bb111, unwind continue];
    }

    bb82: {
        switchInt(move _108) -> [0: bb77, otherwise: bb78];
    }

    bb83: {
        _109 = const false;
        goto -> bb85;
    }

    bb84: {
        _125 = <<B as DeclaredTrait>::Type as PartialEq>::eq(_80, _95) -> [return: bb110, unwind continue];
    }

    bb85: {
        switchInt(move _109) -> [0: bb80, otherwise: bb81];
    }

    bb86: {
        _110 = const false;
        goto -> bb88;
    }

    bb87: {
        _124 = <Option<<B as DeclaredTrait>::Type> as PartialEq>::eq(_79, _94) -> [return: bb109, unwind continue];
    }

    bb88: {
        switchInt(move _110) -> [0: bb83, otherwise: bb84];
    }

    bb89: {
        _111 = const false;
        goto -> bb91;
    }

    bb90: {
        _123 = <<B as DeclaredTrait>::Type as PartialEq>::eq(_78, _93) -> [return: bb108, unwind continue];
    }

    bb91: {
        switchInt(move _111) -> [0: bb86, otherwise: bb87];
    }

    bb92: {
        _112 = const false;
        goto -> bb94;
    }

    bb93: {
        _122 = <B as PartialEq>::eq(_77, _92) -> [return: bb107, unwind continue];
    }

    bb94: {
        switchInt(move _112) -> [0: bb89, otherwise: bb90];
    }

    bb95: {
        _113 = const false;
        goto -> bb97;
    }

    bb96: {
        _121 = <PrivateStruct<A> as PartialEq>::eq(_76, _91) -> [return: bb106, unwind continue];
    }

    bb97: {
        switchInt(move _113) -> [0: bb92, otherwise: bb93];
    }

    bb98: {
        _114 = const false;
        goto -> bb100;
    }

    bb99: {
        _120 = <A as PartialEq>::eq(_75, _90) -> [return: bb105, unwind continue];
    }

    bb100: {
        switchInt(move _114) -> [0: bb95, otherwise: bb96];
    }

    bb101: {
        _115 = const false;
        goto -> bb103;
    }

    bb102: {
        _119 = <Option<i32> as PartialEq>::eq(_74, _89) -> [return: bb104, unwind continue];
    }

    bb103: {
        switchInt(move _115) -> [0: bb98, otherwise: bb99];
    }

    bb104: {
        _115 = move _119;
        goto -> bb103;
    }

    bb105: {
        _114 = move _120;
        goto -> bb100;
    }

    bb106: {
        _113 = move _121;
        goto -> bb97;
    }

    bb107: {
        _112 = move _122;
        goto -> bb94;
    }

    bb108: {
        _111 = move _123;
        goto -> bb91;
    }

    bb109: {
        _110 = move _124;
        goto -> bb88;
    }

    bb110: {
        _109 = move _125;
        goto -> bb85;
    }

    bb111: {
        _108 = move _126;
        goto -> bb82;
    }

    bb112: {
        _107 = move _127;
        goto -> bb79;
    }

    bb113: {
        _106 = move _128;
        goto -> bb76;
    }

    bb114: {
        _105 = move _129;
        goto -> bb73;
    }

    bb115: {
        _104 = move _130;
        goto -> bb70;
    }

    bb116: {
        _103 = move _131;
        goto -> bb67;
    }

    bb117: {
        _0 = move _6;
        goto -> bb3;
    }
}

fn <impl at ui/deriving/deriving-associated-types.rs:65:21: 65:26>::fmt(_1: &Enum<A, B, C>, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &str;
    let _5: &i32;
    let _6: &std::option::Option<i32>;
    let _7: &A;
    let _8: &PrivateStruct<A>;
    let _9: &B;
    let _10: &<B as DeclaredTrait>::Type;
    let _11: &std::option::Option<<B as DeclaredTrait>::Type>;
    let _12: &<B as DeclaredTrait>::Type;
    let _13: &std::option::Option<<B as DeclaredTrait>::Type>;
    let _14: &C;
    let _15: &<C as WhereTrait>::Type;
    let _16: &std::option::Option<<C as WhereTrait>::Type>;
    let _17: &<C as WhereTrait>::Type;
    let _18: &std::option::Option<<C as WhereTrait>::Type>;
    let _19: &i32;
    let _21: &[&dyn std::fmt::Debug; 15];
    let _22: [&dyn std::fmt::Debug; 15];
    let mut _23: &dyn std::fmt::Debug;
    let mut _24: &dyn std::fmt::Debug;
    let mut _25: &dyn std::fmt::Debug;
    let mut _26: &dyn std::fmt::Debug;
    let mut _27: &dyn std::fmt::Debug;
    let mut _28: &dyn std::fmt::Debug;
    let mut _29: &dyn std::fmt::Debug;
    let mut _30: &dyn std::fmt::Debug;
    let mut _31: &dyn std::fmt::Debug;
    let mut _32: &dyn std::fmt::Debug;
    let mut _33: &dyn std::fmt::Debug;
    let mut _34: &dyn std::fmt::Debug;
    let mut _35: &dyn std::fmt::Debug;
    let mut _36: &dyn std::fmt::Debug;
    let mut _37: &dyn std::fmt::Debug;
    let _38: &&i32;
    let _39: &str;
    let _40: &i32;
    let _41: &std::option::Option<i32>;
    let _42: &A;
    let _43: &PrivateStruct<A>;
    let _44: &B;
    let _45: &<B as DeclaredTrait>::Type;
    let _46: &std::option::Option<<B as DeclaredTrait>::Type>;
    let _47: &<B as DeclaredTrait>::Type;
    let _48: &std::option::Option<<B as DeclaredTrait>::Type>;
    let _49: &C;
    let _50: &<C as WhereTrait>::Type;
    let _51: &std::option::Option<<C as WhereTrait>::Type>;
    let _52: &<C as WhereTrait>::Type;
    let _53: &std::option::Option<<C as WhereTrait>::Type>;
    let _54: &i32;
    let _56: &[&dyn std::fmt::Debug; 15];
    let _57: [&dyn std::fmt::Debug; 15];
    let mut _58: &dyn std::fmt::Debug;
    let mut _59: &dyn std::fmt::Debug;
    let mut _60: &dyn std::fmt::Debug;
    let mut _61: &dyn std::fmt::Debug;
    let mut _62: &dyn std::fmt::Debug;
    let mut _63: &dyn std::fmt::Debug;
    let mut _64: &dyn std::fmt::Debug;
    let mut _65: &dyn std::fmt::Debug;
    let mut _66: &dyn std::fmt::Debug;
    let mut _67: &dyn std::fmt::Debug;
    let mut _68: &dyn std::fmt::Debug;
    let mut _69: &dyn std::fmt::Debug;
    let mut _70: &dyn std::fmt::Debug;
    let mut _71: &dyn std::fmt::Debug;
    let mut _72: &dyn std::fmt::Debug;
    let _73: &&i32;
    let _74: &str;
    let mut _75: &[&str];
    scope 1 {
        debug __self_0 => _5;
        debug __self_1 => _6;
        debug __self_2 => _7;
        debug __self_3 => _8;
        debug __self_4 => _9;
        debug __self_5 => _10;
        debug __self_6 => _11;
        debug __self_7 => _12;
        debug __self_8 => _13;
        debug __self_9 => _14;
        debug __self_10 => _15;
        debug __self_11 => _16;
        debug __self_12 => _17;
        debug __self_13 => _18;
        debug __self_14 => _19;
        let _20: &[&dyn std::fmt::Debug];
        scope 2 {
            debug values => _20;
        }
    }
    scope 3 {
        debug __self_0 => _40;
        debug __self_1 => _41;
        debug __self_2 => _42;
        debug __self_3 => _43;
        debug __self_4 => _44;
        debug __self_5 => _45;
        debug __self_6 => _46;
        debug __self_7 => _47;
        debug __self_8 => _48;
        debug __self_9 => _49;
        debug __self_10 => _50;
        debug __self_11 => _51;
        debug __self_12 => _52;
        debug __self_13 => _53;
        debug __self_14 => _54;
        let mut _76: &[&str; 15];
        scope 4 {
            debug names => const _;
            let _55: &[&dyn std::fmt::Debug];
            scope 5 {
                debug values => _55;
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _40 = &(((*_1) as Map).0: i32);
        _41 = &(((*_1) as Map).1: std::option::Option<i32>);
        _42 = &(((*_1) as Map).2: A);
        _43 = &(((*_1) as Map).3: PrivateStruct<A>);
        _44 = &(((*_1) as Map).4: B);
        _45 = &(((*_1) as Map).5: <B as DeclaredTrait>::Type);
        _46 = &(((*_1) as Map).6: std::option::Option<<B as DeclaredTrait>::Type>);
        _47 = &(((*_1) as Map).7: <B as DeclaredTrait>::Type);
        _48 = &(((*_1) as Map).8: std::option::Option<<B as DeclaredTrait>::Type>);
        _49 = &(((*_1) as Map).9: C);
        _50 = &(((*_1) as Map).10: <C as WhereTrait>::Type);
        _51 = &(((*_1) as Map).11: std::option::Option<<C as WhereTrait>::Type>);
        _52 = &(((*_1) as Map).12: <C as WhereTrait>::Type);
        _53 = &(((*_1) as Map).13: std::option::Option<<C as WhereTrait>::Type>);
        _54 = &(((*_1) as Map).14: i32);
        _76 = const _;
        _58 = _40 as &dyn std::fmt::Debug (Pointer(Unsize));
        _59 = _41 as &dyn std::fmt::Debug (Pointer(Unsize));
        _60 = _42 as &dyn std::fmt::Debug (Pointer(Unsize));
        _61 = _43 as &dyn std::fmt::Debug (Pointer(Unsize));
        _62 = _44 as &dyn std::fmt::Debug (Pointer(Unsize));
        _63 = _45 as &dyn std::fmt::Debug (Pointer(Unsize));
        _64 = _46 as &dyn std::fmt::Debug (Pointer(Unsize));
        _65 = _47 as &dyn std::fmt::Debug (Pointer(Unsize));
        _66 = _48 as &dyn std::fmt::Debug (Pointer(Unsize));
        _67 = _49 as &dyn std::fmt::Debug (Pointer(Unsize));
        _68 = _50 as &dyn std::fmt::Debug (Pointer(Unsize));
        _69 = _51 as &dyn std::fmt::Debug (Pointer(Unsize));
        _70 = _52 as &dyn std::fmt::Debug (Pointer(Unsize));
        _71 = _53 as &dyn std::fmt::Debug (Pointer(Unsize));
        _73 = &_54;
        _72 = _73 as &dyn std::fmt::Debug (Pointer(Unsize));
        _57 = [move _58, move _59, move _60, move _61, move _62, move _63, move _64, move _65, move _66, move _67, move _68, move _69, move _70, move _71, move _72];
        _56 = &_57;
        _55 = _56 as &[&dyn std::fmt::Debug] (Pointer(Unsize));
        _74 = const "Map";
        _75 = _76 as &[&str] (Pointer(Unsize));
        _0 = Formatter::<'_>::debug_struct_fields_finish(_2, _74, move _75, _55) -> [return: bb5, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = const "Unit";
        _0 = Formatter::<'_>::write_str(_2, _4) -> [return: bb5, unwind continue];
    }

    bb4: {
        _5 = &(((*_1) as Seq).0: i32);
        _6 = &(((*_1) as Seq).1: std::option::Option<i32>);
        _7 = &(((*_1) as Seq).2: A);
        _8 = &(((*_1) as Seq).3: PrivateStruct<A>);
        _9 = &(((*_1) as Seq).4: B);
        _10 = &(((*_1) as Seq).5: <B as DeclaredTrait>::Type);
        _11 = &(((*_1) as Seq).6: std::option::Option<<B as DeclaredTrait>::Type>);
        _12 = &(((*_1) as Seq).7: <B as DeclaredTrait>::Type);
        _13 = &(((*_1) as Seq).8: std::option::Option<<B as DeclaredTrait>::Type>);
        _14 = &(((*_1) as Seq).9: C);
        _15 = &(((*_1) as Seq).10: <C as WhereTrait>::Type);
        _16 = &(((*_1) as Seq).11: std::option::Option<<C as WhereTrait>::Type>);
        _17 = &(((*_1) as Seq).12: <C as WhereTrait>::Type);
        _18 = &(((*_1) as Seq).13: std::option::Option<<C as WhereTrait>::Type>);
        _19 = &(((*_1) as Seq).14: i32);
        _23 = _5 as &dyn std::fmt::Debug (Pointer(Unsize));
        _24 = _6 as &dyn std::fmt::Debug (Pointer(Unsize));
        _25 = _7 as &dyn std::fmt::Debug (Pointer(Unsize));
        _26 = _8 as &dyn std::fmt::Debug (Pointer(Unsize));
        _27 = _9 as &dyn std::fmt::Debug (Pointer(Unsize));
        _28 = _10 as &dyn std::fmt::Debug (Pointer(Unsize));
        _29 = _11 as &dyn std::fmt::Debug (Pointer(Unsize));
        _30 = _12 as &dyn std::fmt::Debug (Pointer(Unsize));
        _31 = _13 as &dyn std::fmt::Debug (Pointer(Unsize));
        _32 = _14 as &dyn std::fmt::Debug (Pointer(Unsize));
        _33 = _15 as &dyn std::fmt::Debug (Pointer(Unsize));
        _34 = _16 as &dyn std::fmt::Debug (Pointer(Unsize));
        _35 = _17 as &dyn std::fmt::Debug (Pointer(Unsize));
        _36 = _18 as &dyn std::fmt::Debug (Pointer(Unsize));
        _38 = &_19;
        _37 = _38 as &dyn std::fmt::Debug (Pointer(Unsize));
        _22 = [move _23, move _24, move _25, move _26, move _27, move _28, move _29, move _30, move _31, move _32, move _33, move _34, move _35, move _36, move _37];
        _21 = &_22;
        _20 = _21 as &[&dyn std::fmt::Debug] (Pointer(Unsize));
        _39 = const "Seq";
        _0 = Formatter::<'_>::debug_tuple_fields_finish(_2, _39, _20) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

promoted[0] in <impl at ui/deriving/deriving-associated-types.rs:65:21: 65:26>::fmt: &[&str; 15] = {
    let mut _0: &[&str; 15];
    let mut _1: [&str; 15];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;
    let mut _14: &str;
    let mut _15: &str;
    let mut _16: &str;
    let mut _17: &str;
    let mut _18: &str;
    let mut _19: &str;
    let mut _20: &str;
    let mut _21: &str;
    let mut _22: &str;
    let mut _23: &str;
    let mut _24: &str;
    let mut _25: &str;
    let mut _26: &str;
    let mut _27: &str;
    let mut _28: &str;
    let mut _29: &str;

    bb0: {
        _3 = const "m2";
        _2 = &(*_3);
        _5 = const "a1";
        _4 = &(*_5);
        _7 = const "a2";
        _6 = &(*_7);
        _9 = const "b";
        _8 = &(*_9);
        _11 = const "b1";
        _10 = &(*_11);
        _13 = const "b2";
        _12 = &(*_13);
        _15 = const "b3";
        _14 = &(*_15);
        _17 = const "b4";
        _16 = &(*_17);
        _19 = const "c";
        _18 = &(*_19);
        _21 = const "c1";
        _20 = &(*_21);
        _23 = const "c2";
        _22 = &(*_23);
        _25 = const "c3";
        _24 = &(*_25);
        _27 = const "c4";
        _26 = &(*_27);
        _29 = const "d";
        _28 = &(*_29);
        _1 = [const "m1", move _2, move _4, move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22, move _24, move _26, move _28];
        _0 = &_1;
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: TupleStruct<i32, i32, i32>;
    let mut _2: std::option::Option<i32>;
    let mut _3: PrivateStruct<i32>;
    let mut _4: std::option::Option<i32>;
    let mut _5: std::option::Option<i32>;
    let mut _6: std::option::Option<i32>;
    let mut _7: std::option::Option<i32>;
    let mut _8: (&TupleStruct<i32, i32, i32>, &TupleStruct<i32, i32, i32>);
    let mut _9: &TupleStruct<i32, i32, i32>;
    let mut _10: &TupleStruct<i32, i32, i32>;
    let mut _13: bool;
    let mut _14: bool;
    let _16: !;
    let mut _17: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _19: std::option::Option<i32>;
    let mut _20: PrivateStruct<i32>;
    let mut _21: std::option::Option<i32>;
    let mut _22: std::option::Option<i32>;
    let mut _23: std::option::Option<i32>;
    let mut _24: std::option::Option<i32>;
    let mut _25: (&Struct<i32, i32, i32>, &Struct<i32, i32, i32>);
    let mut _26: &Struct<i32, i32, i32>;
    let mut _27: &Struct<i32, i32, i32>;
    let mut _30: bool;
    let mut _31: bool;
    let _33: !;
    let mut _34: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _36: (&Enum<i32, i32, i32>, &Enum<i32, i32, i32>);
    let mut _37: &Enum<i32, i32, i32>;
    let mut _38: &Enum<i32, i32, i32>;
    let mut _41: bool;
    let mut _42: bool;
    let _44: !;
    let mut _45: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _47: std::option::Option<i32>;
    let mut _48: PrivateStruct<i32>;
    let mut _49: std::option::Option<i32>;
    let mut _50: std::option::Option<i32>;
    let mut _51: std::option::Option<i32>;
    let mut _52: std::option::Option<i32>;
    let mut _53: (&Enum<i32, i32, i32>, &Enum<i32, i32, i32>);
    let mut _54: &Enum<i32, i32, i32>;
    let mut _55: &Enum<i32, i32, i32>;
    let mut _58: bool;
    let mut _59: bool;
    let _61: !;
    let mut _62: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _64: std::option::Option<i32>;
    let mut _65: PrivateStruct<i32>;
    let mut _66: std::option::Option<i32>;
    let mut _67: std::option::Option<i32>;
    let mut _68: std::option::Option<i32>;
    let mut _69: std::option::Option<i32>;
    let mut _70: (&Enum<i32, i32, i32>, &Enum<i32, i32, i32>);
    let mut _71: &Enum<i32, i32, i32>;
    let mut _72: &Enum<i32, i32, i32>;
    let mut _75: bool;
    let mut _76: bool;
    let _78: !;
    let mut _79: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug e => _1;
        let _11: &TupleStruct<i32, i32, i32>;
        let _12: &TupleStruct<i32, i32, i32>;
        let _18: Struct<i32, i32, i32>;
        scope 2 {
            debug left_val => _11;
            debug right_val => _12;
            let _15: core::panicking::AssertKind;
            scope 3 {
                debug kind => _15;
            }
        }
        scope 4 {
            debug e => _18;
            let _28: &Struct<i32, i32, i32>;
            let _29: &Struct<i32, i32, i32>;
            let _35: Enum<i32, i32, i32>;
            scope 5 {
                debug left_val => _28;
                debug right_val => _29;
                let _32: core::panicking::AssertKind;
                scope 6 {
                    debug kind => _32;
                }
            }
            scope 7 {
                debug e => _35;
                let _39: &Enum<i32, i32, i32>;
                let _40: &Enum<i32, i32, i32>;
                let _46: Enum<i32, i32, i32>;
                scope 8 {
                    debug left_val => _39;
                    debug right_val => _40;
                    let _43: core::panicking::AssertKind;
                    scope 9 {
                        debug kind => _43;
                    }
                }
                scope 10 {
                    debug e => _46;
                    let _56: &Enum<i32, i32, i32>;
                    let _57: &Enum<i32, i32, i32>;
                    let _63: Enum<i32, i32, i32>;
                    scope 11 {
                        debug left_val => _56;
                        debug right_val => _57;
                        let _60: core::panicking::AssertKind;
                        scope 12 {
                            debug kind => _60;
                        }
                    }
                    scope 13 {
                        debug e => _63;
                        let _73: &Enum<i32, i32, i32>;
                        let _74: &Enum<i32, i32, i32>;
                        scope 14 {
                            debug left_val => _73;
                            debug right_val => _74;
                            let _77: core::panicking::AssertKind;
                            scope 15 {
                                debug kind => _77;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = Option::<i32>::None;
        _3 = PrivateStruct::<i32>(const 0_i32);
        _4 = Option::<i32>::None;
        _5 = Option::<i32>::None;
        _6 = Option::<i32>::None;
        _7 = Option::<i32>::None;
        _1 = TupleStruct::<i32, i32, i32>(const 0_i32, move _2, const 0_i32, move _3, const 0_i32, const 0_i32, move _4, const 0_i32, move _5, const 0_i32, const 0_i32, move _6, const 0_i32, move _7, const 0_i32);
        _9 = &_1;
        _10 = &_1;
        _8 = (move _9, move _10);
        _11 = (_8.0: &TupleStruct<i32, i32, i32>);
        _12 = (_8.1: &TupleStruct<i32, i32, i32>);
        _14 = <TupleStruct<i32, i32, i32> as PartialEq>::eq(_11, _12) -> [return: bb1, unwind continue];
    }

    bb1: {
        _13 = Not(move _14);
        switchInt(move _13) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _15 = core::panicking::AssertKind::Eq;
        _17 = Option::<Arguments<'_>>::None;
        _16 = core::panicking::assert_failed::<TupleStruct<i32, i32, i32>, TupleStruct<i32, i32, i32>>(move _15, _11, _12, move _17) -> unwind continue;
    }

    bb3: {
        _19 = Option::<i32>::None;
        _20 = PrivateStruct::<i32>(const 0_i32);
        _21 = Option::<i32>::None;
        _22 = Option::<i32>::None;
        _23 = Option::<i32>::None;
        _24 = Option::<i32>::None;
        _18 = Struct::<i32, i32, i32> { m1: const 0_i32, m2: move _19, a1: const 0_i32, a2: move _20, b: const 0_i32, b1: const 0_i32, b2: move _21, b3: const 0_i32, b4: move _22, c: const 0_i32, c1: const 0_i32, c2: move _23, c3: const 0_i32, c4: move _24, d: const 0_i32 };
        _26 = &_18;
        _27 = &_18;
        _25 = (move _26, move _27);
        _28 = (_25.0: &Struct<i32, i32, i32>);
        _29 = (_25.1: &Struct<i32, i32, i32>);
        _31 = <Struct<i32, i32, i32> as PartialEq>::eq(_28, _29) -> [return: bb4, unwind continue];
    }

    bb4: {
        _30 = Not(move _31);
        switchInt(move _30) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _32 = core::panicking::AssertKind::Eq;
        _34 = Option::<Arguments<'_>>::None;
        _33 = core::panicking::assert_failed::<Struct<i32, i32, i32>, Struct<i32, i32, i32>>(move _32, _28, _29, move _34) -> unwind continue;
    }

    bb6: {
        _35 = Enum::<i32, i32, i32>::Unit;
        _37 = &_35;
        _38 = &_35;
        _36 = (move _37, move _38);
        _39 = (_36.0: &Enum<i32, i32, i32>);
        _40 = (_36.1: &Enum<i32, i32, i32>);
        _42 = <Enum<i32, i32, i32> as PartialEq>::eq(_39, _40) -> [return: bb7, unwind continue];
    }

    bb7: {
        _41 = Not(move _42);
        switchInt(move _41) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _43 = core::panicking::AssertKind::Eq;
        _45 = Option::<Arguments<'_>>::None;
        _44 = core::panicking::assert_failed::<Enum<i32, i32, i32>, Enum<i32, i32, i32>>(move _43, _39, _40, move _45) -> unwind continue;
    }

    bb9: {
        _47 = Option::<i32>::None;
        _48 = PrivateStruct::<i32>(const 0_i32);
        _49 = Option::<i32>::None;
        _50 = Option::<i32>::None;
        _51 = Option::<i32>::None;
        _52 = Option::<i32>::None;
        _46 = Enum::<i32, i32, i32>::Seq(const 0_i32, move _47, const 0_i32, move _48, const 0_i32, const 0_i32, move _49, const 0_i32, move _50, const 0_i32, const 0_i32, move _51, const 0_i32, move _52, const 0_i32);
        _54 = &_46;
        _55 = &_46;
        _53 = (move _54, move _55);
        _56 = (_53.0: &Enum<i32, i32, i32>);
        _57 = (_53.1: &Enum<i32, i32, i32>);
        _59 = <Enum<i32, i32, i32> as PartialEq>::eq(_56, _57) -> [return: bb10, unwind continue];
    }

    bb10: {
        _58 = Not(move _59);
        switchInt(move _58) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _60 = core::panicking::AssertKind::Eq;
        _62 = Option::<Arguments<'_>>::None;
        _61 = core::panicking::assert_failed::<Enum<i32, i32, i32>, Enum<i32, i32, i32>>(move _60, _56, _57, move _62) -> unwind continue;
    }

    bb12: {
        _64 = Option::<i32>::None;
        _65 = PrivateStruct::<i32>(const 0_i32);
        _66 = Option::<i32>::None;
        _67 = Option::<i32>::None;
        _68 = Option::<i32>::None;
        _69 = Option::<i32>::None;
        _63 = Enum::<i32, i32, i32>::Map { m1: const 0_i32, m2: move _64, a1: const 0_i32, a2: move _65, b: const 0_i32, b1: const 0_i32, b2: move _66, b3: const 0_i32, b4: move _67, c: const 0_i32, c1: const 0_i32, c2: move _68, c3: const 0_i32, c4: move _69, d: const 0_i32 };
        _71 = &_63;
        _72 = &_63;
        _70 = (move _71, move _72);
        _73 = (_70.0: &Enum<i32, i32, i32>);
        _74 = (_70.1: &Enum<i32, i32, i32>);
        _76 = <Enum<i32, i32, i32> as PartialEq>::eq(_73, _74) -> [return: bb13, unwind continue];
    }

    bb13: {
        _75 = Not(move _76);
        switchInt(move _75) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _77 = core::panicking::AssertKind::Eq;
        _79 = Option::<Arguments<'_>>::None;
        _78 = core::panicking::assert_failed::<Enum<i32, i32, i32>, Enum<i32, i32, i32>>(move _77, _73, _74, move _79) -> unwind continue;
    }

    bb15: {
        return;
    }
}

fn PrivateStruct(_1: T) -> PrivateStruct<T> {
    let mut _0: PrivateStruct<T>;

    bb0: {
        _0 = PrivateStruct::<T>(move _1);
        return;
    }
}

// MIR FOR CTFE
fn PrivateStruct(_1: T) -> PrivateStruct<T> {
    let mut _0: PrivateStruct<T>;

    bb0: {
        _0 = PrivateStruct::<T>(move _1);
        return;
    }
}

fn TupleStruct(_1: i32, _2: Option<i32>, _3: A, _4: PrivateStruct<A>, _5: B, _6: <B as DeclaredTrait>::Type, _7: Option<<B as DeclaredTrait>::Type>, _8: <B as DeclaredTrait>::Type, _9: Option<<B as DeclaredTrait>::Type>, _10: C, _11: <C as WhereTrait>::Type, _12: Option<<C as WhereTrait>::Type>, _13: <C as WhereTrait>::Type, _14: Option<<C as WhereTrait>::Type>, _15: i32) -> TupleStruct<A, B, C> {
    let mut _0: TupleStruct<A, B, C>;

    bb0: {
        _0 = TupleStruct::<A, B, C>(move _1, move _2, move _3, move _4, move _5, move _6, move _7, move _8, move _9, move _10, move _11, move _12, move _13, move _14, move _15);
        return;
    }
}

// MIR FOR CTFE
fn TupleStruct(_1: i32, _2: Option<i32>, _3: A, _4: PrivateStruct<A>, _5: B, _6: <B as DeclaredTrait>::Type, _7: Option<<B as DeclaredTrait>::Type>, _8: <B as DeclaredTrait>::Type, _9: Option<<B as DeclaredTrait>::Type>, _10: C, _11: <C as WhereTrait>::Type, _12: Option<<C as WhereTrait>::Type>, _13: <C as WhereTrait>::Type, _14: Option<<C as WhereTrait>::Type>, _15: i32) -> TupleStruct<A, B, C> {
    let mut _0: TupleStruct<A, B, C>;

    bb0: {
        _0 = TupleStruct::<A, B, C>(move _1, move _2, move _3, move _4, move _5, move _6, move _7, move _8, move _9, move _10, move _11, move _12, move _13, move _14, move _15);
        return;
    }
}

fn Enum::Seq(_1: i32, _2: Option<i32>, _3: A, _4: PrivateStruct<A>, _5: B, _6: <B as DeclaredTrait>::Type, _7: Option<<B as DeclaredTrait>::Type>, _8: <B as DeclaredTrait>::Type, _9: Option<<B as DeclaredTrait>::Type>, _10: C, _11: <C as WhereTrait>::Type, _12: Option<<C as WhereTrait>::Type>, _13: <C as WhereTrait>::Type, _14: Option<<C as WhereTrait>::Type>, _15: i32) -> Enum<A, B, C> {
    let mut _0: Enum<A, B, C>;

    bb0: {
        _0 = Enum::<A, B, C>::Seq(move _1, move _2, move _3, move _4, move _5, move _6, move _7, move _8, move _9, move _10, move _11, move _12, move _13, move _14, move _15);
        return;
    }
}

// MIR FOR CTFE
fn Enum::Seq(_1: i32, _2: Option<i32>, _3: A, _4: PrivateStruct<A>, _5: B, _6: <B as DeclaredTrait>::Type, _7: Option<<B as DeclaredTrait>::Type>, _8: <B as DeclaredTrait>::Type, _9: Option<<B as DeclaredTrait>::Type>, _10: C, _11: <C as WhereTrait>::Type, _12: Option<<C as WhereTrait>::Type>, _13: <C as WhereTrait>::Type, _14: Option<<C as WhereTrait>::Type>, _15: i32) -> Enum<A, B, C> {
    let mut _0: Enum<A, B, C>;

    bb0: {
        _0 = Enum::<A, B, C>::Seq(move _1, move _2, move _3, move _4, move _5, move _6, move _7, move _8, move _9, move _10, move _11, move _12, move _13, move _14, move _15);
        return;
    }
}
