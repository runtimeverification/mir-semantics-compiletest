// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();
    let mut _1: std::vec::Vec<i32>;
    let mut _6: std::ops::RangeInclusive<i32>;
    let mut _7: std::ops::RangeInclusive<i32>;
    let mut _8: i32;
    let mut _9: i32;
    let _11: ();
    let mut _12: std::option::Option<i32>;
    let mut _13: &mut std::ops::RangeInclusive<i32>;
    let mut _14: isize;
    let _16: ();
    let mut _17: bool;
    let mut _18: bool;
    let mut _19: bool;
    let mut _20: bool;
    let mut _21: &mut std::vec::Vec<i32>;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: bool;
    let mut _27: bool;
    let mut _28: bool;
    let mut _29: bool;
    let mut _30: bool;
    let mut _31: bool;
    let mut _32: &mut std::vec::Vec<i32>;
    let mut _34: &mut std::vec::Vec<i32>;
    let mut _35: i32;
    let mut _37: (&i32, &i32);
    let mut _38: &i32;
    let mut _41: bool;
    let mut _42: bool;
    let mut _43: i32;
    let mut _44: i32;
    let _46: !;
    let mut _47: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _48: &mut std::vec::Vec<i32>;
    let mut _50: (&i32, &i32);
    let mut _51: &i32;
    let mut _54: bool;
    let mut _55: bool;
    let mut _56: i32;
    let mut _57: i32;
    let _59: !;
    let mut _60: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _61: &mut std::vec::Vec<i32>;
    let mut _62: (&std::vec::Vec<i32>, &[i32; 4]);
    let mut _63: &std::vec::Vec<i32>;
    let mut _66: bool;
    let mut _67: bool;
    let _69: !;
    let mut _70: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _71: (&std::vec::Vec<i32>, &[i32; 4]);
    let mut _72: &std::vec::Vec<i32>;
    let mut _75: bool;
    let mut _76: bool;
    let _78: !;
    let mut _79: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _80: (&std::vec::Vec<i32>, &[i32; 5]);
    let mut _81: &std::vec::Vec<i32>;
    let mut _84: bool;
    let mut _85: bool;
    let _87: !;
    let mut _88: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _89: (&std::vec::Vec<i32>, &[i32; 3]);
    let mut _90: &std::vec::Vec<i32>;
    let mut _93: bool;
    let mut _94: bool;
    let _96: !;
    let mut _97: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _98: (&std::vec::Vec<i32>, &[i32; 2]);
    let mut _99: &std::vec::Vec<i32>;
    let mut _102: bool;
    let mut _103: bool;
    let _105: !;
    let mut _106: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug if_lettable => _1;
        let mut _2: std::vec::Vec<i32>;
        scope 2 {
            debug first_or => _2;
            let mut _3: std::vec::Vec<i32>;
            scope 3 {
                debug or_two => _3;
                let mut _4: std::vec::Vec<i32>;
                scope 4 {
                    debug range_from => _4;
                    let mut _5: std::vec::Vec<i32>;
                    scope 5 {
                        debug bottom => _5;
                        let mut _10: std::ops::RangeInclusive<i32>;
                        let _64: &std::vec::Vec<i32>;
                        let _65: &[i32; 4];
                        let _73: &std::vec::Vec<i32>;
                        let _74: &[i32; 4];
                        let _82: &std::vec::Vec<i32>;
                        let _83: &[i32; 5];
                        let _91: &std::vec::Vec<i32>;
                        let _92: &[i32; 3];
                        let _100: &std::vec::Vec<i32>;
                        let _101: &[i32; 2];
                        let mut _109: &[i32; 2];
                        let mut _110: &[i32; 3];
                        let mut _111: &[i32; 5];
                        let mut _112: &[i32; 4];
                        let mut _113: &[i32; 4];
                        scope 6 {
                            debug iter => _10;
                            let _15: i32;
                            scope 7 {
                                debug x => _15;
                                let _33: i32;
                                let _36: i32;
                                let _49: i32;
                                scope 8 {
                                }
                                scope 9 {
                                    debug y => _33;
                                }
                                scope 10 {
                                    debug y => _36;
                                    let _39: &i32;
                                    let _40: &i32;
                                    let mut _108: &i32;
                                    scope 11 {
                                        debug left_val => _39;
                                        debug right_val => _40;
                                        let _45: core::panicking::AssertKind;
                                        scope 12 {
                                            debug kind => _45;
                                        }
                                    }
                                }
                                scope 13 {
                                    debug y => _15;
                                }
                                scope 14 {
                                    debug y => _49;
                                    let _52: &i32;
                                    let _53: &i32;
                                    let mut _107: &i32;
                                    scope 15 {
                                        debug left_val => _52;
                                        debug right_val => _53;
                                        let _58: core::panicking::AssertKind;
                                        scope 16 {
                                            debug kind => _58;
                                        }
                                    }
                                }
                                scope 17 {
                                    debug y => _15;
                                }
                            }
                        }
                        scope 18 {
                            debug left_val => _64;
                            debug right_val => _65;
                            let _68: core::panicking::AssertKind;
                            scope 19 {
                                debug kind => _68;
                            }
                        }
                        scope 20 {
                            debug left_val => _73;
                            debug right_val => _74;
                            let _77: core::panicking::AssertKind;
                            scope 21 {
                                debug kind => _77;
                            }
                        }
                        scope 22 {
                            debug left_val => _82;
                            debug right_val => _83;
                            let _86: core::panicking::AssertKind;
                            scope 23 {
                                debug kind => _86;
                            }
                        }
                        scope 24 {
                            debug left_val => _91;
                            debug right_val => _92;
                            let _95: core::panicking::AssertKind;
                            scope 25 {
                                debug kind => _95;
                            }
                        }
                        scope 26 {
                            debug left_val => _100;
                            debug right_val => _101;
                            let _104: core::panicking::AssertKind;
                            scope 27 {
                                debug kind => _104;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _1 = Vec::<i32>::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = Vec::<i32>::new() -> [return: bb2, unwind: bb64];
    }

    bb2: {
        _3 = Vec::<i32>::new() -> [return: bb3, unwind: bb63];
    }

    bb3: {
        _4 = Vec::<i32>::new() -> [return: bb4, unwind: bb62];
    }

    bb4: {
        _5 = Vec::<i32>::new() -> [return: bb5, unwind: bb61];
    }

    bb5: {
        _8 = Add(const -9_i32, const 1_i32);
        _9 = Sub(const 9_i32, const 2_i32);
        _7 = RangeInclusive::<i32>::new(move _8, move _9) -> [return: bb6, unwind: bb60];
    }

    bb6: {
        _6 = <RangeInclusive<i32> as IntoIterator>::into_iter(move _7) -> [return: bb7, unwind: bb60];
    }

    bb7: {
        _10 = move _6;
        goto -> bb8;
    }

    bb8: {
        _13 = &mut _10;
        _12 = <RangeInclusive<i32> as Iterator>::next(_13) -> [return: bb9, unwind: bb60];
    }

    bb9: {
        _14 = discriminant(_12);
        switchInt(move _14) -> [0: bb12, 1: bb10, otherwise: bb11];
    }

    bb10: {
        _15 = ((_12 as Some).0: i32);
        _19 = Le(const -1_i32, _15);
        switchInt(move _19) -> [0: bb14, otherwise: bb13];
    }

    bb11: {
        unreachable;
    }

    bb12: {
        _63 = &_1;
        _113 = const _;
        _62 = (move _63, _113);
        _64 = (_62.0: &std::vec::Vec<i32>);
        _65 = (_62.1: &[i32; 4]);
        _67 = <Vec<i32> as PartialEq<[i32; 4]>>::eq(_64, _65) -> [return: bb40, unwind: bb60];
    }

    bb13: {
        _20 = Le(_15, const 0_i32);
        switchInt(move _20) -> [0: bb14, otherwise: bb17];
    }

    bb14: {
        _17 = Le(const 2_i32, _15);
        switchInt(move _17) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _18 = Lt(_15, const 3_i32);
        switchInt(move _18) -> [0: bb16, otherwise: bb17];
    }

    bb16: {
        switchInt(_15) -> [4: bb17, otherwise: bb18];
    }

    bb17: {
        _21 = &mut _1;
        _16 = Vec::<i32>::push(move _21, _15) -> [return: bb66, unwind: bb60];
    }

    bb18: {
        switchInt(_15) -> [1: bb31, otherwise: bb19];
    }

    bb19: {
        _22 = Le(const -3_i32, _15);
        switchInt(move _22) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _23 = Lt(_15, const 0_i32);
        switchInt(move _23) -> [0: bb21, otherwise: bb31];
    }

    bb21: {
        _30 = Le(const 0_i32, _15);
        switchInt(move _30) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _31 = Lt(_15, const 5_i32);
        switchInt(move _31) -> [0: bb23, otherwise: bb33];
    }

    bb23: {
        switchInt(_15) -> [6: bb34, otherwise: bb24];
    }

    bb24: {
        _28 = Le(const 0_i32, _15);
        switchInt(move _28) -> [0: bb26, otherwise: bb25];
    }

    bb25: {
        _29 = Lt(_15, const 6_i32);
        switchInt(move _29) -> [0: bb26, otherwise: bb35];
    }

    bb26: {
        _26 = Le(const -5_i32, _15);
        switchInt(move _26) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        _27 = Le(_15, const i32::MAX);
        switchInt(move _27) -> [0: bb28, otherwise: bb37];
    }

    bb28: {
        _24 = Le(const i32::MIN, _15);
        switchInt(move _24) -> [0: bb30, otherwise: bb29];
    }

    bb29: {
        _25 = Lt(_15, const -7_i32);
        switchInt(move _25) -> [0: bb30, otherwise: bb38];
    }

    bb30: {
        _61 = &mut _5;
        _11 = Vec::<i32>::push(move _61, _15) -> [return: bb67, unwind: bb60];
    }

    bb31: {
        _32 = &mut _2;
        _11 = Vec::<i32>::push(move _32, _15) -> [return: bb68, unwind: bb60];
    }

    bb32: {
        _34 = &mut _3;
        _35 = _33;
        _11 = Vec::<i32>::push(move _34, move _35) -> [return: bb69, unwind: bb60];
    }

    bb33: {
        _33 = _15;
        goto -> bb32;
    }

    bb34: {
        _33 = _15;
        goto -> bb32;
    }

    bb35: {
        _36 = _15;
        _38 = &_36;
        _108 = const _;
        _37 = (move _38, _108);
        _39 = (_37.0: &i32);
        _40 = (_37.1: &i32);
        _43 = (*_39);
        _44 = (*_40);
        _42 = Eq(move _43, move _44);
        _41 = Not(move _42);
        switchInt(move _41) -> [0: bb8, otherwise: bb36];
    }

    bb36: {
        _45 = core::panicking::AssertKind::Eq;
        _47 = Option::<Arguments<'_>>::None;
        _46 = core::panicking::assert_failed::<i32, i32>(move _45, _39, _40, move _47) -> bb60;
    }

    bb37: {
        _48 = &mut _4;
        _11 = Vec::<i32>::push(move _48, _15) -> [return: bb70, unwind: bb60];
    }

    bb38: {
        _49 = _15;
        _51 = &_49;
        _107 = const _;
        _50 = (move _51, _107);
        _52 = (_50.0: &i32);
        _53 = (_50.1: &i32);
        _56 = (*_52);
        _57 = (*_53);
        _55 = Eq(move _56, move _57);
        _54 = Not(move _55);
        switchInt(move _54) -> [0: bb8, otherwise: bb39];
    }

    bb39: {
        _58 = core::panicking::AssertKind::Eq;
        _60 = Option::<Arguments<'_>>::None;
        _59 = core::panicking::assert_failed::<i32, i32>(move _58, _52, _53, move _60) -> bb60;
    }

    bb40: {
        _66 = Not(move _67);
        switchInt(move _66) -> [0: bb42, otherwise: bb41];
    }

    bb41: {
        _68 = core::panicking::AssertKind::Eq;
        _70 = Option::<Arguments<'_>>::None;
        _69 = core::panicking::assert_failed::<Vec<i32>, [i32; 4]>(move _68, _64, _65, move _70) -> bb60;
    }

    bb42: {
        _72 = &_2;
        _112 = const _;
        _71 = (move _72, _112);
        _73 = (_71.0: &std::vec::Vec<i32>);
        _74 = (_71.1: &[i32; 4]);
        _76 = <Vec<i32> as PartialEq<[i32; 4]>>::eq(_73, _74) -> [return: bb43, unwind: bb60];
    }

    bb43: {
        _75 = Not(move _76);
        switchInt(move _75) -> [0: bb45, otherwise: bb44];
    }

    bb44: {
        _77 = core::panicking::AssertKind::Eq;
        _79 = Option::<Arguments<'_>>::None;
        _78 = core::panicking::assert_failed::<Vec<i32>, [i32; 4]>(move _77, _73, _74, move _79) -> bb60;
    }

    bb45: {
        _81 = &_3;
        _111 = const _;
        _80 = (move _81, _111);
        _82 = (_80.0: &std::vec::Vec<i32>);
        _83 = (_80.1: &[i32; 5]);
        _85 = <Vec<i32> as PartialEq<[i32; 5]>>::eq(_82, _83) -> [return: bb46, unwind: bb60];
    }

    bb46: {
        _84 = Not(move _85);
        switchInt(move _84) -> [0: bb48, otherwise: bb47];
    }

    bb47: {
        _86 = core::panicking::AssertKind::Eq;
        _88 = Option::<Arguments<'_>>::None;
        _87 = core::panicking::assert_failed::<Vec<i32>, [i32; 5]>(move _86, _82, _83, move _88) -> bb60;
    }

    bb48: {
        _90 = &_4;
        _110 = const _;
        _89 = (move _90, _110);
        _91 = (_89.0: &std::vec::Vec<i32>);
        _92 = (_89.1: &[i32; 3]);
        _94 = <Vec<i32> as PartialEq<[i32; 3]>>::eq(_91, _92) -> [return: bb49, unwind: bb60];
    }

    bb49: {
        _93 = Not(move _94);
        switchInt(move _93) -> [0: bb51, otherwise: bb50];
    }

    bb50: {
        _95 = core::panicking::AssertKind::Eq;
        _97 = Option::<Arguments<'_>>::None;
        _96 = core::panicking::assert_failed::<Vec<i32>, [i32; 3]>(move _95, _91, _92, move _97) -> bb60;
    }

    bb51: {
        _99 = &_5;
        _109 = const _;
        _98 = (move _99, _109);
        _100 = (_98.0: &std::vec::Vec<i32>);
        _101 = (_98.1: &[i32; 2]);
        _103 = <Vec<i32> as PartialEq<[i32; 2]>>::eq(_100, _101) -> [return: bb52, unwind: bb60];
    }

    bb52: {
        _102 = Not(move _103);
        switchInt(move _102) -> [0: bb54, otherwise: bb53];
    }

    bb53: {
        _104 = core::panicking::AssertKind::Eq;
        _106 = Option::<Arguments<'_>>::None;
        _105 = core::panicking::assert_failed::<Vec<i32>, [i32; 2]>(move _104, _100, _101, move _106) -> bb60;
    }

    bb54: {
        drop(_5) -> [return: bb55, unwind: bb61];
    }

    bb55: {
        drop(_4) -> [return: bb56, unwind: bb62];
    }

    bb56: {
        drop(_3) -> [return: bb57, unwind: bb63];
    }

    bb57: {
        drop(_2) -> [return: bb58, unwind: bb64];
    }

    bb58: {
        drop(_1) -> [return: bb59, unwind continue];
    }

    bb59: {
        return;
    }

    bb60 (cleanup): {
        drop(_5) -> [return: bb61, unwind terminate];
    }

    bb61 (cleanup): {
        drop(_4) -> [return: bb62, unwind terminate];
    }

    bb62 (cleanup): {
        drop(_3) -> [return: bb63, unwind terminate];
    }

    bb63 (cleanup): {
        drop(_2) -> [return: bb64, unwind terminate];
    }

    bb64 (cleanup): {
        drop(_1) -> [return: bb65, unwind terminate];
    }

    bb65 (cleanup): {
        resume;
    }

    bb66: {
        goto -> bb18;
    }

    bb67: {
        goto -> bb8;
    }

    bb68: {
        goto -> bb8;
    }

    bb69: {
        goto -> bb8;
    }

    bb70: {
        goto -> bb8;
    }
}

promoted[0] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const -8_i32;
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 5_i32;
        _0 = &_1;
        return;
    }
}

promoted[2] in main: &[i32; 2] = {
    let mut _0: &[i32; 2];
    let mut _1: [i32; 2];

    bb0: {
        _1 = [const -7_i32, const -6_i32];
        _0 = &_1;
        return;
    }
}

promoted[3] in main: &[i32; 3] = {
    let mut _0: &[i32; 3];
    let mut _1: [i32; 3];

    bb0: {
        _1 = [const -5_i32, const -4_i32, const 7_i32];
        _0 = &_1;
        return;
    }
}

promoted[4] in main: &[i32; 5] = {
    let mut _0: &[i32; 5];
    let mut _1: [i32; 5];

    bb0: {
        _1 = [const 0_i32, const 2_i32, const 3_i32, const 4_i32, const 6_i32];
        _0 = &_1;
        return;
    }
}

promoted[5] in main: &[i32; 4] = {
    let mut _0: &[i32; 4];
    let mut _1: [i32; 4];

    bb0: {
        _1 = [const -3_i32, const -2_i32, const -1_i32, const 1_i32];
        _0 = &_1;
        return;
    }
}

promoted[6] in main: &[i32; 4] = {
    let mut _0: &[i32; 4];
    let mut _1: [i32; 4];

    bb0: {
        _1 = [const -1_i32, const 0_i32, const 2_i32, const 4_i32];
        _0 = &_1;
        return;
    }
}

main::{constant#0}: i32 = {
    let mut _0: i32;
    let mut _1: (i32, bool);

    bb0: {
        _1 = CheckedAdd(const 5_i32, const 1_i32);
        assert(!move (_1.1: bool), "attempt to compute `{} + {}`, which would overflow", const 5_i32, const 1_i32) -> [success: bb1, unwind continue];
    }

    bb1: {
        _0 = move (_1.0: i32);
        return;
    }
}
