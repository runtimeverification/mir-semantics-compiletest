// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();
    let mut _1: std::ops::Range<usize>;
    let mut _2: std::ops::Range<usize>;
    let mut _3: std::ops::Range<usize>;
    let mut _4: std::option::Option<usize>;
    let mut _5: &mut std::ops::Range<usize>;
    let mut _6: isize;
    let mut _9: usize;
    let mut _10: (&usize, &usize);
    let mut _11: &usize;
    let _12: usize;
    let mut _13: &std::collections::BinaryHeap<()>;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: usize;
    let mut _19: usize;
    let _21: !;
    let mut _22: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: usize;
    let mut _26: &std::collections::BinaryHeap<()>;
    let mut _27: usize;
    let mut _28: !;
    let mut _29: std::ops::Range<usize>;
    let mut _30: std::ops::Range<usize>;
    let mut _31: usize;
    let mut _33: std::option::Option<usize>;
    let mut _34: &mut std::ops::Range<usize>;
    let mut _35: isize;
    let _37: ();
    let mut _38: &mut std::collections::BinaryHeap<()>;
    let mut _39: (&usize, &usize);
    let mut _40: &usize;
    let _41: usize;
    let mut _42: &std::collections::BinaryHeap<()>;
    let mut _43: &usize;
    let mut _46: bool;
    let mut _47: bool;
    let mut _48: usize;
    let mut _49: usize;
    let _51: !;
    let mut _52: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _53: (&usize, &usize);
    let mut _54: &usize;
    let _55: usize;
    let mut _56: std::collections::binary_heap::Iter<'_, ()>;
    let mut _57: &std::collections::BinaryHeap<()>;
    let mut _58: &usize;
    let mut _61: bool;
    let mut _62: bool;
    let mut _63: usize;
    let mut _64: usize;
    let _66: !;
    let mut _67: std::option::Option<std::fmt::Arguments<'_>>;
    let _68: ();
    let mut _69: &mut std::collections::BinaryHeap<()>;
    scope 1 {
        debug iter => _3;
        let _7: usize;
        scope 2 {
            debug len => _7;
            let mut _8: std::collections::BinaryHeap<()>;
            scope 3 {
                debug tester => _8;
                let _14: &usize;
                let _15: &usize;
                let mut _32: std::ops::Range<usize>;
                let _44: &usize;
                let _45: &usize;
                let _59: &usize;
                let _60: &usize;
                let mut _70: &usize;
                scope 4 {
                    debug left_val => _14;
                    debug right_val => _15;
                    let _20: core::panicking::AssertKind;
                    scope 5 {
                        debug kind => _20;
                    }
                }
                scope 6 {
                    debug iter => _32;
                    let _36: usize;
                    scope 7 {
                        debug bit => _36;
                    }
                }
                scope 8 {
                    debug left_val => _44;
                    debug right_val => _45;
                    let _50: core::panicking::AssertKind;
                    scope 9 {
                        debug kind => _50;
                    }
                }
                scope 10 {
                    debug left_val => _59;
                    debug right_val => _60;
                    let _65: core::panicking::AssertKind;
                    scope 11 {
                        debug kind => _65;
                    }
                }
            }
        }
    }

    bb0: {
        _2 = std::ops::Range::<usize> { start: const 0_usize, end: const _ };
        _1 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = move _1;
        goto -> bb2;
    }

    bb2: {
        _5 = &mut _3;
        _4 = <std::ops::Range<usize> as Iterator>::next(_5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _7 = ((_4 as Some).0: usize);
        _9 = _7;
        _8 = BinaryHeap::<()>::with_capacity(move _9) -> [return: bb7, unwind continue];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        return;
    }

    bb7: {
        _13 = &_8;
        _12 = BinaryHeap::<()>::len(move _13) -> [return: bb8, unwind: bb27];
    }

    bb8: {
        _11 = &_12;
        _70 = const _;
        _10 = (move _11, _70);
        _14 = (_10.0: &usize);
        _15 = (_10.1: &usize);
        _18 = (*_14);
        _19 = (*_15);
        _17 = Eq(move _18, move _19);
        _16 = Not(move _17);
        switchInt(move _16) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _20 = core::panicking::AssertKind::Eq;
        _22 = Option::<Arguments<'_>>::None;
        _21 = core::panicking::assert_failed::<usize, usize>(move _20, _14, _15, move _22) -> bb27;
    }

    bb10: {
        _26 = &_8;
        _25 = BinaryHeap::<()>::capacity(move _26) -> [return: bb11, unwind: bb27];
    }

    bb11: {
        _27 = _7;
        _24 = Ge(move _25, move _27);
        _23 = Not(move _24);
        switchInt(move _23) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _28 = core::panicking::panic(const "assertion failed: tester.capacity() >= len") -> bb27;
    }

    bb13: {
        _31 = _7;
        _30 = std::ops::Range::<usize> { start: const 0_usize, end: move _31 };
        _29 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _30) -> [return: bb14, unwind: bb27];
    }

    bb14: {
        _32 = move _29;
        goto -> bb15;
    }

    bb15: {
        _34 = &mut _32;
        _33 = <std::ops::Range<usize> as Iterator>::next(_34) -> [return: bb16, unwind: bb27];
    }

    bb16: {
        _35 = discriminant(_33);
        switchInt(move _35) -> [0: bb18, 1: bb17, otherwise: bb5];
    }

    bb17: {
        _36 = ((_33 as Some).0: usize);
        _38 = &mut _8;
        _37 = BinaryHeap::<()>::push(move _38, const ()) -> [return: bb29, unwind: bb27];
    }

    bb18: {
        _42 = &_8;
        _41 = BinaryHeap::<()>::len(move _42) -> [return: bb19, unwind: bb27];
    }

    bb19: {
        _40 = &_41;
        _43 = &_7;
        _39 = (move _40, move _43);
        _44 = (_39.0: &usize);
        _45 = (_39.1: &usize);
        _48 = (*_44);
        _49 = (*_45);
        _47 = Eq(move _48, move _49);
        _46 = Not(move _47);
        switchInt(move _46) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _50 = core::panicking::AssertKind::Eq;
        _52 = Option::<Arguments<'_>>::None;
        _51 = core::panicking::assert_failed::<usize, usize>(move _50, _44, _45, move _52) -> bb27;
    }

    bb21: {
        _57 = &_8;
        _56 = BinaryHeap::<()>::iter(move _57) -> [return: bb22, unwind: bb27];
    }

    bb22: {
        _55 = <std::collections::binary_heap::Iter<'_, ()> as Iterator>::count(move _56) -> [return: bb23, unwind: bb27];
    }

    bb23: {
        _54 = &_55;
        _58 = &_7;
        _53 = (move _54, move _58);
        _59 = (_53.0: &usize);
        _60 = (_53.1: &usize);
        _63 = (*_59);
        _64 = (*_60);
        _62 = Eq(move _63, move _64);
        _61 = Not(move _62);
        switchInt(move _61) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _65 = core::panicking::AssertKind::Eq;
        _67 = Option::<Arguments<'_>>::None;
        _66 = core::panicking::assert_failed::<usize, usize>(move _65, _59, _60, move _67) -> bb27;
    }

    bb25: {
        _69 = &mut _8;
        _68 = BinaryHeap::<()>::clear(move _69) -> [return: bb26, unwind: bb27];
    }

    bb26: {
        drop(_8) -> [return: bb2, unwind continue];
    }

    bb27 (cleanup): {
        drop(_8) -> [return: bb28, unwind terminate];
    }

    bb28 (cleanup): {
        resume;
    }

    bb29: {
        goto -> bb15;
    }
}

promoted[0] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 0_usize;
        _0 = &_1;
        return;
    }
}

const N: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 8_usize;
        return;
    }
}
