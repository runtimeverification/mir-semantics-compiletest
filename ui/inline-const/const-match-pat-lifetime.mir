// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn issue_78174() -> () {
    let mut _0: ();
    let mut _1: &str;
    let mut _2: bool;
    let mut _3: !;

    bb0: {
        _1 = const "foo";
        _2 = <str as PartialEq>::eq(_1, const "foo") -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb2, otherwise: bb3];
    }

    bb2: {
        _3 = core::panicking::panic(const "internal error: entered unreachable code") -> unwind continue;
    }

    bb3: {
        return;
    }
}

issue_78174::{constant#0}: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "foo";
        return;
    }
}

fn <impl at ui/inline-const/const-match-pat-lifetime.rs:18:10: 18:19>::eq(_1: &InvariantRef<'_, T>, _2: &InvariantRef<'_, T>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &&T;
    let mut _5: &&T;
    let mut _6: bool;
    let mut _7: &std::marker::PhantomData<&mut &T>;
    let mut _8: &std::marker::PhantomData<&mut &T>;

    bb0: {
        _4 = &((*_1).0: &T);
        _5 = &((*_2).0: &T);
        _3 = <&T as PartialEq>::eq(move _4, move _5) -> [return: bb4, unwind continue];
    }

    bb1: {
        _0 = const false;
        goto -> bb3;
    }

    bb2: {
        _7 = &((*_1).1: std::marker::PhantomData<&mut &T>);
        _8 = &((*_2).1: std::marker::PhantomData<&mut &T>);
        _6 = <PhantomData<&mut &T> as PartialEq>::eq(move _7, move _8) -> [return: bb5, unwind continue];
    }

    bb3: {
        return;
    }

    bb4: {
        switchInt(move _3) -> [0: bb1, otherwise: bb2];
    }

    bb5: {
        _0 = move _6;
        goto -> bb3;
    }
}

fn <impl at ui/inline-const/const-match-pat-lifetime.rs:18:21: 18:23>::assert_receiver_is_total_eq(_1: &InvariantRef<'_, T>) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        return;
    }
}

fn <impl at ui/inline-const/const-match-pat-lifetime.rs:21:1: 21:40>::new(_1: &T) -> InvariantRef<'_, T> {
    debug r => _1;
    let mut _0: InvariantRef<'_, T>;

    bb0: {
        _0 = InvariantRef::<'_, T>(_1, const ZeroSized: PhantomData<&mut &T>);
        return;
    }
}

// MIR FOR CTFE
fn <impl at ui/inline-const/const-match-pat-lifetime.rs:21:1: 21:40>::new(_1: &T) -> InvariantRef<'_, T> {
    debug r => _1;
    let mut _0: InvariantRef<'_, T>;
    let mut _2: &T;
    let mut _3: std::marker::PhantomData<&mut &T>;

    bb0: {
        StorageLive(_2);
        _2 = &(*_1);
        StorageLive(_3);
        _3 = PhantomData::<&mut &T>;
        _0 = InvariantRef::<'_, T>(move _2, move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn match_invariant_ref() -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}

match_invariant_ref::{constant#0}: InvariantRef<'_, ()> = {
    let mut _0: InvariantRef<'_, ()>;
    let mut _1: &();
    let _2: &();
    let _3: ();
    let mut _4: &();

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _4 = const _;
        _2 = &(*_4);
        _1 = &(*_2);
        ConstEvalCounter;
        _0 = InvariantRef::<'_, ()>::new(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        StorageDead(_1);
        StorageDead(_2);
        return;
    }
}

promoted[0] in match_invariant_ref::{constant#0}: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = ();
        _0 = &_1;
        return;
    }
}

match_invariant_ref::{constant#1}: InvariantRef<'_, ()> = {
    let mut _0: InvariantRef<'_, ()>;
    let mut _1: &();
    let _2: &();
    let _3: ();
    let mut _4: &();

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _4 = const _;
        _2 = &(*_4);
        _1 = &(*_2);
        ConstEvalCounter;
        _0 = InvariantRef::<'_, ()>::new(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        StorageDead(_1);
        StorageDead(_2);
        return;
    }
}

promoted[0] in match_invariant_ref::{constant#1}: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = ();
        _0 = &_1;
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: ();
    let _2: ();

    bb0: {
        _1 = issue_78174() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = match_invariant_ref() -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn InvariantRef(_1: &T, _2: PhantomData<&mut &T>) -> InvariantRef<'_, T> {
    let mut _0: InvariantRef<'_, T>;

    bb0: {
        _0 = InvariantRef::<'_, T>(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn InvariantRef(_1: &T, _2: PhantomData<&mut &T>) -> InvariantRef<'_, T> {
    let mut _0: InvariantRef<'_, T>;

    bb0: {
        _0 = InvariantRef::<'_, T>(move _1, move _2);
        return;
    }
}
