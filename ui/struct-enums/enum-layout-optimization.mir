// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/struct-enums/enum-layout-optimization.rs:39:11: 39:11
    let mut _1: bool;                    // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:40:5: 40:80
    let mut _2: bool;                    // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:40:13: 40:79
    let mut _3: usize;                   // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:40:13: 40:39
    let mut _4: usize;                   // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:40:43: 40:79
    let mut _5: !;                       // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:40:5: 40:80
    let mut _6: bool;                    // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:41:5: 41:81
    let mut _7: bool;                    // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:41:13: 41:80
    let mut _8: usize;                   // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:41:13: 41:39
    let mut _9: usize;                   // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:41:42: 41:80
    let mut _10: !;                      // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:41:5: 41:81
    let mut _11: bool;                   // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:42:5: 42:80
    let mut _12: bool;                   // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:42:13: 42:79
    let mut _13: usize;                  // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:42:13: 42:39
    let mut _14: usize;                  // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:42:42: 42:79
    let mut _15: !;                      // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:42:5: 42:80
    let mut _16: bool;                   // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:44:5: 44:75
    let mut _17: bool;                   // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:44:13: 44:74
    let mut _18: usize;                  // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:44:13: 44:34
    let mut _19: usize;                  // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:44:38: 44:74
    let mut _20: !;                      // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:44:5: 44:75
    let mut _21: bool;                   // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:45:5: 45:76
    let mut _22: bool;                   // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:45:13: 45:75
    let mut _23: usize;                  // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:45:13: 45:34
    let mut _24: usize;                  // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:45:38: 45:75
    let mut _25: !;                      // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:45:5: 45:76
    let mut _26: bool;                   // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:47:5: 47:73
    let mut _27: bool;                   // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:47:13: 47:72
    let mut _28: usize;                  // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:47:13: 47:34
    let mut _29: usize;                  // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:47:38: 47:72
    let mut _30: !;                      // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:47:5: 47:73
    let mut _31: bool;                   // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:48:5: 48:74
    let mut _32: bool;                   // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:48:13: 48:73
    let mut _33: usize;                  // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:48:13: 48:34
    let mut _34: usize;                  // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:48:37: 48:73
    let mut _35: !;                      // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:48:5: 48:74
    let mut _36: bool;                   // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:49:5: 49:73
    let mut _37: bool;                   // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:49:13: 49:72
    let mut _38: usize;                  // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:49:13: 49:34
    let mut _39: usize;                  // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:49:37: 49:72
    let mut _40: !;                      // in scope 0 at ui/struct-enums/enum-layout-optimization.rs:49:5: 49:73

    bb0: {
        _3 = std::mem::size_of::<Box<i32>>() -> bb1; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:40:13: 40:39
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:40:13: 40:37
                                         // + literal: Const { ty: fn() -> usize {std::mem::size_of::<Box<i32>>}, val: Value(<ZST>) }
    }

    bb1: {
        _4 = std::mem::size_of::<Nullable<Box<i32>>>() -> bb2; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:40:43: 40:79
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:40:43: 40:77
                                         // + literal: Const { ty: fn() -> usize {std::mem::size_of::<Nullable<Box<i32>>>}, val: Value(<ZST>) }
    }

    bb2: {
        _2 = Eq(move _3, move _4);       // scope 0 at ui/struct-enums/enum-layout-optimization.rs:40:13: 40:79
        _1 = Not(move _2);               // scope 0 at ui/struct-enums/enum-layout-optimization.rs:40:5: 40:80
        switchInt(move _1) -> [0: bb4, otherwise: bb3]; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:40:5: 40:80
    }

    bb3: {
        _5 = core::panicking::panic(const "assertion failed: mem::size_of::<Box<i32>>() == mem::size_of::<Nullable<Box<i32>>>()"); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:40:5: 40:80
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:40:5: 40:80
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(<ZST>) }
                                         // mir::Constant
                                         // + span: no-location
                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }
    }

    bb4: {
        _8 = std::mem::size_of::<Box<i32>>() -> bb5; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:41:13: 41:39
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:41:13: 41:37
                                         // + literal: Const { ty: fn() -> usize {std::mem::size_of::<Box<i32>>}, val: Value(<ZST>) }
    }

    bb5: {
        _9 = std::mem::size_of::<NullableU8<Box<i32>>>() -> bb6; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:41:42: 41:80
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:41:42: 41:78
                                         // + literal: Const { ty: fn() -> usize {std::mem::size_of::<NullableU8<Box<i32>>>}, val: Value(<ZST>) }
    }

    bb6: {
        _7 = Lt(move _8, move _9);       // scope 0 at ui/struct-enums/enum-layout-optimization.rs:41:13: 41:80
        _6 = Not(move _7);               // scope 0 at ui/struct-enums/enum-layout-optimization.rs:41:5: 41:81
        switchInt(move _6) -> [0: bb8, otherwise: bb7]; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:41:5: 41:81
    }

    bb7: {
        _10 = core::panicking::panic(const "assertion failed: mem::size_of::<Box<i32>>() < mem::size_of::<NullableU8<Box<i32>>>()"); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:41:5: 41:81
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:41:5: 41:81
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(<ZST>) }
                                         // mir::Constant
                                         // + span: no-location
                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }
    }

    bb8: {
        _13 = std::mem::size_of::<Box<i32>>() -> bb9; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:42:13: 42:39
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:42:13: 42:37
                                         // + literal: Const { ty: fn() -> usize {std::mem::size_of::<Box<i32>>}, val: Value(<ZST>) }
    }

    bb9: {
        _14 = std::mem::size_of::<NullableC<Box<i32>>>() -> bb10; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:42:42: 42:79
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:42:42: 42:77
                                         // + literal: Const { ty: fn() -> usize {std::mem::size_of::<NullableC<Box<i32>>>}, val: Value(<ZST>) }
    }

    bb10: {
        _12 = Lt(move _13, move _14);    // scope 0 at ui/struct-enums/enum-layout-optimization.rs:42:13: 42:79
        _11 = Not(move _12);             // scope 0 at ui/struct-enums/enum-layout-optimization.rs:42:5: 42:80
        switchInt(move _11) -> [0: bb12, otherwise: bb11]; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:42:5: 42:80
    }

    bb11: {
        _15 = core::panicking::panic(const "assertion failed: mem::size_of::<Box<i32>>() < mem::size_of::<NullableC<Box<i32>>>()"); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:42:5: 42:80
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:42:5: 42:80
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(<ZST>) }
                                         // mir::Constant
                                         // + span: no-location
                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }
    }

    bb12: {
        _18 = std::mem::size_of::<i32>() -> bb13; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:44:13: 44:34
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:44:13: 44:32
                                         // + literal: Const { ty: fn() -> usize {std::mem::size_of::<i32>}, val: Value(<ZST>) }
    }

    bb13: {
        _19 = std::mem::size_of::<StructNewtype<i32>>() -> bb14; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:44:38: 44:74
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:44:38: 44:72
                                         // + literal: Const { ty: fn() -> usize {std::mem::size_of::<StructNewtype<i32>>}, val: Value(<ZST>) }
    }

    bb14: {
        _17 = Eq(move _18, move _19);    // scope 0 at ui/struct-enums/enum-layout-optimization.rs:44:13: 44:74
        _16 = Not(move _17);             // scope 0 at ui/struct-enums/enum-layout-optimization.rs:44:5: 44:75
        switchInt(move _16) -> [0: bb16, otherwise: bb15]; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:44:5: 44:75
    }

    bb15: {
        _20 = core::panicking::panic(const "assertion failed: mem::size_of::<i32>() == mem::size_of::<StructNewtype<i32>>()"); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:44:5: 44:75
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:44:5: 44:75
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(<ZST>) }
                                         // mir::Constant
                                         // + span: no-location
                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }
    }

    bb16: {
        _23 = std::mem::size_of::<i32>() -> bb17; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:45:13: 45:34
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:45:13: 45:32
                                         // + literal: Const { ty: fn() -> usize {std::mem::size_of::<i32>}, val: Value(<ZST>) }
    }

    bb17: {
        _24 = std::mem::size_of::<StructNewtypeC<i32>>() -> bb18; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:45:38: 45:75
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:45:38: 45:73
                                         // + literal: Const { ty: fn() -> usize {std::mem::size_of::<StructNewtypeC<i32>>}, val: Value(<ZST>) }
    }

    bb18: {
        _22 = Eq(move _23, move _24);    // scope 0 at ui/struct-enums/enum-layout-optimization.rs:45:13: 45:75
        _21 = Not(move _22);             // scope 0 at ui/struct-enums/enum-layout-optimization.rs:45:5: 45:76
        switchInt(move _21) -> [0: bb20, otherwise: bb19]; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:45:5: 45:76
    }

    bb19: {
        _25 = core::panicking::panic(const "assertion failed: mem::size_of::<i32>() == mem::size_of::<StructNewtypeC<i32>>()"); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:45:5: 45:76
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:45:5: 45:76
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(<ZST>) }
                                         // mir::Constant
                                         // + span: no-location
                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }
    }

    bb20: {
        _28 = std::mem::size_of::<i32>() -> bb21; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:47:13: 47:34
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:47:13: 47:32
                                         // + literal: Const { ty: fn() -> usize {std::mem::size_of::<i32>}, val: Value(<ZST>) }
    }

    bb21: {
        _29 = std::mem::size_of::<EnumNewtype<i32>>() -> bb22; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:47:38: 47:72
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:47:38: 47:70
                                         // + literal: Const { ty: fn() -> usize {std::mem::size_of::<EnumNewtype<i32>>}, val: Value(<ZST>) }
    }

    bb22: {
        _27 = Eq(move _28, move _29);    // scope 0 at ui/struct-enums/enum-layout-optimization.rs:47:13: 47:72
        _26 = Not(move _27);             // scope 0 at ui/struct-enums/enum-layout-optimization.rs:47:5: 47:73
        switchInt(move _26) -> [0: bb24, otherwise: bb23]; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:47:5: 47:73
    }

    bb23: {
        _30 = core::panicking::panic(const "assertion failed: mem::size_of::<i32>() == mem::size_of::<EnumNewtype<i32>>()"); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:47:5: 47:73
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:47:5: 47:73
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(<ZST>) }
                                         // mir::Constant
                                         // + span: no-location
                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }
    }

    bb24: {
        _33 = std::mem::size_of::<i32>() -> bb25; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:48:13: 48:34
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:48:13: 48:32
                                         // + literal: Const { ty: fn() -> usize {std::mem::size_of::<i32>}, val: Value(<ZST>) }
    }

    bb25: {
        _34 = std::mem::size_of::<EnumNewtypeU8<i32>>() -> bb26; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:48:37: 48:73
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:48:37: 48:71
                                         // + literal: Const { ty: fn() -> usize {std::mem::size_of::<EnumNewtypeU8<i32>>}, val: Value(<ZST>) }
    }

    bb26: {
        _32 = Lt(move _33, move _34);    // scope 0 at ui/struct-enums/enum-layout-optimization.rs:48:13: 48:73
        _31 = Not(move _32);             // scope 0 at ui/struct-enums/enum-layout-optimization.rs:48:5: 48:74
        switchInt(move _31) -> [0: bb28, otherwise: bb27]; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:48:5: 48:74
    }

    bb27: {
        _35 = core::panicking::panic(const "assertion failed: mem::size_of::<i32>() < mem::size_of::<EnumNewtypeU8<i32>>()"); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:48:5: 48:74
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:48:5: 48:74
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(<ZST>) }
                                         // mir::Constant
                                         // + span: no-location
                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }
    }

    bb28: {
        _38 = std::mem::size_of::<i32>() -> bb29; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:49:13: 49:34
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:49:13: 49:32
                                         // + literal: Const { ty: fn() -> usize {std::mem::size_of::<i32>}, val: Value(<ZST>) }
    }

    bb29: {
        _39 = std::mem::size_of::<EnumNewtypeC<i32>>() -> bb30; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:49:37: 49:72
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:49:37: 49:70
                                         // + literal: Const { ty: fn() -> usize {std::mem::size_of::<EnumNewtypeC<i32>>}, val: Value(<ZST>) }
    }

    bb30: {
        _37 = Lt(move _38, move _39);    // scope 0 at ui/struct-enums/enum-layout-optimization.rs:49:13: 49:72
        _36 = Not(move _37);             // scope 0 at ui/struct-enums/enum-layout-optimization.rs:49:5: 49:73
        switchInt(move _36) -> [0: bb32, otherwise: bb31]; // scope 0 at ui/struct-enums/enum-layout-optimization.rs:49:5: 49:73
    }

    bb31: {
        _40 = core::panicking::panic(const "assertion failed: mem::size_of::<i32>() < mem::size_of::<EnumNewtypeC<i32>>()"); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:49:5: 49:73
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-layout-optimization.rs:49:5: 49:73
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(<ZST>) }
                                         // mir::Constant
                                         // + span: no-location
                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }
    }

    bb32: {
        return;                          // scope 0 at ui/struct-enums/enum-layout-optimization.rs:50:2: 50:2
    }
}

fn Nullable::Alive(_1: T) -> Nullable<T> {
    let mut _0: Nullable<T>;             // return place in scope 0 at ui/struct-enums/enum-layout-optimization.rs:10:5: 10:10

    bb0: {
        _0 = Nullable::<T>::Alive(move _1); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:10:5: 10:10
        return;                          // scope 0 at ui/struct-enums/enum-layout-optimization.rs:10:5: 10:10
    }
}

// MIR FOR CTFE
fn Nullable::Alive(_1: T) -> Nullable<T> {
    let mut _0: Nullable<T>;             // return place in scope 0 at ui/struct-enums/enum-layout-optimization.rs:10:5: 10:10

    bb0: {
        _0 = Nullable::<T>::Alive(move _1); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:10:5: 10:10
        return;                          // scope 0 at ui/struct-enums/enum-layout-optimization.rs:10:5: 10:10
    }
}

fn NullableU8::Alive(_1: T) -> NullableU8<T> {
    let mut _0: NullableU8<T>;           // return place in scope 0 at ui/struct-enums/enum-layout-optimization.rs:16:5: 16:10

    bb0: {
        _0 = NullableU8::<T>::Alive(move _1); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:16:5: 16:10
        return;                          // scope 0 at ui/struct-enums/enum-layout-optimization.rs:16:5: 16:10
    }
}

// MIR FOR CTFE
fn NullableU8::Alive(_1: T) -> NullableU8<T> {
    let mut _0: NullableU8<T>;           // return place in scope 0 at ui/struct-enums/enum-layout-optimization.rs:16:5: 16:10

    bb0: {
        _0 = NullableU8::<T>::Alive(move _1); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:16:5: 16:10
        return;                          // scope 0 at ui/struct-enums/enum-layout-optimization.rs:16:5: 16:10
    }
}

fn NullableC::Alive(_1: T) -> NullableC<T> {
    let mut _0: NullableC<T>;            // return place in scope 0 at ui/struct-enums/enum-layout-optimization.rs:22:5: 22:10

    bb0: {
        _0 = NullableC::<T>::Alive(move _1); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:22:5: 22:10
        return;                          // scope 0 at ui/struct-enums/enum-layout-optimization.rs:22:5: 22:10
    }
}

// MIR FOR CTFE
fn NullableC::Alive(_1: T) -> NullableC<T> {
    let mut _0: NullableC<T>;            // return place in scope 0 at ui/struct-enums/enum-layout-optimization.rs:22:5: 22:10

    bb0: {
        _0 = NullableC::<T>::Alive(move _1); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:22:5: 22:10
        return;                          // scope 0 at ui/struct-enums/enum-layout-optimization.rs:22:5: 22:10
    }
}

fn StructNewtype(_1: T) -> StructNewtype<T> {
    let mut _0: StructNewtype<T>;        // return place in scope 0 at ui/struct-enums/enum-layout-optimization.rs:26:1: 26:24

    bb0: {
        _0 = StructNewtype::<T>(move _1); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:26:1: 26:24
        return;                          // scope 0 at ui/struct-enums/enum-layout-optimization.rs:26:1: 26:24
    }
}

// MIR FOR CTFE
fn StructNewtype(_1: T) -> StructNewtype<T> {
    let mut _0: StructNewtype<T>;        // return place in scope 0 at ui/struct-enums/enum-layout-optimization.rs:26:1: 26:24

    bb0: {
        _0 = StructNewtype::<T>(move _1); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:26:1: 26:24
        return;                          // scope 0 at ui/struct-enums/enum-layout-optimization.rs:26:1: 26:24
    }
}

fn StructNewtypeC(_1: T) -> StructNewtypeC<T> {
    let mut _0: StructNewtypeC<T>;       // return place in scope 0 at ui/struct-enums/enum-layout-optimization.rs:29:1: 29:25

    bb0: {
        _0 = StructNewtypeC::<T>(move _1); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:29:1: 29:25
        return;                          // scope 0 at ui/struct-enums/enum-layout-optimization.rs:29:1: 29:25
    }
}

// MIR FOR CTFE
fn StructNewtypeC(_1: T) -> StructNewtypeC<T> {
    let mut _0: StructNewtypeC<T>;       // return place in scope 0 at ui/struct-enums/enum-layout-optimization.rs:29:1: 29:25

    bb0: {
        _0 = StructNewtypeC::<T>(move _1); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:29:1: 29:25
        return;                          // scope 0 at ui/struct-enums/enum-layout-optimization.rs:29:1: 29:25
    }
}

fn EnumNewtype::Variant(_1: T) -> EnumNewtype<T> {
    let mut _0: EnumNewtype<T>;          // return place in scope 0 at ui/struct-enums/enum-layout-optimization.rs:31:23: 31:30

    bb0: {
        _0 = EnumNewtype::<T>::Variant(move _1); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:31:23: 31:30
        return;                          // scope 0 at ui/struct-enums/enum-layout-optimization.rs:31:23: 31:30
    }
}

// MIR FOR CTFE
fn EnumNewtype::Variant(_1: T) -> EnumNewtype<T> {
    let mut _0: EnumNewtype<T>;          // return place in scope 0 at ui/struct-enums/enum-layout-optimization.rs:31:23: 31:30

    bb0: {
        _0 = EnumNewtype::<T>::Variant(move _1); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:31:23: 31:30
        return;                          // scope 0 at ui/struct-enums/enum-layout-optimization.rs:31:23: 31:30
    }
}

fn EnumNewtypeU8::Variant(_1: T) -> EnumNewtypeU8<T> {
    let mut _0: EnumNewtypeU8<T>;        // return place in scope 0 at ui/struct-enums/enum-layout-optimization.rs:34:25: 34:32

    bb0: {
        _0 = EnumNewtypeU8::<T>::Variant(move _1); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:34:25: 34:32
        return;                          // scope 0 at ui/struct-enums/enum-layout-optimization.rs:34:25: 34:32
    }
}

// MIR FOR CTFE
fn EnumNewtypeU8::Variant(_1: T) -> EnumNewtypeU8<T> {
    let mut _0: EnumNewtypeU8<T>;        // return place in scope 0 at ui/struct-enums/enum-layout-optimization.rs:34:25: 34:32

    bb0: {
        _0 = EnumNewtypeU8::<T>::Variant(move _1); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:34:25: 34:32
        return;                          // scope 0 at ui/struct-enums/enum-layout-optimization.rs:34:25: 34:32
    }
}

fn EnumNewtypeC::Variant(_1: T) -> EnumNewtypeC<T> {
    let mut _0: EnumNewtypeC<T>;         // return place in scope 0 at ui/struct-enums/enum-layout-optimization.rs:37:24: 37:31

    bb0: {
        _0 = EnumNewtypeC::<T>::Variant(move _1); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:37:24: 37:31
        return;                          // scope 0 at ui/struct-enums/enum-layout-optimization.rs:37:24: 37:31
    }
}

// MIR FOR CTFE
fn EnumNewtypeC::Variant(_1: T) -> EnumNewtypeC<T> {
    let mut _0: EnumNewtypeC<T>;         // return place in scope 0 at ui/struct-enums/enum-layout-optimization.rs:37:24: 37:31

    bb0: {
        _0 = EnumNewtypeC::<T>::Variant(move _1); // scope 0 at ui/struct-enums/enum-layout-optimization.rs:37:24: 37:31
        return;                          // scope 0 at ui/struct-enums/enum-layout-optimization.rs:37:24: 37:31
    }
}
