// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn addr_of(_1: &T) -> usize {
    debug ptr => _1;                     // in scope 0 at ui/struct-enums/enum-alignment.rs:7:15: 7:18
    let mut _0: usize;                   // return place in scope 0 at ui/struct-enums/enum-alignment.rs:7:27: 7:32
    let mut _2: *const T;                // in scope 0 at ui/struct-enums/enum-alignment.rs:8:5: 8:20

    bb0: {
        _2 = &raw const (*_1);           // scope 0 at ui/struct-enums/enum-alignment.rs:8:5: 8:8
        _0 = move _2 as usize (PointerExposeAddress); // scope 0 at ui/struct-enums/enum-alignment.rs:8:5: 8:29
        return;                          // scope 0 at ui/struct-enums/enum-alignment.rs:9:2: 9:2
    }
}

fn is_aligned(_1: &T) -> bool {
    debug ptr => _1;                     // in scope 0 at ui/struct-enums/enum-alignment.rs:11:18: 11:21
    let mut _0: bool;                    // return place in scope 0 at ui/struct-enums/enum-alignment.rs:11:30: 11:34
    let mut _3: &T;                      // in scope 0 at ui/struct-enums/enum-alignment.rs:13:42: 13:45
    let mut _4: usize;                   // in scope 0 at ui/struct-enums/enum-alignment.rs:14:9: 14:42
    let mut _5: usize;                   // in scope 0 at ui/struct-enums/enum-alignment.rs:14:10: 14:14
    let mut _6: usize;                   // in scope 0 at ui/struct-enums/enum-alignment.rs:14:17: 14:41
    let mut _7: bool;                    // in scope 0 at ui/struct-enums/enum-alignment.rs:14:9: 14:42
    scope 1 {
        let _2: usize;                   // in scope 1 at ui/struct-enums/enum-alignment.rs:13:13: 13:17
        scope 2 {
            debug addr => _2;            // in scope 2 at ui/struct-enums/enum-alignment.rs:13:13: 13:17
        }
    }

    bb0: {
        _3 = _1;                         // scope 1 at ui/struct-enums/enum-alignment.rs:13:42: 13:45
        _2 = transmute::<&T, usize>(move _3) -> bb1; // scope 1 at ui/struct-enums/enum-alignment.rs:13:27: 13:46
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-alignment.rs:13:27: 13:41
                                         // + literal: Const { ty: unsafe extern "rust-intrinsic" fn(&T) -> usize {transmute::<&T, usize>}, val: Value(<ZST>) }
    }

    bb1: {
        _5 = _2;                         // scope 2 at ui/struct-enums/enum-alignment.rs:14:10: 14:14
        _6 = std::mem::min_align_of::<T>() -> bb2; // scope 2 at ui/struct-enums/enum-alignment.rs:14:17: 14:41
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-alignment.rs:14:17: 14:39
                                         // + literal: Const { ty: fn() -> usize {std::mem::min_align_of::<T>}, val: Value(<ZST>) }
    }

    bb2: {
        _7 = Eq(_6, const 0_usize);      // scope 2 at ui/struct-enums/enum-alignment.rs:14:9: 14:42
        assert(!move _7, "attempt to calculate the remainder of `{}` with a divisor of zero", _5) -> bb3; // scope 2 at ui/struct-enums/enum-alignment.rs:14:9: 14:42
    }

    bb3: {
        _4 = Rem(move _5, move _6);      // scope 2 at ui/struct-enums/enum-alignment.rs:14:9: 14:42
        _0 = Eq(move _4, const 0_usize); // scope 2 at ui/struct-enums/enum-alignment.rs:14:9: 14:47
        return;                          // scope 0 at ui/struct-enums/enum-alignment.rs:16:2: 16:2
    }
}

fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/struct-enums/enum-alignment.rs:18:15: 18:15
    let _1: std::option::Option<u64>;    // in scope 0 at ui/struct-enums/enum-alignment.rs:19:9: 19:10
    let mut _3: bool;                    // in scope 0 at ui/struct-enums/enum-alignment.rs:22:24: 22:46
    let mut _4: bool;                    // in scope 0 at ui/struct-enums/enum-alignment.rs:22:32: 22:45
    let mut _5: &u64;                    // in scope 0 at ui/struct-enums/enum-alignment.rs:22:43: 22:44
    let mut _6: !;                       // in scope 0 at ui/struct-enums/enum-alignment.rs:22:24: 22:46
    scope 1 {
        debug x => _1;                   // in scope 1 at ui/struct-enums/enum-alignment.rs:19:9: 19:10
        let _2: &u64;                    // in scope 1 at ui/struct-enums/enum-alignment.rs:22:14: 22:19
        scope 2 {
            debug y => _2;               // in scope 2 at ui/struct-enums/enum-alignment.rs:22:14: 22:19
        }
    }

    bb0: {
        _1 = Option::<u64>::Some(const 0_u64); // scope 0 at ui/struct-enums/enum-alignment.rs:19:13: 19:23
        _2 = &((_1 as Some).0: u64);     // scope 1 at ui/struct-enums/enum-alignment.rs:22:14: 22:19
        _5 = _2;                         // scope 2 at ui/struct-enums/enum-alignment.rs:22:43: 22:44
        _4 = is_aligned::<u64>(move _5) -> bb1; // scope 2 at ui/struct-enums/enum-alignment.rs:22:32: 22:45
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-alignment.rs:22:32: 22:42
                                         // + literal: Const { ty: for<'a> fn(&'a u64) -> bool {is_aligned::<u64>}, val: Value(<ZST>) }
    }

    bb1: {
        _3 = Not(move _4);               // scope 2 at ui/struct-enums/enum-alignment.rs:22:24: 22:46
        switchInt(move _3) -> [0: bb3, otherwise: bb2]; // scope 2 at ui/struct-enums/enum-alignment.rs:22:24: 22:46
    }

    bb2: {
        _6 = core::panicking::panic(const "assertion failed: is_aligned(y)"); // scope 2 at ui/struct-enums/enum-alignment.rs:22:24: 22:46
                                         // mir::Constant
                                         // + span: ui/struct-enums/enum-alignment.rs:22:24: 22:46
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(<ZST>) }
                                         // mir::Constant
                                         // + span: no-location
                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }
    }

    bb3: {
        return;                          // scope 0 at ui/struct-enums/enum-alignment.rs:24:2: 24:2
    }
}
