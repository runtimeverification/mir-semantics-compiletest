// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/let-else/let-else-deref-coercion-annotated.rs:18:1: 18:19>::deref(_1: &Foo) -> &Bar {
    debug self => _1;
    let mut _0: &Bar;

    bb0: {
        _0 = &((*_1).0: Bar);
        return;
    }
}

fn <impl at ui/let-else/let-else-deref-coercion-annotated.rs:24:1: 24:22>::deref_mut(_1: &mut Foo) -> &mut Bar {
    debug self => _1;
    let mut _0: &mut Bar;

    bb0: {
        _0 = &mut ((*_1).0: Bar);
        return;
    }
}

fn <impl at ui/let-else/let-else-deref-coercion-annotated.rs:29:1: 29:9>::bar(_1: &Bar) -> Option<u32> {
    debug self => _1;
    let mut _0: std::option::Option<u32>;
    let _2: &u32;
    let mut _3: isize;
    let mut _4: u32;
    scope 1 {
        debug z => _2;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _2 = &(((*_1) as Present).0: u32);
        _4 = (*_2);
        _0 = Option::<u32>::Some(move _4);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<u32>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn <impl at ui/let-else/let-else-deref-coercion-annotated.rs:37:1: 37:9>::set_bar_annotated(_1: &mut Foo, _2: u32) -> () {
    debug self => _1;
    debug value => _2;
    let mut _0: ();
    let _3: &mut u32;
    let mut _4: &mut Bar;
    let mut _5: &mut Bar;
    let mut _6: isize;
    scope 1 {
        debug z => _3;
    }

    bb0: {
        _5 = <Foo as DerefMut>::deref_mut(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = _5;
        _6 = discriminant((*_4));
        switchInt(move _6) -> [0: bb2, otherwise: bb3];
    }

    bb2: {
        _3 = &mut (((*_4) as Present).0: u32);
        (*_3) = _2;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let mut _1: Foo;
    let mut _2: Bar;
    let _3: ();
    let mut _4: &mut Foo;
    let mut _5: (&std::option::Option<u32>, &std::option::Option<u32>);
    let mut _6: &std::option::Option<u32>;
    let _7: std::option::Option<u32>;
    let mut _8: &Bar;
    let _9: &Bar;
    let mut _10: &Foo;
    let mut _13: bool;
    let mut _14: bool;
    let _16: !;
    let mut _17: std::option::Option<std::fmt::Arguments<'_>>;
    let _18: ();
    scope 1 {
        debug foo => _1;
        let _11: &std::option::Option<u32>;
        let _12: &std::option::Option<u32>;
        let mut _19: &std::option::Option<u32>;
        scope 2 {
            debug left_val => _11;
            debug right_val => _12;
            let _15: core::panicking::AssertKind;
            scope 3 {
                debug kind => _15;
            }
        }
    }

    bb0: {
        _2 = Bar::Present(const 1_u32);
        _1 = Foo(move _2);
        _4 = &mut _1;
        _3 = Foo::set_bar_annotated(move _4, const 42_u32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _10 = &_1;
        _9 = <Foo as Deref>::deref(move _10) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = _9;
        _7 = Bar::bar(move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = &_7;
        _19 = const _;
        _5 = (move _6, _19);
        _11 = (_5.0: &std::option::Option<u32>);
        _12 = (_5.1: &std::option::Option<u32>);
        _14 = <Option<u32> as PartialEq>::eq(_11, _12) -> [return: bb4, unwind continue];
    }

    bb4: {
        _13 = Not(move _14);
        switchInt(move _13) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _15 = core::panicking::AssertKind::Eq;
        _17 = Option::<Arguments<'_>>::None;
        _16 = core::panicking::assert_failed::<Option<u32>, Option<u32>>(move _15, _11, _12, move _17) -> unwind continue;
    }

    bb6: {
        _18 = inner() -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

promoted[0] in main: &Option<u32> = {
    let mut _0: &std::option::Option<u32>;
    let mut _1: std::option::Option<u32>;

    bb0: {
        _1 = Option::<u32>::Some(const 42_u32);
        _0 = &_1;
        return;
    }
}

fn irrefutable::<impl at ui/let-else/let-else-deref-coercion-annotated.rs:58:5: 58:23>::deref(_1: &irrefutable::Foo) -> &irrefutable::Bar {
    debug self => _1;
    let mut _0: &irrefutable::Bar;

    bb0: {
        _0 = &((*_1).0: irrefutable::Bar);
        return;
    }
}

fn irrefutable::<impl at ui/let-else/let-else-deref-coercion-annotated.rs:64:5: 64:26>::deref_mut(_1: &mut irrefutable::Foo) -> &mut irrefutable::Bar {
    debug self => _1;
    let mut _0: &mut irrefutable::Bar;

    bb0: {
        _0 = &mut ((*_1).0: irrefutable::Bar);
        return;
    }
}

fn foo(_1: &mut irrefutable::Foo) -> () {
    debug x => _1;
    let mut _0: ();
    let _2: &mut u32;
    let mut _3: &mut irrefutable::Bar;
    let mut _4: &mut irrefutable::Bar;
    let mut _5: (&u32, &u32);
    let mut _6: &u32;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: u32;
    let mut _12: u32;
    let _14: !;
    let mut _15: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug z => _2;
        let _7: &u32;
        let _8: &u32;
        let mut _16: &u32;
        scope 2 {
            debug left_val => _7;
            debug right_val => _8;
            let _13: core::panicking::AssertKind;
            scope 3 {
                debug kind => _13;
            }
        }
    }

    bb0: {
        _4 = <irrefutable::Foo as DerefMut>::deref_mut(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = _4;
        _2 = &mut ((*_3).0: u32);
        (*_2) = const 42_u32;
        _6 = &(((*_1).0: irrefutable::Bar).0: u32);
        _16 = const _;
        _5 = (move _6, _16);
        _7 = (_5.0: &u32);
        _8 = (_5.1: &u32);
        _11 = (*_7);
        _12 = (*_8);
        _10 = Eq(move _11, move _12);
        _9 = Not(move _10);
        switchInt(move _9) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _13 = core::panicking::AssertKind::Eq;
        _15 = Option::<Arguments<'_>>::None;
        _14 = core::panicking::assert_failed::<u32, u32>(move _13, _7, _8, move _15) -> unwind continue;
    }

    bb3: {
        return;
    }
}

promoted[0] in foo: &u32 = {
    let mut _0: &u32;
    let mut _1: u32;

    bb0: {
        _1 = const 42_u32;
        _0 = &_1;
        return;
    }
}

fn inner() -> () {
    let mut _0: ();
    let _1: ();
    let mut _2: &mut irrefutable::Foo;
    let mut _3: irrefutable::Foo;
    let mut _4: irrefutable::Bar;

    bb0: {
        _4 = irrefutable::Bar(const 1_u32);
        _3 = irrefutable::Foo(move _4);
        _2 = &mut _3;
        _1 = foo(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn Foo(_1: Bar) -> Foo {
    let mut _0: Foo;

    bb0: {
        _0 = Foo(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Foo(_1: Bar) -> Foo {
    let mut _0: Foo;

    bb0: {
        _0 = Foo(move _1);
        return;
    }
}

fn Bar::Present(_1: u32) -> Bar {
    let mut _0: Bar;

    bb0: {
        _0 = Bar::Present(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Bar::Present(_1: u32) -> Bar {
    let mut _0: Bar;

    bb0: {
        _0 = Bar::Present(move _1);
        return;
    }
}

fn irrefutable::Foo(_1: irrefutable::Bar) -> irrefutable::Foo {
    let mut _0: irrefutable::Foo;

    bb0: {
        _0 = irrefutable::Foo(move _1);
        return;
    }
}

// MIR FOR CTFE
fn irrefutable::Foo(_1: irrefutable::Bar) -> irrefutable::Foo {
    let mut _0: irrefutable::Foo;

    bb0: {
        _0 = irrefutable::Foo(move _1);
        return;
    }
}

fn irrefutable::Bar(_1: u32) -> irrefutable::Bar {
    let mut _0: irrefutable::Bar;

    bb0: {
        _0 = irrefutable::Bar(move _1);
        return;
    }
}

// MIR FOR CTFE
fn irrefutable::Bar(_1: u32) -> irrefutable::Bar {
    let mut _0: irrefutable::Bar;

    bb0: {
        _0 = irrefutable::Bar(move _1);
        return;
    }
}
