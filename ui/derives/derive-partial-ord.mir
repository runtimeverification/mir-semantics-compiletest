// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/derives/derive-partial-ord.rs:6:10: 6:19>::eq(_1: &P, _2: &P) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: f64;
    let mut _5: f64;
    let mut _6: bool;
    let mut _7: f64;
    let mut _8: f64;

    bb0: {
        _4 = ((*_1).0: f64);
        _5 = ((*_2).0: f64);
        _3 = Eq(move _4, move _5);
        switchInt(move _3) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const false;
        goto -> bb3;
    }

    bb2: {
        _7 = ((*_1).1: f64);
        _8 = ((*_2).1: f64);
        _6 = Eq(move _7, move _8);
        _0 = move _6;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn <impl at ui/derives/derive-partial-ord.rs:6:21: 6:31>::partial_cmp(_1: &P, _2: &P) -> Option<std::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: std::option::Option<std::cmp::Ordering>;
    let mut _3: std::option::Option<std::cmp::Ordering>;
    let _4: &f64;
    let _5: &f64;
    let mut _6: i8;
    let mut _7: isize;
    let _8: &f64;
    let _9: &f64;
    let _10: std::option::Option<std::cmp::Ordering>;
    scope 1 {
        debug cmp => _10;
    }

    bb0: {
        _4 = &((*_1).0: f64);
        _5 = &((*_2).0: f64);
        _3 = <f64 as PartialOrd>::partial_cmp(_4, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = discriminant(_3);
        switchInt(move _7) -> [1: bb3, otherwise: bb2];
    }

    bb2: {
        _10 = _3;
        _0 = _10;
        goto -> bb5;
    }

    bb3: {
        _6 = discriminant(((_3 as Some).0: std::cmp::Ordering));
        switchInt(move _6) -> [0: bb4, otherwise: bb2];
    }

    bb4: {
        _8 = &((*_1).1: f64);
        _9 = &((*_2).1: f64);
        _0 = <f64 as PartialOrd>::partial_cmp(_8, _9) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: &[f64];
    let mut _2: std::slice::Iter<'_, f64>;
    let mut _4: std::option::Option<&f64>;
    let mut _5: &mut std::slice::Iter<'_, f64>;
    let mut _6: isize;
    let mut _8: std::slice::Iter<'_, f64>;
    let mut _10: std::option::Option<&f64>;
    let mut _11: &mut std::slice::Iter<'_, f64>;
    let mut _12: isize;
    let mut _14: std::slice::Iter<'_, f64>;
    let mut _16: std::option::Option<&f64>;
    let mut _17: &mut std::slice::Iter<'_, f64>;
    let mut _18: isize;
    let mut _20: std::slice::Iter<'_, f64>;
    let mut _22: std::option::Option<&f64>;
    let mut _23: &mut std::slice::Iter<'_, f64>;
    let mut _24: isize;
    let _26: ();
    let _27: &(f64, f64);
    let _28: (f64, f64);
    let mut _29: f64;
    let mut _30: f64;
    let _31: &(f64, f64);
    let _32: (f64, f64);
    let mut _33: f64;
    let mut _34: f64;
    let _35: ();
    let _36: &P;
    let _37: P;
    let mut _38: f64;
    let mut _39: f64;
    let _40: &P;
    let _41: P;
    let mut _42: f64;
    let mut _43: f64;
    let mut _44: (&std::option::Option<std::cmp::Ordering>, &std::option::Option<std::cmp::Ordering>);
    let mut _45: &std::option::Option<std::cmp::Ordering>;
    let _46: std::option::Option<std::cmp::Ordering>;
    let _47: &(f64, f64);
    let _48: (f64, f64);
    let mut _49: f64;
    let mut _50: f64;
    let _51: &(f64, f64);
    let _52: (f64, f64);
    let mut _53: f64;
    let mut _54: f64;
    let mut _55: &std::option::Option<std::cmp::Ordering>;
    let _56: std::option::Option<std::cmp::Ordering>;
    let _57: &P;
    let _58: P;
    let mut _59: f64;
    let mut _60: f64;
    let _61: &P;
    let _62: P;
    let mut _63: f64;
    let mut _64: f64;
    let mut _67: bool;
    let mut _68: bool;
    let _70: !;
    let mut _71: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _72: &[f64; 3];
    scope 1 {
        debug values => _1;
        let mut _3: std::slice::Iter<'_, f64>;
        scope 2 {
            debug iter => _3;
            let _7: &f64;
            scope 3 {
                debug a => _7;
                let mut _9: std::slice::Iter<'_, f64>;
                scope 4 {
                    debug iter => _9;
                    let _13: &f64;
                    scope 5 {
                        debug b => _13;
                        let mut _15: std::slice::Iter<'_, f64>;
                        scope 6 {
                            debug iter => _15;
                            let _19: &f64;
                            scope 7 {
                                debug c => _19;
                                let mut _21: std::slice::Iter<'_, f64>;
                                scope 8 {
                                    debug iter => _21;
                                    let _25: &f64;
                                    scope 9 {
                                        debug d => _25;
                                        let _65: &std::option::Option<std::cmp::Ordering>;
                                        let _66: &std::option::Option<std::cmp::Ordering>;
                                        scope 10 {
                                            debug left_val => _65;
                                            debug right_val => _66;
                                            let _69: core::panicking::AssertKind;
                                            scope 11 {
                                                debug kind => _69;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _72 = const _;
        _1 = _72 as &[f64] (Pointer(Unsize));
        _2 = <&[f64] as IntoIterator>::into_iter(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = move _2;
        goto -> bb2;
    }

    bb2: {
        _5 = &mut _3;
        _4 = <std::slice::Iter<'_, f64> as Iterator>::next(_5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _7 = ((_4 as Some).0: &f64);
        _8 = <&[f64] as IntoIterator>::into_iter(_1) -> [return: bb7, unwind continue];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        return;
    }

    bb7: {
        _9 = move _8;
        goto -> bb8;
    }

    bb8: {
        _11 = &mut _9;
        _10 = <std::slice::Iter<'_, f64> as Iterator>::next(_11) -> [return: bb9, unwind continue];
    }

    bb9: {
        _12 = discriminant(_10);
        switchInt(move _12) -> [0: bb2, 1: bb10, otherwise: bb5];
    }

    bb10: {
        _13 = ((_10 as Some).0: &f64);
        _14 = <&[f64] as IntoIterator>::into_iter(_1) -> [return: bb11, unwind continue];
    }

    bb11: {
        _15 = move _14;
        goto -> bb12;
    }

    bb12: {
        _17 = &mut _15;
        _16 = <std::slice::Iter<'_, f64> as Iterator>::next(_17) -> [return: bb13, unwind continue];
    }

    bb13: {
        _18 = discriminant(_16);
        switchInt(move _18) -> [0: bb8, 1: bb14, otherwise: bb5];
    }

    bb14: {
        _19 = ((_16 as Some).0: &f64);
        _20 = <&[f64] as IntoIterator>::into_iter(_1) -> [return: bb15, unwind continue];
    }

    bb15: {
        _21 = move _20;
        goto -> bb16;
    }

    bb16: {
        _23 = &mut _21;
        _22 = <std::slice::Iter<'_, f64> as Iterator>::next(_23) -> [return: bb17, unwind continue];
    }

    bb17: {
        _24 = discriminant(_22);
        switchInt(move _24) -> [0: bb12, 1: bb18, otherwise: bb5];
    }

    bb18: {
        _25 = ((_22 as Some).0: &f64);
        _29 = (*_7);
        _30 = (*_13);
        _28 = (move _29, move _30);
        _27 = &_28;
        _33 = (*_19);
        _34 = (*_25);
        _32 = (move _33, move _34);
        _31 = &_32;
        _26 = check::<(f64, f64)>(_27, _31) -> [return: bb19, unwind continue];
    }

    bb19: {
        _38 = (*_7);
        _39 = (*_13);
        _37 = P(move _38, move _39);
        _36 = &_37;
        _42 = (*_19);
        _43 = (*_25);
        _41 = P(move _42, move _43);
        _40 = &_41;
        _35 = check::<P>(_36, _40) -> [return: bb20, unwind continue];
    }

    bb20: {
        _49 = (*_7);
        _50 = (*_13);
        _48 = (move _49, move _50);
        _47 = &_48;
        _53 = (*_19);
        _54 = (*_25);
        _52 = (move _53, move _54);
        _51 = &_52;
        _46 = <(f64, f64) as PartialOrd>::partial_cmp(_47, _51) -> [return: bb21, unwind continue];
    }

    bb21: {
        _45 = &_46;
        _59 = (*_7);
        _60 = (*_13);
        _58 = P(move _59, move _60);
        _57 = &_58;
        _63 = (*_19);
        _64 = (*_25);
        _62 = P(move _63, move _64);
        _61 = &_62;
        _56 = <P as PartialOrd>::partial_cmp(_57, _61) -> [return: bb22, unwind continue];
    }

    bb22: {
        _55 = &_56;
        _44 = (move _45, move _55);
        _65 = (_44.0: &std::option::Option<std::cmp::Ordering>);
        _66 = (_44.1: &std::option::Option<std::cmp::Ordering>);
        _68 = <Option<std::cmp::Ordering> as PartialEq>::eq(_65, _66) -> [return: bb23, unwind continue];
    }

    bb23: {
        _67 = Not(move _68);
        switchInt(move _67) -> [0: bb16, otherwise: bb24];
    }

    bb24: {
        _69 = core::panicking::AssertKind::Eq;
        _71 = Option::<Arguments<'_>>::None;
        _70 = core::panicking::assert_failed::<Option<std::cmp::Ordering>, Option<std::cmp::Ordering>>(move _69, _65, _66, move _71) -> unwind continue;
    }
}

promoted[0] in main: &[f64; 3] = {
    let mut _0: &[f64; 3];
    let mut _1: [f64; 3];

    bb0: {
        _1 = [const 1f64, const 2f64, const _];
        _0 = &_1;
        return;
    }
}

fn check(_1: &T, _2: &T) -> () {
    debug a => _1;
    debug b => _2;
    let mut _0: ();
    let mut _3: std::option::Option<std::cmp::Ordering>;
    let mut _4: &T;
    let mut _5: i8;
    let mut _6: isize;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: &&T;
    let mut _11: &&T;
    let _12: &T;
    let mut _13: !;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: &&T;
    let mut _18: &&T;
    let _19: &T;
    let mut _20: !;
    let mut _21: bool;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: &&T;
    let mut _25: &&T;
    let _26: &T;
    let mut _27: !;
    let mut _28: bool;
    let mut _29: bool;
    let mut _30: bool;
    let mut _31: &&T;
    let mut _32: &&T;
    let _33: &T;
    let mut _34: !;
    let mut _35: bool;
    let mut _36: bool;
    let mut _37: bool;
    let mut _38: &&T;
    let mut _39: &&T;
    let _40: &T;
    let mut _41: !;
    let mut _42: bool;
    let mut _43: bool;
    let mut _44: &&T;
    let mut _45: &&T;
    let _46: &T;
    let mut _47: !;
    let mut _48: bool;
    let mut _49: bool;
    let mut _50: bool;
    let mut _51: &&T;
    let mut _52: &&T;
    let _53: &T;
    let mut _54: !;
    let mut _55: bool;
    let mut _56: bool;
    let mut _57: &&T;
    let mut _58: &&T;
    let _59: &T;
    let mut _60: !;
    let mut _61: bool;
    let mut _62: bool;
    let mut _63: &&T;
    let mut _64: &&T;
    let _65: &T;
    let mut _66: !;
    let mut _67: bool;
    let mut _68: bool;
    let mut _69: &&T;
    let mut _70: &&T;
    let _71: &T;
    let mut _72: !;
    let mut _73: bool;
    let mut _74: bool;
    let mut _75: bool;
    let mut _76: &&T;
    let mut _77: &&T;
    let _78: &T;
    let mut _79: !;
    let mut _80: bool;
    let mut _81: bool;
    let mut _82: bool;
    let mut _83: &&T;
    let mut _84: &&T;
    let _85: &T;
    let mut _86: !;
    let mut _87: bool;
    let mut _88: bool;
    let mut _89: bool;
    let mut _90: &&T;
    let mut _91: &&T;
    let _92: &T;
    let mut _93: !;
    let mut _94: bool;
    let mut _95: bool;
    let mut _96: bool;
    let mut _97: &&T;
    let mut _98: &&T;
    let _99: &T;
    let mut _100: !;
    let mut _101: bool;
    let mut _102: bool;
    let mut _103: &&T;
    let mut _104: &&T;
    let _105: &T;
    let mut _106: !;
    let mut _107: bool;
    let mut _108: bool;
    let mut _109: &&T;
    let mut _110: &&T;
    let _111: &T;
    let mut _112: !;

    bb0: {
        _4 = _1;
        _3 = <T as PartialOrd>::partial_cmp(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb5, 1: bb2, otherwise: bb4];
    }

    bb2: {
        _5 = discriminant(((_3 as Some).0: std::cmp::Ordering));
        switchInt(move _5) -> [255: bb29, 0: bb17, 1: bb3, otherwise: bb4];
    }

    bb3: {
        _90 = &_1;
        _92 = _2;
        _91 = &_92;
        _89 = <&T as PartialOrd>::lt(move _90, move _91) -> [return: bb41, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _10 = &_1;
        _12 = _2;
        _11 = &_12;
        _9 = <&T as PartialOrd>::lt(move _10, move _11) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Not(move _9);
        _7 = Not(move _8);
        switchInt(move _7) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _13 = core::panicking::panic(const "assertion failed: !(a < b)") -> unwind continue;
    }

    bb8: {
        _17 = &_1;
        _19 = _2;
        _18 = &_19;
        _16 = <&T as PartialOrd>::le(move _17, move _18) -> [return: bb9, unwind continue];
    }

    bb9: {
        _15 = Not(move _16);
        _14 = Not(move _15);
        switchInt(move _14) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _20 = core::panicking::panic(const "assertion failed: !(a <= b)") -> unwind continue;
    }

    bb11: {
        _24 = &_1;
        _26 = _2;
        _25 = &_26;
        _23 = <&T as PartialOrd>::gt(move _24, move _25) -> [return: bb12, unwind continue];
    }

    bb12: {
        _22 = Not(move _23);
        _21 = Not(move _22);
        switchInt(move _21) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _27 = core::panicking::panic(const "assertion failed: !(a > b)") -> unwind continue;
    }

    bb14: {
        _31 = &_1;
        _33 = _2;
        _32 = &_33;
        _30 = <&T as PartialOrd>::ge(move _31, move _32) -> [return: bb15, unwind continue];
    }

    bb15: {
        _29 = Not(move _30);
        _28 = Not(move _29);
        switchInt(move _28) -> [0: bb52, otherwise: bb16];
    }

    bb16: {
        _34 = core::panicking::panic(const "assertion failed: !(a >= b)") -> unwind continue;
    }

    bb17: {
        _38 = &_1;
        _40 = _2;
        _39 = &_40;
        _37 = <&T as PartialOrd>::lt(move _38, move _39) -> [return: bb18, unwind continue];
    }

    bb18: {
        _36 = Not(move _37);
        _35 = Not(move _36);
        switchInt(move _35) -> [0: bb20, otherwise: bb19];
    }

    bb19: {
        _41 = core::panicking::panic(const "assertion failed: !(a < b)") -> unwind continue;
    }

    bb20: {
        _44 = &_1;
        _46 = _2;
        _45 = &_46;
        _43 = <&T as PartialOrd>::le(move _44, move _45) -> [return: bb21, unwind continue];
    }

    bb21: {
        _42 = Not(move _43);
        switchInt(move _42) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _47 = core::panicking::panic(const "assertion failed: a <= b") -> unwind continue;
    }

    bb23: {
        _51 = &_1;
        _53 = _2;
        _52 = &_53;
        _50 = <&T as PartialOrd>::gt(move _51, move _52) -> [return: bb24, unwind continue];
    }

    bb24: {
        _49 = Not(move _50);
        _48 = Not(move _49);
        switchInt(move _48) -> [0: bb26, otherwise: bb25];
    }

    bb25: {
        _54 = core::panicking::panic(const "assertion failed: !(a > b)") -> unwind continue;
    }

    bb26: {
        _57 = &_1;
        _59 = _2;
        _58 = &_59;
        _56 = <&T as PartialOrd>::ge(move _57, move _58) -> [return: bb27, unwind continue];
    }

    bb27: {
        _55 = Not(move _56);
        switchInt(move _55) -> [0: bb52, otherwise: bb28];
    }

    bb28: {
        _60 = core::panicking::panic(const "assertion failed: a >= b") -> unwind continue;
    }

    bb29: {
        _63 = &_1;
        _65 = _2;
        _64 = &_65;
        _62 = <&T as PartialOrd>::lt(move _63, move _64) -> [return: bb30, unwind continue];
    }

    bb30: {
        _61 = Not(move _62);
        switchInt(move _61) -> [0: bb32, otherwise: bb31];
    }

    bb31: {
        _66 = core::panicking::panic(const "assertion failed: a < b") -> unwind continue;
    }

    bb32: {
        _69 = &_1;
        _71 = _2;
        _70 = &_71;
        _68 = <&T as PartialOrd>::le(move _69, move _70) -> [return: bb33, unwind continue];
    }

    bb33: {
        _67 = Not(move _68);
        switchInt(move _67) -> [0: bb35, otherwise: bb34];
    }

    bb34: {
        _72 = core::panicking::panic(const "assertion failed: a <= b") -> unwind continue;
    }

    bb35: {
        _76 = &_1;
        _78 = _2;
        _77 = &_78;
        _75 = <&T as PartialOrd>::gt(move _76, move _77) -> [return: bb36, unwind continue];
    }

    bb36: {
        _74 = Not(move _75);
        _73 = Not(move _74);
        switchInt(move _73) -> [0: bb38, otherwise: bb37];
    }

    bb37: {
        _79 = core::panicking::panic(const "assertion failed: !(a > b)") -> unwind continue;
    }

    bb38: {
        _83 = &_1;
        _85 = _2;
        _84 = &_85;
        _82 = <&T as PartialOrd>::ge(move _83, move _84) -> [return: bb39, unwind continue];
    }

    bb39: {
        _81 = Not(move _82);
        _80 = Not(move _81);
        switchInt(move _80) -> [0: bb52, otherwise: bb40];
    }

    bb40: {
        _86 = core::panicking::panic(const "assertion failed: !(a >= b)") -> unwind continue;
    }

    bb41: {
        _88 = Not(move _89);
        _87 = Not(move _88);
        switchInt(move _87) -> [0: bb43, otherwise: bb42];
    }

    bb42: {
        _93 = core::panicking::panic(const "assertion failed: !(a < b)") -> unwind continue;
    }

    bb43: {
        _97 = &_1;
        _99 = _2;
        _98 = &_99;
        _96 = <&T as PartialOrd>::le(move _97, move _98) -> [return: bb44, unwind continue];
    }

    bb44: {
        _95 = Not(move _96);
        _94 = Not(move _95);
        switchInt(move _94) -> [0: bb46, otherwise: bb45];
    }

    bb45: {
        _100 = core::panicking::panic(const "assertion failed: !(a <= b)") -> unwind continue;
    }

    bb46: {
        _103 = &_1;
        _105 = _2;
        _104 = &_105;
        _102 = <&T as PartialOrd>::gt(move _103, move _104) -> [return: bb47, unwind continue];
    }

    bb47: {
        _101 = Not(move _102);
        switchInt(move _101) -> [0: bb49, otherwise: bb48];
    }

    bb48: {
        _106 = core::panicking::panic(const "assertion failed: a > b") -> unwind continue;
    }

    bb49: {
        _109 = &_1;
        _111 = _2;
        _110 = &_111;
        _108 = <&T as PartialOrd>::ge(move _109, move _110) -> [return: bb50, unwind continue];
    }

    bb50: {
        _107 = Not(move _108);
        switchInt(move _107) -> [0: bb52, otherwise: bb51];
    }

    bb51: {
        _112 = core::panicking::panic(const "assertion failed: a >= b") -> unwind continue;
    }

    bb52: {
        return;
    }
}

fn P(_1: f64, _2: f64) -> P {
    let mut _0: P;

    bb0: {
        _0 = P(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn P(_1: f64, _2: f64) -> P {
    let mut _0: P;

    bb0: {
        _0 = P(move _1, move _2);
        return;
    }
}
