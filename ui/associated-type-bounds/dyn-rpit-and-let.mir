// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn assert_copy(_1: T) -> () {
    debug x => _1;                       // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:12:25: 12:26
    let mut _0: ();                      // return place in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:12:31: 12:31
    let _2: T;                           // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:12:37: 12:39
    scope 1 {
        debug _x => _2;                  // in scope 1 at ui/associated-type-bounds/dyn-rpit-and-let.rs:12:37: 12:39
        let _3: T;                       // in scope 1 at ui/associated-type-bounds/dyn-rpit-and-let.rs:12:49: 12:51
        scope 2 {
            debug _x => _3;              // in scope 2 at ui/associated-type-bounds/dyn-rpit-and-let.rs:12:49: 12:51
        }
    }

    bb0: {
        _2 = _1;                         // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:12:42: 12:43
        _3 = _1;                         // scope 1 at ui/associated-type-bounds/dyn-rpit-and-let.rs:12:54: 12:55
        return;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:12:58: 12:58
    }
}

fn assert_static(_1: T) -> () {
    let mut _0: ();                      // return place in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:13:36: 13:36

    bb0: {
        drop(_1) -> bb1;                 // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:13:37: 13:38
    }

    bb1: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:13:38: 13:38
    }
}

fn assert_forall_tr2(_1: T) -> () {
    let mut _0: ();                      // return place in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:14:48: 14:48

    bb0: {
        drop(_1) -> bb1;                 // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:14:49: 14:50
    }

    bb1: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:14:50: 14:50
    }
}

fn <impl at ui/associated-type-bounds/dyn-rpit-and-let.rs:17:16: 17:21>::clone(_1: &S2) -> S2 {
    debug self => _1;                    // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:17:16: 17:21
    let mut _0: S2;                      // return place in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:17:16: 17:21

    bb0: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:17:21: 17:21
    }
}

fn <impl at ui/associated-type-bounds/dyn-rpit-and-let.rs:19:1: 19:16>::mk(_1: &S1) -> S2 {
    debug self => _1;                    // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:19:40: 19:45
    let mut _0: S2;                      // return place in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:19:50: 19:59

    bb0: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:19:66: 19:66
    }
}

fn def_et1() -> Box<dyn Tr1<As1 = impl std::marker::Copy>> {
    let mut _0: std::boxed::Box<dyn Tr1<As1 = impl std::marker::Copy>>; // return place in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:21:17: 21:40
    let mut _1: std::boxed::Box<dyn Tr1<As1 = S2>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:23:5: 23:6
    let _2: std::boxed::Box<S1>;         // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:22:9: 22:10
    let mut _3: S1;                      // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:22:54: 22:56
    let mut _4: std::boxed::Box<S1>;     // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:23:5: 23:6
    scope 1 {
        debug x => _2;                   // in scope 1 at ui/associated-type-bounds/dyn-rpit-and-let.rs:22:9: 22:10
    }

    bb0: {
        _2 = Box::<S1>::new(move _3) -> bb1; // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:22:45: 22:57
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:22:45: 22:53
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(S1) -> Box<S1> {Box::<S1>::new}, val: Value(<ZST>) }
    }

    bb1: {
        _4 = move _2;                    // scope 1 at ui/associated-type-bounds/dyn-rpit-and-let.rs:23:5: 23:6
        _1 = move _4 as std::boxed::Box<dyn Tr1<As1 = S2>> (Pointer(Unsize)); // scope 1 at ui/associated-type-bounds/dyn-rpit-and-let.rs:23:5: 23:6
        _0 = move _1 as std::boxed::Box<dyn Tr1<As1 = S2>> (Pointer(Unsize)); // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:23:5: 23:6
        return;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:24:2: 24:2
    }
}

fn use_et1() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:25:18: 25:18
    let _1: ();                          // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:25:20: 25:47
    let mut _2: impl std::marker::Copy;  // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:25:32: 25:46
    let mut _3: &dyn Tr1<As1 = impl std::marker::Copy>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:25:32: 25:46
    let _4: std::boxed::Box<dyn Tr1<As1 = impl std::marker::Copy>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:25:32: 25:41
    let mut _5: *const dyn Tr1<As1 = impl std::marker::Copy>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:25:32: 25:41

    bb0: {
        _4 = def_et1() -> bb1;           // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:25:32: 25:41
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:25:32: 25:39
                                         // + literal: Const { ty: fn() -> Box<(dyn Tr1<As1 = impl std::marker::Copy> + 'static)> {def_et1}, val: Value(<ZST>) }
    }

    bb1: {
        _5 = (((_4.0: std::ptr::Unique<dyn Tr1<As1 = impl std::marker::Copy>>).0: std::ptr::NonNull<dyn Tr1<As1 = impl std::marker::Copy>>).0: *const dyn Tr1<As1 = impl std::marker::Copy>); // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:25:32: 25:46
        _3 = &(*_5);                     // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:25:32: 25:46
        _2 = <dyn Tr1<As1 = impl std::marker::Copy> as Tr1>::mk(move _3) -> [return: bb2, unwind: bb5]; // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:25:32: 25:46
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:25:42: 25:44
                                         // + literal: Const { ty: for<'a> fn(&'a dyn Tr1<As1 = impl std::marker::Copy>) -> <dyn Tr1<As1 = impl std::marker::Copy> as Tr1>::As1 {<dyn Tr1<As1 = impl std::marker::Copy> as Tr1>::mk}, val: Value(<ZST>) }
    }

    bb2: {
        _1 = assert_copy::<impl std::marker::Copy>(move _2) -> [return: bb3, unwind: bb5]; // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:25:20: 25:47
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:25:20: 25:31
                                         // + literal: Const { ty: fn(impl std::marker::Copy) {assert_copy::<impl std::marker::Copy>}, val: Value(<ZST>) }
    }

    bb3: {
        drop(_4) -> bb4;                 // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:25:47: 25:48
    }

    bb4: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:25:50: 25:50
    }

    bb5 (cleanup): {
        drop(_4) -> bb6;                 // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:25:47: 25:48
    }

    bb6 (cleanup): {
        resume;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:25:1: 25:50
    }
}

fn def_et2() -> Box<dyn Tr1<As1 = impl Send + 'static>> {
    let mut _0: std::boxed::Box<dyn Tr1<As1 = impl std::marker::Send + 'static>>; // return place in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:27:17: 27:50
    let mut _1: std::boxed::Box<dyn Tr1<As1 = S2>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:29:5: 29:6
    let _2: std::boxed::Box<S1>;         // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:28:9: 28:10
    let mut _3: S1;                      // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:28:64: 28:66
    let mut _4: std::boxed::Box<S1>;     // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:29:5: 29:6
    scope 1 {
        debug x => _2;                   // in scope 1 at ui/associated-type-bounds/dyn-rpit-and-let.rs:28:9: 28:10
    }

    bb0: {
        _2 = Box::<S1>::new(move _3) -> bb1; // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:28:55: 28:67
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:28:55: 28:63
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(S1) -> Box<S1> {Box::<S1>::new}, val: Value(<ZST>) }
    }

    bb1: {
        _4 = move _2;                    // scope 1 at ui/associated-type-bounds/dyn-rpit-and-let.rs:29:5: 29:6
        _1 = move _4 as std::boxed::Box<dyn Tr1<As1 = S2>> (Pointer(Unsize)); // scope 1 at ui/associated-type-bounds/dyn-rpit-and-let.rs:29:5: 29:6
        _0 = move _1 as std::boxed::Box<dyn Tr1<As1 = S2>> (Pointer(Unsize)); // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:29:5: 29:6
        return;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:30:2: 30:2
    }
}

fn use_et2() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:31:18: 31:18
    let _1: ();                          // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:31:20: 31:49
    let mut _2: impl std::marker::Send + 'static; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:31:34: 31:48
    let mut _3: &dyn Tr1<As1 = impl std::marker::Send + 'static>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:31:34: 31:48
    let _4: std::boxed::Box<dyn Tr1<As1 = impl std::marker::Send + 'static>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:31:34: 31:43
    let mut _5: *const dyn Tr1<As1 = impl std::marker::Send + 'static>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:31:34: 31:43

    bb0: {
        _4 = def_et2() -> bb1;           // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:31:34: 31:43
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:31:34: 31:41
                                         // + literal: Const { ty: fn() -> Box<(dyn Tr1<As1 = impl Send + 'static> + 'static)> {def_et2}, val: Value(<ZST>) }
    }

    bb1: {
        _5 = (((_4.0: std::ptr::Unique<dyn Tr1<As1 = impl std::marker::Send + 'static>>).0: std::ptr::NonNull<dyn Tr1<As1 = impl std::marker::Send + 'static>>).0: *const dyn Tr1<As1 = impl std::marker::Send + 'static>); // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:31:34: 31:48
        _3 = &(*_5);                     // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:31:34: 31:48
        _2 = <dyn Tr1<As1 = impl Send + 'static> as Tr1>::mk(move _3) -> [return: bb2, unwind: bb5]; // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:31:34: 31:48
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:31:44: 31:46
                                         // + literal: Const { ty: for<'a> fn(&'a dyn Tr1<As1 = impl Send + 'static>) -> <dyn Tr1<As1 = impl Send + 'static> as Tr1>::As1 {<dyn Tr1<As1 = impl Send + 'static> as Tr1>::mk}, val: Value(<ZST>) }
    }

    bb2: {
        _1 = assert_static::<impl Send + 'static>(move _2) -> [return: bb3, unwind: bb5]; // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:31:20: 31:49
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:31:20: 31:33
                                         // + literal: Const { ty: fn(impl Send + 'static) {assert_static::<impl Send + 'static>}, val: Value(<ZST>) }
    }

    bb3: {
        drop(_4) -> bb4;                 // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:31:49: 31:50
    }

    bb4: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:31:52: 31:52
    }

    bb5 (cleanup): {
        drop(_4) -> bb6;                 // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:31:49: 31:50
    }

    bb6 (cleanup): {
        resume;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:31:1: 31:52
    }
}

fn def_et3() -> Box<dyn Tr1<As1 = impl Clone + Iterator<Item = impl Add<u8, Output = impl Into<u8>>>>> {
    let mut _0: std::boxed::Box<dyn Tr1<As1 = impl std::clone::Clone + std::iter::Iterator<Item = impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>>>>; // return place in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:33:17: 33:85
    let mut _1: std::boxed::Box<dyn Tr1<As1 = std::ops::Range<u8>>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:41:5: 41:6
    let _2: std::boxed::Box<def_et3::A>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:39:9: 39:10
    let mut _3: def_et3::A;              // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:40:20: 40:21
    let mut _4: std::boxed::Box<def_et3::A>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:41:5: 41:6
    scope 1 {
        debug x => _2;                   // in scope 1 at ui/associated-type-bounds/dyn-rpit-and-let.rs:39:9: 39:10
    }

    bb0: {
        _2 = Box::<def_et3::A>::new(move _3) -> bb1; // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:40:11: 40:22
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:40:11: 40:19
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(def_et3::A) -> Box<def_et3::A> {Box::<def_et3::A>::new}, val: Value(<ZST>) }
    }

    bb1: {
        _4 = move _2;                    // scope 1 at ui/associated-type-bounds/dyn-rpit-and-let.rs:41:5: 41:6
        _1 = move _4 as std::boxed::Box<dyn Tr1<As1 = std::ops::Range<u8>>> (Pointer(Unsize)); // scope 1 at ui/associated-type-bounds/dyn-rpit-and-let.rs:41:5: 41:6
        _0 = move _1 as std::boxed::Box<dyn Tr1<As1 = std::ops::Range<u8>>> (Pointer(Unsize)); // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:41:5: 41:6
        return;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:42:2: 42:2
    }
}

fn def_et3::<impl at ui/associated-type-bounds/dyn-rpit-and-let.rs:35:5: 35:19>::mk(_1: &def_et3::A) -> std::ops::Range<u8> {
    debug self => _1;                    // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:37:15: 37:20
    let mut _0: std::ops::Range<u8>;     // return place in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:37:25: 37:34

    bb0: {
        _0 = std::ops::Range::<u8> { start: const 0_u8, end: const 10_u8 }; // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:37:37: 37:42
        return;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:37:44: 37:44
    }
}

fn use_et3() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:43:18: 43:18
    let _1: impl std::clone::Clone + std::iter::Iterator<Item = impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:44:9: 44:11
    let mut _2: &impl std::clone::Clone + std::iter::Iterator<Item = impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:44:14: 44:36
    let _3: impl std::clone::Clone + std::iter::Iterator<Item = impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:44:14: 44:28
    let mut _4: &dyn Tr1<As1 = impl std::clone::Clone + std::iter::Iterator<Item = impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:44:14: 44:28
    let _5: std::boxed::Box<dyn Tr1<As1 = impl std::clone::Clone + std::iter::Iterator<Item = impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>>>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:44:14: 44:23
    let mut _7: impl std::clone::Clone + std::iter::Iterator<Item = impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:15: 46:17
    let mut _8: impl std::clone::Clone + std::iter::Iterator<Item = impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:15: 46:17
    let mut _10: std::option::Option<impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:15: 46:17
    let mut _11: &mut impl std::clone::Clone + std::iter::Iterator<Item = impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:15: 46:17
    let mut _12: &mut impl std::clone::Clone + std::iter::Iterator<Item = impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:15: 46:17
    let mut _13: isize;                  // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:5: 49:6
    let mut _16: impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:47:18: 47:20
    let mut _17: u8;                     // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:48:14: 48:23
    let mut _18: impl std::convert::Into<u8>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:48:14: 48:16
    let mut _19: (u8, bool);             // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:48:9: 48:23
    let mut _20: (&u8, &u8);             // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:38:15: 38:32
    let mut _21: &u8;                    // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:38:16: 38:22
    let mut _22: &u8;                    // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:38:24: 38:31
    let _23: u8;                         // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:50:19: 50:47
    let mut _24: std::iter::Map<std::ops::Range<u8>, [closure@ui/associated-type-bounds/dyn-rpit-and-let.rs:50:31: 50:34]>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:50:19: 50:41
    let mut _25: std::ops::Range<u8>;    // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:50:19: 50:26
    let mut _26: [closure@ui/associated-type-bounds/dyn-rpit-and-let.rs:50:31: 50:34]; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:50:31: 50:40
    let mut _29: bool;                   // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:40:20: 40:46
    let mut _30: bool;                   // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:40:21: 40:46
    let mut _31: u8;                     // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:40:22: 40:31
    let mut _32: u8;                     // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:40:35: 40:45
    let _34: !;                          // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:21: 45:114
    let mut _35: core::panicking::AssertKind; // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:54: 45:58
    let mut _36: &u8;                    // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:60: 45:70
    let _37: &u8;                        // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:60: 45:70
    let mut _38: &u8;                    // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:72: 45:83
    let _39: &u8;                        // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:72: 45:83
    let mut _40: std::option::Option<std::fmt::Arguments<'_>>; // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:85: 45:113
    let mut _41: *const dyn Tr1<As1 = impl std::clone::Clone + std::iter::Iterator<Item = impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:44:14: 44:23
    scope 1 {
        debug _0 => _1;                  // in scope 1 at ui/associated-type-bounds/dyn-rpit-and-let.rs:44:9: 44:11
        let mut _6: u8;                  // in scope 1 at ui/associated-type-bounds/dyn-rpit-and-let.rs:45:9: 45:14
        scope 2 {
            debug s => _6;               // in scope 2 at ui/associated-type-bounds/dyn-rpit-and-let.rs:45:9: 45:14
            let mut _9: impl std::clone::Clone + std::iter::Iterator<Item = impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>>; // in scope 2 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:15: 46:17
            let _27: &u8;                // in scope 2 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:39:14: 39:22
            let _28: &u8;                // in scope 2 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:39:24: 39:33
            scope 3 {
                debug iter => _9;        // in scope 3 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:15: 46:17
                let _14: impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>; // in scope 3 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:9: 46:11
                scope 4 {
                    debug _1 => _14;     // in scope 4 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:9: 46:11
                    let _15: impl std::convert::Into<u8>; // in scope 4 at ui/associated-type-bounds/dyn-rpit-and-let.rs:47:13: 47:15
                    scope 5 {
                        debug _2 => _15; // in scope 5 at ui/associated-type-bounds/dyn-rpit-and-let.rs:47:13: 47:15
                    }
                }
            }
            scope 6 {
                debug left_val => _27;   // in scope 6 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:39:14: 39:22
                debug right_val => _28;  // in scope 6 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:39:24: 39:33
                let _33: core::panicking::AssertKind; // in scope 6 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:41:25: 41:29
                scope 7 {
                    debug kind => _33;   // in scope 7 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:41:25: 41:29
                }
            }
        }
    }

    bb0: {
        _5 = def_et3() -> bb1;           // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:44:14: 44:23
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:44:14: 44:21
                                         // + literal: Const { ty: fn() -> Box<(dyn Tr1<As1 = impl Clone + Iterator<Item = impl Add<u8, Output = impl Into<u8>>>> + 'static)> {def_et3}, val: Value(<ZST>) }
    }

    bb1: {
        _41 = (((_5.0: std::ptr::Unique<dyn Tr1<As1 = impl std::clone::Clone + std::iter::Iterator<Item = impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>>>>).0: std::ptr::NonNull<dyn Tr1<As1 = impl std::clone::Clone + std::iter::Iterator<Item = impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>>>>).0: *const dyn Tr1<As1 = impl std::clone::Clone + std::iter::Iterator<Item = impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>>>); // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:44:14: 44:28
        _4 = &(*_41);                    // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:44:14: 44:28
        _3 = <dyn Tr1<As1 = impl Clone + Iterator<Item = impl Add<u8, Output = impl Into<u8>>>> as Tr1>::mk(move _4) -> [return: bb2, unwind: bb18]; // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:44:14: 44:28
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:44:24: 44:26
                                         // + literal: Const { ty: for<'a> fn(&'a dyn Tr1<As1 = impl Clone + Iterator<Item = impl Add<u8, Output = impl Into<u8>>>>) -> <dyn Tr1<As1 = impl Clone + Iterator<Item = impl Add<u8, Output = impl Into<u8>>>> as Tr1>::As1 {<dyn Tr1<As1 = impl Clone + Iterator<Item = impl Add<u8, Output = impl Into<u8>>>> as Tr1>::mk}, val: Value(<ZST>) }
    }

    bb2: {
        _2 = &_3;                        // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:44:14: 44:36
        _1 = <impl Clone + Iterator<Item = impl Add<u8, Output = impl Into<u8>>> as Clone>::clone(move _2) -> [return: bb3, unwind: bb18]; // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:44:14: 44:36
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:44:29: 44:34
                                         // + literal: Const { ty: for<'a> fn(&'a impl Clone + Iterator<Item = impl Add<u8, Output = impl Into<u8>>>) -> impl Clone + Iterator<Item = impl Add<u8, Output = impl Into<u8>>> {<impl Clone + Iterator<Item = impl Add<u8, Output = impl Into<u8>>> as Clone>::clone}, val: Value(<ZST>) }
    }

    bb3: {
        drop(_5) -> bb4;                 // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:44:36: 44:37
    }

    bb4: {
        _6 = const 0_u8;                 // scope 1 at ui/associated-type-bounds/dyn-rpit-and-let.rs:45:17: 45:20
        _8 = move _1;                    // scope 2 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:15: 46:17
        _7 = <impl Clone + Iterator<Item = impl Add<u8, Output = impl Into<u8>>> as IntoIterator>::into_iter(move _8) -> bb5; // scope 2 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:15: 46:17
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:46:15: 46:17
                                         // + literal: Const { ty: fn(impl Clone + Iterator<Item = impl Add<u8, Output = impl Into<u8>>>) -> <impl Clone + Iterator<Item = impl Add<u8, Output = impl Into<u8>>> as IntoIterator>::IntoIter {<impl Clone + Iterator<Item = impl Add<u8, Output = impl Into<u8>>> as IntoIterator>::into_iter}, val: Value(<ZST>) }
    }

    bb5: {
        _9 = move _7;                    // scope 2 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:15: 46:17
        goto -> bb6;                     // scope 3 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:5: 49:6
    }

    bb6: {
        _12 = &mut _9;                   // scope 3 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:15: 46:17
        _11 = &mut (*_12);               // scope 3 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:15: 46:17
        _10 = <impl Clone + Iterator<Item = impl Add<u8, Output = impl Into<u8>>> as Iterator>::next(move _11) -> bb7; // scope 3 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:15: 46:17
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:46:15: 46:17
                                         // + literal: Const { ty: for<'a> fn(&'a mut impl Clone + Iterator<Item = impl Add<u8, Output = impl Into<u8>>>) -> Option<<impl Clone + Iterator<Item = impl Add<u8, Output = impl Into<u8>>> as Iterator>::Item> {<impl Clone + Iterator<Item = impl Add<u8, Output = impl Into<u8>>> as Iterator>::next}, val: Value(<ZST>) }
    }

    bb7: {
        _13 = discriminant(_10);         // scope 3 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:15: 46:17
        switchInt(move _13) -> [0: bb10, 1: bb8, otherwise: bb9]; // scope 3 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:15: 46:17
    }

    bb8: {
        _14 = move ((_10 as Some).0: impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>); // scope 3 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:9: 46:11
        _16 = move _14;                  // scope 4 at ui/associated-type-bounds/dyn-rpit-and-let.rs:47:18: 47:20
        _15 = <impl Add<u8, Output = impl Into<u8>> as Add<u8>>::add(move _16, const 1_u8) -> bb11; // scope 4 at ui/associated-type-bounds/dyn-rpit-and-let.rs:47:18: 47:26
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:47:18: 47:26
                                         // + literal: Const { ty: fn(impl Add<u8, Output = impl Into<u8>>, u8) -> <impl Add<u8, Output = impl Into<u8>> as Add<u8>>::Output {<impl Add<u8, Output = impl Into<u8>> as Add<u8>>::add}, val: Value(<ZST>) }
    }

    bb9: {
        unreachable;                     // scope 3 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:15: 46:17
    }

    bb10: {
        _21 = &_6;                       // scope 2 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:38:16: 38:22
        _25 = std::ops::Range::<u8> { start: const 0_u8, end: const 10_u8 }; // scope 2 at ui/associated-type-bounds/dyn-rpit-and-let.rs:50:19: 50:26
        _24 = <std::ops::Range<u8> as Iterator>::map::<u8, [closure@ui/associated-type-bounds/dyn-rpit-and-let.rs:50:31: 50:34]>(move _25, move _26) -> bb14; // scope 2 at ui/associated-type-bounds/dyn-rpit-and-let.rs:50:19: 50:41
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:50:27: 50:30
                                         // + literal: Const { ty: fn(std::ops::Range<u8>, [closure@ui/associated-type-bounds/dyn-rpit-and-let.rs:50:31: 50:34]) -> Map<std::ops::Range<u8>, [closure@ui/associated-type-bounds/dyn-rpit-and-let.rs:50:31: 50:34]> {<std::ops::Range<u8> as Iterator>::map::<u8, [closure@ui/associated-type-bounds/dyn-rpit-and-let.rs:50:31: 50:34]>}, val: Value(<ZST>) }
    }

    bb11: {
        _18 = move _15;                  // scope 5 at ui/associated-type-bounds/dyn-rpit-and-let.rs:48:14: 48:16
        _17 = <impl Into<u8> as Into<u8>>::into(move _18) -> bb12; // scope 5 at ui/associated-type-bounds/dyn-rpit-and-let.rs:48:14: 48:23
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:48:17: 48:21
                                         // + literal: Const { ty: fn(impl Into<u8>) -> u8 {<impl Into<u8> as Into<u8>>::into}, val: Value(<ZST>) }
    }

    bb12: {
        _19 = CheckedAdd(_6, _17);       // scope 5 at ui/associated-type-bounds/dyn-rpit-and-let.rs:48:9: 48:23
        assert(!move (_19.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, move _17) -> bb13; // scope 5 at ui/associated-type-bounds/dyn-rpit-and-let.rs:48:9: 48:23
    }

    bb13: {
        _6 = move (_19.0: u8);           // scope 5 at ui/associated-type-bounds/dyn-rpit-and-let.rs:48:9: 48:23
        goto -> bb6;                     // scope 3 at ui/associated-type-bounds/dyn-rpit-and-let.rs:46:5: 49:6
    }

    bb14: {
        _23 = <Map<std::ops::Range<u8>, [closure@ui/associated-type-bounds/dyn-rpit-and-let.rs:50:31: 50:34]> as Iterator>::sum::<u8>(move _24) -> bb15; // scope 2 at ui/associated-type-bounds/dyn-rpit-and-let.rs:50:19: 50:47
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:50:42: 50:45
                                         // + literal: Const { ty: fn(Map<std::ops::Range<u8>, [closure@ui/associated-type-bounds/dyn-rpit-and-let.rs:50:31: 50:34]>) -> u8 {<Map<std::ops::Range<u8>, [closure@ui/associated-type-bounds/dyn-rpit-and-let.rs:50:31: 50:34]> as Iterator>::sum::<u8>}, val: Value(<ZST>) }
    }

    bb15: {
        _22 = &_23;                      // scope 2 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:38:24: 38:31
        _20 = (move _21, move _22);      // scope 2 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:38:15: 38:32
        _27 = (_20.0: &u8);              // scope 2 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:39:14: 39:22
        _28 = (_20.1: &u8);              // scope 2 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:39:24: 39:33
        _31 = (*_27);                    // scope 6 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:40:22: 40:31
        _32 = (*_28);                    // scope 6 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:40:35: 40:45
        _30 = Eq(move _31, move _32);    // scope 6 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:40:21: 40:46
        _29 = Not(move _30);             // scope 6 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:40:20: 40:46
        switchInt(move _29) -> [0: bb17, otherwise: bb16]; // scope 6 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:40:20: 40:46
    }

    bb16: {
        _33 = const core::panicking::AssertKind::Eq; // scope 6 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:41:32: 41:65
                                         // mir::Constant
                                         // + span: /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:41:32: 41:65
                                         // + literal: Const { ty: AssertKind, val: Value(Scalar(0x00)) }
        _35 = const core::panicking::AssertKind::Eq; // scope 7 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:54: 45:58
                                         // mir::Constant
                                         // + span: /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:54: 45:58
                                         // + literal: Const { ty: AssertKind, val: Value(Scalar(0x00)) }
        _37 = _27;                       // scope 7 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:60: 45:70
        _36 = _37;                       // scope 7 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:60: 45:70
        _39 = _28;                       // scope 7 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:72: 45:83
        _38 = _39;                       // scope 7 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:72: 45:83
        _40 = Option::<Arguments<'_>>::None; // scope 7 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:85: 45:113
        _34 = assert_failed::<u8, u8>(move _35, move _36, move _38, move _40); // scope 7 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:21: 45:114
                                         // mir::Constant
                                         // + span: /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:21: 45:53
                                         // + literal: Const { ty: for<'a, 'b, 'c> fn(AssertKind, &'a u8, &'b u8, Option<Arguments<'c>>) -> ! {assert_failed::<u8, u8>}, val: Value(<ZST>) }
    }

    bb17: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:51:2: 51:2
    }

    bb18 (cleanup): {
        drop(_5) -> bb19;                // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:44:36: 44:37
    }

    bb19 (cleanup): {
        resume;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:43:1: 51:2
    }
}

fn use_et3::{closure#0}(_1: &mut [closure@ui/associated-type-bounds/dyn-rpit-and-let.rs:50:31: 50:34], _2: u8) -> u8 {
    debug x => _2;                       // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:50:32: 50:33
    let mut _0: u8;                      // return place in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:50:35: 50:35
    let mut _3: u8;                      // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:50:35: 50:36
    let mut _4: (u8, bool);              // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:50:35: 50:40

    bb0: {
        _3 = _2;                         // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:50:35: 50:36
        _4 = CheckedAdd(_3, const 1_u8); // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:50:35: 50:40
        assert(!move (_4.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3, const 1_u8) -> bb1; // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:50:35: 50:40
    }

    bb1: {
        _0 = move (_4.0: u8);            // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:50:35: 50:40
        return;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:50:40: 50:40
    }
}

fn def_et4() -> Box<dyn Tr1<As1 = impl for<'a> Tr2<'a>>> {
    let mut _0: std::boxed::Box<dyn Tr1<As1 = impl for<'a> Tr2<'a>>>; // return place in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:53:17: 53:51
    let mut _1: std::boxed::Box<dyn Tr1<As1 = def_et4::A>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:64:5: 64:6
    let _2: std::boxed::Box<def_et4::A>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:63:9: 63:10
    let mut _3: def_et4::A;              // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:63:65: 63:66
    let mut _4: std::boxed::Box<def_et4::A>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:64:5: 64:6
    scope 1 {
        debug x => _2;                   // in scope 1 at ui/associated-type-bounds/dyn-rpit-and-let.rs:63:9: 63:10
    }

    bb0: {
        _2 = Box::<def_et4::A>::new(move _3) -> bb1; // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:63:56: 63:67
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:63:56: 63:64
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(def_et4::A) -> Box<def_et4::A> {Box::<def_et4::A>::new}, val: Value(<ZST>) }
    }

    bb1: {
        _4 = move _2;                    // scope 1 at ui/associated-type-bounds/dyn-rpit-and-let.rs:64:5: 64:6
        _1 = move _4 as std::boxed::Box<dyn Tr1<As1 = def_et4::A>> (Pointer(Unsize)); // scope 1 at ui/associated-type-bounds/dyn-rpit-and-let.rs:64:5: 64:6
        _0 = move _1 as std::boxed::Box<dyn Tr1<As1 = def_et4::A>> (Pointer(Unsize)); // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:64:5: 64:6
        return;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:65:2: 65:2
    }
}

fn def_et4::<impl at ui/associated-type-bounds/dyn-rpit-and-let.rs:54:20: 54:25>::clone(_1: &def_et4::A) -> def_et4::A {
    debug self => _1;                    // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:54:20: 54:25
    let mut _0: def_et4::A;              // return place in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:54:20: 54:25

    bb0: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:54:25: 54:25
    }
}

fn def_et4::<impl at ui/associated-type-bounds/dyn-rpit-and-let.rs:56:5: 56:19>::mk(_1: &def_et4::A) -> def_et4::A {
    debug self => _1;                    // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:58:15: 58:20
    let mut _0: def_et4::A;              // return place in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:58:25: 58:26

    bb0: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:58:32: 58:32
    }
}

fn def_et4::<impl at ui/associated-type-bounds/dyn-rpit-and-let.rs:60:5: 60:27>::tr2(_1: def_et4::A) -> &def_et4::A {
    debug self => _1;                    // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:61:16: 61:20
    let mut _0: &def_et4::A;             // return place in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:61:36: 61:38
    let mut _2: &def_et4::A;             // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:61:36: 61:38

    bb0: {
        _2 = const _;                    // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:61:36: 61:38
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:61:36: 61:38
                                         // + literal: Const { ty: &def_et4::A, val: Unevaluated(<def_et4::A as Tr2<'a>>::tr2, [ReErased], Some(promoted[0])) }
        _0 = _2;                         // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:61:36: 61:38
        return;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:61:40: 61:40
    }
}

promoted[0] in def_et4::<impl at ui/associated-type-bounds/dyn-rpit-and-let.rs:60:5: 60:27>::tr2: &def_et4::A = {
    let mut _0: &def_et4::A;             // return place in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:61:36: 61:38
    let mut _1: def_et4::A;              // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:61:37: 61:38

    bb0: {
        _1 = def_et4::A;                 // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:61:37: 61:38
        _0 = &_1;                        // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:61:36: 61:38
        return;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:61:36: 61:38
    }
}

fn use_et4() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:66:18: 66:18
    let _1: ();                          // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:66:20: 66:53
    let mut _2: impl for<'a> Tr2<'a>;    // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:66:38: 66:52
    let mut _3: &dyn Tr1<As1 = impl for<'a> Tr2<'a>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:66:38: 66:52
    let _4: std::boxed::Box<dyn Tr1<As1 = impl for<'a> Tr2<'a>>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:66:38: 66:47
    let mut _5: *const dyn Tr1<As1 = impl for<'a> Tr2<'a>>; // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:66:38: 66:47

    bb0: {
        _4 = def_et4() -> bb1;           // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:66:38: 66:47
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:66:38: 66:45
                                         // + literal: Const { ty: fn() -> Box<(dyn Tr1<As1 = impl for<'a> Tr2<'a>> + 'static)> {def_et4}, val: Value(<ZST>) }
    }

    bb1: {
        _5 = (((_4.0: std::ptr::Unique<dyn Tr1<As1 = impl for<'a> Tr2<'a>>>).0: std::ptr::NonNull<dyn Tr1<As1 = impl for<'a> Tr2<'a>>>).0: *const dyn Tr1<As1 = impl for<'a> Tr2<'a>>); // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:66:38: 66:52
        _3 = &(*_5);                     // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:66:38: 66:52
        _2 = <dyn Tr1<As1 = impl for<'a> Tr2<'a>> as Tr1>::mk(move _3) -> [return: bb2, unwind: bb5]; // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:66:38: 66:52
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:66:48: 66:50
                                         // + literal: Const { ty: for<'a> fn(&'a dyn Tr1<As1 = impl for<'a> Tr2<'a>>) -> <dyn Tr1<As1 = impl for<'a> Tr2<'a>> as Tr1>::As1 {<dyn Tr1<As1 = impl for<'a> Tr2<'a>> as Tr1>::mk}, val: Value(<ZST>) }
    }

    bb2: {
        _1 = assert_forall_tr2::<impl for<'a> Tr2<'a>>(move _2) -> [return: bb3, unwind: bb5]; // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:66:20: 66:53
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:66:20: 66:37
                                         // + literal: Const { ty: fn(impl for<'a> Tr2<'a>) {assert_forall_tr2::<impl for<'a> Tr2<'a>>}, val: Value(<ZST>) }
    }

    bb3: {
        drop(_4) -> bb4;                 // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:66:53: 66:54
    }

    bb4: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:66:56: 66:56
    }

    bb5 (cleanup): {
        drop(_4) -> bb6;                 // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:66:53: 66:54
    }

    bb6 (cleanup): {
        resume;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:66:1: 66:56
    }
}

fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:68:11: 68:11
    let mut _1: ();                      // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:69:13: 69:22
    let mut _2: ();                      // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:70:13: 70:22
    let mut _3: ();                      // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:71:13: 71:22
    let mut _4: ();                      // in scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:72:13: 72:22
    scope 1 {
        scope 2 {
            scope 3 {
                scope 4 {
                }
            }
        }
    }

    bb0: {
        _1 = use_et1() -> bb1;           // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:69:13: 69:22
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:69:13: 69:20
                                         // + literal: Const { ty: fn() {use_et1}, val: Value(<ZST>) }
    }

    bb1: {
        _2 = use_et2() -> bb2;           // scope 1 at ui/associated-type-bounds/dyn-rpit-and-let.rs:70:13: 70:22
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:70:13: 70:20
                                         // + literal: Const { ty: fn() {use_et2}, val: Value(<ZST>) }
    }

    bb2: {
        _3 = use_et3() -> bb3;           // scope 2 at ui/associated-type-bounds/dyn-rpit-and-let.rs:71:13: 71:22
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:71:13: 71:20
                                         // + literal: Const { ty: fn() {use_et3}, val: Value(<ZST>) }
    }

    bb3: {
        _4 = use_et4() -> bb4;           // scope 3 at ui/associated-type-bounds/dyn-rpit-and-let.rs:72:13: 72:22
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-rpit-and-let.rs:72:13: 72:20
                                         // + literal: Const { ty: fn() {use_et4}, val: Value(<ZST>) }
    }

    bb4: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-rpit-and-let.rs:73:2: 73:2
    }
}
