// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn assert_copy(_1: T) -> () {
    debug x => _1;                       // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:10:25: 10:26
    let mut _0: ();                      // return place in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:10:31: 10:31
    let _2: T;                           // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:10:37: 10:39
    scope 1 {
        debug _x => _2;                  // in scope 1 at ui/associated-type-bounds/dyn-impl-trait-type.rs:10:37: 10:39
        let _3: T;                       // in scope 1 at ui/associated-type-bounds/dyn-impl-trait-type.rs:10:49: 10:51
        scope 2 {
            debug _x => _3;              // in scope 2 at ui/associated-type-bounds/dyn-impl-trait-type.rs:10:49: 10:51
        }
    }

    bb0: {
        _2 = _1;                         // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:10:42: 10:43
        _3 = _1;                         // scope 1 at ui/associated-type-bounds/dyn-impl-trait-type.rs:10:54: 10:55
        return;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:10:58: 10:58
    }
}

fn assert_static(_1: T) -> () {
    let mut _0: ();                      // return place in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:11:36: 11:36

    bb0: {
        drop(_1) -> bb1;                 // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:11:37: 11:38
    }

    bb1: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:11:38: 11:38
    }
}

fn assert_forall_tr2(_1: T) -> () {
    let mut _0: ();                      // return place in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:12:48: 12:48

    bb0: {
        drop(_1) -> bb1;                 // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:12:49: 12:50
    }

    bb1: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:12:50: 12:50
    }
}

fn <impl at ui/associated-type-bounds/dyn-impl-trait-type.rs:15:16: 15:21>::clone(_1: &S2) -> S2 {
    debug self => _1;                    // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:15:16: 15:21
    let mut _0: S2;                      // return place in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:15:16: 15:21

    bb0: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:15:21: 15:21
    }
}

fn <impl at ui/associated-type-bounds/dyn-impl-trait-type.rs:17:1: 17:16>::mk(_1: &S1) -> S2 {
    debug self => _1;                    // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:17:40: 17:45
    let mut _0: S2;                      // return place in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:17:50: 17:59

    bb0: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:17:66: 17:66
    }
}

fn def_et1() -> Box<dyn Tr1<As1 = Et1::{opaque#0}>> {
    let mut _0: std::boxed::Box<dyn Tr1<As1 = Et1::{opaque#0}>>; // return place in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:20:17: 20:20
    let mut _1: std::boxed::Box<dyn Tr1<As1 = S2>>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:20:23: 20:35
    let mut _2: std::boxed::Box<S1>;     // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:20:23: 20:35
    let mut _3: S1;                      // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:20:32: 20:34

    bb0: {
        _2 = Box::<S1>::new(move _3) -> bb1; // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:20:23: 20:35
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:20:23: 20:31
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(S1) -> Box<S1> {Box::<S1>::new}, val: Value(<ZST>) }
    }

    bb1: {
        _1 = move _2 as std::boxed::Box<dyn Tr1<As1 = S2>> (Pointer(Unsize)); // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:20:23: 20:35
        _0 = move _1 as std::boxed::Box<dyn Tr1<As1 = S2>> (Pointer(Unsize)); // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:20:23: 20:35
        return;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:20:37: 20:37
    }
}

fn use_et1() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:21:18: 21:18
    let _1: ();                          // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:21:20: 21:47
    let mut _2: Et1::{opaque#0};         // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:21:32: 21:46
    let mut _3: &dyn Tr1<As1 = Et1::{opaque#0}>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:21:32: 21:46
    let _4: std::boxed::Box<dyn Tr1<As1 = Et1::{opaque#0}>>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:21:32: 21:41
    let mut _5: *const dyn Tr1<As1 = Et1::{opaque#0}>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:21:32: 21:41

    bb0: {
        _4 = def_et1() -> bb1;           // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:21:32: 21:41
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:21:32: 21:39
                                         // + literal: Const { ty: fn() -> Box<(dyn Tr1<As1 = Et1::{opaque#0}> + 'static)> {def_et1}, val: Value(<ZST>) }
    }

    bb1: {
        _5 = (((_4.0: std::ptr::Unique<dyn Tr1<As1 = Et1::{opaque#0}>>).0: std::ptr::NonNull<dyn Tr1<As1 = Et1::{opaque#0}>>).0: *const dyn Tr1<As1 = Et1::{opaque#0}>); // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:21:32: 21:46
        _3 = &(*_5);                     // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:21:32: 21:46
        _2 = <dyn Tr1<As1 = Et1::{opaque#0}> as Tr1>::mk(move _3) -> [return: bb2, unwind: bb5]; // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:21:32: 21:46
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:21:42: 21:44
                                         // + literal: Const { ty: for<'a> fn(&'a dyn Tr1<As1 = Et1::{opaque#0}>) -> <dyn Tr1<As1 = Et1::{opaque#0}> as Tr1>::As1 {<dyn Tr1<As1 = Et1::{opaque#0}> as Tr1>::mk}, val: Value(<ZST>) }
    }

    bb2: {
        _1 = assert_copy::<Et1::{opaque#0}>(move _2) -> [return: bb3, unwind: bb5]; // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:21:20: 21:47
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:21:20: 21:31
                                         // + literal: Const { ty: fn(Et1::{opaque#0}) {assert_copy::<Et1::{opaque#0}>}, val: Value(<ZST>) }
    }

    bb3: {
        drop(_4) -> bb4;                 // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:21:47: 21:48
    }

    bb4: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:21:50: 21:50
    }

    bb5 (cleanup): {
        drop(_4) -> bb6;                 // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:21:47: 21:48
    }

    bb6 (cleanup): {
        resume;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:21:1: 21:50
    }
}

fn def_et2() -> Box<dyn Tr1<As1 = Et2::{opaque#0}>> {
    let mut _0: std::boxed::Box<dyn Tr1<As1 = Et2::{opaque#0}>>; // return place in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:24:17: 24:20
    let mut _1: std::boxed::Box<dyn Tr1<As1 = S2>>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:24:23: 24:35
    let mut _2: std::boxed::Box<S1>;     // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:24:23: 24:35
    let mut _3: S1;                      // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:24:32: 24:34

    bb0: {
        _2 = Box::<S1>::new(move _3) -> bb1; // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:24:23: 24:35
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:24:23: 24:31
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(S1) -> Box<S1> {Box::<S1>::new}, val: Value(<ZST>) }
    }

    bb1: {
        _1 = move _2 as std::boxed::Box<dyn Tr1<As1 = S2>> (Pointer(Unsize)); // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:24:23: 24:35
        _0 = move _1 as std::boxed::Box<dyn Tr1<As1 = S2>> (Pointer(Unsize)); // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:24:23: 24:35
        return;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:24:37: 24:37
    }
}

fn use_et2() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:25:18: 25:18
    let _1: ();                          // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:25:20: 25:49
    let mut _2: Et2::{opaque#0};         // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:25:34: 25:48
    let mut _3: &dyn Tr1<As1 = Et2::{opaque#0}>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:25:34: 25:48
    let _4: std::boxed::Box<dyn Tr1<As1 = Et2::{opaque#0}>>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:25:34: 25:43
    let mut _5: *const dyn Tr1<As1 = Et2::{opaque#0}>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:25:34: 25:43

    bb0: {
        _4 = def_et2() -> bb1;           // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:25:34: 25:43
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:25:34: 25:41
                                         // + literal: Const { ty: fn() -> Box<(dyn Tr1<As1 = Et2::{opaque#0}> + 'static)> {def_et2}, val: Value(<ZST>) }
    }

    bb1: {
        _5 = (((_4.0: std::ptr::Unique<dyn Tr1<As1 = Et2::{opaque#0}>>).0: std::ptr::NonNull<dyn Tr1<As1 = Et2::{opaque#0}>>).0: *const dyn Tr1<As1 = Et2::{opaque#0}>); // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:25:34: 25:48
        _3 = &(*_5);                     // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:25:34: 25:48
        _2 = <dyn Tr1<As1 = Et2::{opaque#0}> as Tr1>::mk(move _3) -> [return: bb2, unwind: bb5]; // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:25:34: 25:48
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:25:44: 25:46
                                         // + literal: Const { ty: for<'a> fn(&'a dyn Tr1<As1 = Et2::{opaque#0}>) -> <dyn Tr1<As1 = Et2::{opaque#0}> as Tr1>::As1 {<dyn Tr1<As1 = Et2::{opaque#0}> as Tr1>::mk}, val: Value(<ZST>) }
    }

    bb2: {
        _1 = assert_static::<Et2::{opaque#0}>(move _2) -> [return: bb3, unwind: bb5]; // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:25:20: 25:49
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:25:20: 25:33
                                         // + literal: Const { ty: fn(Et2::{opaque#0}) {assert_static::<Et2::{opaque#0}>}, val: Value(<ZST>) }
    }

    bb3: {
        drop(_4) -> bb4;                 // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:25:49: 25:50
    }

    bb4: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:25:52: 25:52
    }

    bb5 (cleanup): {
        drop(_4) -> bb6;                 // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:25:49: 25:50
    }

    bb6 (cleanup): {
        resume;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:25:1: 25:52
    }
}

fn def_et3() -> Box<dyn Tr1<As1 = Et3::{opaque#0}>> {
    let mut _0: std::boxed::Box<dyn Tr1<As1 = Et3::{opaque#0}>>; // return place in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:28:17: 28:20
    let mut _1: std::boxed::Box<dyn Tr1<As1 = std::ops::Range<u8>>>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:34:5: 34:16
    let mut _2: std::boxed::Box<def_et3::A>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:34:5: 34:16
    let mut _3: def_et3::A;              // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:34:14: 34:15

    bb0: {
        _2 = Box::<def_et3::A>::new(move _3) -> bb1; // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:34:5: 34:16
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:34:5: 34:13
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(def_et3::A) -> Box<def_et3::A> {Box::<def_et3::A>::new}, val: Value(<ZST>) }
    }

    bb1: {
        _1 = move _2 as std::boxed::Box<dyn Tr1<As1 = std::ops::Range<u8>>> (Pointer(Unsize)); // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:34:5: 34:16
        _0 = move _1 as std::boxed::Box<dyn Tr1<As1 = std::ops::Range<u8>>> (Pointer(Unsize)); // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:34:5: 34:16
        return;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:35:2: 35:2
    }
}

fn def_et3::<impl at ui/associated-type-bounds/dyn-impl-trait-type.rs:30:5: 30:19>::mk(_1: &def_et3::A) -> std::ops::Range<u8> {
    debug self => _1;                    // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:32:15: 32:20
    let mut _0: std::ops::Range<u8>;     // return place in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:32:25: 32:34

    bb0: {
        _0 = std::ops::Range::<u8> { start: const 0_u8, end: const 10_u8 }; // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:32:37: 32:42
        return;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:32:44: 32:44
    }
}

fn use_et3() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:36:18: 36:18
    let _1: Et3::{opaque#0};             // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:37:9: 37:11
    let mut _2: &Et3::{opaque#0};        // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:37:14: 37:36
    let _3: Et3::{opaque#0};             // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:37:14: 37:28
    let mut _4: &dyn Tr1<As1 = Et3::{opaque#0}>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:37:14: 37:28
    let _5: std::boxed::Box<dyn Tr1<As1 = Et3::{opaque#0}>>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:37:14: 37:23
    let mut _7: Et3::{opaque#0};         // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:15: 39:17
    let mut _8: Et3::{opaque#0};         // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:15: 39:17
    let mut _10: std::option::Option<impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:15: 39:17
    let mut _11: &mut Et3::{opaque#0};   // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:15: 39:17
    let mut _12: &mut Et3::{opaque#0};   // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:15: 39:17
    let mut _13: isize;                  // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:5: 42:6
    let mut _16: impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:40:18: 40:20
    let mut _17: u8;                     // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:41:14: 41:23
    let mut _18: impl std::convert::Into<u8>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:41:14: 41:16
    let mut _19: (u8, bool);             // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:41:9: 41:23
    let mut _20: (&u8, &u8);             // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:38:15: 38:32
    let mut _21: &u8;                    // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:38:16: 38:22
    let mut _22: &u8;                    // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:38:24: 38:31
    let _23: u8;                         // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:43:19: 43:47
    let mut _24: std::iter::Map<std::ops::Range<u8>, [closure@ui/associated-type-bounds/dyn-impl-trait-type.rs:43:31: 43:34]>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:43:19: 43:41
    let mut _25: std::ops::Range<u8>;    // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:43:19: 43:26
    let mut _26: [closure@ui/associated-type-bounds/dyn-impl-trait-type.rs:43:31: 43:34]; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:43:31: 43:40
    let mut _29: bool;                   // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:40:20: 40:46
    let mut _30: bool;                   // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:40:21: 40:46
    let mut _31: u8;                     // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:40:22: 40:31
    let mut _32: u8;                     // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:40:35: 40:45
    let _34: !;                          // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:21: 45:114
    let mut _35: core::panicking::AssertKind; // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:54: 45:58
    let mut _36: &u8;                    // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:60: 45:70
    let _37: &u8;                        // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:60: 45:70
    let mut _38: &u8;                    // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:72: 45:83
    let _39: &u8;                        // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:72: 45:83
    let mut _40: std::option::Option<std::fmt::Arguments<'_>>; // in scope 0 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:85: 45:113
    let mut _41: *const dyn Tr1<As1 = Et3::{opaque#0}>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:37:14: 37:23
    scope 1 {
        debug _0 => _1;                  // in scope 1 at ui/associated-type-bounds/dyn-impl-trait-type.rs:37:9: 37:11
        let mut _6: u8;                  // in scope 1 at ui/associated-type-bounds/dyn-impl-trait-type.rs:38:9: 38:14
        scope 2 {
            debug s => _6;               // in scope 2 at ui/associated-type-bounds/dyn-impl-trait-type.rs:38:9: 38:14
            let mut _9: Et3::{opaque#0}; // in scope 2 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:15: 39:17
            let _27: &u8;                // in scope 2 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:39:14: 39:22
            let _28: &u8;                // in scope 2 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:39:24: 39:33
            scope 3 {
                debug iter => _9;        // in scope 3 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:15: 39:17
                let _14: impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>; // in scope 3 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:9: 39:11
                scope 4 {
                    debug _1 => _14;     // in scope 4 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:9: 39:11
                    let _15: impl std::convert::Into<u8>; // in scope 4 at ui/associated-type-bounds/dyn-impl-trait-type.rs:40:13: 40:15
                    scope 5 {
                        debug _2 => _15; // in scope 5 at ui/associated-type-bounds/dyn-impl-trait-type.rs:40:13: 40:15
                    }
                }
            }
            scope 6 {
                debug left_val => _27;   // in scope 6 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:39:14: 39:22
                debug right_val => _28;  // in scope 6 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:39:24: 39:33
                let _33: core::panicking::AssertKind; // in scope 6 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:41:25: 41:29
                scope 7 {
                    debug kind => _33;   // in scope 7 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:41:25: 41:29
                }
            }
        }
    }

    bb0: {
        _5 = def_et3() -> bb1;           // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:37:14: 37:23
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:37:14: 37:21
                                         // + literal: Const { ty: fn() -> Box<(dyn Tr1<As1 = Et3::{opaque#0}> + 'static)> {def_et3}, val: Value(<ZST>) }
    }

    bb1: {
        _41 = (((_5.0: std::ptr::Unique<dyn Tr1<As1 = Et3::{opaque#0}>>).0: std::ptr::NonNull<dyn Tr1<As1 = Et3::{opaque#0}>>).0: *const dyn Tr1<As1 = Et3::{opaque#0}>); // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:37:14: 37:28
        _4 = &(*_41);                    // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:37:14: 37:28
        _3 = <dyn Tr1<As1 = Et3::{opaque#0}> as Tr1>::mk(move _4) -> [return: bb2, unwind: bb18]; // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:37:14: 37:28
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:37:24: 37:26
                                         // + literal: Const { ty: for<'a> fn(&'a dyn Tr1<As1 = Et3::{opaque#0}>) -> <dyn Tr1<As1 = Et3::{opaque#0}> as Tr1>::As1 {<dyn Tr1<As1 = Et3::{opaque#0}> as Tr1>::mk}, val: Value(<ZST>) }
    }

    bb2: {
        _2 = &_3;                        // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:37:14: 37:36
        _1 = <Et3::{opaque#0} as Clone>::clone(move _2) -> [return: bb3, unwind: bb18]; // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:37:14: 37:36
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:37:29: 37:34
                                         // + literal: Const { ty: for<'a> fn(&'a Et3::{opaque#0}) -> Et3::{opaque#0} {<Et3::{opaque#0} as Clone>::clone}, val: Value(<ZST>) }
    }

    bb3: {
        drop(_5) -> bb4;                 // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:37:36: 37:37
    }

    bb4: {
        _6 = const 0_u8;                 // scope 1 at ui/associated-type-bounds/dyn-impl-trait-type.rs:38:17: 38:20
        _8 = move _1;                    // scope 2 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:15: 39:17
        _7 = <Et3::{opaque#0} as IntoIterator>::into_iter(move _8) -> bb5; // scope 2 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:15: 39:17
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:39:15: 39:17
                                         // + literal: Const { ty: fn(Et3::{opaque#0}) -> <Et3::{opaque#0} as IntoIterator>::IntoIter {<Et3::{opaque#0} as IntoIterator>::into_iter}, val: Value(<ZST>) }
    }

    bb5: {
        _9 = move _7;                    // scope 2 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:15: 39:17
        goto -> bb6;                     // scope 3 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:5: 42:6
    }

    bb6: {
        _12 = &mut _9;                   // scope 3 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:15: 39:17
        _11 = &mut (*_12);               // scope 3 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:15: 39:17
        _10 = <Et3::{opaque#0} as Iterator>::next(move _11) -> bb7; // scope 3 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:15: 39:17
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:39:15: 39:17
                                         // + literal: Const { ty: for<'a> fn(&'a mut Et3::{opaque#0}) -> Option<<Et3::{opaque#0} as Iterator>::Item> {<Et3::{opaque#0} as Iterator>::next}, val: Value(<ZST>) }
    }

    bb7: {
        _13 = discriminant(_10);         // scope 3 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:15: 39:17
        switchInt(move _13) -> [0: bb10, 1: bb8, otherwise: bb9]; // scope 3 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:15: 39:17
    }

    bb8: {
        _14 = move ((_10 as Some).0: impl std::ops::Add<u8, Output = impl std::convert::Into<u8>>); // scope 3 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:9: 39:11
        _16 = move _14;                  // scope 4 at ui/associated-type-bounds/dyn-impl-trait-type.rs:40:18: 40:20
        _15 = <impl Add<u8, Output = impl Into<u8>> as Add<u8>>::add(move _16, const 1_u8) -> bb11; // scope 4 at ui/associated-type-bounds/dyn-impl-trait-type.rs:40:18: 40:26
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:40:18: 40:26
                                         // + literal: Const { ty: fn(impl Add<u8, Output = impl Into<u8>>, u8) -> <impl Add<u8, Output = impl Into<u8>> as Add<u8>>::Output {<impl Add<u8, Output = impl Into<u8>> as Add<u8>>::add}, val: Value(<ZST>) }
    }

    bb9: {
        unreachable;                     // scope 3 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:15: 39:17
    }

    bb10: {
        _21 = &_6;                       // scope 2 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:38:16: 38:22
        _25 = std::ops::Range::<u8> { start: const 0_u8, end: const 10_u8 }; // scope 2 at ui/associated-type-bounds/dyn-impl-trait-type.rs:43:19: 43:26
        _24 = <std::ops::Range<u8> as Iterator>::map::<u8, [closure@ui/associated-type-bounds/dyn-impl-trait-type.rs:43:31: 43:34]>(move _25, move _26) -> bb14; // scope 2 at ui/associated-type-bounds/dyn-impl-trait-type.rs:43:19: 43:41
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:43:27: 43:30
                                         // + literal: Const { ty: fn(std::ops::Range<u8>, [closure@ui/associated-type-bounds/dyn-impl-trait-type.rs:43:31: 43:34]) -> Map<std::ops::Range<u8>, [closure@ui/associated-type-bounds/dyn-impl-trait-type.rs:43:31: 43:34]> {<std::ops::Range<u8> as Iterator>::map::<u8, [closure@ui/associated-type-bounds/dyn-impl-trait-type.rs:43:31: 43:34]>}, val: Value(<ZST>) }
    }

    bb11: {
        _18 = move _15;                  // scope 5 at ui/associated-type-bounds/dyn-impl-trait-type.rs:41:14: 41:16
        _17 = <impl Into<u8> as Into<u8>>::into(move _18) -> bb12; // scope 5 at ui/associated-type-bounds/dyn-impl-trait-type.rs:41:14: 41:23
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:41:17: 41:21
                                         // + literal: Const { ty: fn(impl Into<u8>) -> u8 {<impl Into<u8> as Into<u8>>::into}, val: Value(<ZST>) }
    }

    bb12: {
        _19 = CheckedAdd(_6, _17);       // scope 5 at ui/associated-type-bounds/dyn-impl-trait-type.rs:41:9: 41:23
        assert(!move (_19.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, move _17) -> bb13; // scope 5 at ui/associated-type-bounds/dyn-impl-trait-type.rs:41:9: 41:23
    }

    bb13: {
        _6 = move (_19.0: u8);           // scope 5 at ui/associated-type-bounds/dyn-impl-trait-type.rs:41:9: 41:23
        goto -> bb6;                     // scope 3 at ui/associated-type-bounds/dyn-impl-trait-type.rs:39:5: 42:6
    }

    bb14: {
        _23 = <Map<std::ops::Range<u8>, [closure@ui/associated-type-bounds/dyn-impl-trait-type.rs:43:31: 43:34]> as Iterator>::sum::<u8>(move _24) -> bb15; // scope 2 at ui/associated-type-bounds/dyn-impl-trait-type.rs:43:19: 43:47
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:43:42: 43:45
                                         // + literal: Const { ty: fn(Map<std::ops::Range<u8>, [closure@ui/associated-type-bounds/dyn-impl-trait-type.rs:43:31: 43:34]>) -> u8 {<Map<std::ops::Range<u8>, [closure@ui/associated-type-bounds/dyn-impl-trait-type.rs:43:31: 43:34]> as Iterator>::sum::<u8>}, val: Value(<ZST>) }
    }

    bb15: {
        _22 = &_23;                      // scope 2 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:38:24: 38:31
        _20 = (move _21, move _22);      // scope 2 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:38:15: 38:32
        _27 = (_20.0: &u8);              // scope 2 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:39:14: 39:22
        _28 = (_20.1: &u8);              // scope 2 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:39:24: 39:33
        _31 = (*_27);                    // scope 6 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:40:22: 40:31
        _32 = (*_28);                    // scope 6 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:40:35: 40:45
        _30 = Eq(move _31, move _32);    // scope 6 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:40:21: 40:46
        _29 = Not(move _30);             // scope 6 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:40:20: 40:46
        switchInt(move _29) -> [0: bb17, otherwise: bb16]; // scope 6 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:40:20: 40:46
    }

    bb16: {
        _33 = const core::panicking::AssertKind::Eq; // scope 6 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:41:32: 41:65
                                         // mir::Constant
                                         // + span: /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:41:32: 41:65
                                         // + literal: Const { ty: AssertKind, val: Value(Scalar(0x00)) }
        _35 = const core::panicking::AssertKind::Eq; // scope 7 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:54: 45:58
                                         // mir::Constant
                                         // + span: /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:54: 45:58
                                         // + literal: Const { ty: AssertKind, val: Value(Scalar(0x00)) }
        _37 = _27;                       // scope 7 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:60: 45:70
        _36 = _37;                       // scope 7 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:60: 45:70
        _39 = _28;                       // scope 7 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:72: 45:83
        _38 = _39;                       // scope 7 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:72: 45:83
        _40 = Option::<Arguments<'_>>::None; // scope 7 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:85: 45:113
        _34 = assert_failed::<u8, u8>(move _35, move _36, move _38, move _40); // scope 7 at /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:21: 45:114
                                         // mir::Constant
                                         // + span: /rustc/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd/library/core/src/macros/mod.rs:45:21: 45:53
                                         // + literal: Const { ty: for<'a, 'b, 'c> fn(AssertKind, &'a u8, &'b u8, Option<Arguments<'c>>) -> ! {assert_failed::<u8, u8>}, val: Value(<ZST>) }
    }

    bb17: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:44:2: 44:2
    }

    bb18 (cleanup): {
        drop(_5) -> bb19;                // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:37:36: 37:37
    }

    bb19 (cleanup): {
        resume;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:36:1: 44:2
    }
}

fn use_et3::{closure#0}(_1: &mut [closure@ui/associated-type-bounds/dyn-impl-trait-type.rs:43:31: 43:34], _2: u8) -> u8 {
    debug x => _2;                       // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:43:32: 43:33
    let mut _0: u8;                      // return place in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:43:35: 43:35
    let mut _3: u8;                      // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:43:35: 43:36
    let mut _4: (u8, bool);              // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:43:35: 43:40

    bb0: {
        _3 = _2;                         // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:43:35: 43:36
        _4 = CheckedAdd(_3, const 1_u8); // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:43:35: 43:40
        assert(!move (_4.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3, const 1_u8) -> bb1; // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:43:35: 43:40
    }

    bb1: {
        _0 = move (_4.0: u8);            // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:43:35: 43:40
        return;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:43:40: 43:40
    }
}

fn def_et4() -> Box<dyn Tr1<As1 = Et4::{opaque#0}>> {
    let mut _0: std::boxed::Box<dyn Tr1<As1 = Et4::{opaque#0}>>; // return place in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:47:17: 47:20
    let mut _1: std::boxed::Box<dyn Tr1<As1 = def_et4::A>>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:57:5: 57:16
    let mut _2: std::boxed::Box<def_et4::A>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:57:5: 57:16
    let mut _3: def_et4::A;              // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:57:14: 57:15

    bb0: {
        _2 = Box::<def_et4::A>::new(move _3) -> bb1; // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:57:5: 57:16
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:57:5: 57:13
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: fn(def_et4::A) -> Box<def_et4::A> {Box::<def_et4::A>::new}, val: Value(<ZST>) }
    }

    bb1: {
        _1 = move _2 as std::boxed::Box<dyn Tr1<As1 = def_et4::A>> (Pointer(Unsize)); // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:57:5: 57:16
        _0 = move _1 as std::boxed::Box<dyn Tr1<As1 = def_et4::A>> (Pointer(Unsize)); // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:57:5: 57:16
        return;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:58:2: 58:2
    }
}

fn def_et4::<impl at ui/associated-type-bounds/dyn-impl-trait-type.rs:48:20: 48:25>::clone(_1: &def_et4::A) -> def_et4::A {
    debug self => _1;                    // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:48:20: 48:25
    let mut _0: def_et4::A;              // return place in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:48:20: 48:25

    bb0: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:48:25: 48:25
    }
}

fn def_et4::<impl at ui/associated-type-bounds/dyn-impl-trait-type.rs:50:5: 50:19>::mk(_1: &def_et4::A) -> def_et4::A {
    debug self => _1;                    // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:52:15: 52:20
    let mut _0: def_et4::A;              // return place in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:52:25: 52:26

    bb0: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:52:32: 52:32
    }
}

fn def_et4::<impl at ui/associated-type-bounds/dyn-impl-trait-type.rs:54:5: 54:27>::tr2(_1: def_et4::A) -> &def_et4::A {
    debug self => _1;                    // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:55:16: 55:20
    let mut _0: &def_et4::A;             // return place in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:55:36: 55:38
    let mut _2: &def_et4::A;             // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:55:36: 55:38

    bb0: {
        _2 = const _;                    // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:55:36: 55:38
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:55:36: 55:38
                                         // + literal: Const { ty: &def_et4::A, val: Unevaluated(<def_et4::A as Tr2<'a>>::tr2, [ReErased], Some(promoted[0])) }
        _0 = _2;                         // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:55:36: 55:38
        return;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:55:40: 55:40
    }
}

promoted[0] in def_et4::<impl at ui/associated-type-bounds/dyn-impl-trait-type.rs:54:5: 54:27>::tr2: &def_et4::A = {
    let mut _0: &def_et4::A;             // return place in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:55:36: 55:38
    let mut _1: def_et4::A;              // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:55:37: 55:38

    bb0: {
        _1 = def_et4::A;                 // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:55:37: 55:38
        _0 = &_1;                        // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:55:36: 55:38
        return;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:55:36: 55:38
    }
}

fn use_et4() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:59:18: 59:18
    let _1: ();                          // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:59:20: 59:53
    let mut _2: Et4::{opaque#0};         // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:59:38: 59:52
    let mut _3: &dyn Tr1<As1 = Et4::{opaque#0}>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:59:38: 59:52
    let _4: std::boxed::Box<dyn Tr1<As1 = Et4::{opaque#0}>>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:59:38: 59:47
    let mut _5: *const dyn Tr1<As1 = Et4::{opaque#0}>; // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:59:38: 59:47

    bb0: {
        _4 = def_et4() -> bb1;           // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:59:38: 59:47
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:59:38: 59:45
                                         // + literal: Const { ty: fn() -> Box<(dyn Tr1<As1 = Et4::{opaque#0}> + 'static)> {def_et4}, val: Value(<ZST>) }
    }

    bb1: {
        _5 = (((_4.0: std::ptr::Unique<dyn Tr1<As1 = Et4::{opaque#0}>>).0: std::ptr::NonNull<dyn Tr1<As1 = Et4::{opaque#0}>>).0: *const dyn Tr1<As1 = Et4::{opaque#0}>); // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:59:38: 59:52
        _3 = &(*_5);                     // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:59:38: 59:52
        _2 = <dyn Tr1<As1 = Et4::{opaque#0}> as Tr1>::mk(move _3) -> [return: bb2, unwind: bb5]; // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:59:38: 59:52
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:59:48: 59:50
                                         // + literal: Const { ty: for<'a> fn(&'a dyn Tr1<As1 = Et4::{opaque#0}>) -> <dyn Tr1<As1 = Et4::{opaque#0}> as Tr1>::As1 {<dyn Tr1<As1 = Et4::{opaque#0}> as Tr1>::mk}, val: Value(<ZST>) }
    }

    bb2: {
        _1 = assert_forall_tr2::<Et4::{opaque#0}>(move _2) -> [return: bb3, unwind: bb5]; // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:59:20: 59:53
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:59:20: 59:37
                                         // + literal: Const { ty: fn(Et4::{opaque#0}) {assert_forall_tr2::<Et4::{opaque#0}>}, val: Value(<ZST>) }
    }

    bb3: {
        drop(_4) -> bb4;                 // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:59:53: 59:54
    }

    bb4: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:59:56: 59:56
    }

    bb5 (cleanup): {
        drop(_4) -> bb6;                 // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:59:53: 59:54
    }

    bb6 (cleanup): {
        resume;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:59:1: 59:56
    }
}

fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:61:11: 61:11
    let mut _1: ();                      // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:62:13: 62:22
    let mut _2: ();                      // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:63:13: 63:22
    let mut _3: ();                      // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:64:13: 64:22
    let mut _4: ();                      // in scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:65:13: 65:22
    scope 1 {
        scope 2 {
            scope 3 {
                scope 4 {
                }
            }
        }
    }

    bb0: {
        _1 = use_et1() -> bb1;           // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:62:13: 62:22
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:62:13: 62:20
                                         // + literal: Const { ty: fn() {use_et1}, val: Value(<ZST>) }
    }

    bb1: {
        _2 = use_et2() -> bb2;           // scope 1 at ui/associated-type-bounds/dyn-impl-trait-type.rs:63:13: 63:22
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:63:13: 63:20
                                         // + literal: Const { ty: fn() {use_et2}, val: Value(<ZST>) }
    }

    bb2: {
        _3 = use_et3() -> bb3;           // scope 2 at ui/associated-type-bounds/dyn-impl-trait-type.rs:64:13: 64:22
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:64:13: 64:20
                                         // + literal: Const { ty: fn() {use_et3}, val: Value(<ZST>) }
    }

    bb3: {
        _4 = use_et4() -> bb4;           // scope 3 at ui/associated-type-bounds/dyn-impl-trait-type.rs:65:13: 65:22
                                         // mir::Constant
                                         // + span: ui/associated-type-bounds/dyn-impl-trait-type.rs:65:13: 65:20
                                         // + literal: Const { ty: fn() {use_et4}, val: Value(<ZST>) }
    }

    bb4: {
        return;                          // scope 0 at ui/associated-type-bounds/dyn-impl-trait-type.rs:66:2: 66:2
    }
}
