// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn wrap_en1_1(_1: T) -> En1<T> {
    debug x => _1;
    let mut _0: En1<T>;

    bb0: {
        _0 = En1::<T>::Outest(move _1);
        return;
    }
}

fn wrap_en1_2(_1: <T as Tr1>::As1) -> En1<T> {
    debug x => _1;
    let mut _0: En1<T>;

    bb0: {
        _0 = En1::<T>::Outer(move _1);
        return;
    }
}

fn wrap_en1_3(_1: <<T as Tr1>::As1 as Tr2>::As2) -> En1<T> {
    debug x => _1;
    let mut _0: En1<T>;

    bb0: {
        _0 = En1::<T>::Inner(move _1);
        return;
    }
}

fn _make_en7(_1: _En7<'_, '_, T>) -> () {
    debug x => _1;
    let mut _0: ();
    let mut _2: isize;
    let _3: &T;
    scope 1 {
        debug x => _3;
        scope 2 {
        }
    }

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb2, 1: bb3, otherwise: bb1];
    }

    bb1: {
        unreachable;
    }

    bb2: {
        _3 = ((_1 as V0).0: &T);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let mut _1: En1<&str>;
    let mut _2: bool;
    let mut _3: isize;
    let mut _4: !;
    let mut _5: En1<&str>;
    let mut _6: isize;
    let mut _7: !;
    let mut _8: En1<&str>;
    let mut _9: isize;
    let mut _10: !;
    scope 1 {
    }
    scope 2 {
    }
    scope 3 {
    }
    scope 4 {
        scope 5 {
            scope 6 {
                scope 7 {
                    scope 8 {
                        scope 9 {
                            let _11: (u8,);
                            scope 10 {
                                debug f1 => _11;
                                let _12: (u8,);
                                scope 11 {
                                    debug f2 => _12;
                                    scope 12 {
                                        scope 13 {
                                            scope 14 {
                                                scope 15 {
                                                    scope 16 {
                                                        scope 17 {
                                                            scope 18 {
                                                                scope 19 {
                                                                    scope 20 {
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _1 = wrap_en1_1::<&str>(const "foo") -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = discriminant(_1);
        switchInt(move _3) -> [0: bb2, otherwise: bb5];
    }

    bb2: {
        _2 = <str as PartialEq>::eq(((_1 as Outest).0: &str), const "foo") -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _2) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _5 = wrap_en1_2::<&str>(const true) -> [return: bb6, unwind continue];
    }

    bb5: {
        _4 = begin_panic::<&str>(const "explicit panic") -> unwind continue;
    }

    bb6: {
        _6 = discriminant(_5);
        switchInt(move _6) -> [1: bb7, otherwise: bb9];
    }

    bb7: {
        switchInt(((_5 as Outer).0: bool)) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _8 = wrap_en1_3::<&str>(const 24_u8) -> [return: bb10, unwind continue];
    }

    bb9: {
        _7 = begin_panic::<&str>(const "explicit panic") -> unwind continue;
    }

    bb10: {
        _9 = discriminant(_8);
        switchInt(move _9) -> [2: bb11, otherwise: bb13];
    }

    bb11: {
        switchInt(((_8 as Inner).0: u8)) -> [24: bb12, otherwise: bb13];
    }

    bb12: {
        _11 = (const 1_u8,);
        _12 = (const 2_u8,);
        return;
    }

    bb13: {
        _10 = begin_panic::<&str>(const "explicit panic") -> unwind continue;
    }
}

promoted[0] in main: &bool = {
    let mut _0: &bool;
    let mut _1: bool;

    bb0: {
        _1 = const false;
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &bool = {
    let mut _0: &bool;
    let mut _1: bool;

    bb0: {
        _1 = const true;
        _0 = &_1;
        return;
    }
}

fn main::{closure#0}(_1: &[closure@ui/associated-type-bounds/enum-bounds.rs:105:29: 105:31]) -> u8 {
    let mut _0: u8;

    bb0: {
        _0 = const 12_u8;
        return;
    }
}

fn En1::Outest(_1: T) -> En1<T> {
    let mut _0: En1<T>;

    bb0: {
        _0 = En1::<T>::Outest(move _1);
        return;
    }
}

// MIR FOR CTFE
fn En1::Outest(_1: T) -> En1<T> {
    let mut _0: En1<T>;

    bb0: {
        _0 = En1::<T>::Outest(move _1);
        return;
    }
}

fn En1::Outer(_1: <T as Tr1>::As1) -> En1<T> {
    let mut _0: En1<T>;

    bb0: {
        _0 = En1::<T>::Outer(move _1);
        return;
    }
}

// MIR FOR CTFE
fn En1::Outer(_1: <T as Tr1>::As1) -> En1<T> {
    let mut _0: En1<T>;

    bb0: {
        _0 = En1::<T>::Outer(move _1);
        return;
    }
}

fn En1::Inner(_1: <<T as Tr1>::As1 as Tr2>::As2) -> En1<T> {
    let mut _0: En1<T>;

    bb0: {
        _0 = En1::<T>::Inner(move _1);
        return;
    }
}

// MIR FOR CTFE
fn En1::Inner(_1: <<T as Tr1>::As1 as Tr2>::As2) -> En1<T> {
    let mut _0: En1<T>;

    bb0: {
        _0 = En1::<T>::Inner(move _1);
        return;
    }
}

fn En2::V0(_1: T) -> En2<T> {
    let mut _0: En2<T>;

    bb0: {
        _0 = En2::<T>::V0(move _1);
        return;
    }
}

// MIR FOR CTFE
fn En2::V0(_1: T) -> En2<T> {
    let mut _0: En2<T>;

    bb0: {
        _0 = En2::<T>::V0(move _1);
        return;
    }
}

fn En2::V1(_1: <T as Tr1>::As1) -> En2<T> {
    let mut _0: En2<T>;

    bb0: {
        _0 = En2::<T>::V1(move _1);
        return;
    }
}

// MIR FOR CTFE
fn En2::V1(_1: <T as Tr1>::As1) -> En2<T> {
    let mut _0: En2<T>;

    bb0: {
        _0 = En2::<T>::V1(move _1);
        return;
    }
}

fn En2::V2(_1: <<T as Tr1>::As1 as Tr2>::As2) -> En2<T> {
    let mut _0: En2<T>;

    bb0: {
        _0 = En2::<T>::V2(move _1);
        return;
    }
}

// MIR FOR CTFE
fn En2::V2(_1: <<T as Tr1>::As1 as Tr2>::As2) -> En2<T> {
    let mut _0: En2<T>;

    bb0: {
        _0 = En2::<T>::V2(move _1);
        return;
    }
}

fn En2::V3(_1: <<<T as Tr1>::As1 as Tr2>::As2 as Tr3>::As3) -> En2<T> {
    let mut _0: En2<T>;

    bb0: {
        _0 = En2::<T>::V3(move _1);
        return;
    }
}

// MIR FOR CTFE
fn En2::V3(_1: <<<T as Tr1>::As1 as Tr2>::As2 as Tr3>::As3) -> En2<T> {
    let mut _0: En2<T>;

    bb0: {
        _0 = En2::<T>::V3(move _1);
        return;
    }
}

fn En3::V0(_1: T) -> En3<T> {
    let mut _0: En3<T>;

    bb0: {
        _0 = En3::<T>::V0(move _1);
        return;
    }
}

// MIR FOR CTFE
fn En3::V0(_1: T) -> En3<T> {
    let mut _0: En3<T>;

    bb0: {
        _0 = En3::<T>::V0(move _1);
        return;
    }
}

fn En3::V1(_1: &<T as Tr1>::As1) -> En3<T> {
    let mut _0: En3<T>;

    bb0: {
        _0 = En3::<T>::V1(move _1);
        return;
    }
}

// MIR FOR CTFE
fn En3::V1(_1: &<T as Tr1>::As1) -> En3<T> {
    let mut _0: En3<T>;

    bb0: {
        _0 = En3::<T>::V1(move _1);
        return;
    }
}

fn En4::V0(_1: &<<T as Tr1>::As1 as Tr4<'_>>::As4) -> En4<'_, '_, T> {
    let mut _0: En4<'_, '_, T>;

    bb0: {
        _0 = En4::<'_, '_, T>::V0(move _1);
        return;
    }
}

// MIR FOR CTFE
fn En4::V0(_1: &<<T as Tr1>::As1 as Tr4<'_>>::As4) -> En4<'_, '_, T> {
    let mut _0: En4<'_, '_, T>;

    bb0: {
        _0 = En4::<'_, '_, T>::V0(move _1);
        return;
    }
}

fn En4::V1(_1: &<<T as Tr1>::As1 as Tr4<'_>>::As4) -> En4<'_, '_, T> {
    let mut _0: En4<'_, '_, T>;

    bb0: {
        _0 = En4::<'_, '_, T>::V1(move _1);
        return;
    }
}

// MIR FOR CTFE
fn En4::V1(_1: &<<T as Tr1>::As1 as Tr4<'_>>::As4) -> En4<'_, '_, T> {
    let mut _0: En4<'_, '_, T>;

    bb0: {
        _0 = En4::<'_, '_, T>::V1(move _1);
        return;
    }
}

fn _En5::_V0(_1: &<<T as Tr1>::As1 as Tr4<'_>>::As4) -> _En5<'_, '_, T> {
    let mut _0: _En5<'_, '_, T>;

    bb0: {
        _0 = _En5::<'_, '_, T>::_V0(move _1);
        return;
    }
}

// MIR FOR CTFE
fn _En5::_V0(_1: &<<T as Tr1>::As1 as Tr4<'_>>::As4) -> _En5<'_, '_, T> {
    let mut _0: _En5<'_, '_, T>;

    bb0: {
        _0 = _En5::<'_, '_, T>::_V0(move _1);
        return;
    }
}

fn _En5::_V1(_1: &<<T as Tr1>::As1 as Tr4<'_>>::As4) -> _En5<'_, '_, T> {
    let mut _0: _En5<'_, '_, T>;

    bb0: {
        _0 = _En5::<'_, '_, T>::_V1(move _1);
        return;
    }
}

// MIR FOR CTFE
fn _En5::_V1(_1: &<<T as Tr1>::As1 as Tr4<'_>>::As4) -> _En5<'_, '_, T> {
    let mut _0: _En5<'_, '_, T>;

    bb0: {
        _0 = _En5::<'_, '_, T>::_V1(move _1);
        return;
    }
}

fn En6::V0(_1: T) -> En6<T> {
    let mut _0: En6<T>;

    bb0: {
        _0 = En6::<T>::V0(move _1);
        return;
    }
}

// MIR FOR CTFE
fn En6::V0(_1: T) -> En6<T> {
    let mut _0: En6<T>;

    bb0: {
        _0 = En6::<T>::V0(move _1);
        return;
    }
}

fn En6::V1(_1: <<T as Tr1>::As1 as Tr2>::As2) -> En6<T> {
    let mut _0: En6<T>;

    bb0: {
        _0 = En6::<T>::V1(move _1);
        return;
    }
}

// MIR FOR CTFE
fn En6::V1(_1: <<T as Tr1>::As1 as Tr2>::As2) -> En6<T> {
    let mut _0: En6<T>;

    bb0: {
        _0 = En6::<T>::V1(move _1);
        return;
    }
}

fn En6::V2(_1: &<T as Tr1>::As1) -> En6<T> {
    let mut _0: En6<T>;

    bb0: {
        _0 = En6::<T>::V2(move _1);
        return;
    }
}

// MIR FOR CTFE
fn En6::V2(_1: &<T as Tr1>::As1) -> En6<T> {
    let mut _0: En6<T>;

    bb0: {
        _0 = En6::<T>::V2(move _1);
        return;
    }
}

fn En6::V3(_1: <<T as Tr1>::As1 as Tr5>::As5) -> En6<T> {
    let mut _0: En6<T>;

    bb0: {
        _0 = En6::<T>::V3(move _1);
        return;
    }
}

// MIR FOR CTFE
fn En6::V3(_1: <<T as Tr1>::As1 as Tr5>::As5) -> En6<T> {
    let mut _0: En6<T>;

    bb0: {
        _0 = En6::<T>::V3(move _1);
        return;
    }
}

fn _En7::V0(_1: &T) -> _En7<'_, '_, T> {
    let mut _0: _En7<'_, '_, T>;

    bb0: {
        _0 = _En7::<'_, '_, T>::V0(move _1);
        return;
    }
}

// MIR FOR CTFE
fn _En7::V0(_1: &T) -> _En7<'_, '_, T> {
    let mut _0: _En7<'_, '_, T>;

    bb0: {
        _0 = _En7::<'_, '_, T>::V0(move _1);
        return;
    }
}

fn _En7::V1(_1: &<<T as Tr1>::As1 as Tr2>::As2) -> _En7<'_, '_, T> {
    let mut _0: _En7<'_, '_, T>;

    bb0: {
        _0 = _En7::<'_, '_, T>::V1(move _1);
        return;
    }
}

// MIR FOR CTFE
fn _En7::V1(_1: &<<T as Tr1>::As1 as Tr2>::As2) -> _En7<'_, '_, T> {
    let mut _0: _En7<'_, '_, T>;

    bb0: {
        _0 = _En7::<'_, '_, T>::V1(move _1);
        return;
    }
}

fn EnSelf::V0(_1: T) -> EnSelf<T> {
    let mut _0: EnSelf<T>;

    bb0: {
        _0 = EnSelf::<T>::V0(move _1);
        return;
    }
}

// MIR FOR CTFE
fn EnSelf::V0(_1: T) -> EnSelf<T> {
    let mut _0: EnSelf<T>;

    bb0: {
        _0 = EnSelf::<T>::V0(move _1);
        return;
    }
}

fn EnSelf::V1(_1: <EnSelf<T> as Tr1>::As1) -> EnSelf<T> {
    let mut _0: EnSelf<T>;

    bb0: {
        _0 = EnSelf::<T>::V1(move _1);
        return;
    }
}

// MIR FOR CTFE
fn EnSelf::V1(_1: <EnSelf<T> as Tr1>::As1) -> EnSelf<T> {
    let mut _0: EnSelf<T>;

    bb0: {
        _0 = EnSelf::<T>::V1(move _1);
        return;
    }
}

fn EnSelf::V2(_1: <<EnSelf<T> as Tr1>::As1 as Tr2>::As2) -> EnSelf<T> {
    let mut _0: EnSelf<T>;

    bb0: {
        _0 = EnSelf::<T>::V2(move _1);
        return;
    }
}

// MIR FOR CTFE
fn EnSelf::V2(_1: <<EnSelf<T> as Tr1>::As1 as Tr2>::As2) -> EnSelf<T> {
    let mut _0: EnSelf<T>;

    bb0: {
        _0 = EnSelf::<T>::V2(move _1);
        return;
    }
}
