// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn unwrap_1_st1(_1: St1<T>) -> (T, <T as Tr1>::As1, <<T as Tr1>::As1 as Tr2>::As2) {
    debug x => _1;
    let mut _0: (T, <T as Tr1>::As1, <<T as Tr1>::As1 as Tr2>::As2);
    let mut _2: T;
    let mut _3: <T as Tr1>::As1;
    let mut _4: <<T as Tr1>::As1 as Tr2>::As2;

    bb0: {
        _2 = move (_1.0: T);
        _3 = move (_1.1: <T as Tr1>::As1);
        _4 = move (_1.2: <<T as Tr1>::As1 as Tr2>::As2);
        _0 = (move _2, move _3, move _4);
        return;
    }
}

fn unwrap_2_st1(_1: St1<T>) -> (T, <T as Tr1>::As1, <<T as Tr1>::As1 as Tr2>::As2) {
    debug x => _1;
    let mut _0: (T, <T as Tr1>::As1, <<T as Tr1>::As1 as Tr2>::As2);

    bb0: {
        _0 = unwrap_1_st1::<T>(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn _use_st7(_1: St7<'_, '_, T>) -> () {
    debug x => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: St1<&str>;
    let mut _2: (&(&str, bool, u8), &(&str, bool, u8));
    let mut _3: &(&str, bool, u8);
    let _4: (&str, bool, u8);
    let mut _7: bool;
    let mut _8: bool;
    let _10: !;
    let mut _11: std::option::Option<std::fmt::Arguments<'_>>;
    let _15: &u8;
    let _16: &u8;
    let mut _17: (&(&u8, &u8), &(&u8, &u8));
    let mut _18: &(&u8, &u8);
    let _19: (&u8, &u8);
    let mut _20: &u8;
    let mut _21: &u8;
    let mut _24: bool;
    let mut _25: bool;
    let _27: !;
    let mut _28: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _30: (&(&str, u8, &bool, u16), &(&str, u8, &bool, u16));
    let mut _31: &(&str, u8, &bool, u16);
    let _32: (&str, u8, &bool, u16);
    let mut _33: &str;
    let mut _34: u8;
    let mut _35: &bool;
    let mut _36: u16;
    let mut _39: bool;
    let mut _40: bool;
    let _42: !;
    let mut _43: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _45: (&u8, &u8);
    let mut _46: &u8;
    let mut _49: bool;
    let mut _50: bool;
    let mut _51: u8;
    let mut _52: u8;
    let _54: !;
    let mut _55: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug st1 => _1;
        let _5: &(&str, bool, u8);
        let _6: &(&str, bool, u8);
        let mut _60: &(&str, bool, u8);
        scope 2 {
            debug left_val => _5;
            debug right_val => _6;
            let _9: core::panicking::AssertKind;
            scope 3 {
                debug kind => _9;
            }
        }
        scope 4 {
            scope 5 {
                let _12: (u8,);
                scope 6 {
                    debug f1 => _12;
                    let _13: (u8,);
                    scope 7 {
                        debug f2 => _13;
                        let _14: St4<'_, '_, ()>;
                        scope 8 {
                            debug st4 => _14;
                            let _22: &(&u8, &u8);
                            let _23: &(&u8, &u8);
                            let _29: St6<&str>;
                            let mut _58: &bool;
                            let mut _59: &(&u8, &u8);
                            scope 9 {
                                debug left_val => _22;
                                debug right_val => _23;
                                let _26: core::panicking::AssertKind;
                                scope 10 {
                                    debug kind => _26;
                                }
                            }
                            scope 11 {
                                debug st6 => _29;
                                let _37: &(&str, u8, &bool, u16);
                                let _38: &(&str, u8, &bool, u16);
                                let _44: StSelf<&str>;
                                let mut _57: &(&str, u8, &bool, u16);
                                scope 12 {
                                    debug left_val => _37;
                                    debug right_val => _38;
                                    let _41: core::panicking::AssertKind;
                                    scope 13 {
                                        debug kind => _41;
                                    }
                                }
                                scope 14 {
                                    debug stself => _44;
                                    let _47: &u8;
                                    let _48: &u8;
                                    let mut _56: &u8;
                                    scope 15 {
                                        debug left_val => _47;
                                        debug right_val => _48;
                                        let _53: core::panicking::AssertKind;
                                        scope 16 {
                                            debug kind => _53;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _1 = St1::<&str> { outest: const "foo", outer: const true, inner: const 42_u8 };
        _60 = const _;
        _4 = unwrap_1_st1::<&str>(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = &_4;
        _2 = (_60, move _3);
        _5 = (_2.0: &(&str, bool, u8));
        _6 = (_2.1: &(&str, bool, u8));
        _8 = <(&str, bool, u8) as PartialEq>::eq(_5, _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = Not(move _8);
        switchInt(move _7) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _9 = core::panicking::AssertKind::Eq;
        _11 = Option::<Arguments<'_>>::None;
        _10 = core::panicking::assert_failed::<(&str, bool, u8), (&str, bool, u8)>(move _9, _5, _6, move _11) -> unwind continue;
    }

    bb4: {
        _12 = (const 1_u8,);
        _13 = (const 2_u8,);
        _15 = &(_12.0: u8);
        _16 = &(_13.0: u8);
        _14 = St4::<'_, '_, ()> { f1: _15, f2: _16 };
        _59 = const _;
        _20 = (_14.0: &u8);
        _21 = (_14.1: &u8);
        _19 = (move _20, move _21);
        _18 = &_19;
        _17 = (_59, move _18);
        _22 = (_17.0: &(&u8, &u8));
        _23 = (_17.1: &(&u8, &u8));
        _25 = <(&u8, &u8) as PartialEq>::eq(_22, _23) -> [return: bb5, unwind continue];
    }

    bb5: {
        _24 = Not(move _25);
        switchInt(move _24) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _26 = core::panicking::AssertKind::Eq;
        _28 = Option::<Arguments<'_>>::None;
        _27 = core::panicking::assert_failed::<(&u8, &u8), (&u8, &u8)>(move _26, _22, _23, move _28) -> unwind continue;
    }

    bb7: {
        _58 = const _;
        _29 = St6::<&str> { f0: const "bar", f1: const 24_u8, f2: _58, f3: const 12_u16 };
        _57 = const _;
        _33 = (_29.0: &str);
        _34 = (_29.1: u8);
        _35 = (_29.2: &bool);
        _36 = (_29.3: u16);
        _32 = (move _33, move _34, move _35, move _36);
        _31 = &_32;
        _30 = (_57, move _31);
        _37 = (_30.0: &(&str, u8, &bool, u16));
        _38 = (_30.1: &(&str, u8, &bool, u16));
        _40 = <(&str, u8, &bool, u16) as PartialEq>::eq(_37, _38) -> [return: bb8, unwind continue];
    }

    bb8: {
        _39 = Not(move _40);
        switchInt(move _39) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _41 = core::panicking::AssertKind::Eq;
        _43 = Option::<Arguments<'_>>::None;
        _42 = core::panicking::assert_failed::<(&str, u8, &bool, u16), (&str, u8, &bool, u16)>(move _41, _37, _38, move _43) -> unwind continue;
    }

    bb10: {
        _44 = StSelf::<&str> { f2: const 42_u8 };
        _46 = &(_44.0: u8);
        _56 = const _;
        _45 = (move _46, _56);
        _47 = (_45.0: &u8);
        _48 = (_45.1: &u8);
        _51 = (*_47);
        _52 = (*_48);
        _50 = Eq(move _51, move _52);
        _49 = Not(move _50);
        switchInt(move _49) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _53 = core::panicking::AssertKind::Eq;
        _55 = Option::<Arguments<'_>>::None;
        _54 = core::panicking::assert_failed::<u8, u8>(move _53, _47, _48, move _55) -> unwind continue;
    }

    bb12: {
        return;
    }
}

promoted[0] in main: &u8 = {
    let mut _0: &u8;
    let mut _1: u8;

    bb0: {
        _1 = const 42_u8;
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &(&str, u8, &bool, u16) = {
    let mut _0: &(&str, u8, &bool, u16);
    let mut _1: (&str, u8, &bool, u16);
    let mut _2: &bool;
    let mut _3: bool;

    bb0: {
        _3 = const true;
        _2 = &_3;
        _1 = (const "bar", const 24_u8, move _2, const 12_u16);
        _0 = &_1;
        return;
    }
}

promoted[2] in main: &bool = {
    let mut _0: &bool;
    let mut _1: bool;

    bb0: {
        _1 = const true;
        _0 = &_1;
        return;
    }
}

promoted[3] in main: &(&u8, &u8) = {
    let mut _0: &(&u8, &u8);
    let mut _1: (&u8, &u8);
    let mut _2: &u8;
    let mut _3: u8;
    let mut _4: &u8;
    let mut _5: u8;

    bb0: {
        _3 = const 1_u8;
        _2 = &_3;
        _5 = const 2_u8;
        _4 = &_5;
        _1 = (move _2, move _4);
        _0 = &_1;
        return;
    }
}

promoted[4] in main: &bool = {
    let mut _0: &bool;
    let mut _1: bool;

    bb0: {
        _1 = const true;
        _0 = &_1;
        return;
    }
}

promoted[5] in main: &(&str, bool, u8) = {
    let mut _0: &(&str, bool, u8);
    let mut _1: (&str, bool, u8);

    bb0: {
        _1 = (const "foo", const true, const 42_u8);
        _0 = &_1;
        return;
    }
}
