// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/overloaded/overloaded-index-autoderef.rs:13:1: 13:26>::index(_1: &Foo, _2: isize) -> &isize {
    debug self => _1;
    debug z => _2;
    let mut _0: &isize;
    let _3: &isize;
    let _4: &isize;

    bb0: {
        switchInt(move _2) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _3 = &((*_1).0: isize);
        _0 = _3;
        goto -> bb3;
    }

    bb2: {
        _4 = &((*_1).1: isize);
        _0 = _4;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn <impl at ui/overloaded/overloaded-index-autoderef.rs:25:1: 25:29>::index_mut(_1: &mut Foo, _2: isize) -> &mut isize {
    debug self => _1;
    debug z => _2;
    let mut _0: &mut isize;
    let mut _3: &mut isize;
    let mut _4: &mut isize;
    let mut _5: &mut isize;

    bb0: {
        switchInt(move _2) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _4 = &mut ((*_1).0: isize);
        _3 = _4;
        goto -> bb3;
    }

    bb2: {
        _5 = &mut ((*_1).1: isize);
        _3 = _5;
        goto -> bb3;
    }

    bb3: {
        _0 = _3;
        return;
    }
}

fn <impl at ui/overloaded/overloaded-index-autoderef.rs:41:1: 41:19>::get(_1: isize) -> isize {
    debug self => _1;
    let mut _0: isize;

    bb0: {
        _0 = _1;
        return;
    }
}

fn <impl at ui/overloaded/overloaded-index-autoderef.rs:41:1: 41:19>::get_from_ref(_1: &isize) -> isize {
    debug self => _1;
    let mut _0: isize;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn <impl at ui/overloaded/overloaded-index-autoderef.rs:41:1: 41:19>::inc(_1: &mut isize) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        (*_1) = Add((*_1), const 1_isize);
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let mut _1: std::boxed::Box<Foo>;
    let mut _2: Foo;
    let mut _3: (&isize, &isize);
    let mut _4: &isize;
    let _5: &isize;
    let mut _6: &Foo;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: isize;
    let mut _12: isize;
    let _14: !;
    let mut _15: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _16: &mut isize;
    let mut _17: &mut Foo;
    let mut _18: (&isize, &isize);
    let mut _19: &isize;
    let _20: &isize;
    let mut _21: &Foo;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: isize;
    let mut _27: isize;
    let _29: !;
    let mut _30: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _32: &mut isize;
    let mut _33: &mut Foo;
    let _35: &isize;
    let mut _36: &Foo;
    let mut _37: (&isize, &isize);
    let mut _40: bool;
    let mut _41: bool;
    let mut _42: isize;
    let mut _43: isize;
    let _45: !;
    let mut _46: std::option::Option<std::fmt::Arguments<'_>>;
    let _47: ();
    let mut _48: &mut isize;
    let mut _49: &mut isize;
    let mut _50: &mut Foo;
    let mut _51: (&isize, &isize);
    let mut _52: &isize;
    let _53: isize;
    let mut _54: isize;
    let mut _55: &isize;
    let mut _56: &Foo;
    let mut _59: bool;
    let mut _60: bool;
    let mut _61: isize;
    let mut _62: isize;
    let _64: !;
    let mut _65: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _66: (&isize, &isize);
    let mut _67: &isize;
    let _68: isize;
    let mut _69: &isize;
    let _70: &isize;
    let mut _71: &Foo;
    let mut _74: bool;
    let mut _75: bool;
    let mut _76: isize;
    let mut _77: isize;
    let _79: !;
    let mut _80: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _86: *const Foo;
    let mut _87: *const Foo;
    let mut _88: *const Foo;
    let mut _89: *const Foo;
    let mut _90: *const Foo;
    let mut _91: *const Foo;
    let mut _92: *const Foo;
    let mut _93: *const Foo;
    scope 1 {
        debug f => _1;
        let _7: &isize;
        let _8: &isize;
        let _22: &isize;
        let _23: &isize;
        let _31: &mut isize;
        let _34: &isize;
        let _57: &isize;
        let _58: &isize;
        let _72: &isize;
        let _73: &isize;
        let mut _81: &isize;
        let mut _82: &isize;
        let mut _84: &isize;
        let mut _85: &isize;
        let mut _94: *const ();
        let mut _95: usize;
        let mut _96: usize;
        let mut _97: usize;
        let mut _98: usize;
        let mut _99: bool;
        let mut _100: *const ();
        let mut _101: usize;
        let mut _102: usize;
        let mut _103: usize;
        let mut _104: usize;
        let mut _105: bool;
        let mut _106: *const ();
        let mut _107: usize;
        let mut _108: usize;
        let mut _109: usize;
        let mut _110: usize;
        let mut _111: bool;
        let mut _112: *const ();
        let mut _113: usize;
        let mut _114: usize;
        let mut _115: usize;
        let mut _116: usize;
        let mut _117: bool;
        let mut _118: *const ();
        let mut _119: usize;
        let mut _120: usize;
        let mut _121: usize;
        let mut _122: usize;
        let mut _123: bool;
        let mut _124: *const ();
        let mut _125: usize;
        let mut _126: usize;
        let mut _127: usize;
        let mut _128: usize;
        let mut _129: bool;
        let mut _130: *const ();
        let mut _131: usize;
        let mut _132: usize;
        let mut _133: usize;
        let mut _134: usize;
        let mut _135: bool;
        let mut _136: *const ();
        let mut _137: usize;
        let mut _138: usize;
        let mut _139: usize;
        let mut _140: usize;
        let mut _141: bool;
        scope 2 {
            debug left_val => _7;
            debug right_val => _8;
            let _13: core::panicking::AssertKind;
            scope 3 {
                debug kind => _13;
            }
        }
        scope 4 {
            debug left_val => _22;
            debug right_val => _23;
            let _28: core::panicking::AssertKind;
            scope 5 {
                debug kind => _28;
            }
        }
        scope 6 {
            debug p => _31;
        }
        scope 7 {
            debug p => _34;
            let _38: &isize;
            let _39: &isize;
            let mut _83: &isize;
            scope 8 {
                debug left_val => _38;
                debug right_val => _39;
                let _44: core::panicking::AssertKind;
                scope 9 {
                    debug kind => _44;
                }
            }
        }
        scope 10 {
            debug left_val => _57;
            debug right_val => _58;
            let _63: core::panicking::AssertKind;
            scope 11 {
                debug kind => _63;
            }
        }
        scope 12 {
            debug left_val => _72;
            debug right_val => _73;
            let _78: core::panicking::AssertKind;
            scope 13 {
                debug kind => _78;
            }
        }
    }

    bb0: {
        _2 = Foo { x: const 1_isize, y: const 2_isize };
        _1 = Box::<Foo>::new(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _86 = (((_1.0: std::ptr::Unique<Foo>).0: std::ptr::NonNull<Foo>).0: *const Foo);
        _136 = _86 as *const () (PtrToPtr);
        _137 = _136 as usize (Transmute);
        _138 = AlignOf(Foo);
        _139 = Sub(_138, const 1_usize);
        _140 = BitAnd(_137, _139);
        _141 = Eq(_140, const 0_usize);
        assert(_141, "misaligned pointer dereference: address must be a multiple of {} but is {}", _138, _137) -> [success: bb33, unwind unreachable];
    }

    bb2: {
        _4 = _5;
        _85 = const _;
        _3 = (move _4, _85);
        _7 = (_3.0: &isize);
        _8 = (_3.1: &isize);
        _11 = (*_7);
        _12 = (*_8);
        _10 = Eq(move _11, move _12);
        _9 = Not(move _10);
        switchInt(move _9) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _13 = core::panicking::AssertKind::Eq;
        _15 = Option::<Arguments<'_>>::None;
        _14 = core::panicking::assert_failed::<isize, isize>(move _13, _7, _8, move _15) -> bb24;
    }

    bb4: {
        _87 = (((_1.0: std::ptr::Unique<Foo>).0: std::ptr::NonNull<Foo>).0: *const Foo);
        _130 = _87 as *const () (PtrToPtr);
        _131 = _130 as usize (Transmute);
        _132 = AlignOf(Foo);
        _133 = Sub(_132, const 1_usize);
        _134 = BitAnd(_131, _133);
        _135 = Eq(_134, const 0_usize);
        assert(_135, "misaligned pointer dereference: address must be a multiple of {} but is {}", _132, _131) -> [success: bb32, unwind unreachable];
    }

    bb5: {
        (*_16) = const 3_isize;
        _88 = (((_1.0: std::ptr::Unique<Foo>).0: std::ptr::NonNull<Foo>).0: *const Foo);
        _124 = _88 as *const () (PtrToPtr);
        _125 = _124 as usize (Transmute);
        _126 = AlignOf(Foo);
        _127 = Sub(_126, const 1_usize);
        _128 = BitAnd(_125, _127);
        _129 = Eq(_128, const 0_usize);
        assert(_129, "misaligned pointer dereference: address must be a multiple of {} but is {}", _126, _125) -> [success: bb31, unwind unreachable];
    }

    bb6: {
        _19 = _20;
        _84 = const _;
        _18 = (move _19, _84);
        _22 = (_18.0: &isize);
        _23 = (_18.1: &isize);
        _26 = (*_22);
        _27 = (*_23);
        _25 = Eq(move _26, move _27);
        _24 = Not(move _25);
        switchInt(move _24) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _28 = core::panicking::AssertKind::Eq;
        _30 = Option::<Arguments<'_>>::None;
        _29 = core::panicking::assert_failed::<isize, isize>(move _28, _22, _23, move _30) -> bb24;
    }

    bb8: {
        _89 = (((_1.0: std::ptr::Unique<Foo>).0: std::ptr::NonNull<Foo>).0: *const Foo);
        _118 = _89 as *const () (PtrToPtr);
        _119 = _118 as usize (Transmute);
        _120 = AlignOf(Foo);
        _121 = Sub(_120, const 1_usize);
        _122 = BitAnd(_119, _121);
        _123 = Eq(_122, const 0_usize);
        assert(_123, "misaligned pointer dereference: address must be a multiple of {} but is {}", _120, _119) -> [success: bb30, unwind unreachable];
    }

    bb9: {
        _31 = _32;
        (*_31) = const 4_isize;
        _90 = (((_1.0: std::ptr::Unique<Foo>).0: std::ptr::NonNull<Foo>).0: *const Foo);
        _112 = _90 as *const () (PtrToPtr);
        _113 = _112 as usize (Transmute);
        _114 = AlignOf(Foo);
        _115 = Sub(_114, const 1_usize);
        _116 = BitAnd(_113, _115);
        _117 = Eq(_116, const 0_usize);
        assert(_117, "misaligned pointer dereference: address must be a multiple of {} but is {}", _114, _113) -> [success: bb29, unwind unreachable];
    }

    bb10: {
        _34 = _35;
        _83 = const _;
        _37 = (_34, _83);
        _38 = (_37.0: &isize);
        _39 = (_37.1: &isize);
        _42 = (*_38);
        _43 = (*_39);
        _41 = Eq(move _42, move _43);
        _40 = Not(move _41);
        switchInt(move _40) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _44 = core::panicking::AssertKind::Eq;
        _46 = Option::<Arguments<'_>>::None;
        _45 = core::panicking::assert_failed::<isize, isize>(move _44, _38, _39, move _46) -> bb24;
    }

    bb12: {
        _91 = (((_1.0: std::ptr::Unique<Foo>).0: std::ptr::NonNull<Foo>).0: *const Foo);
        _106 = _91 as *const () (PtrToPtr);
        _107 = _106 as usize (Transmute);
        _108 = AlignOf(Foo);
        _109 = Sub(_108, const 1_usize);
        _110 = BitAnd(_107, _109);
        _111 = Eq(_110, const 0_usize);
        assert(_111, "misaligned pointer dereference: address must be a multiple of {} but is {}", _108, _107) -> [success: bb28, unwind unreachable];
    }

    bb13: {
        _48 = _49;
        _47 = <isize as Int>::inc(move _48) -> [return: bb14, unwind: bb24];
    }

    bb14: {
        _92 = (((_1.0: std::ptr::Unique<Foo>).0: std::ptr::NonNull<Foo>).0: *const Foo);
        _100 = _92 as *const () (PtrToPtr);
        _101 = _100 as usize (Transmute);
        _102 = AlignOf(Foo);
        _103 = Sub(_102, const 1_usize);
        _104 = BitAnd(_101, _103);
        _105 = Eq(_104, const 0_usize);
        assert(_105, "misaligned pointer dereference: address must be a multiple of {} but is {}", _102, _101) -> [success: bb27, unwind unreachable];
    }

    bb15: {
        _54 = (*_55);
        _53 = <isize as Int>::get(move _54) -> [return: bb16, unwind: bb24];
    }

    bb16: {
        _52 = &_53;
        _82 = const _;
        _51 = (move _52, _82);
        _57 = (_51.0: &isize);
        _58 = (_51.1: &isize);
        _61 = (*_57);
        _62 = (*_58);
        _60 = Eq(move _61, move _62);
        _59 = Not(move _60);
        switchInt(move _59) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _63 = core::panicking::AssertKind::Eq;
        _65 = Option::<Arguments<'_>>::None;
        _64 = core::panicking::assert_failed::<isize, isize>(move _63, _57, _58, move _65) -> bb24;
    }

    bb18: {
        _93 = (((_1.0: std::ptr::Unique<Foo>).0: std::ptr::NonNull<Foo>).0: *const Foo);
        _94 = _93 as *const () (PtrToPtr);
        _95 = _94 as usize (Transmute);
        _96 = AlignOf(Foo);
        _97 = Sub(_96, const 1_usize);
        _98 = BitAnd(_95, _97);
        _99 = Eq(_98, const 0_usize);
        assert(_99, "misaligned pointer dereference: address must be a multiple of {} but is {}", _96, _95) -> [success: bb26, unwind unreachable];
    }

    bb19: {
        _69 = _70;
        _68 = <isize as Int>::get_from_ref(move _69) -> [return: bb20, unwind: bb24];
    }

    bb20: {
        _67 = &_68;
        _81 = const _;
        _66 = (move _67, _81);
        _72 = (_66.0: &isize);
        _73 = (_66.1: &isize);
        _76 = (*_72);
        _77 = (*_73);
        _75 = Eq(move _76, move _77);
        _74 = Not(move _75);
        switchInt(move _74) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _78 = core::panicking::AssertKind::Eq;
        _80 = Option::<Arguments<'_>>::None;
        _79 = core::panicking::assert_failed::<isize, isize>(move _78, _72, _73, move _80) -> bb24;
    }

    bb22: {
        drop(_1) -> [return: bb23, unwind continue];
    }

    bb23: {
        return;
    }

    bb24 (cleanup): {
        drop(_1) -> [return: bb25, unwind terminate];
    }

    bb25 (cleanup): {
        resume;
    }

    bb26: {
        _71 = &(*_93);
        _70 = <Foo as Index<isize>>::index(move _71, const 1_isize) -> [return: bb19, unwind: bb24];
    }

    bb27: {
        _56 = &(*_92);
        _55 = <Foo as Index<isize>>::index(move _56, const 1_isize) -> [return: bb15, unwind: bb24];
    }

    bb28: {
        _50 = &mut (*_91);
        _49 = <Foo as IndexMut<isize>>::index_mut(move _50, const 1_isize) -> [return: bb13, unwind: bb24];
    }

    bb29: {
        _36 = &(*_90);
        _35 = <Foo as Index<isize>>::index(move _36, const 1_isize) -> [return: bb10, unwind: bb24];
    }

    bb30: {
        _33 = &mut (*_89);
        _32 = <Foo as IndexMut<isize>>::index_mut(move _33, const 1_isize) -> [return: bb9, unwind: bb24];
    }

    bb31: {
        _21 = &(*_88);
        _20 = <Foo as Index<isize>>::index(move _21, const 0_isize) -> [return: bb6, unwind: bb24];
    }

    bb32: {
        _17 = &mut (*_87);
        _16 = <Foo as IndexMut<isize>>::index_mut(move _17, const 0_isize) -> [return: bb5, unwind: bb24];
    }

    bb33: {
        _6 = &(*_86);
        _5 = <Foo as Index<isize>>::index(move _6, const 1_isize) -> [return: bb2, unwind: bb24];
    }
}

promoted[0] in main: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 5_isize;
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 5_isize;
        _0 = &_1;
        return;
    }
}

promoted[2] in main: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 4_isize;
        _0 = &_1;
        return;
    }
}

promoted[3] in main: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 3_isize;
        _0 = &_1;
        return;
    }
}

promoted[4] in main: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 2_isize;
        _0 = &_1;
        return;
    }
}
