// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/overloaded/overloaded-autoderef-order.rs:8:16: 8:21>::clone(_1: &DerefWrapper<X, Y>) -> DerefWrapper<X, Y> {
    debug self => _1;
    let mut _0: DerefWrapper<X, Y>;
    let mut _2: X;
    let _3: &X;
    let mut _4: Y;
    let _5: &Y;

    bb0: {
        _3 = &((*_1).0: X);
        _2 = <X as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &((*_1).1: Y);
        _4 = <Y as Clone>::clone(_5) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        _0 = DerefWrapper::<X, Y> { x: move _2, y: move _4 };
        return;
    }

    bb3 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate];
    }

    bb4 (cleanup): {
        resume;
    }
}

fn <impl at ui/overloaded/overloaded-autoderef-order.rs:14:1: 14:30>::get_x(_1: DerefWrapper<X, Y>) -> X {
    debug self => _1;
    let mut _0: X;

    bb0: {
        _0 = move (_1.0: X);
        drop((_1.1: Y)) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/overloaded/overloaded-autoderef-order.rs:20:1: 20:40>::deref(_1: &DerefWrapper<X, Y>) -> &Y {
    debug self => _1;
    let mut _0: &Y;

    bb0: {
        _0 = &((*_1).1: Y);
        return;
    }
}

fn priv_test::<impl at ui/overloaded/overloaded-autoderef-order.rs:31:20: 31:25>::clone(_1: &DerefWrapperHideX<X, Y>) -> DerefWrapperHideX<X, Y> {
    debug self => _1;
    let mut _0: priv_test::DerefWrapperHideX<X, Y>;
    let mut _2: X;
    let _3: &X;
    let mut _4: Y;
    let _5: &Y;

    bb0: {
        _3 = &((*_1).0: X);
        _2 = <X as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &((*_1).1: Y);
        _4 = <Y as Clone>::clone(_5) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        _0 = DerefWrapperHideX::<X, Y> { x: move _2, y: move _4 };
        return;
    }

    bb3 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate];
    }

    bb4 (cleanup): {
        resume;
    }
}

fn priv_test::<impl at ui/overloaded/overloaded-autoderef-order.rs:37:5: 37:39>::new(_1: X, _2: Y) -> DerefWrapperHideX<X, Y> {
    debug x => _1;
    debug y => _2;
    let mut _0: priv_test::DerefWrapperHideX<X, Y>;

    bb0: {
        _0 = DerefWrapperHideX::<X, Y> { x: move _1, y: move _2 };
        return;
    }
}

fn priv_test::<impl at ui/overloaded/overloaded-autoderef-order.rs:46:5: 46:49>::deref(_1: &DerefWrapperHideX<X, Y>) -> &Y {
    debug self => _1;
    let mut _0: &Y;

    bb0: {
        _0 = &((*_1).1: Y);
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: DerefWrapper<bool, DerefWrapper<i32, i32>>;
    let mut _2: DerefWrapper<i32, i32>;
    let mut _3: (&bool, &bool);
    let mut _4: &bool;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: bool;
    let _12: !;
    let mut _13: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _14: (&i32, &i32);
    let mut _15: &i32;
    let _16: &DerefWrapper<i32, i32>;
    let mut _17: &DerefWrapper<bool, DerefWrapper<i32, i32>>;
    let mut _20: bool;
    let mut _21: bool;
    let mut _22: i32;
    let mut _23: i32;
    let _25: !;
    let mut _26: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _27: (&bool, &bool);
    let mut _28: &bool;
    let _29: bool;
    let mut _30: DerefWrapper<bool, DerefWrapper<i32, i32>>;
    let mut _33: bool;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: bool;
    let _38: !;
    let mut _39: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _40: (&i32, &i32);
    let mut _41: &i32;
    let _42: i32;
    let mut _43: DerefWrapper<i32, i32>;
    let mut _44: &DerefWrapper<i32, i32>;
    let mut _45: &DerefWrapper<bool, DerefWrapper<i32, i32>>;
    let mut _48: bool;
    let mut _49: bool;
    let mut _50: i32;
    let mut _51: i32;
    let _53: !;
    let mut _54: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _55: (&bool, &bool);
    let mut _56: &bool;
    let _57: &DerefWrapper<bool, DerefWrapper<i32, i32>>;
    let mut _58: &std::rc::Rc<DerefWrapper<bool, DerefWrapper<i32, i32>>>;
    let _59: std::rc::Rc<DerefWrapper<bool, DerefWrapper<i32, i32>>>;
    let mut _60: DerefWrapper<bool, DerefWrapper<i32, i32>>;
    let mut _63: bool;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: bool;
    let _68: !;
    let mut _69: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _71: DerefWrapper<i32, i32>;
    let mut _72: (&i32, &i32);
    let mut _73: &i32;
    let _74: &DerefWrapper<i32, i32>;
    let mut _75: &priv_test::DerefWrapperHideX<bool, DerefWrapper<i32, i32>>;
    let mut _78: bool;
    let mut _79: bool;
    let mut _80: i32;
    let mut _81: i32;
    let _83: !;
    let mut _84: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _85: (&i32, &i32);
    let mut _86: &i32;
    let _87: &DerefWrapper<i32, i32>;
    let mut _88: &priv_test::DerefWrapperHideX<bool, DerefWrapper<i32, i32>>;
    let mut _91: bool;
    let mut _92: bool;
    let mut _93: i32;
    let mut _94: i32;
    let _96: !;
    let mut _97: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug nested => _1;
        let _5: &bool;
        let _6: &bool;
        let _18: &i32;
        let _19: &i32;
        let _31: &bool;
        let _32: &bool;
        let _46: &i32;
        let _47: &i32;
        let _61: &bool;
        let _62: &bool;
        let _70: priv_test::DerefWrapperHideX<bool, DerefWrapper<i32, i32>>;
        let mut _100: &bool;
        let mut _101: &i32;
        let mut _102: &bool;
        let mut _103: &i32;
        let mut _104: &bool;
        scope 2 {
            debug left_val => _5;
            debug right_val => _6;
            let _11: core::panicking::AssertKind;
            scope 3 {
                debug kind => _11;
            }
        }
        scope 4 {
            debug left_val => _18;
            debug right_val => _19;
            let _24: core::panicking::AssertKind;
            scope 5 {
                debug kind => _24;
            }
        }
        scope 6 {
            debug left_val => _31;
            debug right_val => _32;
            let _37: core::panicking::AssertKind;
            scope 7 {
                debug kind => _37;
            }
        }
        scope 8 {
            debug left_val => _46;
            debug right_val => _47;
            let _52: core::panicking::AssertKind;
            scope 9 {
                debug kind => _52;
            }
        }
        scope 10 {
            debug left_val => _61;
            debug right_val => _62;
            let _67: core::panicking::AssertKind;
            scope 11 {
                debug kind => _67;
            }
        }
        scope 12 {
            debug nested_priv => _70;
            let _76: &i32;
            let _77: &i32;
            let _89: &i32;
            let _90: &i32;
            let mut _98: &i32;
            let mut _99: &i32;
            scope 13 {
                debug left_val => _76;
                debug right_val => _77;
                let _82: core::panicking::AssertKind;
                scope 14 {
                    debug kind => _82;
                }
            }
            scope 15 {
                debug left_val => _89;
                debug right_val => _90;
                let _95: core::panicking::AssertKind;
                scope 16 {
                    debug kind => _95;
                }
            }
        }
    }

    bb0: {
        _2 = DerefWrapper::<i32, i32> { x: const 0_i32, y: const 1_i32 };
        _1 = DerefWrapper::<bool, DerefWrapper<i32, i32>> { x: const true, y: move _2 };
        _4 = &(_1.0: bool);
        _104 = const _;
        _3 = (move _4, _104);
        _5 = (_3.0: &bool);
        _6 = (_3.1: &bool);
        _9 = (*_5);
        _10 = (*_6);
        _8 = Eq(move _9, move _10);
        _7 = Not(move _8);
        switchInt(move _7) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _11 = core::panicking::AssertKind::Eq;
        _13 = Option::<Arguments<'_>>::None;
        _12 = core::panicking::assert_failed::<bool, bool>(move _11, _5, _6, move _13) -> unwind continue;
    }

    bb2: {
        _17 = &_1;
        _16 = <DerefWrapper<bool, DerefWrapper<i32, i32>> as Deref>::deref(move _17) -> [return: bb3, unwind continue];
    }

    bb3: {
        _15 = &((*_16).0: i32);
        _103 = const _;
        _14 = (move _15, _103);
        _18 = (_14.0: &i32);
        _19 = (_14.1: &i32);
        _22 = (*_18);
        _23 = (*_19);
        _21 = Eq(move _22, move _23);
        _20 = Not(move _21);
        switchInt(move _20) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _24 = core::panicking::AssertKind::Eq;
        _26 = Option::<Arguments<'_>>::None;
        _25 = core::panicking::assert_failed::<i32, i32>(move _24, _18, _19, move _26) -> unwind continue;
    }

    bb5: {
        _30 = _1;
        _29 = DerefWrapper::<bool, DerefWrapper<i32, i32>>::get_x(move _30) -> [return: bb6, unwind continue];
    }

    bb6: {
        _28 = &_29;
        _102 = const _;
        _27 = (move _28, _102);
        _31 = (_27.0: &bool);
        _32 = (_27.1: &bool);
        _35 = (*_31);
        _36 = (*_32);
        _34 = Eq(move _35, move _36);
        _33 = Not(move _34);
        switchInt(move _33) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _37 = core::panicking::AssertKind::Eq;
        _39 = Option::<Arguments<'_>>::None;
        _38 = core::panicking::assert_failed::<bool, bool>(move _37, _31, _32, move _39) -> unwind continue;
    }

    bb8: {
        _45 = &_1;
        _44 = <DerefWrapper<bool, DerefWrapper<i32, i32>> as Deref>::deref(move _45) -> [return: bb9, unwind continue];
    }

    bb9: {
        _43 = (*_44);
        _42 = DerefWrapper::<i32, i32>::get_x(move _43) -> [return: bb10, unwind continue];
    }

    bb10: {
        _41 = &_42;
        _101 = const _;
        _40 = (move _41, _101);
        _46 = (_40.0: &i32);
        _47 = (_40.1: &i32);
        _50 = (*_46);
        _51 = (*_47);
        _49 = Eq(move _50, move _51);
        _48 = Not(move _49);
        switchInt(move _48) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _52 = core::panicking::AssertKind::Eq;
        _54 = Option::<Arguments<'_>>::None;
        _53 = core::panicking::assert_failed::<i32, i32>(move _52, _46, _47, move _54) -> unwind continue;
    }

    bb12: {
        _60 = _1;
        _59 = Rc::<DerefWrapper<bool, DerefWrapper<i32, i32>>>::new(move _60) -> [return: bb13, unwind continue];
    }

    bb13: {
        _58 = &_59;
        _57 = <Rc<DerefWrapper<bool, DerefWrapper<i32, i32>>> as Deref>::deref(move _58) -> [return: bb14, unwind: bb25];
    }

    bb14: {
        _56 = &((*_57).0: bool);
        _100 = const _;
        _55 = (move _56, _100);
        _61 = (_55.0: &bool);
        _62 = (_55.1: &bool);
        _65 = (*_61);
        _66 = (*_62);
        _64 = Eq(move _65, move _66);
        _63 = Not(move _64);
        switchInt(move _63) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _67 = core::panicking::AssertKind::Eq;
        _69 = Option::<Arguments<'_>>::None;
        _68 = core::panicking::assert_failed::<bool, bool>(move _67, _61, _62, move _69) -> bb25;
    }

    bb16: {
        drop(_59) -> [return: bb17, unwind continue];
    }

    bb17: {
        _71 = DerefWrapper::<i32, i32> { x: const 0_i32, y: const 1_i32 };
        _70 = DerefWrapperHideX::<bool, DerefWrapper<i32, i32>>::new(const true, move _71) -> [return: bb18, unwind continue];
    }

    bb18: {
        _75 = &_70;
        _74 = <DerefWrapperHideX<bool, DerefWrapper<i32, i32>> as Deref>::deref(move _75) -> [return: bb19, unwind continue];
    }

    bb19: {
        _73 = &((*_74).0: i32);
        _99 = const _;
        _72 = (move _73, _99);
        _76 = (_72.0: &i32);
        _77 = (_72.1: &i32);
        _80 = (*_76);
        _81 = (*_77);
        _79 = Eq(move _80, move _81);
        _78 = Not(move _79);
        switchInt(move _78) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _82 = core::panicking::AssertKind::Eq;
        _84 = Option::<Arguments<'_>>::None;
        _83 = core::panicking::assert_failed::<i32, i32>(move _82, _76, _77, move _84) -> unwind continue;
    }

    bb21: {
        _88 = &_70;
        _87 = <DerefWrapperHideX<bool, DerefWrapper<i32, i32>> as Deref>::deref(move _88) -> [return: bb22, unwind continue];
    }

    bb22: {
        _86 = &((*_87).0: i32);
        _98 = const _;
        _85 = (move _86, _98);
        _89 = (_85.0: &i32);
        _90 = (_85.1: &i32);
        _93 = (*_89);
        _94 = (*_90);
        _92 = Eq(move _93, move _94);
        _91 = Not(move _92);
        switchInt(move _91) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _95 = core::panicking::AssertKind::Eq;
        _97 = Option::<Arguments<'_>>::None;
        _96 = core::panicking::assert_failed::<i32, i32>(move _95, _89, _90, move _97) -> unwind continue;
    }

    bb24: {
        return;
    }

    bb25 (cleanup): {
        drop(_59) -> [return: bb26, unwind terminate];
    }

    bb26 (cleanup): {
        resume;
    }
}

promoted[0] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 0_i32;
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 0_i32;
        _0 = &_1;
        return;
    }
}

promoted[2] in main: &bool = {
    let mut _0: &bool;
    let mut _1: bool;

    bb0: {
        _1 = const true;
        _0 = &_1;
        return;
    }
}

promoted[3] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 0_i32;
        _0 = &_1;
        return;
    }
}

promoted[4] in main: &bool = {
    let mut _0: &bool;
    let mut _1: bool;

    bb0: {
        _1 = const true;
        _0 = &_1;
        return;
    }
}

promoted[5] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 0_i32;
        _0 = &_1;
        return;
    }
}

promoted[6] in main: &bool = {
    let mut _0: &bool;
    let mut _1: bool;

    bb0: {
        _1 = const true;
        _0 = &_1;
        return;
    }
}
