// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
static S0: &[u32] = {
    let mut _0: &[u32];
    let _1: &[u32];
    let mut _2: *const u32;
    scope 1 {
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        ConstEvalCounter;
        _2 = dangling::<u32>() -> [return: bb1, unwind continue];
    }

    bb1: {
        ConstEvalCounter;
        _1 = std::slice::from_raw_parts::<'_, u32>(move _2, const 0_usize) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = &(*_1);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static S1: &[()] = {
    let mut _0: &[()];
    let _1: &[()];
    let mut _2: *const ();
    scope 1 {
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        ConstEvalCounter;
        _2 = dangling::<()>() -> [return: bb1, unwind continue];
    }

    bb1: {
        ConstEvalCounter;
        _1 = std::slice::from_raw_parts::<'_, ()>(move _2, const 3_usize) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = &(*_1);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static S2: &[u32] = {
    let mut _0: &[u32];
    let _1: &[u32];
    let mut _2: *const u32;
    let _3: &u32;
    let _4: u32;
    scope 1 {
        let mut _5: &u32;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _5 = const _;
        _3 = &(*_5);
        _2 = &raw const (*_3);
        ConstEvalCounter;
        _1 = std::slice::from_raw_parts::<'_, u32>(move _2, const 1_usize) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = &(*_1);
        StorageDead(_2);
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in S2: &u32 = {
    let mut _0: &u32;
    let mut _1: u32;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

static S3: &[MaybeUninit<&u32>] = {
    let mut _0: &[std::mem::MaybeUninit<&u32>];
    let _1: &[std::mem::MaybeUninit<&u32>];
    let mut _2: *const std::mem::MaybeUninit<&u32>;
    let _3: &std::mem::MaybeUninit<&u32>;
    let _4: std::mem::MaybeUninit<&u32>;
    scope 1 {
        let mut _5: &std::mem::MaybeUninit<&u32>;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _5 = const _;
        _3 = &(*_5);
        _2 = &raw const (*_3);
        ConstEvalCounter;
        _1 = std::slice::from_raw_parts::<'_, MaybeUninit<&u32>>(move _2, const 1_usize) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = &(*_1);
        StorageDead(_2);
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in S3: &MaybeUninit<&u32> = {
    let mut _0: &std::mem::MaybeUninit<&u32>;
    let mut _1: std::mem::MaybeUninit<&u32>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

static S4: &[u8] = {
    let mut _0: &[u8];
    let _1: &[u8];
    let mut _2: *const u8;
    let mut _3: *const u8;
    let mut _4: *const u32;
    let mut _5: *const u32;
    let _6: &u32;
    let _7: u32;
    scope 1 {
        let mut _8: &u32;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _8 = const _;
        _6 = &(*_8);
        _5 = &raw const (*_6);
        _4 = _5;
        _3 = move _4 as *const u8 (PtrToPtr);
        _2 = _3;
        StorageDead(_4);
        ConstEvalCounter;
        _1 = std::slice::from_raw_parts::<'_, u8>(move _2, const 3_usize) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = &(*_1);
        StorageDead(_2);
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in S4: &u32 = {
    let mut _0: &u32;
    let mut _1: u32;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

static S5: &[MaybeUninit<u8>] = {
    let mut _0: &[std::mem::MaybeUninit<u8>];
    let _1: &[std::mem::MaybeUninit<u8>];
    let mut _2: *const std::mem::MaybeUninit<u8>;
    let mut _3: *const std::mem::MaybeUninit<u8>;
    let mut _4: *const std::mem::MaybeUninit<&u32>;
    let mut _5: *const std::mem::MaybeUninit<&u32>;
    let _6: &std::mem::MaybeUninit<&u32>;
    let _7: std::mem::MaybeUninit<&u32>;
    scope 1 {
        let mut _8: &std::mem::MaybeUninit<&u32>;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _8 = const _;
        _6 = &(*_8);
        _5 = &raw const (*_6);
        _4 = _5;
        _3 = move _4 as *const std::mem::MaybeUninit<u8> (PtrToPtr);
        _2 = _3;
        StorageDead(_4);
        ConstEvalCounter;
        _1 = std::slice::from_raw_parts::<'_, MaybeUninit<u8>>(move _2, const 2_usize) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = &(*_1);
        StorageDead(_2);
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in S5: &MaybeUninit<&u32> = {
    let mut _0: &std::mem::MaybeUninit<&u32>;
    let mut _1: std::mem::MaybeUninit<&u32>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

static S6: &[bool] = {
    let mut _0: &[bool];
    let _1: &[bool];
    let mut _2: *const bool;
    let mut _3: *const bool;
    let mut _4: *const u32;
    let mut _5: *const u32;
    let _6: &u32;
    let _7: u32;
    scope 1 {
        let mut _8: &u32;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _8 = const _;
        _6 = &(*_8);
        _5 = &raw const (*_6);
        _4 = _5;
        _3 = move _4 as *const bool (PtrToPtr);
        _2 = _3;
        StorageDead(_4);
        ConstEvalCounter;
        _1 = std::slice::from_raw_parts::<'_, bool>(move _2, const 4_usize) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = &(*_1);
        StorageDead(_2);
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in S6: &u32 = {
    let mut _0: &u32;
    let mut _1: u32;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

static S7: &[u16] = {
    let mut _0: &[u16];
    let mut _2: *const u16;
    let mut _3: *const Struct;
    let _4: &Struct;
    let _5: Struct;
    let _6: &[u16];
    let mut _7: *const u16;
    scope 1 {
        let _1: *const u16;
        let mut _8: &Struct;
        scope 2 {
            debug ptr => _1;
        }
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _8 = const _;
        _4 = &(*_8);
        _3 = &raw const (*_4);
        _2 = move _3 as *const u16 (PtrToPtr);
        StorageDead(_3);
        ConstEvalCounter;
        _1 = ptr::const_ptr::<impl *const u16>::byte_add(move _2, const 4_usize) -> [return: bb1, unwind continue];
    }

    bb1: {
        StorageDead(_2);
        StorageDead(_4);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _1;
        ConstEvalCounter;
        _6 = std::slice::from_raw_parts::<'_, u16>(move _7, const 3_usize) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = &(*_6);
        StorageDead(_7);
        StorageDead(_1);
        StorageDead(_6);
        return;
    }
}

promoted[0] in S7: &Struct = {
    let mut _0: &Struct;
    let mut _1: Struct;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

static S8: &[MaybeUninit<u16>] = {
    let mut _0: &[std::mem::MaybeUninit<u16>];
    let mut _2: *const Struct;
    let _3: &Struct;
    let _4: Struct;
    let _5: &[std::mem::MaybeUninit<u16>];
    let mut _6: *const std::mem::MaybeUninit<u16>;
    scope 1 {
        let _1: *const std::mem::MaybeUninit<u16>;
        let mut _7: &Struct;
        scope 2 {
            debug ptr => _1;
        }
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _7 = const _;
        _3 = &(*_7);
        _2 = &raw const (*_3);
        _1 = move _2 as *const std::mem::MaybeUninit<u16> (PtrToPtr);
        StorageDead(_2);
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        ConstEvalCounter;
        _5 = std::slice::from_raw_parts::<'_, MaybeUninit<u16>>(move _6, const 6_usize) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = &(*_5);
        StorageDead(_6);
        StorageDead(_1);
        StorageDead(_5);
        return;
    }
}

promoted[0] in S8: &Struct = {
    let mut _0: &Struct;
    let mut _1: Struct;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

static R0: &[u32] = {
    let mut _0: &[u32];
    let _1: &[u32];
    let mut _2: std::ops::Range<*const u32>;
    let mut _3: *const u32;
    let mut _4: *const u32;
    scope 1 {
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        ConstEvalCounter;
        _3 = dangling::<u32>() -> [return: bb1, unwind continue];
    }

    bb1: {
        StorageLive(_4);
        ConstEvalCounter;
        _4 = dangling::<u32>() -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = std::ops::Range::<*const u32> { start: move _3, end: move _4 };
        StorageDead(_4);
        StorageDead(_3);
        ConstEvalCounter;
        _1 = from_ptr_range::<'_, u32>(move _2) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = &(*_1);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static R2: &[u32] = {
    let mut _0: &[u32];
    let _2: &u32;
    let _3: u32;
    let _4: &[u32];
    let mut _5: std::ops::Range<*const u32>;
    let mut _6: *const u32;
    let mut _7: *const u32;
    let mut _8: *const u32;
    scope 1 {
        let _1: *const u32;
        let mut _9: &u32;
        scope 2 {
            debug ptr => _1;
        }
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _9 = const _;
        _2 = &(*_9);
        _1 = &raw const (*_2);
        StorageDead(_2);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        StorageLive(_7);
        StorageLive(_8);
        _8 = _1;
        ConstEvalCounter;
        _7 = ptr::const_ptr::<impl *const u32>::add(move _8, const 1_usize) -> [return: bb1, unwind continue];
    }

    bb1: {
        StorageDead(_8);
        _5 = std::ops::Range::<*const u32> { start: move _6, end: move _7 };
        StorageDead(_7);
        StorageDead(_6);
        ConstEvalCounter;
        _4 = from_ptr_range::<'_, u32>(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = &(*_4);
        StorageDead(_5);
        StorageDead(_1);
        StorageDead(_4);
        return;
    }
}

promoted[0] in R2: &u32 = {
    let mut _0: &u32;
    let mut _1: u32;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

static R3: &[MaybeUninit<&u32>] = {
    let mut _0: &[std::mem::MaybeUninit<&u32>];
    let mut _2: *const std::mem::MaybeUninit<&u32>;
    let _3: &std::mem::MaybeUninit<&u32>;
    let _4: std::mem::MaybeUninit<&u32>;
    let _5: &[std::mem::MaybeUninit<&u32>];
    let mut _6: std::ops::Range<*const std::mem::MaybeUninit<&u32>>;
    let mut _7: *const std::mem::MaybeUninit<&u32>;
    let mut _8: *const std::mem::MaybeUninit<&u32>;
    let mut _9: *const std::mem::MaybeUninit<&u32>;
    scope 1 {
        let _1: *const std::mem::MaybeUninit<&u32>;
        let mut _10: &std::mem::MaybeUninit<&u32>;
        scope 2 {
            debug ptr => _1;
        }
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _10 = const _;
        _3 = &(*_10);
        _2 = &raw const (*_3);
        _1 = _2;
        StorageDead(_3);
        StorageDead(_2);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _1;
        StorageLive(_8);
        StorageLive(_9);
        _9 = _1;
        ConstEvalCounter;
        _8 = ptr::const_ptr::<impl *const MaybeUninit<&u32>>::add(move _9, const 1_usize) -> [return: bb1, unwind continue];
    }

    bb1: {
        StorageDead(_9);
        _6 = std::ops::Range::<*const MaybeUninit<&u32>> { start: move _7, end: move _8 };
        StorageDead(_8);
        StorageDead(_7);
        ConstEvalCounter;
        _5 = from_ptr_range::<'_, MaybeUninit<&u32>>(move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = &(*_5);
        StorageDead(_6);
        StorageDead(_1);
        StorageDead(_5);
        return;
    }
}

promoted[0] in R3: &MaybeUninit<&u32> = {
    let mut _0: &std::mem::MaybeUninit<&u32>;
    let mut _1: std::mem::MaybeUninit<&u32>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

static R4: &[u8] = {
    let mut _0: &[u8];
    let mut _2: *const u32;
    let _3: &u32;
    let _4: u32;
    let _5: &[u8];
    let mut _6: std::ops::Range<*const u8>;
    let mut _7: *const u8;
    let mut _8: *const u8;
    let mut _9: *const u8;
    scope 1 {
        let _1: *const u8;
        let mut _10: &u32;
        scope 2 {
            debug ptr => _1;
        }
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _10 = const _;
        _3 = &(*_10);
        _2 = &raw const (*_3);
        _1 = move _2 as *const u8 (PtrToPtr);
        StorageDead(_2);
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _1;
        StorageLive(_8);
        StorageLive(_9);
        _9 = _1;
        ConstEvalCounter;
        _8 = ptr::const_ptr::<impl *const u8>::add(move _9, const 3_usize) -> [return: bb1, unwind continue];
    }

    bb1: {
        StorageDead(_9);
        _6 = std::ops::Range::<*const u8> { start: move _7, end: move _8 };
        StorageDead(_8);
        StorageDead(_7);
        ConstEvalCounter;
        _5 = from_ptr_range::<'_, u8>(move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = &(*_5);
        StorageDead(_6);
        StorageDead(_1);
        StorageDead(_5);
        return;
    }
}

promoted[0] in R4: &u32 = {
    let mut _0: &u32;
    let mut _1: u32;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

static R5: &[MaybeUninit<u8>] = {
    let mut _0: &[std::mem::MaybeUninit<u8>];
    let mut _2: *const std::mem::MaybeUninit<&u32>;
    let mut _3: *const std::mem::MaybeUninit<&u32>;
    let _4: &std::mem::MaybeUninit<&u32>;
    let _5: std::mem::MaybeUninit<&u32>;
    let _6: &[std::mem::MaybeUninit<u8>];
    let mut _7: std::ops::Range<*const std::mem::MaybeUninit<u8>>;
    let mut _8: *const std::mem::MaybeUninit<u8>;
    let mut _9: *const std::mem::MaybeUninit<u8>;
    let mut _10: *const std::mem::MaybeUninit<u8>;
    scope 1 {
        let _1: *const std::mem::MaybeUninit<u8>;
        let mut _11: &std::mem::MaybeUninit<&u32>;
        scope 2 {
            debug ptr => _1;
        }
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _11 = const _;
        _4 = &(*_11);
        _3 = &raw const (*_4);
        _2 = _3;
        _1 = move _2 as *const std::mem::MaybeUninit<u8> (PtrToPtr);
        StorageDead(_2);
        StorageDead(_4);
        StorageDead(_3);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _1;
        StorageLive(_9);
        StorageLive(_10);
        _10 = _1;
        ConstEvalCounter;
        _9 = ptr::const_ptr::<impl *const MaybeUninit<u8>>::add(move _10, const 2_usize) -> [return: bb1, unwind continue];
    }

    bb1: {
        StorageDead(_10);
        _7 = std::ops::Range::<*const MaybeUninit<u8>> { start: move _8, end: move _9 };
        StorageDead(_9);
        StorageDead(_8);
        ConstEvalCounter;
        _6 = from_ptr_range::<'_, MaybeUninit<u8>>(move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = &(*_6);
        StorageDead(_7);
        StorageDead(_1);
        StorageDead(_6);
        return;
    }
}

promoted[0] in R5: &MaybeUninit<&u32> = {
    let mut _0: &std::mem::MaybeUninit<&u32>;
    let mut _1: std::mem::MaybeUninit<&u32>;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

static R6: &[bool] = {
    let mut _0: &[bool];
    let mut _2: *const u32;
    let _3: &u32;
    let _4: u32;
    let _5: &[bool];
    let mut _6: std::ops::Range<*const bool>;
    let mut _7: *const bool;
    let mut _8: *const bool;
    let mut _9: *const bool;
    scope 1 {
        let _1: *const bool;
        let mut _10: &u32;
        scope 2 {
            debug ptr => _1;
        }
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _10 = const _;
        _3 = &(*_10);
        _2 = &raw const (*_3);
        _1 = move _2 as *const bool (PtrToPtr);
        StorageDead(_2);
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _1;
        StorageLive(_8);
        StorageLive(_9);
        _9 = _1;
        ConstEvalCounter;
        _8 = ptr::const_ptr::<impl *const bool>::add(move _9, const 4_usize) -> [return: bb1, unwind continue];
    }

    bb1: {
        StorageDead(_9);
        _6 = std::ops::Range::<*const bool> { start: move _7, end: move _8 };
        StorageDead(_8);
        StorageDead(_7);
        ConstEvalCounter;
        _5 = from_ptr_range::<'_, bool>(move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = &(*_5);
        StorageDead(_6);
        StorageDead(_1);
        StorageDead(_5);
        return;
    }
}

promoted[0] in R6: &u32 = {
    let mut _0: &u32;
    let mut _1: u32;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

static R7: &[u16] = {
    let mut _0: &[u16];
    let _2: Struct;
    let mut _4: *const u32;
    let _5: &u32;
    let mut _7: *const u8;
    let _8: &u8;
    let _9: &[u16];
    let mut _10: std::ops::Range<*const u16>;
    let mut _11: *const u16;
    let mut _12: *const u16;
    scope 1 {
        let _1: &Struct;
        let mut _13: &Struct;
        scope 2 {
            debug d2 => _1;
            let _3: *const u16;
            scope 3 {
                debug l => _3;
                let _6: *const u16;
                scope 4 {
                    debug r => _6;
                }
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _13 = const _;
        _1 = &(*_13);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = &((*_1).1: u32);
        _4 = &raw const (*_5);
        _3 = move _4 as *const u16 (PtrToPtr);
        StorageDead(_4);
        StorageDead(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = &((*_1).3: u8);
        _7 = &raw const (*_8);
        _6 = move _7 as *const u16 (PtrToPtr);
        StorageDead(_7);
        StorageDead(_8);
        StorageLive(_9);
        StorageLive(_10);
        StorageLive(_11);
        _11 = _3;
        StorageLive(_12);
        _12 = _6;
        _10 = std::ops::Range::<*const u16> { start: move _11, end: move _12 };
        StorageDead(_12);
        StorageDead(_11);
        ConstEvalCounter;
        _9 = from_ptr_range::<'_, u16>(move _10) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = &(*_9);
        StorageDead(_10);
        StorageDead(_6);
        StorageDead(_3);
        StorageDead(_1);
        StorageDead(_9);
        return;
    }
}

promoted[0] in R7: &Struct = {
    let mut _0: &Struct;
    let mut _1: Struct;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

static R8: &[MaybeUninit<u16>] = {
    let mut _0: &[std::mem::MaybeUninit<u16>];
    let _2: Struct;
    let mut _4: *const Struct;
    let mut _6: *const u8;
    let _7: &u8;
    let _8: &[std::mem::MaybeUninit<u16>];
    let mut _9: std::ops::Range<*const std::mem::MaybeUninit<u16>>;
    let mut _10: *const std::mem::MaybeUninit<u16>;
    let mut _11: *const std::mem::MaybeUninit<u16>;
    scope 1 {
        let _1: &Struct;
        let mut _12: &Struct;
        scope 2 {
            debug d2 => _1;
            let _3: *const std::mem::MaybeUninit<u16>;
            scope 3 {
                debug l => _3;
                let _5: *const std::mem::MaybeUninit<u16>;
                scope 4 {
                    debug r => _5;
                }
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _12 = const _;
        _1 = &(*_12);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &raw const (*_1);
        _3 = move _4 as *const std::mem::MaybeUninit<u16> (PtrToPtr);
        StorageDead(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &((*_1).3: u8);
        _6 = &raw const (*_7);
        _5 = move _6 as *const std::mem::MaybeUninit<u16> (PtrToPtr);
        StorageDead(_6);
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _3;
        StorageLive(_11);
        _11 = _5;
        _9 = std::ops::Range::<*const MaybeUninit<u16>> { start: move _10, end: move _11 };
        StorageDead(_11);
        StorageDead(_10);
        ConstEvalCounter;
        _8 = from_ptr_range::<'_, MaybeUninit<u16>>(move _9) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = &(*_8);
        StorageDead(_9);
        StorageDead(_5);
        StorageDead(_3);
        StorageDead(_1);
        StorageDead(_8);
        return;
    }
}

promoted[0] in R8: &Struct = {
    let mut _0: &Struct;
    let mut _1: Struct;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

static R9: &[u32] = {
    let mut _0: &[u32];
    let _1: &[u32];
    let mut _2: std::ops::Range<*const u32>;
    let mut _3: &[u32];
    let _4: &&[u32];
    let mut _5: &[u32];
    scope 1 {
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = const {alloc1: &&[u32]};
        _5 = deref_copy (*_4);
        _3 = &(*_5);
        ConstEvalCounter;
        _2 = core::slice::<impl [u32]>::as_ptr_range(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        StorageDead(_3);
        ConstEvalCounter;
        _1 = from_ptr_range::<'_, u32>(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = &(*_1);
        StorageDead(_2);
        StorageDead(_4);
        StorageDead(_1);
        return;
    }
}

alloc1 (static: R0, size: 16, align: 8) {
    04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 │ ................
}

static R10: &[u32] = {
    let mut _0: &[u32];
    let _1: &[u32];
    let mut _2: std::ops::Range<*const u32>;
    let mut _3: &[u32];
    let _4: &&[u32];
    let mut _5: &[u32];
    scope 1 {
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = const {alloc2: &&[u32]};
        _5 = deref_copy (*_4);
        _3 = &(*_5);
        ConstEvalCounter;
        _2 = core::slice::<impl [u32]>::as_ptr_range(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        StorageDead(_3);
        ConstEvalCounter;
        _1 = from_ptr_range::<'_, u32>(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = &(*_1);
        StorageDead(_2);
        StorageDead(_4);
        StorageDead(_1);
        return;
    }
}

alloc2 (static: R2, size: 16, align: 8) {
    ╾───────alloc71───────╼ 01 00 00 00 00 00 00 00 │ ╾──────╼........
}

alloc71 (size: 4, align: 4) {
    01 00 01 00                                     │ ....
}

const D0: u32 = {
    let mut _0: u32;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 16_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb1, unwind continue];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 16_i32);
        _0 = BitOr(move _1, const 1_u32);
        StorageDead(_1);
        return;
    }
}

const D1: MaybeUninit<&u32> = {
    let mut _0: std::mem::MaybeUninit<&u32>;

    bb0: {
        ConstEvalCounter;
        _0 = MaybeUninit::<&u32>::uninit() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const D2: Struct = {
    let mut _0: Struct;

    bb0: {
        _0 = Struct { a: const 1_u8, b: const 2_u32, c: const 3_u16, d: const 4_u8 };
        return;
    }
}

fn dangling() -> *const T {
    let mut _0: *const T;
    let mut _1: *mut T;
    let mut _2: std::ptr::NonNull<T>;

    bb0: {
        _2 = NonNull::<T>::dangling() -> [return: bb1, unwind continue];
    }

    bb1: {
        _1 = NonNull::<T>::as_ptr(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = move _1 as *const T (Pointer(MutToConstPointer));
        return;
    }
}

// MIR FOR CTFE
fn dangling() -> *const T {
    let mut _0: *const T;
    let mut _1: *const T;
    let mut _2: *mut T;
    let mut _3: std::ptr::NonNull<T>;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        ConstEvalCounter;
        _3 = NonNull::<T>::dangling() -> [return: bb1, unwind continue];
    }

    bb1: {
        ConstEvalCounter;
        _2 = NonNull::<T>::as_ptr(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _1 = move _2 as *const T (Pointer(MutToConstPointer));
        StorageDead(_3);
        StorageDead(_2);
        _0 = _1;
        StorageDead(_1);
        return;
    }
}

fn main() -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}
