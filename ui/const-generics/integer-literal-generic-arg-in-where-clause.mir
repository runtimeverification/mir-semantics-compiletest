// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn takes_closure_of_array_3(_1: F) -> () {
    debug f => _1;                       // in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:3:32: 3:33
    let mut _0: ();                      // return place in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:3:38: 3:38
    let _2: ();                          // in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:4:5: 4:17
    let mut _3: &F;                      // in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:4:5: 4:6
    let mut _4: ([i32; 3],);             // in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:4:5: 4:17
    let mut _5: [i32; 3];                // in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:4:7: 4:16

    bb0: {
        _3 = &_1;                        // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:4:5: 4:6
        _5 = [const 1_i32, const 2_i32, const 3_i32]; // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:4:7: 4:16
        _4 = (move _5,);                 // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:4:5: 4:17
        _2 = <F as Fn<([i32; 3],)>>::call(move _3, move _4) -> [return: bb1, unwind: bb3]; // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:4:5: 4:17
                                         // mir::Constant
                                         // + span: ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:4:5: 4:6
                                         // + literal: Const { ty: for<'a> extern "rust-call" fn(&'a F, ([i32; 3],)) -> <F as FnOnce<([i32; 3],)>>::Output {<F as Fn<([i32; 3],)>>::call}, val: Value(<ZST>) }
    }

    bb1: {
        drop(_1) -> bb2;                 // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:5:1: 5:2
    }

    bb2: {
        return;                          // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:5:2: 5:2
    }

    bb3 (cleanup): {
        drop(_1) -> bb4;                 // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:5:1: 5:2
    }

    bb4 (cleanup): {
        resume;                          // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:3:1: 5:2
    }
}

takes_closure_of_array_3::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:3:56: 3:57

    bb0: {
        _0 = const 3_usize;              // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:3:56: 3:57
        return;                          // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:3:56: 3:57
    }
}

fn takes_closure_of_array_3_apit(_1: impl Fn([i32; 3])) -> () {
    debug f => _1;                       // in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:7:34: 7:35
    let mut _0: ();                      // return place in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:7:56: 7:56
    let _2: ();                          // in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:8:5: 8:17
    let mut _3: &impl Fn([i32; 3]);      // in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:8:5: 8:6
    let mut _4: ([i32; 3],);             // in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:8:5: 8:17
    let mut _5: [i32; 3];                // in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:8:7: 8:16

    bb0: {
        _3 = &_1;                        // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:8:5: 8:6
        _5 = [const 1_i32, const 2_i32, const 3_i32]; // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:8:7: 8:16
        _4 = (move _5,);                 // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:8:5: 8:17
        _2 = <impl Fn([i32; 3]) as Fn<([i32; 3],)>>::call(move _3, move _4) -> [return: bb1, unwind: bb3]; // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:8:5: 8:17
                                         // mir::Constant
                                         // + span: ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:8:5: 8:6
                                         // + literal: Const { ty: for<'a> extern "rust-call" fn(&'a impl Fn([i32; 3]), ([i32; 3],)) -> <impl Fn([i32; 3]) as FnOnce<([i32; 3],)>>::Output {<impl Fn([i32; 3]) as Fn<([i32; 3],)>>::call}, val: Value(<ZST>) }
    }

    bb1: {
        drop(_1) -> bb2;                 // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:9:1: 9:2
    }

    bb2: {
        return;                          // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:9:2: 9:2
    }

    bb3 (cleanup): {
        drop(_1) -> bb4;                 // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:9:1: 9:2
    }

    bb4 (cleanup): {
        resume;                          // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:7:1: 9:2
    }
}

takes_closure_of_array_3_apit::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:7:51: 7:52

    bb0: {
        _0 = const 3_usize;              // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:7:51: 7:52
        return;                          // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:7:51: 7:52
    }
}

fn returns_closure_of_array_3() -> impl Fn([i32; 3]) {
    let mut _0: impl Fn([i32; 3]);       // return place in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:11:36: 11:53

    bb0: {
        return;                          // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:13:2: 13:2
    }
}

returns_closure_of_array_3::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:11:50: 11:51

    bb0: {
        _0 = const 3_usize;              // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:11:50: 11:51
        return;                          // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:11:50: 11:51
    }
}

fn returns_closure_of_array_3::{closure#0}(_1: &[closure@ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:12:5: 12:8], _2: [i32; 3]) -> () {
    let mut _0: ();                      // return place in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:12:9: 12:9

    bb0: {
        return;                          // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:12:11: 12:11
    }
}

fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:15:11: 15:11
    let _1: ();                          // in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:16:5: 16:59
    let mut _2: impl Fn([i32; 3]);       // in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:16:30: 16:58
    let _3: ();                          // in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:17:5: 17:64
    let mut _4: impl Fn([i32; 3]);       // in scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:17:35: 17:63

    bb0: {
        _2 = returns_closure_of_array_3() -> bb1; // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:16:30: 16:58
                                         // mir::Constant
                                         // + span: ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:16:30: 16:56
                                         // + literal: Const { ty: fn() -> impl Fn([i32; 3]) {returns_closure_of_array_3}, val: Value(<ZST>) }
    }

    bb1: {
        _1 = takes_closure_of_array_3::<impl Fn([i32; 3])>(move _2) -> bb2; // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:16:5: 16:59
                                         // mir::Constant
                                         // + span: ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:16:5: 16:29
                                         // + literal: Const { ty: fn(impl Fn([i32; 3])) {takes_closure_of_array_3::<impl Fn([i32; 3])>}, val: Value(<ZST>) }
    }

    bb2: {
        _4 = returns_closure_of_array_3() -> bb3; // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:17:35: 17:63
                                         // mir::Constant
                                         // + span: ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:17:35: 17:61
                                         // + literal: Const { ty: fn() -> impl Fn([i32; 3]) {returns_closure_of_array_3}, val: Value(<ZST>) }
    }

    bb3: {
        _3 = takes_closure_of_array_3_apit::<impl Fn([i32; 3])>(move _4) -> bb4; // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:17:5: 17:64
                                         // mir::Constant
                                         // + span: ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:17:5: 17:34
                                         // + literal: Const { ty: fn(impl Fn([i32; 3])) {takes_closure_of_array_3_apit::<impl Fn([i32; 3])>}, val: Value(<ZST>) }
    }

    bb4: {
        return;                          // scope 0 at ui/const-generics/integer-literal-generic-arg-in-where-clause.rs:18:2: 18:2
    }
}
