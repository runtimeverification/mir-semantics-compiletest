// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn yes_as_ref() -> impl AsRef<[u8]> {
    let mut _0: impl std::convert::AsRef<[u8]>;

    bb0: {
        _0 = [const 0_u8; 33];
        return;
    }
}

yes_as_ref::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 33_usize;
        return;
    }
}

fn yes_as_mut() -> impl AsMut<[u8]> {
    let mut _0: impl std::convert::AsMut<[u8]>;

    bb0: {
        _0 = [const 0_u8; 33];
        return;
    }
}

yes_as_mut::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 33_usize;
        return;
    }
}

fn yes_borrow() -> impl Borrow<[u8]> {
    let mut _0: impl std::borrow::Borrow<[u8]>;

    bb0: {
        _0 = [const 0_u8; 33];
        return;
    }
}

yes_borrow::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 33_usize;
        return;
    }
}

fn yes_borrow_mut() -> impl BorrowMut<[u8]> {
    let mut _0: impl std::borrow::BorrowMut<[u8]>;

    bb0: {
        _0 = [const 0_u8; 33];
        return;
    }
}

yes_borrow_mut::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 33_usize;
        return;
    }
}

fn yes_try_from_slice() -> impl TryFrom<&'static [u8]> {
    let mut _0: impl std::convert::TryFrom<&'static [u8]>;

    bb0: {
        _0 = [const 0_u8; 33];
        return;
    }
}

yes_try_from_slice::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 33_usize;
        return;
    }
}

fn yes_ref_try_from_slice() -> impl TryFrom<&'static [u8]> {
    let mut _0: impl std::convert::TryFrom<&'static [u8]>;
    let mut _1: &[u8; 33];
    scope 1 {
        debug a => const _;
    }

    bb0: {
        _1 = const _;
        _0 = _1;
        return;
    }
}

promoted[0] in yes_ref_try_from_slice: &[u8; 33] = {
    let mut _0: &[u8; 33];
    let mut _1: [u8; 33];

    bb0: {
        _1 = [const 0_u8; 33];
        _0 = &_1;
        return;
    }
}

yes_ref_try_from_slice::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 33_usize;
        return;
    }
}

fn yes_hash() -> impl Hash {
    let mut _0: impl std::hash::Hash;

    bb0: {
        _0 = [const 0_i32; 33];
        return;
    }
}

yes_hash::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 33_usize;
        return;
    }
}

fn yes_debug() -> impl Debug {
    let mut _0: impl std::fmt::Debug;

    bb0: {
        _0 = [const 0_i32; 33];
        return;
    }
}

yes_debug::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 33_usize;
        return;
    }
}

fn yes_ref_into_iterator() -> impl IntoIterator<Item = &'static u8> {
    let mut _0: impl std::iter::IntoIterator<Item = &'static u8>;
    let mut _1: &[u8; 33];
    scope 1 {
        debug a => const _;
    }

    bb0: {
        _1 = const _;
        _0 = _1;
        return;
    }
}

promoted[0] in yes_ref_into_iterator: &[u8; 33] = {
    let mut _0: &[u8; 33];
    let mut _1: [u8; 33];

    bb0: {
        _1 = [const 0_u8; 33];
        _0 = &_1;
        return;
    }
}

yes_ref_into_iterator::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 33_usize;
        return;
    }
}

fn yes_partial_eq() -> impl PartialEq<[u8; 33]> {
    let mut _0: impl std::cmp::PartialEq<[u8; 33]>;

    bb0: {
        _0 = [const 0_u8; 33];
        return;
    }
}

yes_partial_eq::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 33_usize;
        return;
    }
}

yes_partial_eq::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 33_usize;
        return;
    }
}

fn yes_partial_eq_slice() -> impl PartialEq<[u8]> {
    let mut _0: impl std::cmp::PartialEq<[u8]>;

    bb0: {
        _0 = [const 0_u8; 33];
        return;
    }
}

yes_partial_eq_slice::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 33_usize;
        return;
    }
}

fn yes_slice_partial_eq() -> impl PartialEq<[u8; 33]> {
    let mut _0: impl std::cmp::PartialEq<[u8; 33]>;
    let _1: &[u8];
    let mut _2: &[u8; 33];
    scope 1 {
        debug a => const _;
    }

    bb0: {
        _2 = const _;
        _1 = <[u8; 33] as Index<RangeFull>>::index(_2, const RangeFull) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

promoted[0] in yes_slice_partial_eq: &[u8; 33] = {
    let mut _0: &[u8; 33];
    let mut _1: [u8; 33];

    bb0: {
        _1 = [const 0_u8; 33];
        _0 = &_1;
        return;
    }
}

yes_slice_partial_eq::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 33_usize;
        return;
    }
}

yes_slice_partial_eq::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 33_usize;
        return;
    }
}

fn yes_eq() -> impl Eq {
    let mut _0: impl std::cmp::Eq;

    bb0: {
        _0 = [const 0_i32; 33];
        return;
    }
}

yes_eq::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 33_usize;
        return;
    }
}

fn yes_partial_ord() -> impl PartialOrd<[u8; 33]> {
    let mut _0: impl std::cmp::PartialOrd<[u8; 33]>;

    bb0: {
        _0 = [const 0_u8; 33];
        return;
    }
}

yes_partial_ord::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 33_usize;
        return;
    }
}

yes_partial_ord::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 33_usize;
        return;
    }
}

fn yes_ord() -> impl Ord {
    let mut _0: impl std::cmp::Ord;

    bb0: {
        _0 = [const 0_i32; 33];
        return;
    }
}

yes_ord::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 33_usize;
        return;
    }
}

fn main() -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}
