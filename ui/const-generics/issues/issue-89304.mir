// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
<impl at ui/const-generics/issues/issue-89304.rs:8:1: 8:71>::{constant#1}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/issues/issue-89304.rs:8:41: 8:42

    bb0: {
        _0 = const T;                    // scope 0 at ui/const-generics/issues/issue-89304.rs:8:41: 8:42
        return;                          // scope 0 at ui/const-generics/issues/issue-89304.rs:8:41: 8:42
    }
}

<impl at ui/const-generics/issues/issue-89304.rs:8:1: 8:71>::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/issues/issue-89304.rs:8:63: 8:70
    let mut _1: (usize, bool);           // in scope 0 at ui/const-generics/issues/issue-89304.rs:8:64: 8:69

    bb0: {
        _1 = CheckedAdd(const T, const 1_usize); // scope 0 at ui/const-generics/issues/issue-89304.rs:8:64: 8:69
        assert(!move (_1.1: bool), "attempt to compute `{} + {}`, which would overflow", const T, const 1_usize) -> bb1; // scope 0 at ui/const-generics/issues/issue-89304.rs:8:64: 8:69
    }

    bb1: {
        _0 = move (_1.0: usize);         // scope 0 at ui/const-generics/issues/issue-89304.rs:8:64: 8:69
        return;                          // scope 0 at ui/const-generics/issues/issue-89304.rs:8:63: 8:70
    }
}

fn <impl at ui/const-generics/issues/issue-89304.rs:8:1: 8:71>::from(_1: GenericStruct<T>) -> GenericStruct<{T + 1}> {
    debug other => _1;                   // in scope 0 at ui/const-generics/issues/issue-89304.rs:9:13: 9:18
    let mut _0: GenericStruct<{T + 1}>;  // return place in scope 0 at ui/const-generics/issues/issue-89304.rs:9:41: 9:45
    let mut _2: i64;                     // in scope 0 at ui/const-generics/issues/issue-89304.rs:10:21: 10:30

    bb0: {
        _2 = (_1.0: i64);                // scope 0 at ui/const-generics/issues/issue-89304.rs:10:21: 10:30
        _0 = GenericStruct::<{T + 1}> { val: move _2 }; // scope 0 at ui/const-generics/issues/issue-89304.rs:10:9: 10:32
                                         // adt
                                         // + user_ty: UserType(0)
        return;                          // scope 0 at ui/const-generics/issues/issue-89304.rs:11:6: 11:6
    }
}

<impl at ui/const-generics/issues/issue-89304.rs:8:1: 8:71>::from::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/issues/issue-89304.rs:9:34: 9:35

    bb0: {
        _0 = const T;                    // scope 0 at ui/const-generics/issues/issue-89304.rs:9:34: 9:35
        return;                          // scope 0 at ui/const-generics/issues/issue-89304.rs:9:34: 9:35
    }
}

<impl at ui/const-generics/issues/issue-89304.rs:14:1: 14:71>::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/issues/issue-89304.rs:14:41: 14:48
    let mut _1: (usize, bool);           // in scope 0 at ui/const-generics/issues/issue-89304.rs:14:42: 14:47

    bb0: {
        _1 = CheckedAdd(const T, const 1_usize); // scope 0 at ui/const-generics/issues/issue-89304.rs:14:42: 14:47
        assert(!move (_1.1: bool), "attempt to compute `{} + {}`, which would overflow", const T, const 1_usize) -> bb1; // scope 0 at ui/const-generics/issues/issue-89304.rs:14:42: 14:47
    }

    bb1: {
        _0 = move (_1.0: usize);         // scope 0 at ui/const-generics/issues/issue-89304.rs:14:42: 14:47
        return;                          // scope 0 at ui/const-generics/issues/issue-89304.rs:14:41: 14:48
    }
}

<impl at ui/const-generics/issues/issue-89304.rs:14:1: 14:71>::{constant#1}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/issues/issue-89304.rs:14:69: 14:70

    bb0: {
        _0 = const T;                    // scope 0 at ui/const-generics/issues/issue-89304.rs:14:69: 14:70
        return;                          // scope 0 at ui/const-generics/issues/issue-89304.rs:14:69: 14:70
    }
}

fn <impl at ui/const-generics/issues/issue-89304.rs:14:1: 14:71>::from(_1: GenericStruct<{T + 1}>) -> GenericStruct<T> {
    debug other => _1;                   // in scope 0 at ui/const-generics/issues/issue-89304.rs:15:13: 15:18
    let mut _0: GenericStruct<T>;        // return place in scope 0 at ui/const-generics/issues/issue-89304.rs:15:47: 15:51
    let mut _2: i64;                     // in scope 0 at ui/const-generics/issues/issue-89304.rs:16:21: 16:30

    bb0: {
        _2 = (_1.0: i64);                // scope 0 at ui/const-generics/issues/issue-89304.rs:16:21: 16:30
        _0 = GenericStruct::<T> { val: move _2 }; // scope 0 at ui/const-generics/issues/issue-89304.rs:16:9: 16:32
        return;                          // scope 0 at ui/const-generics/issues/issue-89304.rs:17:6: 17:6
    }
}

<impl at ui/const-generics/issues/issue-89304.rs:14:1: 14:71>::from::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/issues/issue-89304.rs:15:34: 15:41
    let mut _1: (usize, bool);           // in scope 0 at ui/const-generics/issues/issue-89304.rs:15:35: 15:40

    bb0: {
        _1 = CheckedAdd(const T, const 1_usize); // scope 0 at ui/const-generics/issues/issue-89304.rs:15:35: 15:40
        assert(!move (_1.1: bool), "attempt to compute `{} + {}`, which would overflow", const T, const 1_usize) -> bb1; // scope 0 at ui/const-generics/issues/issue-89304.rs:15:35: 15:40
    }

    bb1: {
        _0 = move (_1.0: usize);         // scope 0 at ui/const-generics/issues/issue-89304.rs:15:35: 15:40
        return;                          // scope 0 at ui/const-generics/issues/issue-89304.rs:15:34: 15:41
    }
}

fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/const-generics/issues/issue-89304.rs:20:11: 20:11

    bb0: {
        return;                          // scope 0 at ui/const-generics/issues/issue-89304.rs:20:13: 20:13
    }
}
