// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
Melon::new::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:8:23: 8:24

    bb0: {
        _0 = const X;                    // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:8:23: 8:24
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:8:23: 8:24
    }
}

Melon::change::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:9:24: 9:25

    bb0: {
        _0 = const X;                    // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:9:24: 9:25
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:9:24: 9:25
    }
}

Foo::0::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:12:18: 12:19

    bb0: {
        _0 = const 5_usize;              // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:12:18: 12:19
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:12:18: 12:19
    }
}

Bar::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:15:10: 15:15
    let mut _1: (usize, bool);           // in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:15:10: 15:15

    bb0: {
        _1 = CheckedAdd(const A, const B); // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:15:10: 15:15
        assert(!move (_1.1: bool), "attempt to compute `{} + {}`, which would overflow", const A, const B) -> bb1; // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:15:10: 15:15
    }

    bb1: {
        _0 = move (_1.0: usize);         // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:15:10: 15:15
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:15:10: 15:15
    }
}

Bar::0::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:13:50: 13:55
    let mut _1: (usize, bool);           // in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:13:50: 13:55

    bb0: {
        _1 = CheckedAdd(const A, const B); // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:13:50: 13:55
        assert(!move (_1.1: bool), "attempt to compute `{} + {}`, which would overflow", const A, const B) -> bb1; // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:13:50: 13:55
    }

    bb1: {
        _0 = move (_1.0: usize);         // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:13:50: 13:55
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:13:50: 13:55
    }
}

<impl at ui/const-generics/generic_const_exprs/issue-84408.rs:17:1: 17:22>::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:17:12: 17:13

    bb0: {
        _0 = const 5_usize;              // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:17:12: 17:13
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:17:12: 17:13
    }
}

fn <impl at ui/const-generics/generic_const_exprs/issue-84408.rs:17:1: 17:22>::new(_1: [i32; 5]) -> Foo {
    debug arr => _1;                     // in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:18:12: 18:15
    let mut _0: Foo;                     // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:18:30: 18:34
    let mut _2: [i32; 5];                // in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:19:13: 19:16

    bb0: {
        _2 = _1;                         // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:19:13: 19:16
        _0 = Foo(move _2);               // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:19:9: 19:17
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:20:6: 20:6
    }
}

<impl at ui/const-generics/generic_const_exprs/issue-84408.rs:17:1: 17:22>::new::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:18:23: 18:24

    bb0: {
        _0 = const 5_usize;              // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:18:23: 18:24
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:18:23: 18:24
    }
}

fn <impl at ui/const-generics/generic_const_exprs/issue-84408.rs:17:1: 17:22>::change(_1: Foo) -> T {
    debug self => _1;                    // in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:21:28: 21:32
    let mut _0: T;                       // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:21:37: 21:38
    let mut _2: [i32; 5];                // in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:22:16: 22:22

    bb0: {
        _2 = (_1.0: [i32; 5]);           // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:22:16: 22:22
        _0 = <T as Melon<5>>::new(move _2) -> bb1; // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:22:9: 22:23
                                         // mir::Constant
                                         // + span: ui/const-generics/generic_const_exprs/issue-84408.rs:22:9: 22:15
                                         // + literal: Const { ty: fn([i32; 5]) -> T {<T as Melon<5>>::new}, val: Value(<ZST>) }
    }

    bb1: {
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:23:6: 23:6
    }
}

<impl at ui/const-generics/generic_const_exprs/issue-84408.rs:17:1: 17:22>::change::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:21:24: 21:25

    bb0: {
        _0 = const 5_usize;              // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:21:24: 21:25
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:21:24: 21:25
    }
}

<impl at ui/const-generics/generic_const_exprs/issue-84408.rs:26:1: 26:68>::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:28:10: 28:15
    let mut _1: (usize, bool);           // in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:28:10: 28:15

    bb0: {
        _1 = CheckedAdd(const A, const B); // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:28:10: 28:15
        assert(!move (_1.1: bool), "attempt to compute `{} + {}`, which would overflow", const A, const B) -> bb1; // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:28:10: 28:15
    }

    bb1: {
        _0 = move (_1.0: usize);         // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:28:10: 28:15
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:28:10: 28:15
    }
}

<impl at ui/const-generics/generic_const_exprs/issue-84408.rs:26:1: 26:68>::{constant#1}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:26:44: 26:53
    let mut _1: (usize, bool);           // in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:26:46: 26:51

    bb0: {
        _1 = CheckedAdd(const A, const B); // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:26:46: 26:51
        assert(!move (_1.1: bool), "attempt to compute `{} + {}`, which would overflow", const A, const B) -> bb1; // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:26:46: 26:51
    }

    bb1: {
        _0 = move (_1.0: usize);         // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:26:46: 26:51
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:26:44: 26:53
    }
}

<impl at ui/const-generics/generic_const_exprs/issue-84408.rs:26:1: 26:68>::{constant#2}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:26:63: 26:64

    bb0: {
        _0 = const A;                    // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:26:63: 26:64
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:26:63: 26:64
    }
}

<impl at ui/const-generics/generic_const_exprs/issue-84408.rs:26:1: 26:68>::{constant#3}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:26:66: 26:67

    bb0: {
        _0 = const B;                    // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:26:66: 26:67
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:26:66: 26:67
    }
}

fn <impl at ui/const-generics/generic_const_exprs/issue-84408.rs:26:1: 26:68>::new(_1: [i32; A + B]) -> Bar<A, B> {
    debug arr => _1;                     // in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:30:12: 30:15
    let mut _0: Bar<A, B>;               // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:30:34: 30:38
    let mut _2: [i32; A + B];            // in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:31:13: 31:16

    bb0: {
        _2 = _1;                         // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:31:13: 31:16
        _0 = Bar::<A, B>(move _2);       // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:31:9: 31:17
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:32:6: 32:6
    }
}

<impl at ui/const-generics/generic_const_exprs/issue-84408.rs:26:1: 26:68>::new::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:30:23: 30:28
    let mut _1: (usize, bool);           // in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:30:23: 30:28

    bb0: {
        _1 = CheckedAdd(const A, const B); // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:30:23: 30:28
        assert(!move (_1.1: bool), "attempt to compute `{} + {}`, which would overflow", const A, const B) -> bb1; // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:30:23: 30:28
    }

    bb1: {
        _0 = move (_1.0: usize);         // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:30:23: 30:28
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:30:23: 30:28
    }
}

fn <impl at ui/const-generics/generic_const_exprs/issue-84408.rs:26:1: 26:68>::change(_1: Bar<A, B>) -> T {
    debug self => _1;                    // in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:33:36: 33:40
    let mut _0: T;                       // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:33:45: 33:46
    let mut _2: [i32; A + B];            // in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:34:16: 34:22

    bb0: {
        _2 = (_1.0: [i32; A + B]);       // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:34:16: 34:22
        _0 = <T as Melon<{ A + B }>>::new(move _2) -> bb1; // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:34:9: 34:23
                                         // mir::Constant
                                         // + span: ui/const-generics/generic_const_exprs/issue-84408.rs:34:9: 34:15
                                         // + literal: Const { ty: fn([i32; { A + B }]) -> T {<T as Melon<{ A + B }>>::new}, val: Value(<ZST>) }
    }

    bb1: {
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:35:6: 35:6
    }
}

<impl at ui/const-generics/generic_const_exprs/issue-84408.rs:26:1: 26:68>::change::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:33:24: 33:33
    let mut _1: (usize, bool);           // in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:33:26: 33:31

    bb0: {
        _1 = CheckedAdd(const A, const B); // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:33:26: 33:31
        assert(!move (_1.1: bool), "attempt to compute `{} + {}`, which would overflow", const A, const B) -> bb1; // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:33:26: 33:31
    }

    bb1: {
        _0 = move (_1.0: usize);         // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:33:26: 33:31
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:33:24: 33:33
    }
}

fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:38:11: 38:11

    bb0: {
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:38:13: 38:13
    }
}

fn Foo(_1: [i32; 5]) -> Foo {
    let mut _0: Foo;                     // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:12:1: 12:11

    bb0: {
        _0 = Foo(move _1);               // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:12:1: 12:11
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:12:1: 12:11
    }
}

// MIR FOR CTFE
fn Foo(_1: [i32; 5]) -> Foo {
    let mut _0: Foo;                     // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:12:1: 12:11

    bb0: {
        _0 = Foo(move _1);               // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:12:1: 12:11
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:12:1: 12:11
    }
}

fn Bar(_1: [i32; A + B]) -> Bar<A, B> {
    let mut _0: Bar<A, B>;               // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:13:1: 13:43

    bb0: {
        _0 = Bar::<A, B>(move _1);       // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:13:1: 13:43
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:13:1: 13:43
    }
}

// MIR FOR CTFE
fn Bar(_1: [i32; A + B]) -> Bar<A, B> {
    let mut _0: Bar<A, B>;               // return place in scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:13:1: 13:43

    bb0: {
        _0 = Bar::<A, B>(move _1);       // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:13:1: 13:43
        return;                          // scope 0 at ui/const-generics/generic_const_exprs/issue-84408.rs:13:1: 13:43
    }
}
