// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
ConstChunksExactTrait::const_chunks_exact::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const N;
        return;
    }
}

fn <impl at ui/const-generics/type-dependent/issue-70507.rs:7:1: 7:42>::const_chunks_exact(_1: &[T]) -> ConstChunksExact<'_, T, N> {
    debug self => _1;
    let mut _0: ConstChunksExact<'_, T, N>;
    let mut _2: bool;
    let mut _3: bool;
    let mut _4: !;
    let _5: usize;
    let mut _6: usize;
    let mut _7: bool;
    let mut _9: usize;
    let mut _11: (&[T], &[T]);
    scope 1 {
        debug rem => _5;
        let _8: usize;
        scope 2 {
            debug len => _8;
            let _10: &[T];
            scope 3 {
                debug fst => _10;
            }
        }
    }

    bb0: {
        _3 = Ne(const N, const 0_usize);
        _2 = Not(move _3);
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = core::panicking::panic(const "assertion failed: N != 0") -> unwind continue;
    }

    bb2: {
        _6 = Len((*_1));
        _7 = Eq(const N, const 0_usize);
        assert(!move _7, "attempt to calculate the remainder of `{}` with a divisor of zero", _6) -> [success: bb3, unwind continue];
    }

    bb3: {
        _5 = Rem(move _6, const N);
        _9 = Len((*_1));
        _8 = Sub(move _9, _5);
        _11 = core::slice::<impl [T]>::split_at(_1, _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        _10 = (_11.0: &[T]);
        _0 = ConstChunksExact::<'_, T, N> { v: _10 };
        return;
    }
}

<impl at ui/const-generics/type-dependent/issue-70507.rs:7:1: 7:42>::const_chunks_exact::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const N;
        return;
    }
}

<impl at ui/const-generics/type-dependent/issue-70507.rs:21:1: 21:88>::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const N;
        return;
    }
}

<impl at ui/const-generics/type-dependent/issue-70507.rs:21:1: 21:88>::Item::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const N;
        return;
    }
}

fn <impl at ui/const-generics/type-dependent/issue-70507.rs:21:1: 21:88>::next(_1: &mut ConstChunksExact<'_, T, N>) -> Option<&[T; N]> {
    debug self => _1;
    let mut _0: std::option::Option<&[T; N]>;
    let mut _2: bool;
    let mut _3: usize;
    let _4: &[T];
    let _5: &[T];
    let mut _6: (&[T], &[T]);
    let mut _7: *const [T; N];
    let mut _8: *const T;
    let _9: &[T; N];
    let mut _10: &[T];
    let mut _11: &[T];
    scope 1 {
        debug fst => _4;
        debug snd => _5;
        scope 2 {
            debug ptr => _7;
            scope 3 {
                let mut _12: *const ();
                let mut _13: usize;
                let mut _14: usize;
                let mut _15: usize;
                let mut _16: usize;
                let mut _17: bool;
            }
        }
    }

    bb0: {
        _10 = deref_copy ((*_1).0: &[T]);
        _3 = Len((*_10));
        _2 = Lt(move _3, const N);
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<&[T; N]>::None;
        goto -> bb5;
    }

    bb2: {
        _11 = deref_copy ((*_1).0: &[T]);
        _6 = core::slice::<impl [T]>::split_at(_11, const N) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = (_6.0: &[T]);
        _5 = (_6.1: &[T]);
        ((*_1).0: &[T]) = _5;
        _8 = core::slice::<impl [T]>::as_ptr(_4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = move _8 as *const [T; N] (PtrToPtr);
        _12 = _7 as *const () (PtrToPtr);
        _13 = _12 as usize (Transmute);
        _14 = AlignOf(T);
        _15 = Sub(_14, const 1_usize);
        _16 = BitAnd(_13, _15);
        _17 = Eq(_16, const 0_usize);
        assert(_17, "misaligned pointer dereference: address must be a multiple of {} but is {}", _14, _13) -> [success: bb6, unwind unreachable];
    }

    bb5: {
        return;
    }

    bb6: {
        _9 = &(*_7);
        _0 = Option::<&[T; N]>::Some(_9);
        goto -> bb5;
    }
}

fn main() -> () {
    let mut _0: ();
    let mut _2: &[[i32; 3]];
    let mut _3: ConstChunksExact<'_, i32, 3>;
    let mut _4: ConstChunksExact<'_, i32, 3>;
    let mut _5: &[i32];
    let mut _7: std::option::Option<&[i32; 3]>;
    let mut _8: &mut ConstChunksExact<'_, i32, 3>;
    let mut _9: isize;
    let mut _11: (&&[i32; 3], &&[i32; 3]);
    let mut _12: &&[i32; 3];
    let mut _13: &&[i32; 3];
    let _14: &[i32; 3];
    let mut _15: std::option::Option<&[i32; 3]>;
    let mut _16: &mut std::slice::Iter<'_, [i32; 3]>;
    let mut _19: bool;
    let mut _20: bool;
    let _22: !;
    let mut _23: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _25: &[i32; 10];
    scope 1 {
        debug slice => const _;
        let mut _1: std::slice::Iter<'_, [i32; 3]>;
        let mut _24: &[[i32; 3]; 3];
        scope 2 {
            debug iter => _1;
            let mut _6: ConstChunksExact<'_, i32, 3>;
            scope 3 {
                debug iter => _6;
                let _10: &[i32; 3];
                scope 4 {
                    debug a => _10;
                    let _17: &&[i32; 3];
                    let _18: &&[i32; 3];
                    scope 5 {
                        debug left_val => _17;
                        debug right_val => _18;
                        let _21: core::panicking::AssertKind;
                        scope 6 {
                            debug kind => _21;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _25 = const _;
        _24 = const _;
        _2 = _24 as &[[i32; 3]] (Pointer(Unsize));
        _1 = core::slice::<impl [[i32; 3]]>::iter(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = _25 as &[i32] (Pointer(Unsize));
        _4 = <[i32] as ConstChunksExactTrait<i32>>::const_chunks_exact::<3>(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = <ConstChunksExact<'_, i32, 3> as IntoIterator>::into_iter(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = move _3;
        goto -> bb4;
    }

    bb4: {
        _8 = &mut _6;
        _7 = <ConstChunksExact<'_, i32, 3> as Iterator>::next(_8) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb8, 1: bb6, otherwise: bb7];
    }

    bb6: {
        _10 = ((_7 as Some).0: &[i32; 3]);
        _12 = &_10;
        _16 = &mut _1;
        _15 = <std::slice::Iter<'_, [i32; 3]> as Iterator>::next(move _16) -> [return: bb9, unwind continue];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        return;
    }

    bb9: {
        _14 = Option::<&[i32; 3]>::unwrap(move _15) -> [return: bb10, unwind continue];
    }

    bb10: {
        _13 = &_14;
        _11 = (move _12, move _13);
        _17 = (_11.0: &&[i32; 3]);
        _18 = (_11.1: &&[i32; 3]);
        _20 = <&[i32; 3] as PartialEq>::eq(_17, _18) -> [return: bb11, unwind continue];
    }

    bb11: {
        _19 = Not(move _20);
        switchInt(move _19) -> [0: bb4, otherwise: bb12];
    }

    bb12: {
        _21 = core::panicking::AssertKind::Eq;
        _23 = Option::<Arguments<'_>>::None;
        _22 = core::panicking::assert_failed::<&[i32; 3], &[i32; 3]>(move _21, _17, _18, move _23) -> unwind continue;
    }
}

promoted[0] in main: &[[i32; 3]; 3] = {
    let mut _0: &[[i32; 3]; 3];
    let mut _1: [[i32; 3]; 3];
    let mut _2: [i32; 3];
    let mut _3: [i32; 3];
    let mut _4: [i32; 3];

    bb0: {
        _2 = [const 1_i32, const 2_i32, const 3_i32];
        _3 = [const 4_i32, const 5_i32, const 6_i32];
        _4 = [const 7_i32, const 8_i32, const 9_i32];
        _1 = [move _2, move _3, move _4];
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &[i32; 10] = {
    let mut _0: &[i32; 10];
    let mut _1: [i32; 10];

    bb0: {
        _1 = [const 1_i32, const 2_i32, const 3_i32, const 4_i32, const 5_i32, const 6_i32, const 7_i32, const 8_i32, const 9_i32, const 10_i32];
        _0 = &_1;
        return;
    }
}

main::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 3_usize;
        return;
    }
}
