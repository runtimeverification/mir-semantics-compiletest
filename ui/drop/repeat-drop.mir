// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
static mut CHECK: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 0_usize;
        return;
    }
}

fn <impl at ui/drop/repeat-drop.rs:10:1: 10:26>::drop(_1: &mut DropChecker) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: bool;
    let mut _3: usize;
    let mut _4: *mut usize;
    let mut _5: usize;
    let mut _6: usize;
    let _7: !;
    let mut _8: std::fmt::Arguments<'_>;
    let mut _9: &[&str];
    let mut _10: &[core::fmt::rt::Argument<'_>];
    let _11: &[core::fmt::rt::Argument<'_>; 2];
    let _12: [core::fmt::rt::Argument<'_>; 2];
    let mut _13: core::fmt::rt::Argument<'_>;
    let _14: &usize;
    let _15: *mut usize;
    let mut _16: core::fmt::rt::Argument<'_>;
    let _17: &usize;
    let _18: usize;
    let mut _19: usize;
    let mut _20: usize;
    let mut _21: *mut usize;
    scope 1 {
        let mut _22: &[&str; 2];
        let mut _23: *const ();
        let mut _24: usize;
        let mut _25: usize;
        let mut _26: usize;
        let mut _27: usize;
        let mut _28: bool;
        let mut _29: *const ();
        let mut _30: usize;
        let mut _31: usize;
        let mut _32: usize;
        let mut _33: usize;
        let mut _34: bool;
        let mut _35: *const ();
        let mut _36: usize;
        let mut _37: usize;
        let mut _38: usize;
        let mut _39: usize;
        let mut _40: bool;
    }

    bb0: {
        _4 = const {alloc1: *mut usize};
        _35 = _4 as *const () (PtrToPtr);
        _36 = _35 as usize (Transmute);
        _37 = AlignOf(usize);
        _38 = Sub(_37, const 1_usize);
        _39 = BitAnd(_36, _38);
        _40 = Eq(_39, const 0_usize);
        assert(_40, "misaligned pointer dereference: address must be a multiple of {} but is {}", _37, _36) -> [success: bb8, unwind unreachable];
    }

    bb1: {
        _22 = const _;
        _9 = _22 as &[&str] (Pointer(Unsize));
        _15 = const {alloc1: *mut usize};
        _29 = _15 as *const () (PtrToPtr);
        _30 = _29 as usize (Transmute);
        _31 = AlignOf(usize);
        _32 = Sub(_31, const 1_usize);
        _33 = BitAnd(_30, _32);
        _34 = Eq(_33, const 0_usize);
        assert(_34, "misaligned pointer dereference: address must be a multiple of {} but is {}", _31, _30) -> [success: bb7, unwind unreachable];
    }

    bb2: {
        _19 = ((*_1).0: usize);
        _18 = Sub(move _19, const 1_usize);
        _17 = &_18;
        _16 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_17) -> [return: bb3, unwind continue];
    }

    bb3: {
        _12 = [move _13, move _16];
        _11 = &_12;
        _10 = _11 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _8 = Arguments::<'_>::new_v1(move _9, move _10) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = panic_fmt(move _8) -> unwind continue;
    }

    bb5: {
        _20 = ((*_1).0: usize);
        _21 = const {alloc1: *mut usize};
        _23 = _21 as *const () (PtrToPtr);
        _24 = _23 as usize (Transmute);
        _25 = AlignOf(usize);
        _26 = Sub(_25, const 1_usize);
        _27 = BitAnd(_24, _26);
        _28 = Eq(_27, const 0_usize);
        assert(_28, "misaligned pointer dereference: address must be a multiple of {} but is {}", _25, _24) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        (*_21) = move _20;
        return;
    }

    bb7: {
        _14 = &(*_15);
        _13 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_14) -> [return: bb2, unwind continue];
    }

    bb8: {
        _3 = (*_4);
        _6 = ((*_1).0: usize);
        _5 = Sub(move _6, const 1_usize);
        _2 = Ne(move _3, move _5);
        switchInt(move _2) -> [0: bb5, otherwise: bb1];
    }
}

alloc1 (static: CHECK, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

promoted[0] in <impl at ui/drop/repeat-drop.rs:10:1: 10:26>::drop: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Found ", const ", should have found "];
        _0 = &_1;
        return;
    }
}

fn <impl at ui/drop/repeat-drop.rs:29:1: 29:24>::drop(_1: &mut DropPanic) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: !;

    bb0: {
        _2 = begin_panic::<&str>(const "explicit panic") -> unwind continue;
    }
}

fn value_zero() -> () {
    let mut _0: ();
    let mut _1: *mut usize;
    let _2: DropChecker;
    let mut _3: DropChecker;
    let mut _4: (&usize, &usize);
    let mut _5: &usize;
    let _6: *mut usize;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: usize;
    let mut _12: usize;
    let _14: !;
    let mut _15: std::option::Option<std::fmt::Arguments<'_>>;
    let _16: ();
    let mut _17: (&usize, &usize);
    let mut _18: &usize;
    let _19: *mut usize;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: usize;
    let mut _25: usize;
    let _27: !;
    let mut _28: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        let mut _43: *const ();
        let mut _44: usize;
        let mut _45: usize;
        let mut _46: usize;
        let mut _47: usize;
        let mut _48: bool;
    }
    scope 2 {
        debug foo => _2;
        scope 3 {
            debug v => const [];
            scope 4 {
                let _7: &usize;
                let _8: &usize;
                let mut _30: &usize;
                let mut _37: *const ();
                let mut _38: usize;
                let mut _39: usize;
                let mut _40: usize;
                let mut _41: usize;
                let mut _42: bool;
                scope 5 {
                    debug left_val => _7;
                    debug right_val => _8;
                    let _13: core::panicking::AssertKind;
                    scope 6 {
                        debug kind => _13;
                    }
                }
            }
            scope 7 {
                let _20: &usize;
                let _21: &usize;
                let mut _29: &usize;
                let mut _31: *const ();
                let mut _32: usize;
                let mut _33: usize;
                let mut _34: usize;
                let mut _35: usize;
                let mut _36: bool;
                scope 8 {
                    debug left_val => _20;
                    debug right_val => _21;
                    let _26: core::panicking::AssertKind;
                    scope 9 {
                        debug kind => _26;
                    }
                }
            }
        }
    }

    bb0: {
        _1 = const {alloc1: *mut usize};
        _43 = _1 as *const () (PtrToPtr);
        _44 = _43 as usize (Transmute);
        _45 = AlignOf(usize);
        _46 = Sub(_45, const 1_usize);
        _47 = BitAnd(_44, _46);
        _48 = Eq(_47, const 0_usize);
        assert(_48, "misaligned pointer dereference: address must be a multiple of {} but is {}", _45, _44) -> [success: bb9, unwind unreachable];
    }

    bb1: {
        _6 = const {alloc1: *mut usize};
        _37 = _6 as *const () (PtrToPtr);
        _38 = _37 as usize (Transmute);
        _39 = AlignOf(usize);
        _40 = Sub(_39, const 1_usize);
        _41 = BitAnd(_38, _40);
        _42 = Eq(_41, const 0_usize);
        assert(_42, "misaligned pointer dereference: address must be a multiple of {} but is {}", _39, _38) -> [success: bb8, unwind unreachable];
    }

    bb2: {
        _13 = core::panicking::AssertKind::Eq;
        _15 = Option::<Arguments<'_>>::None;
        _14 = core::panicking::assert_failed::<usize, usize>(move _13, _7, _8, move _15) -> unwind continue;
    }

    bb3: {
        _16 = std::mem::drop::<[DropChecker; 0]>(const []) -> [return: bb4, unwind continue];
    }

    bb4: {
        _19 = const {alloc1: *mut usize};
        _31 = _19 as *const () (PtrToPtr);
        _32 = _31 as usize (Transmute);
        _33 = AlignOf(usize);
        _34 = Sub(_33, const 1_usize);
        _35 = BitAnd(_32, _34);
        _36 = Eq(_35, const 0_usize);
        assert(_36, "misaligned pointer dereference: address must be a multiple of {} but is {}", _33, _32) -> [success: bb7, unwind unreachable];
    }

    bb5: {
        _26 = core::panicking::AssertKind::Eq;
        _28 = Option::<Arguments<'_>>::None;
        _27 = core::panicking::assert_failed::<usize, usize>(move _26, _20, _21, move _28) -> unwind continue;
    }

    bb6: {
        return;
    }

    bb7: {
        _18 = &(*_19);
        _29 = const _;
        _17 = (move _18, _29);
        _20 = (_17.0: &usize);
        _21 = (_17.1: &usize);
        _24 = (*_20);
        _25 = (*_21);
        _23 = Eq(move _24, move _25);
        _22 = Not(move _23);
        switchInt(move _22) -> [0: bb6, otherwise: bb5];
    }

    bb8: {
        _5 = &(*_6);
        _30 = const _;
        _4 = (move _5, _30);
        _7 = (_4.0: &usize);
        _8 = (_4.1: &usize);
        _11 = (*_7);
        _12 = (*_8);
        _10 = Eq(move _11, move _12);
        _9 = Not(move _10);
        switchInt(move _9) -> [0: bb3, otherwise: bb2];
    }

    bb9: {
        (*_1) = const 0_usize;
        _2 = DropChecker(const 1_usize);
        _3 = move _2;
        drop(_3) -> [return: bb1, unwind continue];
    }
}

alloc1 (static: CHECK, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

promoted[0] in value_zero: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 1_usize;
        _0 = &_1;
        return;
    }
}

promoted[1] in value_zero: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 1_usize;
        _0 = &_1;
        return;
    }
}

value_zero::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 0_usize;
        return;
    }
}

value_zero::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 0_usize;
        return;
    }
}

fn value_one() -> () {
    let mut _0: ();
    let mut _1: *mut usize;
    let _2: DropChecker;
    let mut _4: (&usize, &usize);
    let mut _5: &usize;
    let _6: *mut usize;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: usize;
    let mut _12: usize;
    let _14: !;
    let mut _15: std::option::Option<std::fmt::Arguments<'_>>;
    let _16: ();
    let mut _17: [DropChecker; 1];
    let mut _18: (&usize, &usize);
    let mut _19: &usize;
    let _20: *mut usize;
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: usize;
    let mut _26: usize;
    let _28: !;
    let mut _29: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _32: bool;
    scope 1 {
        let mut _45: *const ();
        let mut _46: usize;
        let mut _47: usize;
        let mut _48: usize;
        let mut _49: usize;
        let mut _50: bool;
    }
    scope 2 {
        debug foo => _2;
        let _3: [DropChecker; 1];
        scope 3 {
            debug v => _3;
            scope 4 {
                let _7: &usize;
                let _8: &usize;
                let mut _31: &usize;
                let mut _39: *const ();
                let mut _40: usize;
                let mut _41: usize;
                let mut _42: usize;
                let mut _43: usize;
                let mut _44: bool;
                scope 5 {
                    debug left_val => _7;
                    debug right_val => _8;
                    let _13: core::panicking::AssertKind;
                    scope 6 {
                        debug kind => _13;
                    }
                }
            }
            scope 7 {
                let _21: &usize;
                let _22: &usize;
                let mut _30: &usize;
                let mut _33: *const ();
                let mut _34: usize;
                let mut _35: usize;
                let mut _36: usize;
                let mut _37: usize;
                let mut _38: bool;
                scope 8 {
                    debug left_val => _21;
                    debug right_val => _22;
                    let _27: core::panicking::AssertKind;
                    scope 9 {
                        debug kind => _27;
                    }
                }
            }
        }
    }

    bb0: {
        _32 = const false;
        _1 = const {alloc1: *mut usize};
        _45 = _1 as *const () (PtrToPtr);
        _46 = _45 as usize (Transmute);
        _47 = AlignOf(usize);
        _48 = Sub(_47, const 1_usize);
        _49 = BitAnd(_46, _48);
        _50 = Eq(_49, const 0_usize);
        assert(_50, "misaligned pointer dereference: address must be a multiple of {} but is {}", _47, _46) -> [success: bb11, unwind unreachable];
    }

    bb1: {
        _13 = core::panicking::AssertKind::Eq;
        _15 = Option::<Arguments<'_>>::None;
        _14 = core::panicking::assert_failed::<usize, usize>(move _13, _7, _8, move _15) -> bb8;
    }

    bb2: {
        _32 = const false;
        _17 = move _3;
        _16 = std::mem::drop::<[DropChecker; 1]>(move _17) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _20 = const {alloc1: *mut usize};
        _33 = _20 as *const () (PtrToPtr);
        _34 = _33 as usize (Transmute);
        _35 = AlignOf(usize);
        _36 = Sub(_35, const 1_usize);
        _37 = BitAnd(_34, _36);
        _38 = Eq(_37, const 0_usize);
        assert(_38, "misaligned pointer dereference: address must be a multiple of {} but is {}", _35, _34) -> [success: bb9, unwind unreachable];
    }

    bb4: {
        _27 = core::panicking::AssertKind::Eq;
        _29 = Option::<Arguments<'_>>::None;
        _28 = core::panicking::assert_failed::<usize, usize>(move _27, _21, _22, move _29) -> bb8;
    }

    bb5: {
        _32 = const false;
        return;
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        drop(_3) -> [return: bb6, unwind terminate];
    }

    bb8 (cleanup): {
        switchInt(_32) -> [0: bb6, otherwise: bb7];
    }

    bb9: {
        _19 = &(*_20);
        _30 = const _;
        _18 = (move _19, _30);
        _21 = (_18.0: &usize);
        _22 = (_18.1: &usize);
        _25 = (*_21);
        _26 = (*_22);
        _24 = Eq(move _25, move _26);
        _23 = Not(move _24);
        switchInt(move _23) -> [0: bb5, otherwise: bb4];
    }

    bb10: {
        _5 = &(*_6);
        _31 = const _;
        _4 = (move _5, _31);
        _7 = (_4.0: &usize);
        _8 = (_4.1: &usize);
        _11 = (*_7);
        _12 = (*_8);
        _10 = Eq(move _11, move _12);
        _9 = Not(move _10);
        switchInt(move _9) -> [0: bb2, otherwise: bb1];
    }

    bb11: {
        (*_1) = const 0_usize;
        _2 = DropChecker(const 1_usize);
        _32 = const true;
        _3 = [move _2; 1];
        _6 = const {alloc1: *mut usize};
        _39 = _6 as *const () (PtrToPtr);
        _40 = _39 as usize (Transmute);
        _41 = AlignOf(usize);
        _42 = Sub(_41, const 1_usize);
        _43 = BitAnd(_40, _42);
        _44 = Eq(_43, const 0_usize);
        assert(_44, "misaligned pointer dereference: address must be a multiple of {} but is {}", _41, _40) -> [success: bb10, unwind unreachable];
    }
}

alloc1 (static: CHECK, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

promoted[0] in value_one: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 1_usize;
        _0 = &_1;
        return;
    }
}

promoted[1] in value_one: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 0_usize;
        _0 = &_1;
        return;
    }
}

value_one::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

value_one::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

const DROP_CHECKER: DropChecker = {
    let mut _0: DropChecker;

    bb0: {
        _0 = DropChecker(const 1_usize);
        return;
    }
}

fn const_zero() -> () {
    let mut _0: ();
    let mut _1: *mut usize;
    let mut _2: (&usize, &usize);
    let mut _3: &usize;
    let _4: *mut usize;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: usize;
    let mut _10: usize;
    let _12: !;
    let mut _13: std::option::Option<std::fmt::Arguments<'_>>;
    let _14: ();
    let mut _15: (&usize, &usize);
    let mut _16: &usize;
    let _17: *mut usize;
    let mut _20: bool;
    let mut _21: bool;
    let mut _22: usize;
    let mut _23: usize;
    let _25: !;
    let mut _26: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        let mut _41: *const ();
        let mut _42: usize;
        let mut _43: usize;
        let mut _44: usize;
        let mut _45: usize;
        let mut _46: bool;
    }
    scope 2 {
        debug v => const [];
        scope 3 {
            let _5: &usize;
            let _6: &usize;
            let mut _28: &usize;
            let mut _35: *const ();
            let mut _36: usize;
            let mut _37: usize;
            let mut _38: usize;
            let mut _39: usize;
            let mut _40: bool;
            scope 4 {
                debug left_val => _5;
                debug right_val => _6;
                let _11: core::panicking::AssertKind;
                scope 5 {
                    debug kind => _11;
                }
            }
        }
        scope 6 {
            let _18: &usize;
            let _19: &usize;
            let mut _27: &usize;
            let mut _29: *const ();
            let mut _30: usize;
            let mut _31: usize;
            let mut _32: usize;
            let mut _33: usize;
            let mut _34: bool;
            scope 7 {
                debug left_val => _18;
                debug right_val => _19;
                let _24: core::panicking::AssertKind;
                scope 8 {
                    debug kind => _24;
                }
            }
        }
    }

    bb0: {
        _1 = const {alloc1: *mut usize};
        _41 = _1 as *const () (PtrToPtr);
        _42 = _41 as usize (Transmute);
        _43 = AlignOf(usize);
        _44 = Sub(_43, const 1_usize);
        _45 = BitAnd(_42, _44);
        _46 = Eq(_45, const 0_usize);
        assert(_46, "misaligned pointer dereference: address must be a multiple of {} but is {}", _43, _42) -> [success: bb8, unwind unreachable];
    }

    bb1: {
        _11 = core::panicking::AssertKind::Eq;
        _13 = Option::<Arguments<'_>>::None;
        _12 = core::panicking::assert_failed::<usize, usize>(move _11, _5, _6, move _13) -> unwind continue;
    }

    bb2: {
        _14 = std::mem::drop::<[DropChecker; 0]>(const []) -> [return: bb3, unwind continue];
    }

    bb3: {
        _17 = const {alloc1: *mut usize};
        _29 = _17 as *const () (PtrToPtr);
        _30 = _29 as usize (Transmute);
        _31 = AlignOf(usize);
        _32 = Sub(_31, const 1_usize);
        _33 = BitAnd(_30, _32);
        _34 = Eq(_33, const 0_usize);
        assert(_34, "misaligned pointer dereference: address must be a multiple of {} but is {}", _31, _30) -> [success: bb6, unwind unreachable];
    }

    bb4: {
        _24 = core::panicking::AssertKind::Eq;
        _26 = Option::<Arguments<'_>>::None;
        _25 = core::panicking::assert_failed::<usize, usize>(move _24, _18, _19, move _26) -> unwind continue;
    }

    bb5: {
        return;
    }

    bb6: {
        _16 = &(*_17);
        _27 = const _;
        _15 = (move _16, _27);
        _18 = (_15.0: &usize);
        _19 = (_15.1: &usize);
        _22 = (*_18);
        _23 = (*_19);
        _21 = Eq(move _22, move _23);
        _20 = Not(move _21);
        switchInt(move _20) -> [0: bb5, otherwise: bb4];
    }

    bb7: {
        _3 = &(*_4);
        _28 = const _;
        _2 = (move _3, _28);
        _5 = (_2.0: &usize);
        _6 = (_2.1: &usize);
        _9 = (*_5);
        _10 = (*_6);
        _8 = Eq(move _9, move _10);
        _7 = Not(move _8);
        switchInt(move _7) -> [0: bb2, otherwise: bb1];
    }

    bb8: {
        (*_1) = const 0_usize;
        _4 = const {alloc1: *mut usize};
        _35 = _4 as *const () (PtrToPtr);
        _36 = _35 as usize (Transmute);
        _37 = AlignOf(usize);
        _38 = Sub(_37, const 1_usize);
        _39 = BitAnd(_36, _38);
        _40 = Eq(_39, const 0_usize);
        assert(_40, "misaligned pointer dereference: address must be a multiple of {} but is {}", _37, _36) -> [success: bb7, unwind unreachable];
    }
}

alloc1 (static: CHECK, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

promoted[0] in const_zero: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 0_usize;
        _0 = &_1;
        return;
    }
}

promoted[1] in const_zero: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 0_usize;
        _0 = &_1;
        return;
    }
}

const_zero::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 0_usize;
        return;
    }
}

const_zero::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 0_usize;
        return;
    }
}

fn const_one() -> () {
    let mut _0: ();
    let mut _1: *mut usize;
    let _2: [DropChecker; 1];
    let mut _3: (&usize, &usize);
    let mut _4: &usize;
    let _5: *mut usize;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: usize;
    let mut _11: usize;
    let _13: !;
    let mut _14: std::option::Option<std::fmt::Arguments<'_>>;
    let _15: ();
    let mut _16: [DropChecker; 1];
    let mut _17: (&usize, &usize);
    let mut _18: &usize;
    let _19: *mut usize;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: usize;
    let mut _25: usize;
    let _27: !;
    let mut _28: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _31: bool;
    scope 1 {
        let mut _44: *const ();
        let mut _45: usize;
        let mut _46: usize;
        let mut _47: usize;
        let mut _48: usize;
        let mut _49: bool;
    }
    scope 2 {
        debug v => _2;
        scope 3 {
            let _6: &usize;
            let _7: &usize;
            let mut _30: &usize;
            let mut _38: *const ();
            let mut _39: usize;
            let mut _40: usize;
            let mut _41: usize;
            let mut _42: usize;
            let mut _43: bool;
            scope 4 {
                debug left_val => _6;
                debug right_val => _7;
                let _12: core::panicking::AssertKind;
                scope 5 {
                    debug kind => _12;
                }
            }
        }
        scope 6 {
            let _20: &usize;
            let _21: &usize;
            let mut _29: &usize;
            let mut _32: *const ();
            let mut _33: usize;
            let mut _34: usize;
            let mut _35: usize;
            let mut _36: usize;
            let mut _37: bool;
            scope 7 {
                debug left_val => _20;
                debug right_val => _21;
                let _26: core::panicking::AssertKind;
                scope 8 {
                    debug kind => _26;
                }
            }
        }
    }

    bb0: {
        _31 = const false;
        _1 = const {alloc1: *mut usize};
        _44 = _1 as *const () (PtrToPtr);
        _45 = _44 as usize (Transmute);
        _46 = AlignOf(usize);
        _47 = Sub(_46, const 1_usize);
        _48 = BitAnd(_45, _47);
        _49 = Eq(_48, const 0_usize);
        assert(_49, "misaligned pointer dereference: address must be a multiple of {} but is {}", _46, _45) -> [success: bb11, unwind unreachable];
    }

    bb1: {
        _12 = core::panicking::AssertKind::Eq;
        _14 = Option::<Arguments<'_>>::None;
        _13 = core::panicking::assert_failed::<usize, usize>(move _12, _6, _7, move _14) -> bb8;
    }

    bb2: {
        _31 = const false;
        _16 = move _2;
        _15 = std::mem::drop::<[DropChecker; 1]>(move _16) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _19 = const {alloc1: *mut usize};
        _32 = _19 as *const () (PtrToPtr);
        _33 = _32 as usize (Transmute);
        _34 = AlignOf(usize);
        _35 = Sub(_34, const 1_usize);
        _36 = BitAnd(_33, _35);
        _37 = Eq(_36, const 0_usize);
        assert(_37, "misaligned pointer dereference: address must be a multiple of {} but is {}", _34, _33) -> [success: bb9, unwind unreachable];
    }

    bb4: {
        _26 = core::panicking::AssertKind::Eq;
        _28 = Option::<Arguments<'_>>::None;
        _27 = core::panicking::assert_failed::<usize, usize>(move _26, _20, _21, move _28) -> bb8;
    }

    bb5: {
        _31 = const false;
        return;
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb6, unwind terminate];
    }

    bb8 (cleanup): {
        switchInt(_31) -> [0: bb6, otherwise: bb7];
    }

    bb9: {
        _18 = &(*_19);
        _29 = const _;
        _17 = (move _18, _29);
        _20 = (_17.0: &usize);
        _21 = (_17.1: &usize);
        _24 = (*_20);
        _25 = (*_21);
        _23 = Eq(move _24, move _25);
        _22 = Not(move _23);
        switchInt(move _22) -> [0: bb5, otherwise: bb4];
    }

    bb10: {
        _4 = &(*_5);
        _30 = const _;
        _3 = (move _4, _30);
        _6 = (_3.0: &usize);
        _7 = (_3.1: &usize);
        _10 = (*_6);
        _11 = (*_7);
        _9 = Eq(move _10, move _11);
        _8 = Not(move _9);
        switchInt(move _8) -> [0: bb2, otherwise: bb1];
    }

    bb11: {
        (*_1) = const 0_usize;
        _31 = const true;
        _2 = [const _; 1];
        _5 = const {alloc1: *mut usize};
        _38 = _5 as *const () (PtrToPtr);
        _39 = _38 as usize (Transmute);
        _40 = AlignOf(usize);
        _41 = Sub(_40, const 1_usize);
        _42 = BitAnd(_39, _41);
        _43 = Eq(_42, const 0_usize);
        assert(_43, "misaligned pointer dereference: address must be a multiple of {} but is {}", _40, _39) -> [success: bb10, unwind unreachable];
    }
}

alloc1 (static: CHECK, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

promoted[0] in const_one: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 1_usize;
        _0 = &_1;
        return;
    }
}

promoted[1] in const_one: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 0_usize;
        _0 = &_1;
        return;
    }
}

const_one::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

const_one::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn const_generic_zero() -> () {
    let mut _0: ();
    let mut _1: *mut usize;
    let _2: [DropChecker; N];
    let mut _3: (&usize, &usize);
    let mut _4: &usize;
    let _5: *mut usize;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: usize;
    let mut _11: usize;
    let _13: !;
    let mut _14: std::option::Option<std::fmt::Arguments<'_>>;
    let _15: ();
    let mut _16: [DropChecker; N];
    let mut _17: (&usize, &usize);
    let mut _18: &usize;
    let _19: *mut usize;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: usize;
    let mut _25: usize;
    let _27: !;
    let mut _28: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _31: bool;
    scope 1 {
        let mut _44: *const ();
        let mut _45: usize;
        let mut _46: usize;
        let mut _47: usize;
        let mut _48: usize;
        let mut _49: bool;
    }
    scope 2 {
        debug v => _2;
        scope 3 {
            let _6: &usize;
            let _7: &usize;
            let mut _30: &usize;
            let mut _38: *const ();
            let mut _39: usize;
            let mut _40: usize;
            let mut _41: usize;
            let mut _42: usize;
            let mut _43: bool;
            scope 4 {
                debug left_val => _6;
                debug right_val => _7;
                let _12: core::panicking::AssertKind;
                scope 5 {
                    debug kind => _12;
                }
            }
        }
        scope 6 {
            let _20: &usize;
            let _21: &usize;
            let mut _29: &usize;
            let mut _32: *const ();
            let mut _33: usize;
            let mut _34: usize;
            let mut _35: usize;
            let mut _36: usize;
            let mut _37: bool;
            scope 7 {
                debug left_val => _20;
                debug right_val => _21;
                let _26: core::panicking::AssertKind;
                scope 8 {
                    debug kind => _26;
                }
            }
        }
    }

    bb0: {
        _31 = const false;
        _1 = const {alloc1: *mut usize};
        _44 = _1 as *const () (PtrToPtr);
        _45 = _44 as usize (Transmute);
        _46 = AlignOf(usize);
        _47 = Sub(_46, const 1_usize);
        _48 = BitAnd(_45, _47);
        _49 = Eq(_48, const 0_usize);
        assert(_49, "misaligned pointer dereference: address must be a multiple of {} but is {}", _46, _45) -> [success: bb11, unwind unreachable];
    }

    bb1: {
        _12 = core::panicking::AssertKind::Eq;
        _14 = Option::<Arguments<'_>>::None;
        _13 = core::panicking::assert_failed::<usize, usize>(move _12, _6, _7, move _14) -> bb8;
    }

    bb2: {
        _31 = const false;
        _16 = move _2;
        _15 = std::mem::drop::<[DropChecker; N]>(move _16) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _19 = const {alloc1: *mut usize};
        _32 = _19 as *const () (PtrToPtr);
        _33 = _32 as usize (Transmute);
        _34 = AlignOf(usize);
        _35 = Sub(_34, const 1_usize);
        _36 = BitAnd(_33, _35);
        _37 = Eq(_36, const 0_usize);
        assert(_37, "misaligned pointer dereference: address must be a multiple of {} but is {}", _34, _33) -> [success: bb9, unwind unreachable];
    }

    bb4: {
        _26 = core::panicking::AssertKind::Eq;
        _28 = Option::<Arguments<'_>>::None;
        _27 = core::panicking::assert_failed::<usize, usize>(move _26, _20, _21, move _28) -> bb8;
    }

    bb5: {
        _31 = const false;
        return;
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb6, unwind terminate];
    }

    bb8 (cleanup): {
        switchInt(_31) -> [0: bb6, otherwise: bb7];
    }

    bb9: {
        _18 = &(*_19);
        _29 = const _;
        _17 = (move _18, _29);
        _20 = (_17.0: &usize);
        _21 = (_17.1: &usize);
        _24 = (*_20);
        _25 = (*_21);
        _23 = Eq(move _24, move _25);
        _22 = Not(move _23);
        switchInt(move _22) -> [0: bb5, otherwise: bb4];
    }

    bb10: {
        _4 = &(*_5);
        _30 = const _;
        _3 = (move _4, _30);
        _6 = (_3.0: &usize);
        _7 = (_3.1: &usize);
        _10 = (*_6);
        _11 = (*_7);
        _9 = Eq(move _10, move _11);
        _8 = Not(move _9);
        switchInt(move _8) -> [0: bb2, otherwise: bb1];
    }

    bb11: {
        (*_1) = const 0_usize;
        _31 = const true;
        _2 = [const _; N];
        _5 = const {alloc1: *mut usize};
        _38 = _5 as *const () (PtrToPtr);
        _39 = _38 as usize (Transmute);
        _40 = AlignOf(usize);
        _41 = Sub(_40, const 1_usize);
        _42 = BitAnd(_39, _41);
        _43 = Eq(_42, const 0_usize);
        assert(_43, "misaligned pointer dereference: address must be a multiple of {} but is {}", _40, _39) -> [success: bb10, unwind unreachable];
    }
}

alloc1 (static: CHECK, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

promoted[0] in const_generic_zero: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 0_usize;
        _0 = &_1;
        return;
    }
}

promoted[1] in const_generic_zero: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 0_usize;
        _0 = &_1;
        return;
    }
}

const_generic_zero::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const N;
        return;
    }
}

const_generic_zero::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const N;
        return;
    }
}

fn const_generic_one() -> () {
    let mut _0: ();
    let mut _1: *mut usize;
    let _2: [DropChecker; N];
    let mut _3: (&usize, &usize);
    let mut _4: &usize;
    let _5: *mut usize;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: usize;
    let mut _11: usize;
    let _13: !;
    let mut _14: std::option::Option<std::fmt::Arguments<'_>>;
    let _15: ();
    let mut _16: [DropChecker; N];
    let mut _17: (&usize, &usize);
    let mut _18: &usize;
    let _19: *mut usize;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: usize;
    let mut _25: usize;
    let _27: !;
    let mut _28: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _31: bool;
    scope 1 {
        let mut _44: *const ();
        let mut _45: usize;
        let mut _46: usize;
        let mut _47: usize;
        let mut _48: usize;
        let mut _49: bool;
    }
    scope 2 {
        debug v => _2;
        scope 3 {
            let _6: &usize;
            let _7: &usize;
            let mut _30: &usize;
            let mut _38: *const ();
            let mut _39: usize;
            let mut _40: usize;
            let mut _41: usize;
            let mut _42: usize;
            let mut _43: bool;
            scope 4 {
                debug left_val => _6;
                debug right_val => _7;
                let _12: core::panicking::AssertKind;
                scope 5 {
                    debug kind => _12;
                }
            }
        }
        scope 6 {
            let _20: &usize;
            let _21: &usize;
            let mut _29: &usize;
            let mut _32: *const ();
            let mut _33: usize;
            let mut _34: usize;
            let mut _35: usize;
            let mut _36: usize;
            let mut _37: bool;
            scope 7 {
                debug left_val => _20;
                debug right_val => _21;
                let _26: core::panicking::AssertKind;
                scope 8 {
                    debug kind => _26;
                }
            }
        }
    }

    bb0: {
        _31 = const false;
        _1 = const {alloc1: *mut usize};
        _44 = _1 as *const () (PtrToPtr);
        _45 = _44 as usize (Transmute);
        _46 = AlignOf(usize);
        _47 = Sub(_46, const 1_usize);
        _48 = BitAnd(_45, _47);
        _49 = Eq(_48, const 0_usize);
        assert(_49, "misaligned pointer dereference: address must be a multiple of {} but is {}", _46, _45) -> [success: bb11, unwind unreachable];
    }

    bb1: {
        _12 = core::panicking::AssertKind::Eq;
        _14 = Option::<Arguments<'_>>::None;
        _13 = core::panicking::assert_failed::<usize, usize>(move _12, _6, _7, move _14) -> bb8;
    }

    bb2: {
        _31 = const false;
        _16 = move _2;
        _15 = std::mem::drop::<[DropChecker; N]>(move _16) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _19 = const {alloc1: *mut usize};
        _32 = _19 as *const () (PtrToPtr);
        _33 = _32 as usize (Transmute);
        _34 = AlignOf(usize);
        _35 = Sub(_34, const 1_usize);
        _36 = BitAnd(_33, _35);
        _37 = Eq(_36, const 0_usize);
        assert(_37, "misaligned pointer dereference: address must be a multiple of {} but is {}", _34, _33) -> [success: bb9, unwind unreachable];
    }

    bb4: {
        _26 = core::panicking::AssertKind::Eq;
        _28 = Option::<Arguments<'_>>::None;
        _27 = core::panicking::assert_failed::<usize, usize>(move _26, _20, _21, move _28) -> bb8;
    }

    bb5: {
        _31 = const false;
        return;
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb6, unwind terminate];
    }

    bb8 (cleanup): {
        switchInt(_31) -> [0: bb6, otherwise: bb7];
    }

    bb9: {
        _18 = &(*_19);
        _29 = const _;
        _17 = (move _18, _29);
        _20 = (_17.0: &usize);
        _21 = (_17.1: &usize);
        _24 = (*_20);
        _25 = (*_21);
        _23 = Eq(move _24, move _25);
        _22 = Not(move _23);
        switchInt(move _22) -> [0: bb5, otherwise: bb4];
    }

    bb10: {
        _4 = &(*_5);
        _30 = const _;
        _3 = (move _4, _30);
        _6 = (_3.0: &usize);
        _7 = (_3.1: &usize);
        _10 = (*_6);
        _11 = (*_7);
        _9 = Eq(move _10, move _11);
        _8 = Not(move _9);
        switchInt(move _8) -> [0: bb2, otherwise: bb1];
    }

    bb11: {
        (*_1) = const 0_usize;
        _31 = const true;
        _2 = [const _; N];
        _5 = const {alloc1: *mut usize};
        _38 = _5 as *const () (PtrToPtr);
        _39 = _38 as usize (Transmute);
        _40 = AlignOf(usize);
        _41 = Sub(_40, const 1_usize);
        _42 = BitAnd(_39, _41);
        _43 = Eq(_42, const 0_usize);
        assert(_43, "misaligned pointer dereference: address must be a multiple of {} but is {}", _40, _39) -> [success: bb10, unwind unreachable];
    }
}

alloc1 (static: CHECK, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

promoted[0] in const_generic_one: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 1_usize;
        _0 = &_1;
        return;
    }
}

promoted[1] in const_generic_one: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 0_usize;
        _0 = &_1;
        return;
    }
}

const_generic_one::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const N;
        return;
    }
}

const_generic_one::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const N;
        return;
    }
}

fn allow_promote() -> () {
    let mut _0: ();
    let mut _1: *mut usize;
    let _2: DropChecker;
    let mut _3: DropChecker;
    let mut _4: (&usize, &usize);
    let mut _5: &usize;
    let _6: *mut usize;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: usize;
    let mut _12: usize;
    let _14: !;
    let mut _15: std::option::Option<std::fmt::Arguments<'_>>;
    let _16: ();
    let mut _17: (&usize, &usize);
    let mut _18: &usize;
    let _19: *mut usize;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: usize;
    let mut _25: usize;
    let _27: !;
    let mut _28: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        let mut _44: *const ();
        let mut _45: usize;
        let mut _46: usize;
        let mut _47: usize;
        let mut _48: usize;
        let mut _49: bool;
    }
    scope 2 {
        debug foo => _2;
        let mut _31: &[DropChecker; 0];
        scope 3 {
            debug v => const _;
            scope 4 {
                let _7: &usize;
                let _8: &usize;
                let mut _30: &usize;
                let mut _38: *const ();
                let mut _39: usize;
                let mut _40: usize;
                let mut _41: usize;
                let mut _42: usize;
                let mut _43: bool;
                scope 5 {
                    debug left_val => _7;
                    debug right_val => _8;
                    let _13: core::panicking::AssertKind;
                    scope 6 {
                        debug kind => _13;
                    }
                }
            }
            scope 7 {
                let _20: &usize;
                let _21: &usize;
                let mut _29: &usize;
                let mut _32: *const ();
                let mut _33: usize;
                let mut _34: usize;
                let mut _35: usize;
                let mut _36: usize;
                let mut _37: bool;
                scope 8 {
                    debug left_val => _20;
                    debug right_val => _21;
                    let _26: core::panicking::AssertKind;
                    scope 9 {
                        debug kind => _26;
                    }
                }
            }
        }
    }

    bb0: {
        _1 = const {alloc1: *mut usize};
        _44 = _1 as *const () (PtrToPtr);
        _45 = _44 as usize (Transmute);
        _46 = AlignOf(usize);
        _47 = Sub(_46, const 1_usize);
        _48 = BitAnd(_45, _47);
        _49 = Eq(_48, const 0_usize);
        assert(_49, "misaligned pointer dereference: address must be a multiple of {} but is {}", _46, _45) -> [success: bb9, unwind unreachable];
    }

    bb1: {
        _31 = const _;
        _6 = const {alloc1: *mut usize};
        _38 = _6 as *const () (PtrToPtr);
        _39 = _38 as usize (Transmute);
        _40 = AlignOf(usize);
        _41 = Sub(_40, const 1_usize);
        _42 = BitAnd(_39, _41);
        _43 = Eq(_42, const 0_usize);
        assert(_43, "misaligned pointer dereference: address must be a multiple of {} but is {}", _40, _39) -> [success: bb8, unwind unreachable];
    }

    bb2: {
        _13 = core::panicking::AssertKind::Eq;
        _15 = Option::<Arguments<'_>>::None;
        _14 = core::panicking::assert_failed::<usize, usize>(move _13, _7, _8, move _15) -> unwind continue;
    }

    bb3: {
        _16 = std::mem::drop::<&[DropChecker; 0]>(_31) -> [return: bb4, unwind continue];
    }

    bb4: {
        _19 = const {alloc1: *mut usize};
        _32 = _19 as *const () (PtrToPtr);
        _33 = _32 as usize (Transmute);
        _34 = AlignOf(usize);
        _35 = Sub(_34, const 1_usize);
        _36 = BitAnd(_33, _35);
        _37 = Eq(_36, const 0_usize);
        assert(_37, "misaligned pointer dereference: address must be a multiple of {} but is {}", _34, _33) -> [success: bb7, unwind unreachable];
    }

    bb5: {
        _26 = core::panicking::AssertKind::Eq;
        _28 = Option::<Arguments<'_>>::None;
        _27 = core::panicking::assert_failed::<usize, usize>(move _26, _20, _21, move _28) -> unwind continue;
    }

    bb6: {
        return;
    }

    bb7: {
        _18 = &(*_19);
        _29 = const _;
        _17 = (move _18, _29);
        _20 = (_17.0: &usize);
        _21 = (_17.1: &usize);
        _24 = (*_20);
        _25 = (*_21);
        _23 = Eq(move _24, move _25);
        _22 = Not(move _23);
        switchInt(move _22) -> [0: bb6, otherwise: bb5];
    }

    bb8: {
        _5 = &(*_6);
        _30 = const _;
        _4 = (move _5, _30);
        _7 = (_4.0: &usize);
        _8 = (_4.1: &usize);
        _11 = (*_7);
        _12 = (*_8);
        _10 = Eq(move _11, move _12);
        _9 = Not(move _10);
        switchInt(move _9) -> [0: bb3, otherwise: bb2];
    }

    bb9: {
        (*_1) = const 0_usize;
        _2 = DropChecker(const 1_usize);
        _3 = move _2;
        drop(_3) -> [return: bb1, unwind continue];
    }
}

alloc1 (static: CHECK, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

promoted[0] in allow_promote: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 1_usize;
        _0 = &_1;
        return;
    }
}

promoted[1] in allow_promote: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 1_usize;
        _0 = &_1;
        return;
    }
}

promoted[2] in allow_promote: &[DropChecker; 0] = {
    let mut _0: &[DropChecker; 0];
    let mut _1: [DropChecker; 0];

    bb0: {
        _1 = [];
        _0 = &_1;
        return;
    }
}

allow_promote::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 0_usize;
        return;
    }
}

allow_promote::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 0_usize;
        return;
    }
}

fn on_unwind() -> () {
    let mut _0: ();
    let mut _1: *mut usize;
    let _2: std::boxed::Box<dyn std::any::Any + std::marker::Send>;
    let mut _3: std::result::Result<(), std::boxed::Box<dyn std::any::Any + std::marker::Send>>;
    let mut _4: (&usize, &usize);
    let mut _5: &usize;
    let _6: *mut usize;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: usize;
    let mut _12: usize;
    let _14: !;
    let mut _15: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        let mut _23: *const ();
        let mut _24: usize;
        let mut _25: usize;
        let mut _26: usize;
        let mut _27: usize;
        let mut _28: bool;
    }
    scope 2 {
        let _7: &usize;
        let _8: &usize;
        let mut _16: &usize;
        let mut _17: *const ();
        let mut _18: usize;
        let mut _19: usize;
        let mut _20: usize;
        let mut _21: usize;
        let mut _22: bool;
        scope 3 {
            debug left_val => _7;
            debug right_val => _8;
            let _13: core::panicking::AssertKind;
            scope 4 {
                debug kind => _13;
            }
        }
    }

    bb0: {
        _1 = const {alloc1: *mut usize};
        _23 = _1 as *const () (PtrToPtr);
        _24 = _23 as usize (Transmute);
        _25 = AlignOf(usize);
        _26 = Sub(_25, const 1_usize);
        _27 = BitAnd(_24, _26);
        _28 = Eq(_27, const 0_usize);
        assert(_28, "misaligned pointer dereference: address must be a multiple of {} but is {}", _25, _24) -> [success: bb7, unwind unreachable];
    }

    bb1: {
        _2 = Result::<(), Box<dyn Any + Send>>::unwrap_err(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        drop(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = const {alloc1: *mut usize};
        _17 = _6 as *const () (PtrToPtr);
        _18 = _17 as usize (Transmute);
        _19 = AlignOf(usize);
        _20 = Sub(_19, const 1_usize);
        _21 = BitAnd(_18, _20);
        _22 = Eq(_21, const 0_usize);
        assert(_22, "misaligned pointer dereference: address must be a multiple of {} but is {}", _19, _18) -> [success: bb6, unwind unreachable];
    }

    bb4: {
        _13 = core::panicking::AssertKind::Eq;
        _15 = Option::<Arguments<'_>>::None;
        _14 = core::panicking::assert_failed::<usize, usize>(move _13, _7, _8, move _15) -> unwind continue;
    }

    bb5: {
        return;
    }

    bb6: {
        _5 = &(*_6);
        _16 = const _;
        _4 = (move _5, _16);
        _7 = (_4.0: &usize);
        _8 = (_4.1: &usize);
        _11 = (*_7);
        _12 = (*_8);
        _10 = Eq(move _11, move _12);
        _9 = Not(move _10);
        switchInt(move _9) -> [0: bb5, otherwise: bb4];
    }

    bb7: {
        (*_1) = const 0_usize;
        _3 = catch_unwind::<[closure@ui/drop/repeat-drop.rs:101:30: 101:32], ()>(const ZeroSized: [closure@ui/drop/repeat-drop.rs:101:30: 101:32]) -> [return: bb1, unwind continue];
    }
}

alloc1 (static: CHECK, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

promoted[0] in on_unwind: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 2_usize;
        _0 = &_1;
        return;
    }
}

fn on_unwind::{closure#0}(_1: [closure@ui/drop/repeat-drop.rs:101:30: 101:32]) -> () {
    let mut _0: ();
    let mut _4: DropChecker;
    let mut _5: DropPanic;
    let _6: !;
    scope 1 {
        debug panic => const DropPanic;
        let _2: DropChecker;
        scope 2 {
            debug _local => _2;
            let _3: (DropChecker, [DropPanic; 0]);
            scope 3 {
                debug _v => _3;
            }
        }
    }

    bb0: {
        _2 = DropChecker(const 2_usize);
        _4 = DropChecker(const 1_usize);
        drop(_5) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        _3 = (move _4, const []);
        _6 = std::process::abort() -> bb2;
    }

    bb2 (cleanup): {
        drop(_3) -> [return: bb4, unwind terminate];
    }

    bb3 (cleanup): {
        drop(_4) -> [return: bb4, unwind terminate];
    }

    bb4 (cleanup): {
        drop(_2) -> [return: bb5, unwind terminate];
    }

    bb5 (cleanup): {
        resume;
    }
}

on_unwind::{closure#0}::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 0_usize;
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: ();
    let _2: ();
    let _3: ();
    let _4: ();
    let _5: ();
    let _6: ();
    let _7: ();
    let _8: ();

    bb0: {
        _1 = value_zero() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = value_one() -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = const_zero() -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = const_one() -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = const_generic_zero::<0>() -> [return: bb5, unwind continue];
    }

    bb5: {
        _6 = const_generic_one::<1>() -> [return: bb6, unwind continue];
    }

    bb6: {
        _7 = allow_promote() -> [return: bb7, unwind continue];
    }

    bb7: {
        _8 = on_unwind() -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

main::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 0_usize;
        return;
    }
}

main::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn DropChecker(_1: usize) -> DropChecker {
    let mut _0: DropChecker;

    bb0: {
        _0 = DropChecker(move _1);
        return;
    }
}

// MIR FOR CTFE
fn DropChecker(_1: usize) -> DropChecker {
    let mut _0: DropChecker;

    bb0: {
        _0 = DropChecker(move _1);
        return;
    }
}
