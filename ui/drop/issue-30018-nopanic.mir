// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/drop/issue-30018-nopanic.rs:15:1: 15:24>::drop(_1: &mut D<'_>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: std::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 1];
    let _7: [core::fmt::rt::Argument<'_>; 1];
    let mut _8: core::fmt::rt::Argument<'_>;
    let _9: &i32;
    let _10: ();
    let mut _11: &mut std::vec::Vec<i32>;
    let mut _12: &mut std::vec::Vec<i32>;
    let mut _13: &mut std::cell::RefMut<'_, std::vec::Vec<i32>>;
    let mut _14: std::cell::RefMut<'_, std::vec::Vec<i32>>;
    let mut _15: i32;
    let mut _16: &[&str; 2];
    let mut _17: &std::cell::RefCell<std::vec::Vec<i32>>;

    bb0: {
        _16 = const _;
        _4 = _16 as &[&str] (Pointer(Unsize));
        _9 = &((*_1).1: i32);
        _8 = core::fmt::rt::Argument::<'_>::new_display::<i32>(_9) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = [move _8];
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _3 = Arguments::<'_>::new_v1(move _4, move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = _print(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _17 = deref_copy ((*_1).0: &std::cell::RefCell<std::vec::Vec<i32>>);
        _14 = RefCell::<Vec<i32>>::borrow_mut(_17) -> [return: bb4, unwind continue];
    }

    bb4: {
        _13 = &mut _14;
        _12 = <RefMut<'_, Vec<i32>> as DerefMut>::deref_mut(move _13) -> [return: bb5, unwind: bb8];
    }

    bb5: {
        _11 = _12;
        _15 = ((*_1).1: i32);
        _10 = Vec::<i32>::push(move _11, move _15) -> [return: bb6, unwind: bb8];
    }

    bb6: {
        drop(_14) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_14) -> [return: bb9, unwind terminate];
    }

    bb9 (cleanup): {
        resume;
    }
}

promoted[0] in <impl at ui/drop/issue-30018-nopanic.rs:15:1: 15:24>::drop: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Dropping D(", const ")\n"];
        _0 = &_1;
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: ();
    let mut _2: std::fmt::Arguments<'_>;
    let mut _3: &[&str];
    let _4: ();
    let _5: ();
    let _6: ();
    let mut _7: std::fmt::Arguments<'_>;
    let mut _8: &[&str];
    let mut _9: &[&str; 1];
    let mut _10: &[&str; 1];

    bb0: {
        _10 = const _;
        _3 = _10 as &[&str] (Pointer(Unsize));
        _2 = Arguments::<'_>::new_const(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _1 = _print(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = break_during_elem() -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = break_after_whole() -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = const _;
        _8 = _9 as &[&str] (Pointer(Unsize));
        _7 = Arguments::<'_>::new_const(move _8) -> [return: bb5, unwind continue];
    }

    bb5: {
        _6 = _print(move _7) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

promoted[0] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Finis\n"];
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Start\n"];
        _0 = &_1;
        return;
    }
}

fn break_during_elem() -> () {
    let mut _0: ();
    let _1: &std::cell::RefCell<std::vec::Vec<i32>>;
    let _2: std::cell::RefCell<std::vec::Vec<i32>>;
    let mut _3: std::vec::Vec<i32>;
    let mut _5: D<'_>;
    let mut _6: D<'_>;
    let _7: D<'_>;
    let mut _8: (&&[i32], &&[i32; 3]);
    let mut _9: &&[i32];
    let _10: &[i32];
    let _11: &[i32];
    let mut _12: &std::vec::Vec<i32>;
    let _13: &std::vec::Vec<i32>;
    let mut _14: &std::cell::Ref<'_, std::vec::Vec<i32>>;
    let _15: std::cell::Ref<'_, std::vec::Vec<i32>>;
    let mut _18: bool;
    let mut _19: bool;
    let _21: !;
    let mut _22: std::option::Option<std::fmt::Arguments<'_>>;
    let _23: ();
    let mut _24: &mut std::vec::Vec<i32>;
    let mut _25: &mut std::vec::Vec<i32>;
    let mut _26: &mut std::cell::RefMut<'_, std::vec::Vec<i32>>;
    let mut _27: std::cell::RefMut<'_, std::vec::Vec<i32>>;
    let mut _29: D<'_>;
    let mut _30: D<'_>;
    let _31: D<'_>;
    let mut _32: (&&[i32], &&[i32; 3]);
    let mut _33: &&[i32];
    let _34: &[i32];
    let _35: &[i32];
    let mut _36: &std::vec::Vec<i32>;
    let _37: &std::vec::Vec<i32>;
    let mut _38: &std::cell::Ref<'_, std::vec::Vec<i32>>;
    let _39: std::cell::Ref<'_, std::vec::Vec<i32>>;
    let mut _42: bool;
    let mut _43: bool;
    let _45: !;
    let mut _46: std::option::Option<std::fmt::Arguments<'_>>;
    let _47: ();
    let mut _48: &mut std::vec::Vec<i32>;
    let mut _49: &mut std::vec::Vec<i32>;
    let mut _50: &mut std::cell::RefMut<'_, std::vec::Vec<i32>>;
    let mut _51: std::cell::RefMut<'_, std::vec::Vec<i32>>;
    let mut _53: D<'_>;
    let mut _54: D<'_>;
    let _55: D<'_>;
    let mut _56: (&&[i32], &&[i32; 3]);
    let mut _57: &&[i32];
    let _58: &[i32];
    let _59: &[i32];
    let mut _60: &std::vec::Vec<i32>;
    let _61: &std::vec::Vec<i32>;
    let mut _62: &std::cell::Ref<'_, std::vec::Vec<i32>>;
    let _63: std::cell::Ref<'_, std::vec::Vec<i32>>;
    let mut _66: bool;
    let mut _67: bool;
    let _69: !;
    let mut _70: std::option::Option<std::fmt::Arguments<'_>>;
    let _71: ();
    let mut _72: &mut std::vec::Vec<i32>;
    let mut _73: &mut std::vec::Vec<i32>;
    let mut _74: &mut std::cell::RefMut<'_, std::vec::Vec<i32>>;
    let mut _75: std::cell::RefMut<'_, std::vec::Vec<i32>>;
    scope 1 {
        debug log => _1;
        let _4: [D<'_>; 4];
        let _16: &&[i32];
        let _17: &&[i32; 3];
        let _28: &[D<'_>; 4];
        let _40: &&[i32];
        let _41: &&[i32; 3];
        let _52: &[D<'_>];
        let _64: &&[i32];
        let _65: &&[i32; 3];
        let mut _76: &&[i32; 3];
        let mut _77: &&[i32; 3];
        let mut _78: &&[i32; 3];
        scope 2 {
            debug _r => _4;
        }
        scope 3 {
            debug left_val => _16;
            debug right_val => _17;
            let _20: core::panicking::AssertKind;
            scope 4 {
                debug kind => _20;
            }
        }
        scope 5 {
            debug _r => _28;
        }
        scope 6 {
            debug left_val => _40;
            debug right_val => _41;
            let _44: core::panicking::AssertKind;
            scope 7 {
                debug kind => _44;
            }
        }
        scope 8 {
            debug _r => _52;
        }
        scope 9 {
            debug left_val => _64;
            debug right_val => _65;
            let _68: core::panicking::AssertKind;
            scope 10 {
                debug kind => _68;
            }
        }
    }

    bb0: {
        _3 = Vec::<i32>::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = RefCell::<Vec<i32>>::new(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _1 = &_2;
        _5 = D::<'_>(_1, const 10_i32);
        _6 = D::<'_>(_1, const 11_i32);
        _7 = D::<'_>(_1, const 12_i32);
        drop(_7) -> [return: bb3, unwind: bb56];
    }

    bb3: {
        drop(_6) -> [return: bb4, unwind: bb57];
    }

    bb4: {
        drop(_5) -> [return: bb5, unwind: bb58];
    }

    bb5: {
        _15 = RefCell::<Vec<i32>>::borrow(_1) -> [return: bb6, unwind: bb58];
    }

    bb6: {
        _14 = &_15;
        _13 = <Ref<'_, Vec<i32>> as Deref>::deref(move _14) -> [return: bb7, unwind: bb55];
    }

    bb7: {
        _12 = _13;
        _11 = <Vec<i32> as Index<RangeFull>>::index(move _12, const RangeFull) -> [return: bb8, unwind: bb55];
    }

    bb8: {
        _10 = _11;
        _9 = &_10;
        _78 = const _;
        _8 = (move _9, _78);
        _16 = (_8.0: &&[i32]);
        _17 = (_8.1: &&[i32; 3]);
        _19 = <&[i32] as PartialEq<&[i32; 3]>>::eq(_16, _17) -> [return: bb9, unwind: bb55];
    }

    bb9: {
        _18 = Not(move _19);
        switchInt(move _18) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _20 = core::panicking::AssertKind::Eq;
        _22 = Option::<Arguments<'_>>::None;
        _21 = core::panicking::assert_failed::<&[i32], &[i32; 3]>(move _20, _16, _17, move _22) -> bb55;
    }

    bb11: {
        drop(_15) -> [return: bb12, unwind: bb58];
    }

    bb12: {
        _27 = RefCell::<Vec<i32>>::borrow_mut(_1) -> [return: bb13, unwind: bb58];
    }

    bb13: {
        _26 = &mut _27;
        _25 = <RefMut<'_, Vec<i32>> as DerefMut>::deref_mut(move _26) -> [return: bb14, unwind: bb54];
    }

    bb14: {
        _24 = _25;
        _23 = Vec::<i32>::clear(move _24) -> [return: bb15, unwind: bb54];
    }

    bb15: {
        drop(_27) -> [return: bb16, unwind: bb58];
    }

    bb16: {
        _29 = D::<'_>(_1, const 20_i32);
        _30 = D::<'_>(_1, const 21_i32);
        _31 = D::<'_>(_1, const 22_i32);
        drop(_31) -> [return: bb17, unwind: bb52];
    }

    bb17: {
        drop(_30) -> [return: bb18, unwind: bb53];
    }

    bb18: {
        drop(_29) -> [return: bb19, unwind: bb58];
    }

    bb19: {
        _39 = RefCell::<Vec<i32>>::borrow(_1) -> [return: bb20, unwind: bb58];
    }

    bb20: {
        _38 = &_39;
        _37 = <Ref<'_, Vec<i32>> as Deref>::deref(move _38) -> [return: bb21, unwind: bb51];
    }

    bb21: {
        _36 = _37;
        _35 = <Vec<i32> as Index<RangeFull>>::index(move _36, const RangeFull) -> [return: bb22, unwind: bb51];
    }

    bb22: {
        _34 = _35;
        _33 = &_34;
        _77 = const _;
        _32 = (move _33, _77);
        _40 = (_32.0: &&[i32]);
        _41 = (_32.1: &&[i32; 3]);
        _43 = <&[i32] as PartialEq<&[i32; 3]>>::eq(_40, _41) -> [return: bb23, unwind: bb51];
    }

    bb23: {
        _42 = Not(move _43);
        switchInt(move _42) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _44 = core::panicking::AssertKind::Eq;
        _46 = Option::<Arguments<'_>>::None;
        _45 = core::panicking::assert_failed::<&[i32], &[i32; 3]>(move _44, _40, _41, move _46) -> bb51;
    }

    bb25: {
        drop(_39) -> [return: bb26, unwind: bb58];
    }

    bb26: {
        _51 = RefCell::<Vec<i32>>::borrow_mut(_1) -> [return: bb27, unwind: bb58];
    }

    bb27: {
        _50 = &mut _51;
        _49 = <RefMut<'_, Vec<i32>> as DerefMut>::deref_mut(move _50) -> [return: bb28, unwind: bb50];
    }

    bb28: {
        _48 = _49;
        _47 = Vec::<i32>::clear(move _48) -> [return: bb29, unwind: bb50];
    }

    bb29: {
        drop(_51) -> [return: bb30, unwind: bb58];
    }

    bb30: {
        _53 = D::<'_>(_1, const 30_i32);
        _54 = D::<'_>(_1, const 31_i32);
        _55 = D::<'_>(_1, const 32_i32);
        drop(_55) -> [return: bb31, unwind: bb48];
    }

    bb31: {
        drop(_54) -> [return: bb32, unwind: bb49];
    }

    bb32: {
        drop(_53) -> [return: bb33, unwind: bb58];
    }

    bb33: {
        _63 = RefCell::<Vec<i32>>::borrow(_1) -> [return: bb34, unwind: bb58];
    }

    bb34: {
        _62 = &_63;
        _61 = <Ref<'_, Vec<i32>> as Deref>::deref(move _62) -> [return: bb35, unwind: bb47];
    }

    bb35: {
        _60 = _61;
        _59 = <Vec<i32> as Index<RangeFull>>::index(move _60, const RangeFull) -> [return: bb36, unwind: bb47];
    }

    bb36: {
        _58 = _59;
        _57 = &_58;
        _76 = const _;
        _56 = (move _57, _76);
        _64 = (_56.0: &&[i32]);
        _65 = (_56.1: &&[i32; 3]);
        _67 = <&[i32] as PartialEq<&[i32; 3]>>::eq(_64, _65) -> [return: bb37, unwind: bb47];
    }

    bb37: {
        _66 = Not(move _67);
        switchInt(move _66) -> [0: bb39, otherwise: bb38];
    }

    bb38: {
        _68 = core::panicking::AssertKind::Eq;
        _70 = Option::<Arguments<'_>>::None;
        _69 = core::panicking::assert_failed::<&[i32], &[i32; 3]>(move _68, _64, _65, move _70) -> bb47;
    }

    bb39: {
        drop(_63) -> [return: bb40, unwind: bb58];
    }

    bb40: {
        _75 = RefCell::<Vec<i32>>::borrow_mut(_1) -> [return: bb41, unwind: bb58];
    }

    bb41: {
        _74 = &mut _75;
        _73 = <RefMut<'_, Vec<i32>> as DerefMut>::deref_mut(move _74) -> [return: bb42, unwind: bb46];
    }

    bb42: {
        _72 = _73;
        _71 = Vec::<i32>::clear(move _72) -> [return: bb43, unwind: bb46];
    }

    bb43: {
        drop(_75) -> [return: bb44, unwind: bb58];
    }

    bb44: {
        drop(_2) -> [return: bb45, unwind continue];
    }

    bb45: {
        return;
    }

    bb46 (cleanup): {
        drop(_75) -> [return: bb58, unwind terminate];
    }

    bb47 (cleanup): {
        drop(_63) -> [return: bb58, unwind terminate];
    }

    bb48 (cleanup): {
        drop(_54) -> [return: bb49, unwind terminate];
    }

    bb49 (cleanup): {
        drop(_53) -> [return: bb58, unwind terminate];
    }

    bb50 (cleanup): {
        drop(_51) -> [return: bb58, unwind terminate];
    }

    bb51 (cleanup): {
        drop(_39) -> [return: bb58, unwind terminate];
    }

    bb52 (cleanup): {
        drop(_30) -> [return: bb53, unwind terminate];
    }

    bb53 (cleanup): {
        drop(_29) -> [return: bb58, unwind terminate];
    }

    bb54 (cleanup): {
        drop(_27) -> [return: bb58, unwind terminate];
    }

    bb55 (cleanup): {
        drop(_15) -> [return: bb58, unwind terminate];
    }

    bb56 (cleanup): {
        drop(_6) -> [return: bb57, unwind terminate];
    }

    bb57 (cleanup): {
        drop(_5) -> [return: bb58, unwind terminate];
    }

    bb58 (cleanup): {
        drop(_2) -> [return: bb59, unwind terminate];
    }

    bb59 (cleanup): {
        resume;
    }
}

promoted[0] in break_during_elem: &&[i32; 3] = {
    let mut _0: &&[i32; 3];
    let mut _1: &[i32; 3];
    let mut _2: [i32; 3];

    bb0: {
        _2 = [const 32_i32, const 31_i32, const 30_i32];
        _1 = &_2;
        _0 = &_1;
        return;
    }
}

promoted[1] in break_during_elem: &&[i32; 3] = {
    let mut _0: &&[i32; 3];
    let mut _1: &[i32; 3];
    let mut _2: [i32; 3];

    bb0: {
        _2 = [const 22_i32, const 21_i32, const 20_i32];
        _1 = &_2;
        _0 = &_1;
        return;
    }
}

promoted[2] in break_during_elem: &&[i32; 3] = {
    let mut _0: &&[i32; 3];
    let mut _1: &[i32; 3];
    let mut _2: [i32; 3];

    bb0: {
        _2 = [const 12_i32, const 11_i32, const 10_i32];
        _1 = &_2;
        _0 = &_1;
        return;
    }
}

fn break_after_whole() -> () {
    let mut _0: ();
    let _1: &std::cell::RefCell<std::vec::Vec<i32>>;
    let _2: std::cell::RefCell<std::vec::Vec<i32>>;
    let mut _3: std::vec::Vec<i32>;
    let mut _5: D<'_>;
    let mut _6: D<'_>;
    let mut _7: D<'_>;
    let mut _8: (&&[i32], &&[i32; 3]);
    let mut _9: &&[i32];
    let _10: &[i32];
    let _11: &[i32];
    let mut _12: &std::vec::Vec<i32>;
    let _13: &std::vec::Vec<i32>;
    let mut _14: &std::cell::Ref<'_, std::vec::Vec<i32>>;
    let _15: std::cell::Ref<'_, std::vec::Vec<i32>>;
    let mut _18: bool;
    let mut _19: bool;
    let _21: !;
    let mut _22: std::option::Option<std::fmt::Arguments<'_>>;
    let _23: ();
    let mut _24: &mut std::vec::Vec<i32>;
    let mut _25: &mut std::vec::Vec<i32>;
    let mut _26: &mut std::cell::RefMut<'_, std::vec::Vec<i32>>;
    let mut _27: std::cell::RefMut<'_, std::vec::Vec<i32>>;
    let _29: [D<'_>; 3];
    let mut _30: D<'_>;
    let mut _31: D<'_>;
    let mut _32: D<'_>;
    let mut _33: (&&[i32], &&[i32; 3]);
    let mut _34: &&[i32];
    let _35: &[i32];
    let _36: &[i32];
    let mut _37: &std::vec::Vec<i32>;
    let _38: &std::vec::Vec<i32>;
    let mut _39: &std::cell::Ref<'_, std::vec::Vec<i32>>;
    let _40: std::cell::Ref<'_, std::vec::Vec<i32>>;
    let mut _43: bool;
    let mut _44: bool;
    let _46: !;
    let mut _47: std::option::Option<std::fmt::Arguments<'_>>;
    let _48: ();
    let mut _49: &mut std::vec::Vec<i32>;
    let mut _50: &mut std::vec::Vec<i32>;
    let mut _51: &mut std::cell::RefMut<'_, std::vec::Vec<i32>>;
    let mut _52: std::cell::RefMut<'_, std::vec::Vec<i32>>;
    let _54: &[D<'_>];
    let mut _55: &[D<'_>; 3];
    let _56: [D<'_>; 3];
    let mut _57: D<'_>;
    let mut _58: D<'_>;
    let mut _59: D<'_>;
    let mut _60: (&&[i32], &&[i32; 3]);
    let mut _61: &&[i32];
    let _62: &[i32];
    let _63: &[i32];
    let mut _64: &std::vec::Vec<i32>;
    let _65: &std::vec::Vec<i32>;
    let mut _66: &std::cell::Ref<'_, std::vec::Vec<i32>>;
    let _67: std::cell::Ref<'_, std::vec::Vec<i32>>;
    let mut _70: bool;
    let mut _71: bool;
    let _73: !;
    let mut _74: std::option::Option<std::fmt::Arguments<'_>>;
    let _75: ();
    let mut _76: &mut std::vec::Vec<i32>;
    let mut _77: &mut std::vec::Vec<i32>;
    let mut _78: &mut std::cell::RefMut<'_, std::vec::Vec<i32>>;
    let mut _79: std::cell::RefMut<'_, std::vec::Vec<i32>>;
    scope 1 {
        debug log => _1;
        let _4: [D<'_>; 3];
        let _16: &&[i32];
        let _17: &&[i32; 3];
        let _28: &[D<'_>; 3];
        let _41: &&[i32];
        let _42: &&[i32; 3];
        let _53: &[D<'_>];
        let _68: &&[i32];
        let _69: &&[i32; 3];
        let mut _80: &&[i32; 3];
        let mut _81: &&[i32; 3];
        let mut _82: &&[i32; 3];
        scope 2 {
            debug _r => _4;
        }
        scope 3 {
            debug left_val => _16;
            debug right_val => _17;
            let _20: core::panicking::AssertKind;
            scope 4 {
                debug kind => _20;
            }
        }
        scope 5 {
            debug _r => _28;
        }
        scope 6 {
            debug left_val => _41;
            debug right_val => _42;
            let _45: core::panicking::AssertKind;
            scope 7 {
                debug kind => _45;
            }
        }
        scope 8 {
            debug _r => _53;
        }
        scope 9 {
            debug left_val => _68;
            debug right_val => _69;
            let _72: core::panicking::AssertKind;
            scope 10 {
                debug kind => _72;
            }
        }
    }

    bb0: {
        _3 = Vec::<i32>::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = RefCell::<Vec<i32>>::new(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _1 = &_2;
        _5 = D::<'_>(_1, const 10_i32);
        _6 = D::<'_>(_1, const 11_i32);
        _7 = D::<'_>(_1, const 12_i32);
        _4 = [move _5, move _6, move _7];
        drop(_4) -> [return: bb3, unwind: bb48];
    }

    bb3: {
        _15 = RefCell::<Vec<i32>>::borrow(_1) -> [return: bb4, unwind: bb48];
    }

    bb4: {
        _14 = &_15;
        _13 = <Ref<'_, Vec<i32>> as Deref>::deref(move _14) -> [return: bb5, unwind: bb47];
    }

    bb5: {
        _12 = _13;
        _11 = <Vec<i32> as Index<RangeFull>>::index(move _12, const RangeFull) -> [return: bb6, unwind: bb47];
    }

    bb6: {
        _10 = _11;
        _9 = &_10;
        _82 = const _;
        _8 = (move _9, _82);
        _16 = (_8.0: &&[i32]);
        _17 = (_8.1: &&[i32; 3]);
        _19 = <&[i32] as PartialEq<&[i32; 3]>>::eq(_16, _17) -> [return: bb7, unwind: bb47];
    }

    bb7: {
        _18 = Not(move _19);
        switchInt(move _18) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _20 = core::panicking::AssertKind::Eq;
        _22 = Option::<Arguments<'_>>::None;
        _21 = core::panicking::assert_failed::<&[i32], &[i32; 3]>(move _20, _16, _17, move _22) -> bb47;
    }

    bb9: {
        drop(_15) -> [return: bb10, unwind: bb48];
    }

    bb10: {
        _27 = RefCell::<Vec<i32>>::borrow_mut(_1) -> [return: bb11, unwind: bb48];
    }

    bb11: {
        _26 = &mut _27;
        _25 = <RefMut<'_, Vec<i32>> as DerefMut>::deref_mut(move _26) -> [return: bb12, unwind: bb46];
    }

    bb12: {
        _24 = _25;
        _23 = Vec::<i32>::clear(move _24) -> [return: bb13, unwind: bb46];
    }

    bb13: {
        drop(_27) -> [return: bb14, unwind: bb48];
    }

    bb14: {
        _30 = D::<'_>(_1, const 20_i32);
        _31 = D::<'_>(_1, const 21_i32);
        _32 = D::<'_>(_1, const 22_i32);
        _29 = [move _30, move _31, move _32];
        _28 = &_29;
        drop(_29) -> [return: bb15, unwind: bb48];
    }

    bb15: {
        _40 = RefCell::<Vec<i32>>::borrow(_1) -> [return: bb16, unwind: bb48];
    }

    bb16: {
        _39 = &_40;
        _38 = <Ref<'_, Vec<i32>> as Deref>::deref(move _39) -> [return: bb17, unwind: bb45];
    }

    bb17: {
        _37 = _38;
        _36 = <Vec<i32> as Index<RangeFull>>::index(move _37, const RangeFull) -> [return: bb18, unwind: bb45];
    }

    bb18: {
        _35 = _36;
        _34 = &_35;
        _81 = const _;
        _33 = (move _34, _81);
        _41 = (_33.0: &&[i32]);
        _42 = (_33.1: &&[i32; 3]);
        _44 = <&[i32] as PartialEq<&[i32; 3]>>::eq(_41, _42) -> [return: bb19, unwind: bb45];
    }

    bb19: {
        _43 = Not(move _44);
        switchInt(move _43) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _45 = core::panicking::AssertKind::Eq;
        _47 = Option::<Arguments<'_>>::None;
        _46 = core::panicking::assert_failed::<&[i32], &[i32; 3]>(move _45, _41, _42, move _47) -> bb45;
    }

    bb21: {
        drop(_40) -> [return: bb22, unwind: bb48];
    }

    bb22: {
        _52 = RefCell::<Vec<i32>>::borrow_mut(_1) -> [return: bb23, unwind: bb48];
    }

    bb23: {
        _51 = &mut _52;
        _50 = <RefMut<'_, Vec<i32>> as DerefMut>::deref_mut(move _51) -> [return: bb24, unwind: bb44];
    }

    bb24: {
        _49 = _50;
        _48 = Vec::<i32>::clear(move _49) -> [return: bb25, unwind: bb44];
    }

    bb25: {
        drop(_52) -> [return: bb26, unwind: bb48];
    }

    bb26: {
        _57 = D::<'_>(_1, const 30_i32);
        _58 = D::<'_>(_1, const 31_i32);
        _59 = D::<'_>(_1, const 32_i32);
        _56 = [move _57, move _58, move _59];
        _55 = &_56;
        _54 = <[D<'_>; 3] as Index<RangeFull>>::index(move _55, const RangeFull) -> [return: bb27, unwind: bb43];
    }

    bb27: {
        _53 = _54;
        drop(_56) -> [return: bb28, unwind: bb48];
    }

    bb28: {
        _67 = RefCell::<Vec<i32>>::borrow(_1) -> [return: bb29, unwind: bb48];
    }

    bb29: {
        _66 = &_67;
        _65 = <Ref<'_, Vec<i32>> as Deref>::deref(move _66) -> [return: bb30, unwind: bb42];
    }

    bb30: {
        _64 = _65;
        _63 = <Vec<i32> as Index<RangeFull>>::index(move _64, const RangeFull) -> [return: bb31, unwind: bb42];
    }

    bb31: {
        _62 = _63;
        _61 = &_62;
        _80 = const _;
        _60 = (move _61, _80);
        _68 = (_60.0: &&[i32]);
        _69 = (_60.1: &&[i32; 3]);
        _71 = <&[i32] as PartialEq<&[i32; 3]>>::eq(_68, _69) -> [return: bb32, unwind: bb42];
    }

    bb32: {
        _70 = Not(move _71);
        switchInt(move _70) -> [0: bb34, otherwise: bb33];
    }

    bb33: {
        _72 = core::panicking::AssertKind::Eq;
        _74 = Option::<Arguments<'_>>::None;
        _73 = core::panicking::assert_failed::<&[i32], &[i32; 3]>(move _72, _68, _69, move _74) -> bb42;
    }

    bb34: {
        drop(_67) -> [return: bb35, unwind: bb48];
    }

    bb35: {
        _79 = RefCell::<Vec<i32>>::borrow_mut(_1) -> [return: bb36, unwind: bb48];
    }

    bb36: {
        _78 = &mut _79;
        _77 = <RefMut<'_, Vec<i32>> as DerefMut>::deref_mut(move _78) -> [return: bb37, unwind: bb41];
    }

    bb37: {
        _76 = _77;
        _75 = Vec::<i32>::clear(move _76) -> [return: bb38, unwind: bb41];
    }

    bb38: {
        drop(_79) -> [return: bb39, unwind: bb48];
    }

    bb39: {
        drop(_2) -> [return: bb40, unwind continue];
    }

    bb40: {
        return;
    }

    bb41 (cleanup): {
        drop(_79) -> [return: bb48, unwind terminate];
    }

    bb42 (cleanup): {
        drop(_67) -> [return: bb48, unwind terminate];
    }

    bb43 (cleanup): {
        drop(_56) -> [return: bb48, unwind terminate];
    }

    bb44 (cleanup): {
        drop(_52) -> [return: bb48, unwind terminate];
    }

    bb45 (cleanup): {
        drop(_40) -> [return: bb48, unwind terminate];
    }

    bb46 (cleanup): {
        drop(_27) -> [return: bb48, unwind terminate];
    }

    bb47 (cleanup): {
        drop(_15) -> [return: bb48, unwind terminate];
    }

    bb48 (cleanup): {
        drop(_2) -> [return: bb49, unwind terminate];
    }

    bb49 (cleanup): {
        resume;
    }
}

promoted[0] in break_after_whole: &&[i32; 3] = {
    let mut _0: &&[i32; 3];
    let mut _1: &[i32; 3];
    let mut _2: [i32; 3];

    bb0: {
        _2 = [const 30_i32, const 31_i32, const 32_i32];
        _1 = &_2;
        _0 = &_1;
        return;
    }
}

promoted[1] in break_after_whole: &&[i32; 3] = {
    let mut _0: &&[i32; 3];
    let mut _1: &[i32; 3];
    let mut _2: [i32; 3];

    bb0: {
        _2 = [const 20_i32, const 21_i32, const 22_i32];
        _1 = &_2;
        _0 = &_1;
        return;
    }
}

promoted[2] in break_after_whole: &&[i32; 3] = {
    let mut _0: &&[i32; 3];
    let mut _1: &[i32; 3];
    let mut _2: [i32; 3];

    bb0: {
        _2 = [const 10_i32, const 11_i32, const 12_i32];
        _1 = &_2;
        _0 = &_1;
        return;
    }
}

fn D(_1: &RefCell<Vec<i32>>, _2: i32) -> D<'_> {
    let mut _0: D<'_>;

    bb0: {
        _0 = D::<'_>(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn D(_1: &RefCell<Vec<i32>>, _2: i32) -> D<'_> {
    let mut _0: D<'_>;

    bb0: {
        _0 = D::<'_>(move _1, move _2);
        return;
    }
}
