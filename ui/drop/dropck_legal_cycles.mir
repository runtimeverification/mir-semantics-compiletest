// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
const PRINT: bool = {
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: ContextData;
    let mut _3: std::boxed::Box<[S2<'_>]>;
    let mut _4: std::boxed::Box<[S2<'_>; 4]>;
    let mut _5: usize;
    let mut _6: usize;
    let mut _7: *mut u8;
    let mut _8: std::boxed::Box<[S2<'_>; 4]>;
    let mut _9: S2<'_>;
    let mut _10: S2<'_>;
    let mut _11: S2<'_>;
    let mut _12: S2<'_>;
    let _13: ();
    let mut _14: &std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>;
    let _15: &S2<'_>;
    let mut _16: &std::vec::Vec<S2<'_>>;
    let mut _17: (std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>);
    let mut _18: std::option::Option<&S2<'_>>;
    let _19: &S2<'_>;
    let _20: &S2<'_>;
    let mut _21: &std::vec::Vec<S2<'_>>;
    let mut _22: std::option::Option<&S2<'_>>;
    let _23: &S2<'_>;
    let _24: &S2<'_>;
    let mut _25: &std::vec::Vec<S2<'_>>;
    let _26: ();
    let mut _27: &std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>;
    let _28: &S2<'_>;
    let mut _29: &std::vec::Vec<S2<'_>>;
    let mut _30: (std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>);
    let mut _31: std::option::Option<&S2<'_>>;
    let _32: &S2<'_>;
    let _33: &S2<'_>;
    let mut _34: &std::vec::Vec<S2<'_>>;
    let mut _35: std::option::Option<&S2<'_>>;
    let _36: ();
    let mut _37: &std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>;
    let _38: &S2<'_>;
    let mut _39: &std::vec::Vec<S2<'_>>;
    let mut _40: (std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>);
    let mut _41: std::option::Option<&S2<'_>>;
    let _42: &S2<'_>;
    let _43: &S2<'_>;
    let mut _44: &std::vec::Vec<S2<'_>>;
    let mut _45: std::option::Option<&S2<'_>>;
    let _46: ();
    let mut _47: &std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>;
    let _48: &S2<'_>;
    let mut _49: &std::vec::Vec<S2<'_>>;
    let mut _50: (std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>);
    let mut _51: std::option::Option<&S2<'_>>;
    let mut _52: std::option::Option<&S2<'_>>;
    let mut _54: &ContextData;
    let mut _55: bool;
    let mut _56: bool;
    let mut _57: bool;
    let mut _58: !;
    let _59: ();
    let mut _60: &S2<'_>;
    let _61: &S2<'_>;
    let mut _62: &std::vec::Vec<S2<'_>>;
    let mut _63: &mut ContextData;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: bool;
    let mut _67: !;
    let mut _68: bool;
    let _69: ();
    let mut _70: std::fmt::Arguments<'_>;
    let mut _71: &[&str];
    let mut _73: std::boxed::Box<[S<'_>]>;
    let mut _74: std::boxed::Box<[S<'_>; 2]>;
    let mut _75: usize;
    let mut _76: usize;
    let mut _77: *mut u8;
    let mut _78: std::boxed::Box<[S<'_>; 2]>;
    let mut _79: S<'_>;
    let mut _80: S<'_>;
    let _81: ();
    let mut _82: &std::cell::Cell<std::option::Option<&S<'_>>>;
    let _83: &S<'_>;
    let mut _84: &std::vec::Vec<S<'_>>;
    let mut _85: std::option::Option<&S<'_>>;
    let _86: &S<'_>;
    let _87: &S<'_>;
    let mut _88: &std::vec::Vec<S<'_>>;
    let _89: ();
    let mut _90: &std::cell::Cell<std::option::Option<&S<'_>>>;
    let _91: &S<'_>;
    let mut _92: &std::vec::Vec<S<'_>>;
    let mut _93: std::option::Option<&S<'_>>;
    let _94: &S<'_>;
    let _95: &S<'_>;
    let mut _96: &std::vec::Vec<S<'_>>;
    let mut _98: &ContextData;
    let mut _99: bool;
    let mut _100: bool;
    let mut _101: bool;
    let mut _102: !;
    let _103: ();
    let mut _104: &S<'_>;
    let _105: &S<'_>;
    let mut _106: &std::vec::Vec<S<'_>>;
    let mut _107: &mut ContextData;
    let mut _108: bool;
    let mut _109: bool;
    let mut _110: !;
    let mut _111: bool;
    let _112: ();
    let mut _113: std::fmt::Arguments<'_>;
    let mut _114: &[&str];
    let _116: ();
    let mut _117: &std::cell::Cell<std::option::Option<&V<'_>>>;
    let _118: &std::cell::Cell<std::option::Option<&V<'_>>>;
    let mut _119: &std::vec::Vec<std::cell::Cell<std::option::Option<&V<'_>>>>;
    let mut _120: std::option::Option<&V<'_>>;
    let _121: &V<'_>;
    let _122: ();
    let mut _123: &std::cell::Cell<std::option::Option<&V<'_>>>;
    let _124: &std::cell::Cell<std::option::Option<&V<'_>>>;
    let mut _125: &std::vec::Vec<std::cell::Cell<std::option::Option<&V<'_>>>>;
    let mut _126: std::option::Option<&V<'_>>;
    let _127: &V<'_>;
    let mut _129: &ContextData;
    let mut _130: bool;
    let mut _131: bool;
    let mut _132: bool;
    let mut _133: !;
    let _134: ();
    let mut _135: &V<'_>;
    let mut _136: &mut ContextData;
    let mut _137: bool;
    let mut _138: bool;
    let mut _139: !;
    let mut _140: bool;
    let _141: ();
    let mut _142: std::fmt::Arguments<'_>;
    let mut _143: &[&str];
    let _145: std::option::Option<H<'_>>;
    let mut _146: &mut std::collections::HashMap<H<'_>, H<'_>>;
    let mut _147: H<'_>;
    let mut _148: H<'_>;
    let _149: std::option::Option<H<'_>>;
    let mut _150: &mut std::collections::HashMap<H<'_>, H<'_>>;
    let mut _151: H<'_>;
    let mut _152: H<'_>;
    let mut _153: std::collections::hash_map::Iter<'_, H<'_>, H<'_>>;
    let mut _154: std::collections::hash_map::Iter<'_, H<'_>, H<'_>>;
    let mut _155: &std::collections::HashMap<H<'_>, H<'_>>;
    let mut _157: std::option::Option<(&H<'_>, &H<'_>)>;
    let mut _158: &mut std::collections::hash_map::Iter<'_, H<'_>, H<'_>>;
    let mut _159: isize;
    let _162: ();
    let mut _163: &std::cell::Cell<std::option::Option<&H<'_>>>;
    let mut _164: std::option::Option<&H<'_>>;
    let _165: ();
    let mut _166: &std::cell::Cell<std::option::Option<&H<'_>>>;
    let mut _167: std::option::Option<&H<'_>>;
    let mut _169: &ContextData;
    let mut _170: std::collections::hash_map::Iter<'_, H<'_>, H<'_>>;
    let mut _171: std::collections::hash_map::Iter<'_, H<'_>, H<'_>>;
    let mut _172: &std::collections::HashMap<H<'_>, H<'_>>;
    let mut _174: std::option::Option<(&H<'_>, &H<'_>)>;
    let mut _175: &mut std::collections::hash_map::Iter<'_, H<'_>, H<'_>>;
    let mut _176: isize;
    let _178: ();
    let mut _179: &mut ContextData;
    let mut _180: bool;
    let mut _181: bool;
    let mut _182: !;
    let mut _183: bool;
    let _184: ();
    let mut _185: std::fmt::Arguments<'_>;
    let mut _186: &[&str];
    let _188: std::option::Option<HM<'_>>;
    let mut _189: &mut std::collections::HashMap<HM<'_>, HM<'_>>;
    let mut _190: HM<'_>;
    let mut _191: HM<'_>;
    let _192: std::option::Option<HM<'_>>;
    let mut _193: &mut std::collections::HashMap<HM<'_>, HM<'_>>;
    let mut _194: HM<'_>;
    let mut _195: HM<'_>;
    let mut _196: std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
    let mut _197: std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
    let mut _198: &std::collections::HashMap<HM<'_>, HM<'_>>;
    let mut _200: std::option::Option<(&HM<'_>, &HM<'_>)>;
    let mut _201: &mut std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
    let mut _202: isize;
    let _205: ();
    let mut _206: &std::cell::Cell<std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>>;
    let mut _207: std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>;
    let _208: &std::collections::HashMap<HM<'_>, HM<'_>>;
    let _209: ();
    let mut _210: &std::cell::Cell<std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>>;
    let mut _211: std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>;
    let _212: &std::collections::HashMap<HM<'_>, HM<'_>>;
    let mut _214: &ContextData;
    let mut _215: std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
    let mut _216: std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
    let mut _217: &std::collections::HashMap<HM<'_>, HM<'_>>;
    let mut _219: std::option::Option<(&HM<'_>, &HM<'_>)>;
    let mut _220: &mut std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
    let mut _221: isize;
    let _223: ();
    let mut _224: &mut ContextData;
    let mut _225: bool;
    let mut _226: bool;
    let mut _227: !;
    let mut _228: bool;
    let _229: ();
    let mut _230: std::fmt::Arguments<'_>;
    let mut _231: &[&str];
    let _233: ();
    let mut _234: &mut std::collections::VecDeque<S<'_>>;
    let mut _235: S<'_>;
    let _236: ();
    let mut _237: &mut std::collections::VecDeque<S<'_>>;
    let mut _238: S<'_>;
    let _239: ();
    let mut _240: &std::cell::Cell<std::option::Option<&S<'_>>>;
    let _241: &S<'_>;
    let mut _242: &std::collections::VecDeque<S<'_>>;
    let mut _243: std::option::Option<&S<'_>>;
    let _244: &S<'_>;
    let _245: &S<'_>;
    let mut _246: &std::collections::VecDeque<S<'_>>;
    let _247: ();
    let mut _248: &std::cell::Cell<std::option::Option<&S<'_>>>;
    let _249: &S<'_>;
    let mut _250: &std::collections::VecDeque<S<'_>>;
    let mut _251: std::option::Option<&S<'_>>;
    let _252: &S<'_>;
    let _253: &S<'_>;
    let mut _254: &std::collections::VecDeque<S<'_>>;
    let mut _256: &ContextData;
    let mut _257: bool;
    let mut _258: bool;
    let mut _259: bool;
    let mut _260: !;
    let _261: ();
    let mut _262: &S<'_>;
    let _263: &S<'_>;
    let mut _264: &std::collections::VecDeque<S<'_>>;
    let mut _265: &mut ContextData;
    let mut _266: bool;
    let mut _267: bool;
    let mut _268: !;
    let mut _269: bool;
    let _270: ();
    let mut _271: std::fmt::Arguments<'_>;
    let mut _272: &[&str];
    let _274: ();
    let mut _275: &mut std::collections::VecDeque<VD<'_>>;
    let mut _276: VD<'_>;
    let _277: ();
    let mut _278: &mut std::collections::VecDeque<VD<'_>>;
    let mut _279: VD<'_>;
    let _280: ();
    let mut _281: &std::cell::Cell<std::option::Option<&std::collections::VecDeque<VD<'_>>>>;
    let _282: &VD<'_>;
    let mut _283: &std::collections::VecDeque<VD<'_>>;
    let mut _284: std::option::Option<&std::collections::VecDeque<VD<'_>>>;
    let _285: &std::collections::VecDeque<VD<'_>>;
    let _286: ();
    let mut _287: &std::cell::Cell<std::option::Option<&std::collections::VecDeque<VD<'_>>>>;
    let _288: &VD<'_>;
    let mut _289: &std::collections::VecDeque<VD<'_>>;
    let mut _290: std::option::Option<&std::collections::VecDeque<VD<'_>>>;
    let _291: &std::collections::VecDeque<VD<'_>>;
    let mut _293: &ContextData;
    let mut _294: bool;
    let mut _295: bool;
    let mut _296: bool;
    let mut _297: !;
    let _298: ();
    let mut _299: &VD<'_>;
    let _300: &VD<'_>;
    let mut _301: &std::collections::VecDeque<VD<'_>>;
    let mut _302: &mut ContextData;
    let mut _303: bool;
    let mut _304: bool;
    let mut _305: !;
    let mut _306: bool;
    let _307: ();
    let mut _308: std::fmt::Arguments<'_>;
    let mut _309: &[&str];
    let _311: std::option::Option<VM<'_>>;
    let mut _312: &mut std::collections::HashMap<usize, VM<'_>>;
    let mut _313: VM<'_>;
    let _314: std::option::Option<VM<'_>>;
    let mut _315: &mut std::collections::HashMap<usize, VM<'_>>;
    let mut _316: VM<'_>;
    let _317: ();
    let mut _318: &std::cell::Cell<std::option::Option<&std::collections::HashMap<usize, VM<'_>>>>;
    let _319: &VM<'_>;
    let mut _320: &std::collections::HashMap<usize, VM<'_>>;
    let mut _321: std::option::Option<&std::collections::HashMap<usize, VM<'_>>>;
    let _322: &std::collections::HashMap<usize, VM<'_>>;
    let _323: ();
    let mut _324: &std::cell::Cell<std::option::Option<&std::collections::HashMap<usize, VM<'_>>>>;
    let _325: &VM<'_>;
    let mut _326: &std::collections::HashMap<usize, VM<'_>>;
    let mut _327: std::option::Option<&std::collections::HashMap<usize, VM<'_>>>;
    let _328: &std::collections::HashMap<usize, VM<'_>>;
    let mut _330: &ContextData;
    let mut _331: bool;
    let mut _332: bool;
    let mut _333: bool;
    let mut _334: !;
    let _335: ();
    let mut _336: &VM<'_>;
    let _337: &VM<'_>;
    let mut _338: &std::collections::HashMap<usize, VM<'_>>;
    let mut _339: &mut ContextData;
    let mut _340: bool;
    let mut _341: bool;
    let mut _342: !;
    let mut _343: bool;
    let _344: ();
    let mut _345: std::fmt::Arguments<'_>;
    let mut _346: &[&str];
    let _348: ();
    let mut _349: &mut std::collections::LinkedList<LL<'_>>;
    let mut _350: LL<'_>;
    let _351: ();
    let mut _352: &mut std::collections::LinkedList<LL<'_>>;
    let mut _353: LL<'_>;
    let mut _354: std::collections::linked_list::Iter<'_, LL<'_>>;
    let mut _355: &std::collections::LinkedList<LL<'_>>;
    let mut _357: std::option::Option<&LL<'_>>;
    let mut _358: &mut std::collections::linked_list::Iter<'_, LL<'_>>;
    let mut _359: isize;
    let _361: ();
    let mut _362: &std::cell::Cell<std::option::Option<&std::collections::LinkedList<LL<'_>>>>;
    let mut _363: std::option::Option<&std::collections::LinkedList<LL<'_>>>;
    let _364: &std::collections::LinkedList<LL<'_>>;
    let mut _366: &ContextData;
    let mut _367: std::collections::linked_list::Iter<'_, LL<'_>>;
    let mut _368: &std::collections::LinkedList<LL<'_>>;
    let mut _370: std::option::Option<&LL<'_>>;
    let mut _371: &mut std::collections::linked_list::Iter<'_, LL<'_>>;
    let mut _372: isize;
    let _374: ();
    let mut _375: &mut ContextData;
    let mut _376: bool;
    let mut _377: bool;
    let mut _378: !;
    let mut _379: bool;
    let _380: ();
    let mut _381: std::fmt::Arguments<'_>;
    let mut _382: &[&str];
    let _384: ();
    let mut _385: &mut std::collections::BinaryHeap<BH<'_>>;
    let mut _386: BH<'_>;
    let _387: ();
    let mut _388: &mut std::collections::BinaryHeap<BH<'_>>;
    let mut _389: BH<'_>;
    let mut _390: std::collections::binary_heap::Iter<'_, BH<'_>>;
    let mut _391: std::collections::binary_heap::Iter<'_, BH<'_>>;
    let mut _392: &std::collections::BinaryHeap<BH<'_>>;
    let mut _394: std::option::Option<&BH<'_>>;
    let mut _395: &mut std::collections::binary_heap::Iter<'_, BH<'_>>;
    let mut _396: isize;
    let _398: ();
    let mut _399: &std::cell::Cell<std::option::Option<&std::collections::BinaryHeap<BH<'_>>>>;
    let mut _400: std::option::Option<&std::collections::BinaryHeap<BH<'_>>>;
    let _401: &std::collections::BinaryHeap<BH<'_>>;
    let mut _403: &ContextData;
    let mut _404: std::collections::binary_heap::Iter<'_, BH<'_>>;
    let mut _405: &std::collections::BinaryHeap<BH<'_>>;
    let mut _407: std::option::Option<&BH<'_>>;
    let mut _408: &mut std::collections::binary_heap::Iter<'_, BH<'_>>;
    let mut _409: isize;
    let _411: ();
    let mut _412: &mut ContextData;
    let mut _413: bool;
    let mut _414: bool;
    let mut _415: !;
    let mut _416: bool;
    let _417: ();
    let mut _418: std::fmt::Arguments<'_>;
    let mut _419: &[&str];
    let _421: std::option::Option<BTM<'_>>;
    let mut _422: &mut std::collections::BTreeMap<BTM<'_>, BTM<'_>>;
    let mut _423: BTM<'_>;
    let mut _424: BTM<'_>;
    let _425: std::option::Option<BTM<'_>>;
    let mut _426: &mut std::collections::BTreeMap<BTM<'_>, BTM<'_>>;
    let mut _427: BTM<'_>;
    let mut _428: BTM<'_>;
    let mut _429: std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>>;
    let mut _430: std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>>;
    let mut _431: &std::collections::BTreeMap<BTM<'_>, BTM<'_>>;
    let mut _433: std::option::Option<(&BTM<'_>, &BTM<'_>)>;
    let mut _434: &mut std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>>;
    let mut _435: isize;
    let _438: ();
    let mut _439: &std::cell::Cell<std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>>;
    let mut _440: std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>;
    let _441: &std::collections::BTreeMap<BTM<'_>, BTM<'_>>;
    let _442: ();
    let mut _443: &std::cell::Cell<std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>>;
    let mut _444: std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>;
    let _445: &std::collections::BTreeMap<BTM<'_>, BTM<'_>>;
    let mut _447: &ContextData;
    let mut _448: std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>>;
    let mut _449: &std::collections::BTreeMap<BTM<'_>, BTM<'_>>;
    let mut _451: std::option::Option<(&BTM<'_>, &BTM<'_>)>;
    let mut _452: &mut std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>>;
    let mut _453: isize;
    let _455: ();
    let mut _456: &mut ContextData;
    let mut _457: bool;
    let mut _458: bool;
    let mut _459: !;
    let mut _460: bool;
    let _461: ();
    let mut _462: std::fmt::Arguments<'_>;
    let mut _463: &[&str];
    let _465: bool;
    let mut _466: &mut std::collections::BTreeSet<BTS<'_>>;
    let mut _467: BTS<'_>;
    let _468: bool;
    let mut _469: &mut std::collections::BTreeSet<BTS<'_>>;
    let mut _470: BTS<'_>;
    let mut _471: std::collections::btree_set::Iter<'_, BTS<'_>>;
    let mut _472: std::collections::btree_set::Iter<'_, BTS<'_>>;
    let mut _473: &std::collections::BTreeSet<BTS<'_>>;
    let mut _475: std::option::Option<&BTS<'_>>;
    let mut _476: &mut std::collections::btree_set::Iter<'_, BTS<'_>>;
    let mut _477: isize;
    let _479: ();
    let mut _480: &std::cell::Cell<std::option::Option<&std::collections::BTreeSet<BTS<'_>>>>;
    let mut _481: std::option::Option<&std::collections::BTreeSet<BTS<'_>>>;
    let _482: &std::collections::BTreeSet<BTS<'_>>;
    let mut _484: &ContextData;
    let mut _485: std::collections::btree_set::Iter<'_, BTS<'_>>;
    let mut _486: &std::collections::BTreeSet<BTS<'_>>;
    let mut _488: std::option::Option<&BTS<'_>>;
    let mut _489: &mut std::collections::btree_set::Iter<'_, BTS<'_>>;
    let mut _490: isize;
    let _492: ();
    let mut _493: &mut ContextData;
    let mut _494: bool;
    let mut _495: bool;
    let mut _496: !;
    let mut _497: bool;
    let _498: ();
    let mut _499: std::fmt::Arguments<'_>;
    let mut _500: &[&str];
    let mut _504: RCRC<'_>;
    let mut _505: RCRC<'_>;
    let mut _506: RCRC<'_>;
    let mut _507: std::option::Option<&RCRC<'_>>;
    let _508: &RCRC<'_>;
    let mut _509: &mut RCRCData<'_>;
    let mut _510: &mut std::cell::RefMut<'_, RCRCData<'_>>;
    let mut _511: std::cell::RefMut<'_, RCRCData<'_>>;
    let mut _512: &std::cell::RefCell<RCRCData<'_>>;
    let _513: &std::cell::RefCell<RCRCData<'_>>;
    let mut _514: &std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>;
    let mut _515: std::option::Option<&RCRC<'_>>;
    let _516: &RCRC<'_>;
    let mut _517: &mut RCRCData<'_>;
    let mut _518: &mut std::cell::RefMut<'_, RCRCData<'_>>;
    let mut _519: std::cell::RefMut<'_, RCRCData<'_>>;
    let mut _520: &std::cell::RefCell<RCRCData<'_>>;
    let _521: &std::cell::RefCell<RCRCData<'_>>;
    let mut _522: &std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>;
    let mut _523: std::option::Option<&RCRC<'_>>;
    let _524: &RCRC<'_>;
    let mut _525: &mut RCRCData<'_>;
    let mut _526: &mut std::cell::RefMut<'_, RCRCData<'_>>;
    let mut _527: std::cell::RefMut<'_, RCRCData<'_>>;
    let mut _528: &std::cell::RefCell<RCRCData<'_>>;
    let _529: &std::cell::RefCell<RCRCData<'_>>;
    let mut _530: &std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>;
    let mut _532: &ContextData;
    let mut _533: bool;
    let mut _534: bool;
    let mut _535: bool;
    let mut _536: !;
    let _537: ();
    let mut _538: &RCRC<'_>;
    let mut _539: &mut ContextData;
    let mut _540: bool;
    let mut _541: bool;
    let mut _542: !;
    let mut _543: bool;
    let _544: ();
    let mut _545: std::fmt::Arguments<'_>;
    let mut _546: &[&str];
    let mut _550: ARCRC<'_>;
    let mut _551: ARCRC<'_>;
    let mut _552: ARCRC<'_>;
    let mut _553: std::option::Option<&ARCRC<'_>>;
    let _554: &ARCRC<'_>;
    let mut _555: &mut ARCRCData<'_>;
    let mut _556: &mut std::cell::RefMut<'_, ARCRCData<'_>>;
    let mut _557: std::cell::RefMut<'_, ARCRCData<'_>>;
    let mut _558: &std::cell::RefCell<ARCRCData<'_>>;
    let _559: &std::cell::RefCell<ARCRCData<'_>>;
    let mut _560: &std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>;
    let mut _561: std::option::Option<&ARCRC<'_>>;
    let _562: &ARCRC<'_>;
    let mut _563: &mut ARCRCData<'_>;
    let mut _564: &mut std::cell::RefMut<'_, ARCRCData<'_>>;
    let mut _565: std::cell::RefMut<'_, ARCRCData<'_>>;
    let mut _566: &std::cell::RefCell<ARCRCData<'_>>;
    let _567: &std::cell::RefCell<ARCRCData<'_>>;
    let mut _568: &std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>;
    let mut _569: std::option::Option<&ARCRC<'_>>;
    let _570: &ARCRC<'_>;
    let mut _571: &mut ARCRCData<'_>;
    let mut _572: &mut std::cell::RefMut<'_, ARCRCData<'_>>;
    let mut _573: std::cell::RefMut<'_, ARCRCData<'_>>;
    let mut _574: &std::cell::RefCell<ARCRCData<'_>>;
    let _575: &std::cell::RefCell<ARCRCData<'_>>;
    let mut _576: &std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>;
    let mut _578: &ContextData;
    let mut _579: bool;
    let mut _580: bool;
    let mut _581: bool;
    let mut _582: !;
    let _583: ();
    let mut _584: &ARCRC<'_>;
    let mut _585: &mut ContextData;
    let mut _586: bool;
    let mut _587: bool;
    let mut _588: !;
    let mut _589: bool;
    let _590: ();
    let mut _591: std::fmt::Arguments<'_>;
    let mut _592: &[&str];
    let mut _596: ARCRW<'_>;
    let mut _597: ARCRW<'_>;
    let mut _598: ARCRW<'_>;
    let mut _599: std::option::Option<&ARCRW<'_>>;
    let _600: &ARCRW<'_>;
    let mut _601: &mut ARCRWData<'_>;
    let mut _602: &mut std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>;
    let mut _603: std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>;
    let mut _604: std::result::Result<std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>, std::sync::PoisonError<std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>>>;
    let mut _605: &std::sync::RwLock<ARCRWData<'_>>;
    let _606: &std::sync::RwLock<ARCRWData<'_>>;
    let mut _607: &std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>;
    let mut _608: std::option::Option<&ARCRW<'_>>;
    let _609: &ARCRW<'_>;
    let mut _610: &mut ARCRWData<'_>;
    let mut _611: &mut std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>;
    let mut _612: std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>;
    let mut _613: std::result::Result<std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>, std::sync::PoisonError<std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>>>;
    let mut _614: &std::sync::RwLock<ARCRWData<'_>>;
    let _615: &std::sync::RwLock<ARCRWData<'_>>;
    let mut _616: &std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>;
    let mut _617: std::option::Option<&ARCRW<'_>>;
    let _618: &ARCRW<'_>;
    let mut _619: &mut ARCRWData<'_>;
    let mut _620: &mut std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>;
    let mut _621: std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>;
    let mut _622: std::result::Result<std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>, std::sync::PoisonError<std::sync::RwLockWriteGuard<'_, ARCRWData<'_>>>>;
    let mut _623: &std::sync::RwLock<ARCRWData<'_>>;
    let _624: &std::sync::RwLock<ARCRWData<'_>>;
    let mut _625: &std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>;
    let mut _627: &ContextData;
    let mut _628: bool;
    let mut _629: bool;
    let mut _630: bool;
    let mut _631: !;
    let _632: ();
    let mut _633: &ARCRW<'_>;
    let mut _634: &mut ContextData;
    let mut _635: bool;
    let mut _636: bool;
    let mut _637: !;
    let mut _638: bool;
    let _639: ();
    let mut _640: std::fmt::Arguments<'_>;
    let mut _641: &[&str];
    let mut _645: ARCM<'_>;
    let mut _646: ARCM<'_>;
    let mut _647: ARCM<'_>;
    let mut _648: std::option::Option<&ARCM<'_>>;
    let _649: &ARCM<'_>;
    let mut _650: &mut ARCMData<'_>;
    let mut _651: &mut std::sync::MutexGuard<'_, ARCMData<'_>>;
    let mut _652: std::sync::MutexGuard<'_, ARCMData<'_>>;
    let mut _653: std::result::Result<std::sync::MutexGuard<'_, ARCMData<'_>>, std::sync::PoisonError<std::sync::MutexGuard<'_, ARCMData<'_>>>>;
    let mut _654: &std::sync::Mutex<ARCMData<'_>>;
    let _655: &std::sync::Mutex<ARCMData<'_>>;
    let mut _656: &std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>;
    let mut _657: std::option::Option<&ARCM<'_>>;
    let _658: &ARCM<'_>;
    let mut _659: &mut ARCMData<'_>;
    let mut _660: &mut std::sync::MutexGuard<'_, ARCMData<'_>>;
    let mut _661: std::sync::MutexGuard<'_, ARCMData<'_>>;
    let mut _662: std::result::Result<std::sync::MutexGuard<'_, ARCMData<'_>>, std::sync::PoisonError<std::sync::MutexGuard<'_, ARCMData<'_>>>>;
    let mut _663: &std::sync::Mutex<ARCMData<'_>>;
    let _664: &std::sync::Mutex<ARCMData<'_>>;
    let mut _665: &std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>;
    let mut _666: std::option::Option<&ARCM<'_>>;
    let _667: &ARCM<'_>;
    let mut _668: &mut ARCMData<'_>;
    let mut _669: &mut std::sync::MutexGuard<'_, ARCMData<'_>>;
    let mut _670: std::sync::MutexGuard<'_, ARCMData<'_>>;
    let mut _671: std::result::Result<std::sync::MutexGuard<'_, ARCMData<'_>>, std::sync::PoisonError<std::sync::MutexGuard<'_, ARCMData<'_>>>>;
    let mut _672: &std::sync::Mutex<ARCMData<'_>>;
    let _673: &std::sync::Mutex<ARCMData<'_>>;
    let mut _674: &std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>;
    let mut _676: &ContextData;
    let mut _677: bool;
    let mut _678: bool;
    let mut _679: bool;
    let mut _680: !;
    let _681: ();
    let mut _682: &ARCM<'_>;
    let mut _683: &mut ContextData;
    let mut _684: bool;
    let mut _685: bool;
    let mut _686: !;
    let mut _705: bool;
    let mut _706: bool;
    let mut _707: bool;
    let mut _708: bool;
    let mut _709: bool;
    let mut _710: bool;
    let mut _711: bool;
    let mut _712: bool;
    let mut _713: bool;
    let mut _714: bool;
    let mut _715: bool;
    let mut _716: bool;
    let mut _717: &mut std::boxed::Box<[S<'_>; 2]>;
    let mut _718: ();
    let mut _719: &mut std::boxed::Box<[S2<'_>; 4]>;
    let mut _720: ();
    let mut _721: *const [S2<'_>; 4];
    let mut _722: *const [S<'_>; 2];
    scope 1 {
        debug c_orig => _1;
        let _2: std::vec::Vec<S2<'_>>;
        let mut _729: *const ();
        let mut _730: usize;
        let mut _731: usize;
        let mut _732: usize;
        let mut _733: usize;
        let mut _734: bool;
        scope 2 {
            debug v => _2;
            let mut _53: ContextData;
            scope 4 {
                debug c => _53;
                let _72: std::vec::Vec<S<'_>>;
                let mut _704: &[&str; 1];
                let mut _723: *const ();
                let mut _724: usize;
                let mut _725: usize;
                let mut _726: usize;
                let mut _727: usize;
                let mut _728: bool;
                scope 5 {
                    debug v => _72;
                    let mut _97: ContextData;
                    scope 7 {
                        debug c => _97;
                        let _115: V<'_>;
                        let mut _703: &[&str; 1];
                        scope 8 {
                            debug v => _115;
                            let mut _128: ContextData;
                            scope 9 {
                                debug c => _128;
                                let mut _144: std::collections::HashMap<H<'_>, H<'_>>;
                                let mut _702: &[&str; 1];
                                scope 10 {
                                    debug h => _144;
                                    let mut _156: std::collections::hash_map::Iter<'_, H<'_>, H<'_>>;
                                    let mut _168: ContextData;
                                    scope 11 {
                                        debug iter => _156;
                                        let _160: &H<'_>;
                                        let _161: &H<'_>;
                                        scope 12 {
                                            debug key => _160;
                                            debug val => _161;
                                        }
                                    }
                                    scope 13 {
                                        debug c => _168;
                                        let mut _173: std::collections::hash_map::Iter<'_, H<'_>, H<'_>>;
                                        let mut _187: std::collections::HashMap<HM<'_>, HM<'_>>;
                                        let mut _701: &[&str; 1];
                                        scope 14 {
                                            debug iter => _173;
                                            let _177: &H<'_>;
                                            scope 15 {
                                                debug key => _177;
                                            }
                                        }
                                        scope 16 {
                                            debug h => _187;
                                            let mut _199: std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
                                            let mut _213: ContextData;
                                            scope 17 {
                                                debug iter => _199;
                                                let _203: &HM<'_>;
                                                let _204: &HM<'_>;
                                                scope 18 {
                                                    debug key => _203;
                                                    debug val => _204;
                                                }
                                            }
                                            scope 19 {
                                                debug c => _213;
                                                let mut _218: std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
                                                let mut _232: std::collections::VecDeque<S<'_>>;
                                                let mut _700: &[&str; 1];
                                                scope 20 {
                                                    debug iter => _218;
                                                    let _222: &HM<'_>;
                                                    scope 21 {
                                                        debug key => _222;
                                                    }
                                                }
                                                scope 22 {
                                                    debug vd => _232;
                                                    let mut _255: ContextData;
                                                    scope 23 {
                                                        debug c => _255;
                                                        let mut _273: std::collections::VecDeque<VD<'_>>;
                                                        let mut _699: &[&str; 1];
                                                        scope 24 {
                                                            debug vd => _273;
                                                            let mut _292: ContextData;
                                                            scope 25 {
                                                                debug c => _292;
                                                                let mut _310: std::collections::HashMap<usize, VM<'_>>;
                                                                let mut _698: &[&str; 1];
                                                                scope 26 {
                                                                    debug vm => _310;
                                                                    let mut _329: ContextData;
                                                                    let mut _696: &usize;
                                                                    let mut _697: &usize;
                                                                    scope 27 {
                                                                        debug c => _329;
                                                                        let mut _347: std::collections::LinkedList<LL<'_>>;
                                                                        let mut _694: &[&str; 1];
                                                                        let mut _695: &usize;
                                                                        scope 28 {
                                                                            debug ll => _347;
                                                                            let mut _356: std::collections::linked_list::Iter<'_, LL<'_>>;
                                                                            let mut _365: ContextData;
                                                                            scope 29 {
                                                                                debug iter => _356;
                                                                                let _360: &LL<'_>;
                                                                                scope 30 {
                                                                                    debug e => _360;
                                                                                }
                                                                            }
                                                                            scope 31 {
                                                                                debug c => _365;
                                                                                let mut _369: std::collections::linked_list::Iter<'_, LL<'_>>;
                                                                                let mut _383: std::collections::BinaryHeap<BH<'_>>;
                                                                                let mut _693: &[&str; 1];
                                                                                scope 32 {
                                                                                    debug iter => _369;
                                                                                    let _373: &LL<'_>;
                                                                                    scope 33 {
                                                                                        debug e => _373;
                                                                                    }
                                                                                }
                                                                                scope 34 {
                                                                                    debug bh => _383;
                                                                                    let mut _393: std::collections::binary_heap::Iter<'_, BH<'_>>;
                                                                                    let mut _402: ContextData;
                                                                                    scope 35 {
                                                                                        debug iter => _393;
                                                                                        let _397: &BH<'_>;
                                                                                        scope 36 {
                                                                                            debug b => _397;
                                                                                        }
                                                                                    }
                                                                                    scope 37 {
                                                                                        debug c => _402;
                                                                                        let mut _406: std::collections::binary_heap::Iter<'_, BH<'_>>;
                                                                                        let mut _420: std::collections::BTreeMap<BTM<'_>, BTM<'_>>;
                                                                                        let mut _692: &[&str; 1];
                                                                                        scope 38 {
                                                                                            debug iter => _406;
                                                                                            let _410: &BH<'_>;
                                                                                            scope 39 {
                                                                                                debug b => _410;
                                                                                            }
                                                                                        }
                                                                                        scope 40 {
                                                                                            debug btm => _420;
                                                                                            let mut _432: std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>>;
                                                                                            let mut _446: ContextData;
                                                                                            scope 41 {
                                                                                                debug iter => _432;
                                                                                                let _436: &BTM<'_>;
                                                                                                let _437: &BTM<'_>;
                                                                                                scope 42 {
                                                                                                    debug k => _436;
                                                                                                    debug v => _437;
                                                                                                }
                                                                                            }
                                                                                            scope 43 {
                                                                                                debug c => _446;
                                                                                                let mut _450: std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>>;
                                                                                                let mut _464: std::collections::BTreeSet<BTS<'_>>;
                                                                                                let mut _691: &[&str; 1];
                                                                                                scope 44 {
                                                                                                    debug iter => _450;
                                                                                                    let _454: &BTM<'_>;
                                                                                                    scope 45 {
                                                                                                        debug k => _454;
                                                                                                    }
                                                                                                }
                                                                                                scope 46 {
                                                                                                    debug bts => _464;
                                                                                                    let mut _474: std::collections::btree_set::Iter<'_, BTS<'_>>;
                                                                                                    let mut _483: ContextData;
                                                                                                    scope 47 {
                                                                                                        debug iter => _474;
                                                                                                        let _478: &BTS<'_>;
                                                                                                        scope 48 {
                                                                                                            debug v => _478;
                                                                                                        }
                                                                                                    }
                                                                                                    scope 49 {
                                                                                                        debug c => _483;
                                                                                                        let mut _487: std::collections::btree_set::Iter<'_, BTS<'_>>;
                                                                                                        let _501: RCRC<'_>;
                                                                                                        let _502: RCRC<'_>;
                                                                                                        let _503: RCRC<'_>;
                                                                                                        let mut _690: &[&str; 1];
                                                                                                        scope 50 {
                                                                                                            debug iter => _487;
                                                                                                            let _491: &BTS<'_>;
                                                                                                            scope 51 {
                                                                                                                debug b => _491;
                                                                                                            }
                                                                                                        }
                                                                                                        scope 52 {
                                                                                                            debug rc0 => _501;
                                                                                                            debug rc1 => _502;
                                                                                                            debug rc2 => _503;
                                                                                                            let mut _531: ContextData;
                                                                                                            scope 53 {
                                                                                                                debug c => _531;
                                                                                                                let _547: ARCRC<'_>;
                                                                                                                let _548: ARCRC<'_>;
                                                                                                                let _549: ARCRC<'_>;
                                                                                                                let mut _689: &[&str; 1];
                                                                                                                scope 54 {
                                                                                                                    debug arc0 => _547;
                                                                                                                    debug arc1 => _548;
                                                                                                                    debug arc2 => _549;
                                                                                                                    let mut _577: ContextData;
                                                                                                                    scope 55 {
                                                                                                                        debug c => _577;
                                                                                                                        let _593: ARCRW<'_>;
                                                                                                                        let _594: ARCRW<'_>;
                                                                                                                        let _595: ARCRW<'_>;
                                                                                                                        let mut _688: &[&str; 1];
                                                                                                                        scope 56 {
                                                                                                                            debug arc0 => _593;
                                                                                                                            debug arc1 => _594;
                                                                                                                            debug arc2 => _595;
                                                                                                                            let mut _626: ContextData;
                                                                                                                            scope 57 {
                                                                                                                                debug c => _626;
                                                                                                                                let _642: ARCM<'_>;
                                                                                                                                let _643: ARCM<'_>;
                                                                                                                                let _644: ARCM<'_>;
                                                                                                                                let mut _687: &[&str; 1];
                                                                                                                                scope 58 {
                                                                                                                                    debug arc0 => _642;
                                                                                                                                    debug arc1 => _643;
                                                                                                                                    debug arc2 => _644;
                                                                                                                                    let mut _675: ContextData;
                                                                                                                                    scope 59 {
                                                                                                                                        debug c => _675;
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                scope 6 {
                }
            }
        }
        scope 3 {
        }
    }

    bb0: {
        _716 = const false;
        _715 = const false;
        _714 = const false;
        _713 = const false;
        _712 = const false;
        _711 = const false;
        _710 = const false;
        _709 = const false;
        _708 = const false;
        _707 = const false;
        _706 = const false;
        _705 = const false;
        _1 = ContextData { curr_depth: const 0_usize, max_depth: const 3_usize, visited: const 0_usize, max_visits: const 1000_usize, skipped: const 0_usize, curr_mark: const 0_u32, saw_prev_marked: const false, control_bits: const 0_u64 };
        _5 = SizeOf([S2<'_>; 4]);
        _6 = AlignOf([S2<'_>; 4]);
        _7 = alloc::alloc::exchange_malloc(move _5, move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = ShallowInitBox(move _7, [S2<'_>; 4]);
        _9 = <S2<'_> as Named>::new(const "s0") -> [return: bb2, unwind: bb438];
    }

    bb2: {
        _10 = <S2<'_> as Named>::new(const "s1") -> [return: bb3, unwind: bb438];
    }

    bb3: {
        _11 = <S2<'_> as Named>::new(const "s2") -> [return: bb4, unwind: bb438];
    }

    bb4: {
        _12 = <S2<'_> as Named>::new(const "s3") -> [return: bb5, unwind: bb438];
    }

    bb5: {
        _721 = (((_8.0: std::ptr::Unique<[S2<'_>; 4]>).0: std::ptr::NonNull<[S2<'_>; 4]>).0: *const [S2<'_>; 4]);
        _729 = _721 as *const () (PtrToPtr);
        _730 = _729 as usize (Transmute);
        _731 = AlignOf(S2<'_>);
        _732 = Sub(_731, const 1_usize);
        _733 = BitAnd(_730, _732);
        _734 = Eq(_733, const 0_usize);
        assert(_734, "misaligned pointer dereference: address must be a multiple of {} but is {}", _731, _730) -> [success: bb440, unwind unreachable];
    }

    bb6: {
        _16 = &_2;
        _15 = <Vec<S2<'_>> as Index<usize>>::index(move _16, const 0_usize) -> [return: bb7, unwind: bb411];
    }

    bb7: {
        _14 = &((*_15).2: std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>);
        _21 = &_2;
        _20 = <Vec<S2<'_>> as Index<usize>>::index(move _21, const 1_usize) -> [return: bb8, unwind: bb411];
    }

    bb8: {
        _19 = _20;
        _18 = Option::<&S2<'_>>::Some(_19);
        _25 = &_2;
        _24 = <Vec<S2<'_>> as Index<usize>>::index(move _25, const 2_usize) -> [return: bb9, unwind: bb411];
    }

    bb9: {
        _23 = _24;
        _22 = Option::<&S2<'_>>::Some(_23);
        _17 = (move _18, move _22);
        _13 = Cell::<(Option<&S2<'_>>, Option<&S2<'_>>)>::set(move _14, move _17) -> [return: bb10, unwind: bb411];
    }

    bb10: {
        _29 = &_2;
        _28 = <Vec<S2<'_>> as Index<usize>>::index(move _29, const 1_usize) -> [return: bb11, unwind: bb411];
    }

    bb11: {
        _27 = &((*_28).2: std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>);
        _34 = &_2;
        _33 = <Vec<S2<'_>> as Index<usize>>::index(move _34, const 3_usize) -> [return: bb12, unwind: bb411];
    }

    bb12: {
        _32 = _33;
        _31 = Option::<&S2<'_>>::Some(_32);
        _35 = Option::<&S2<'_>>::None;
        _30 = (move _31, move _35);
        _26 = Cell::<(Option<&S2<'_>>, Option<&S2<'_>>)>::set(move _27, move _30) -> [return: bb13, unwind: bb411];
    }

    bb13: {
        _39 = &_2;
        _38 = <Vec<S2<'_>> as Index<usize>>::index(move _39, const 2_usize) -> [return: bb14, unwind: bb411];
    }

    bb14: {
        _37 = &((*_38).2: std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>);
        _44 = &_2;
        _43 = <Vec<S2<'_>> as Index<usize>>::index(move _44, const 3_usize) -> [return: bb15, unwind: bb411];
    }

    bb15: {
        _42 = _43;
        _41 = Option::<&S2<'_>>::Some(_42);
        _45 = Option::<&S2<'_>>::None;
        _40 = (move _41, move _45);
        _36 = Cell::<(Option<&S2<'_>>, Option<&S2<'_>>)>::set(move _37, move _40) -> [return: bb16, unwind: bb411];
    }

    bb16: {
        _49 = &_2;
        _48 = <Vec<S2<'_>> as Index<usize>>::index(move _49, const 3_usize) -> [return: bb17, unwind: bb411];
    }

    bb17: {
        _47 = &((*_48).2: std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>);
        _51 = Option::<&S2<'_>>::None;
        _52 = Option::<&S2<'_>>::None;
        _50 = (move _51, move _52);
        _46 = Cell::<(Option<&S2<'_>>, Option<&S2<'_>>)>::set(move _47, move _50) -> [return: bb18, unwind: bb411];
    }

    bb18: {
        _54 = &_1;
        _53 = <ContextData as Clone>::clone(move _54) -> [return: bb19, unwind: bb411];
    }

    bb19: {
        (_53.5: u32) = const 10_u32;
        _57 = (_53.6: bool);
        _56 = Not(move _57);
        _55 = Not(move _56);
        switchInt(move _55) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _58 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb411;
    }

    bb21: {
        _62 = &_2;
        _61 = <Vec<S2<'_>> as Index<usize>>::index(move _62, const 0_usize) -> [return: bb22, unwind: bb411];
    }

    bb22: {
        _60 = _61;
        _63 = &mut _53;
        _59 = <S2<'_> as Children<'_>>::descend_into_self::<ContextData>(move _60, _63) -> [return: bb23, unwind: bb411];
    }

    bb23: {
        _66 = (_53.6: bool);
        _65 = Not(move _66);
        _64 = Not(move _65);
        switchInt(move _64) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _67 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb411;
    }

    bb25: {
        _68 = const _;
        switchInt(move _68) -> [0: bb28, otherwise: bb26];
    }

    bb26: {
        _704 = const _;
        _71 = _704 as &[&str] (Pointer(Unsize));
        _70 = Arguments::<'_>::new_const(move _71) -> [return: bb27, unwind: bb411];
    }

    bb27: {
        _69 = _print(move _70) -> [return: bb441, unwind: bb411];
    }

    bb28: {
        _75 = SizeOf([S<'_>; 2]);
        _76 = AlignOf([S<'_>; 2]);
        _77 = alloc::alloc::exchange_malloc(move _75, move _76) -> [return: bb29, unwind: bb411];
    }

    bb29: {
        _78 = ShallowInitBox(move _77, [S<'_>; 2]);
        _79 = <S<'_> as Named>::new(const "s0") -> [return: bb30, unwind: bb437];
    }

    bb30: {
        _80 = <S<'_> as Named>::new(const "s1") -> [return: bb31, unwind: bb437];
    }

    bb31: {
        _722 = (((_78.0: std::ptr::Unique<[S<'_>; 2]>).0: std::ptr::NonNull<[S<'_>; 2]>).0: *const [S<'_>; 2]);
        _723 = _722 as *const () (PtrToPtr);
        _724 = _723 as usize (Transmute);
        _725 = AlignOf(S<'_>);
        _726 = Sub(_725, const 1_usize);
        _727 = BitAnd(_724, _726);
        _728 = Eq(_727, const 0_usize);
        assert(_728, "misaligned pointer dereference: address must be a multiple of {} but is {}", _725, _724) -> [success: bb439, unwind unreachable];
    }

    bb32: {
        _84 = &_72;
        _83 = <Vec<S<'_>> as Index<usize>>::index(move _84, const 0_usize) -> [return: bb33, unwind: bb410];
    }

    bb33: {
        _82 = &((*_83).2: std::cell::Cell<std::option::Option<&S<'_>>>);
        _88 = &_72;
        _87 = <Vec<S<'_>> as Index<usize>>::index(move _88, const 1_usize) -> [return: bb34, unwind: bb410];
    }

    bb34: {
        _86 = _87;
        _85 = Option::<&S<'_>>::Some(_86);
        _81 = Cell::<Option<&S<'_>>>::set(move _82, move _85) -> [return: bb35, unwind: bb410];
    }

    bb35: {
        _92 = &_72;
        _91 = <Vec<S<'_>> as Index<usize>>::index(move _92, const 1_usize) -> [return: bb36, unwind: bb410];
    }

    bb36: {
        _90 = &((*_91).2: std::cell::Cell<std::option::Option<&S<'_>>>);
        _96 = &_72;
        _95 = <Vec<S<'_>> as Index<usize>>::index(move _96, const 0_usize) -> [return: bb37, unwind: bb410];
    }

    bb37: {
        _94 = _95;
        _93 = Option::<&S<'_>>::Some(_94);
        _89 = Cell::<Option<&S<'_>>>::set(move _90, move _93) -> [return: bb38, unwind: bb410];
    }

    bb38: {
        _98 = &_1;
        _97 = <ContextData as Clone>::clone(move _98) -> [return: bb39, unwind: bb410];
    }

    bb39: {
        (_97.5: u32) = const 10_u32;
        _101 = (_97.6: bool);
        _100 = Not(move _101);
        _99 = Not(move _100);
        switchInt(move _99) -> [0: bb41, otherwise: bb40];
    }

    bb40: {
        _102 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb410;
    }

    bb41: {
        _106 = &_72;
        _105 = <Vec<S<'_>> as Index<usize>>::index(move _106, const 0_usize) -> [return: bb42, unwind: bb410];
    }

    bb42: {
        _104 = _105;
        _107 = &mut _97;
        _103 = <S<'_> as Children<'_>>::descend_into_self::<ContextData>(move _104, _107) -> [return: bb43, unwind: bb410];
    }

    bb43: {
        _109 = (_97.6: bool);
        _108 = Not(move _109);
        switchInt(move _108) -> [0: bb45, otherwise: bb44];
    }

    bb44: {
        _110 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb410;
    }

    bb45: {
        _111 = const _;
        switchInt(move _111) -> [0: bb48, otherwise: bb46];
    }

    bb46: {
        _703 = const _;
        _114 = _703 as &[&str] (Pointer(Unsize));
        _113 = Arguments::<'_>::new_const(move _114) -> [return: bb47, unwind: bb410];
    }

    bb47: {
        _112 = _print(move _113) -> [return: bb442, unwind: bb410];
    }

    bb48: {
        _115 = <V<'_> as Named>::new(const "v") -> [return: bb49, unwind: bb410];
    }

    bb49: {
        _119 = &(_115.2: std::vec::Vec<std::cell::Cell<std::option::Option<&V<'_>>>>);
        _118 = <Vec<Cell<Option<&V<'_>>>> as Index<usize>>::index(move _119, const 0_usize) -> [return: bb50, unwind: bb409];
    }

    bb50: {
        _117 = _118;
        _121 = &_115;
        _120 = Option::<&V<'_>>::Some(_121);
        _116 = Cell::<Option<&V<'_>>>::set(move _117, move _120) -> [return: bb51, unwind: bb409];
    }

    bb51: {
        _125 = &(_115.2: std::vec::Vec<std::cell::Cell<std::option::Option<&V<'_>>>>);
        _124 = <Vec<Cell<Option<&V<'_>>>> as Index<usize>>::index(move _125, const 1_usize) -> [return: bb52, unwind: bb409];
    }

    bb52: {
        _123 = _124;
        _127 = &_115;
        _126 = Option::<&V<'_>>::Some(_127);
        _122 = Cell::<Option<&V<'_>>>::set(move _123, move _126) -> [return: bb53, unwind: bb409];
    }

    bb53: {
        _129 = &_1;
        _128 = <ContextData as Clone>::clone(move _129) -> [return: bb54, unwind: bb409];
    }

    bb54: {
        (_128.5: u32) = const 20_u32;
        _132 = (_128.6: bool);
        _131 = Not(move _132);
        _130 = Not(move _131);
        switchInt(move _130) -> [0: bb56, otherwise: bb55];
    }

    bb55: {
        _133 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb409;
    }

    bb56: {
        _135 = &_115;
        _136 = &mut _128;
        _134 = <V<'_> as Children<'_>>::descend_into_self::<ContextData>(move _135, _136) -> [return: bb57, unwind: bb409];
    }

    bb57: {
        _138 = (_128.6: bool);
        _137 = Not(move _138);
        switchInt(move _137) -> [0: bb59, otherwise: bb58];
    }

    bb58: {
        _139 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb409;
    }

    bb59: {
        _140 = const _;
        switchInt(move _140) -> [0: bb62, otherwise: bb60];
    }

    bb60: {
        _702 = const _;
        _143 = _702 as &[&str] (Pointer(Unsize));
        _142 = Arguments::<'_>::new_const(move _143) -> [return: bb61, unwind: bb409];
    }

    bb61: {
        _141 = _print(move _142) -> [return: bb443, unwind: bb409];
    }

    bb62: {
        _144 = HashMap::<H<'_>, H<'_>>::new() -> [return: bb63, unwind: bb409];
    }

    bb63: {
        _146 = &mut _144;
        _147 = <H<'_> as Named>::new(const "hk0") -> [return: bb64, unwind: bb408];
    }

    bb64: {
        _148 = <H<'_> as Named>::new(const "hv0") -> [return: bb65, unwind: bb408];
    }

    bb65: {
        _145 = HashMap::<H<'_>, H<'_>>::insert(move _146, move _147, move _148) -> [return: bb66, unwind: bb408];
    }

    bb66: {
        _150 = &mut _144;
        _151 = <H<'_> as Named>::new(const "hk1") -> [return: bb67, unwind: bb408];
    }

    bb67: {
        _152 = <H<'_> as Named>::new(const "hv1") -> [return: bb68, unwind: bb408];
    }

    bb68: {
        _149 = HashMap::<H<'_>, H<'_>>::insert(move _150, move _151, move _152) -> [return: bb69, unwind: bb408];
    }

    bb69: {
        _155 = &_144;
        _154 = HashMap::<H<'_>, H<'_>>::iter(move _155) -> [return: bb70, unwind: bb408];
    }

    bb70: {
        _153 = <std::collections::hash_map::Iter<'_, H<'_>, H<'_>> as IntoIterator>::into_iter(move _154) -> [return: bb71, unwind: bb408];
    }

    bb71: {
        _156 = move _153;
        goto -> bb72;
    }

    bb72: {
        _158 = &mut _156;
        _157 = <std::collections::hash_map::Iter<'_, H<'_>, H<'_>> as Iterator>::next(_158) -> [return: bb73, unwind: bb408];
    }

    bb73: {
        _159 = discriminant(_157);
        switchInt(move _159) -> [0: bb76, 1: bb74, otherwise: bb75];
    }

    bb74: {
        _160 = (((_157 as Some).0: (&H<'_>, &H<'_>)).0: &H<'_>);
        _161 = (((_157 as Some).0: (&H<'_>, &H<'_>)).1: &H<'_>);
        _163 = &((*_161).2: std::cell::Cell<std::option::Option<&H<'_>>>);
        _164 = Option::<&H<'_>>::Some(_160);
        _162 = Cell::<Option<&H<'_>>>::set(move _163, move _164) -> [return: bb77, unwind: bb408];
    }

    bb75: {
        unreachable;
    }

    bb76: {
        _169 = &_1;
        _168 = <ContextData as Clone>::clone(move _169) -> [return: bb78, unwind: bb408];
    }

    bb77: {
        _166 = &((*_160).2: std::cell::Cell<std::option::Option<&H<'_>>>);
        _167 = Option::<&H<'_>>::Some(_161);
        _165 = Cell::<Option<&H<'_>>>::set(move _166, move _167) -> [return: bb444, unwind: bb408];
    }

    bb78: {
        (_168.5: u32) = const 30_u32;
        _172 = &_144;
        _171 = HashMap::<H<'_>, H<'_>>::iter(move _172) -> [return: bb79, unwind: bb408];
    }

    bb79: {
        _170 = <std::collections::hash_map::Iter<'_, H<'_>, H<'_>> as IntoIterator>::into_iter(move _171) -> [return: bb80, unwind: bb408];
    }

    bb80: {
        _173 = move _170;
        goto -> bb81;
    }

    bb81: {
        _175 = &mut _173;
        _174 = <std::collections::hash_map::Iter<'_, H<'_>, H<'_>> as Iterator>::next(_175) -> [return: bb82, unwind: bb408];
    }

    bb82: {
        _176 = discriminant(_174);
        switchInt(move _176) -> [0: bb84, 1: bb83, otherwise: bb75];
    }

    bb83: {
        _177 = (((_174 as Some).0: (&H<'_>, &H<'_>)).0: &H<'_>);
        (_168.5: u32) = Add((_168.5: u32), const 1_u32);
        (_168.6: bool) = const false;
        _179 = &mut _168;
        _178 = <H<'_> as Children<'_>>::descend_into_self::<ContextData>(_177, _179) -> [return: bb85, unwind: bb408];
    }

    bb84: {
        _183 = const _;
        switchInt(move _183) -> [0: bb89, otherwise: bb87];
    }

    bb85: {
        _181 = (_168.6: bool);
        _180 = Not(move _181);
        switchInt(move _180) -> [0: bb81, otherwise: bb86];
    }

    bb86: {
        _182 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb408;
    }

    bb87: {
        _701 = const _;
        _186 = _701 as &[&str] (Pointer(Unsize));
        _185 = Arguments::<'_>::new_const(move _186) -> [return: bb88, unwind: bb408];
    }

    bb88: {
        _184 = _print(move _185) -> [return: bb445, unwind: bb408];
    }

    bb89: {
        _187 = HashMap::<HM<'_>, HM<'_>>::new() -> [return: bb90, unwind: bb408];
    }

    bb90: {
        _189 = &mut _187;
        _190 = <HM<'_> as Named>::new(const "hmk0") -> [return: bb91, unwind: bb407];
    }

    bb91: {
        _191 = <HM<'_> as Named>::new(const "hmv0") -> [return: bb92, unwind: bb407];
    }

    bb92: {
        _188 = HashMap::<HM<'_>, HM<'_>>::insert(move _189, move _190, move _191) -> [return: bb93, unwind: bb407];
    }

    bb93: {
        _193 = &mut _187;
        _194 = <HM<'_> as Named>::new(const "hmk0") -> [return: bb94, unwind: bb407];
    }

    bb94: {
        _195 = <HM<'_> as Named>::new(const "hmv0") -> [return: bb95, unwind: bb407];
    }

    bb95: {
        _192 = HashMap::<HM<'_>, HM<'_>>::insert(move _193, move _194, move _195) -> [return: bb96, unwind: bb407];
    }

    bb96: {
        _198 = &_187;
        _197 = HashMap::<HM<'_>, HM<'_>>::iter(move _198) -> [return: bb97, unwind: bb407];
    }

    bb97: {
        _196 = <std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>> as IntoIterator>::into_iter(move _197) -> [return: bb98, unwind: bb407];
    }

    bb98: {
        _199 = move _196;
        goto -> bb99;
    }

    bb99: {
        _201 = &mut _199;
        _200 = <std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>> as Iterator>::next(_201) -> [return: bb100, unwind: bb407];
    }

    bb100: {
        _202 = discriminant(_200);
        switchInt(move _202) -> [0: bb102, 1: bb101, otherwise: bb75];
    }

    bb101: {
        _203 = (((_200 as Some).0: (&HM<'_>, &HM<'_>)).0: &HM<'_>);
        _204 = (((_200 as Some).0: (&HM<'_>, &HM<'_>)).1: &HM<'_>);
        _206 = &((*_204).2: std::cell::Cell<std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>>);
        _208 = &_187;
        _207 = Option::<&HashMap<HM<'_>, HM<'_>>>::Some(_208);
        _205 = Cell::<Option<&HashMap<HM<'_>, HM<'_>>>>::set(move _206, move _207) -> [return: bb103, unwind: bb407];
    }

    bb102: {
        _214 = &_1;
        _213 = <ContextData as Clone>::clone(move _214) -> [return: bb104, unwind: bb407];
    }

    bb103: {
        _210 = &((*_203).2: std::cell::Cell<std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>>);
        _212 = &_187;
        _211 = Option::<&HashMap<HM<'_>, HM<'_>>>::Some(_212);
        _209 = Cell::<Option<&HashMap<HM<'_>, HM<'_>>>>::set(move _210, move _211) -> [return: bb446, unwind: bb407];
    }

    bb104: {
        (_213.1: usize) = const 2_usize;
        (_213.5: u32) = const 40_u32;
        _217 = &_187;
        _216 = HashMap::<HM<'_>, HM<'_>>::iter(move _217) -> [return: bb105, unwind: bb407];
    }

    bb105: {
        _215 = <std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>> as IntoIterator>::into_iter(move _216) -> [return: bb106, unwind: bb407];
    }

    bb106: {
        _218 = move _215;
        goto -> bb107;
    }

    bb107: {
        _220 = &mut _218;
        _219 = <std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>> as Iterator>::next(_220) -> [return: bb108, unwind: bb407];
    }

    bb108: {
        _221 = discriminant(_219);
        switchInt(move _221) -> [0: bb110, 1: bb109, otherwise: bb75];
    }

    bb109: {
        _222 = (((_219 as Some).0: (&HM<'_>, &HM<'_>)).0: &HM<'_>);
        (_213.5: u32) = Add((_213.5: u32), const 1_u32);
        (_213.6: bool) = const false;
        _224 = &mut _213;
        _223 = <HM<'_> as Children<'_>>::descend_into_self::<ContextData>(_222, _224) -> [return: bb111, unwind: bb407];
    }

    bb110: {
        _228 = const _;
        switchInt(move _228) -> [0: bb115, otherwise: bb113];
    }

    bb111: {
        _226 = (_213.6: bool);
        _225 = Not(move _226);
        switchInt(move _225) -> [0: bb107, otherwise: bb112];
    }

    bb112: {
        _227 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb407;
    }

    bb113: {
        _700 = const _;
        _231 = _700 as &[&str] (Pointer(Unsize));
        _230 = Arguments::<'_>::new_const(move _231) -> [return: bb114, unwind: bb407];
    }

    bb114: {
        _229 = _print(move _230) -> [return: bb447, unwind: bb407];
    }

    bb115: {
        _232 = VecDeque::<S<'_>>::new() -> [return: bb116, unwind: bb407];
    }

    bb116: {
        _234 = &mut _232;
        _235 = <S<'_> as Named>::new(const "d0") -> [return: bb117, unwind: bb406];
    }

    bb117: {
        _233 = VecDeque::<S<'_>>::push_back(move _234, move _235) -> [return: bb118, unwind: bb406];
    }

    bb118: {
        _237 = &mut _232;
        _238 = <S<'_> as Named>::new(const "d1") -> [return: bb119, unwind: bb406];
    }

    bb119: {
        _236 = VecDeque::<S<'_>>::push_back(move _237, move _238) -> [return: bb120, unwind: bb406];
    }

    bb120: {
        _242 = &_232;
        _241 = <VecDeque<S<'_>> as Index<usize>>::index(move _242, const 0_usize) -> [return: bb121, unwind: bb406];
    }

    bb121: {
        _240 = &((*_241).2: std::cell::Cell<std::option::Option<&S<'_>>>);
        _246 = &_232;
        _245 = <VecDeque<S<'_>> as Index<usize>>::index(move _246, const 1_usize) -> [return: bb122, unwind: bb406];
    }

    bb122: {
        _244 = _245;
        _243 = Option::<&S<'_>>::Some(_244);
        _239 = Cell::<Option<&S<'_>>>::set(move _240, move _243) -> [return: bb123, unwind: bb406];
    }

    bb123: {
        _250 = &_232;
        _249 = <VecDeque<S<'_>> as Index<usize>>::index(move _250, const 1_usize) -> [return: bb124, unwind: bb406];
    }

    bb124: {
        _248 = &((*_249).2: std::cell::Cell<std::option::Option<&S<'_>>>);
        _254 = &_232;
        _253 = <VecDeque<S<'_>> as Index<usize>>::index(move _254, const 0_usize) -> [return: bb125, unwind: bb406];
    }

    bb125: {
        _252 = _253;
        _251 = Option::<&S<'_>>::Some(_252);
        _247 = Cell::<Option<&S<'_>>>::set(move _248, move _251) -> [return: bb126, unwind: bb406];
    }

    bb126: {
        _256 = &_1;
        _255 = <ContextData as Clone>::clone(move _256) -> [return: bb127, unwind: bb406];
    }

    bb127: {
        (_255.5: u32) = const 50_u32;
        _259 = (_255.6: bool);
        _258 = Not(move _259);
        _257 = Not(move _258);
        switchInt(move _257) -> [0: bb129, otherwise: bb128];
    }

    bb128: {
        _260 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb406;
    }

    bb129: {
        _264 = &_232;
        _263 = <VecDeque<S<'_>> as Index<usize>>::index(move _264, const 0_usize) -> [return: bb130, unwind: bb406];
    }

    bb130: {
        _262 = _263;
        _265 = &mut _255;
        _261 = <S<'_> as Children<'_>>::descend_into_self::<ContextData>(move _262, _265) -> [return: bb131, unwind: bb406];
    }

    bb131: {
        _267 = (_255.6: bool);
        _266 = Not(move _267);
        switchInt(move _266) -> [0: bb133, otherwise: bb132];
    }

    bb132: {
        _268 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb406;
    }

    bb133: {
        _269 = const _;
        switchInt(move _269) -> [0: bb136, otherwise: bb134];
    }

    bb134: {
        _699 = const _;
        _272 = _699 as &[&str] (Pointer(Unsize));
        _271 = Arguments::<'_>::new_const(move _272) -> [return: bb135, unwind: bb406];
    }

    bb135: {
        _270 = _print(move _271) -> [return: bb448, unwind: bb406];
    }

    bb136: {
        _273 = VecDeque::<VD<'_>>::new() -> [return: bb137, unwind: bb406];
    }

    bb137: {
        _275 = &mut _273;
        _276 = <VD<'_> as Named>::new(const "vd0") -> [return: bb138, unwind: bb405];
    }

    bb138: {
        _274 = VecDeque::<VD<'_>>::push_back(move _275, move _276) -> [return: bb139, unwind: bb405];
    }

    bb139: {
        _278 = &mut _273;
        _279 = <VD<'_> as Named>::new(const "vd1") -> [return: bb140, unwind: bb405];
    }

    bb140: {
        _277 = VecDeque::<VD<'_>>::push_back(move _278, move _279) -> [return: bb141, unwind: bb405];
    }

    bb141: {
        _283 = &_273;
        _282 = <VecDeque<VD<'_>> as Index<usize>>::index(move _283, const 0_usize) -> [return: bb142, unwind: bb405];
    }

    bb142: {
        _281 = &((*_282).2: std::cell::Cell<std::option::Option<&std::collections::VecDeque<VD<'_>>>>);
        _285 = &_273;
        _284 = Option::<&VecDeque<VD<'_>>>::Some(_285);
        _280 = Cell::<Option<&VecDeque<VD<'_>>>>::set(move _281, move _284) -> [return: bb143, unwind: bb405];
    }

    bb143: {
        _289 = &_273;
        _288 = <VecDeque<VD<'_>> as Index<usize>>::index(move _289, const 1_usize) -> [return: bb144, unwind: bb405];
    }

    bb144: {
        _287 = &((*_288).2: std::cell::Cell<std::option::Option<&std::collections::VecDeque<VD<'_>>>>);
        _291 = &_273;
        _290 = Option::<&VecDeque<VD<'_>>>::Some(_291);
        _286 = Cell::<Option<&VecDeque<VD<'_>>>>::set(move _287, move _290) -> [return: bb145, unwind: bb405];
    }

    bb145: {
        _293 = &_1;
        _292 = <ContextData as Clone>::clone(move _293) -> [return: bb146, unwind: bb405];
    }

    bb146: {
        (_292.5: u32) = const 60_u32;
        _296 = (_292.6: bool);
        _295 = Not(move _296);
        _294 = Not(move _295);
        switchInt(move _294) -> [0: bb148, otherwise: bb147];
    }

    bb147: {
        _297 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb405;
    }

    bb148: {
        _301 = &_273;
        _300 = <VecDeque<VD<'_>> as Index<usize>>::index(move _301, const 0_usize) -> [return: bb149, unwind: bb405];
    }

    bb149: {
        _299 = _300;
        _302 = &mut _292;
        _298 = <VD<'_> as Children<'_>>::descend_into_self::<ContextData>(move _299, _302) -> [return: bb150, unwind: bb405];
    }

    bb150: {
        _304 = (_292.6: bool);
        _303 = Not(move _304);
        switchInt(move _303) -> [0: bb152, otherwise: bb151];
    }

    bb151: {
        _305 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb405;
    }

    bb152: {
        _306 = const _;
        switchInt(move _306) -> [0: bb155, otherwise: bb153];
    }

    bb153: {
        _698 = const _;
        _309 = _698 as &[&str] (Pointer(Unsize));
        _308 = Arguments::<'_>::new_const(move _309) -> [return: bb154, unwind: bb405];
    }

    bb154: {
        _307 = _print(move _308) -> [return: bb449, unwind: bb405];
    }

    bb155: {
        _310 = HashMap::<usize, VM<'_>>::new() -> [return: bb156, unwind: bb405];
    }

    bb156: {
        _312 = &mut _310;
        _313 = <VM<'_> as Named>::new(const "vm0") -> [return: bb157, unwind: bb404];
    }

    bb157: {
        _311 = HashMap::<usize, VM<'_>>::insert(move _312, const 0_usize, move _313) -> [return: bb158, unwind: bb404];
    }

    bb158: {
        _315 = &mut _310;
        _316 = <VM<'_> as Named>::new(const "vm1") -> [return: bb159, unwind: bb404];
    }

    bb159: {
        _314 = HashMap::<usize, VM<'_>>::insert(move _315, const 1_usize, move _316) -> [return: bb160, unwind: bb404];
    }

    bb160: {
        _320 = &_310;
        _697 = const _;
        _319 = <HashMap<usize, VM<'_>> as Index<&usize>>::index(move _320, _697) -> [return: bb161, unwind: bb404];
    }

    bb161: {
        _318 = &((*_319).2: std::cell::Cell<std::option::Option<&std::collections::HashMap<usize, VM<'_>>>>);
        _322 = &_310;
        _321 = Option::<&HashMap<usize, VM<'_>>>::Some(_322);
        _317 = Cell::<Option<&HashMap<usize, VM<'_>>>>::set(move _318, move _321) -> [return: bb162, unwind: bb404];
    }

    bb162: {
        _326 = &_310;
        _696 = const _;
        _325 = <HashMap<usize, VM<'_>> as Index<&usize>>::index(move _326, _696) -> [return: bb163, unwind: bb404];
    }

    bb163: {
        _324 = &((*_325).2: std::cell::Cell<std::option::Option<&std::collections::HashMap<usize, VM<'_>>>>);
        _328 = &_310;
        _327 = Option::<&HashMap<usize, VM<'_>>>::Some(_328);
        _323 = Cell::<Option<&HashMap<usize, VM<'_>>>>::set(move _324, move _327) -> [return: bb164, unwind: bb404];
    }

    bb164: {
        _330 = &_1;
        _329 = <ContextData as Clone>::clone(move _330) -> [return: bb165, unwind: bb404];
    }

    bb165: {
        (_329.5: u32) = const 70_u32;
        _333 = (_329.6: bool);
        _332 = Not(move _333);
        _331 = Not(move _332);
        switchInt(move _331) -> [0: bb167, otherwise: bb166];
    }

    bb166: {
        _334 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb404;
    }

    bb167: {
        _338 = &_310;
        _695 = const _;
        _337 = <HashMap<usize, VM<'_>> as Index<&usize>>::index(move _338, _695) -> [return: bb168, unwind: bb404];
    }

    bb168: {
        _336 = _337;
        _339 = &mut _329;
        _335 = <VM<'_> as Children<'_>>::descend_into_self::<ContextData>(move _336, _339) -> [return: bb169, unwind: bb404];
    }

    bb169: {
        _341 = (_329.6: bool);
        _340 = Not(move _341);
        switchInt(move _340) -> [0: bb171, otherwise: bb170];
    }

    bb170: {
        _342 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb404;
    }

    bb171: {
        _343 = const _;
        switchInt(move _343) -> [0: bb174, otherwise: bb172];
    }

    bb172: {
        _694 = const _;
        _346 = _694 as &[&str] (Pointer(Unsize));
        _345 = Arguments::<'_>::new_const(move _346) -> [return: bb173, unwind: bb404];
    }

    bb173: {
        _344 = _print(move _345) -> [return: bb450, unwind: bb404];
    }

    bb174: {
        _347 = LinkedList::<LL<'_>>::new() -> [return: bb175, unwind: bb404];
    }

    bb175: {
        _349 = &mut _347;
        _350 = <LL<'_> as Named>::new(const "ll0") -> [return: bb176, unwind: bb403];
    }

    bb176: {
        _348 = LinkedList::<LL<'_>>::push_back(move _349, move _350) -> [return: bb177, unwind: bb403];
    }

    bb177: {
        _352 = &mut _347;
        _353 = <LL<'_> as Named>::new(const "ll1") -> [return: bb178, unwind: bb403];
    }

    bb178: {
        _351 = LinkedList::<LL<'_>>::push_back(move _352, move _353) -> [return: bb179, unwind: bb403];
    }

    bb179: {
        _355 = &_347;
        _354 = <&LinkedList<LL<'_>> as IntoIterator>::into_iter(move _355) -> [return: bb180, unwind: bb403];
    }

    bb180: {
        _356 = move _354;
        goto -> bb181;
    }

    bb181: {
        _358 = &mut _356;
        _357 = <std::collections::linked_list::Iter<'_, LL<'_>> as Iterator>::next(_358) -> [return: bb182, unwind: bb403];
    }

    bb182: {
        _359 = discriminant(_357);
        switchInt(move _359) -> [0: bb184, 1: bb183, otherwise: bb75];
    }

    bb183: {
        _360 = ((_357 as Some).0: &LL<'_>);
        _362 = &((*_360).2: std::cell::Cell<std::option::Option<&std::collections::LinkedList<LL<'_>>>>);
        _364 = &_347;
        _363 = Option::<&LinkedList<LL<'_>>>::Some(_364);
        _361 = Cell::<Option<&LinkedList<LL<'_>>>>::set(move _362, move _363) -> [return: bb451, unwind: bb403];
    }

    bb184: {
        _366 = &_1;
        _365 = <ContextData as Clone>::clone(move _366) -> [return: bb185, unwind: bb403];
    }

    bb185: {
        (_365.5: u32) = const 80_u32;
        _368 = &_347;
        _367 = <&LinkedList<LL<'_>> as IntoIterator>::into_iter(move _368) -> [return: bb186, unwind: bb403];
    }

    bb186: {
        _369 = move _367;
        goto -> bb187;
    }

    bb187: {
        _371 = &mut _369;
        _370 = <std::collections::linked_list::Iter<'_, LL<'_>> as Iterator>::next(_371) -> [return: bb188, unwind: bb403];
    }

    bb188: {
        _372 = discriminant(_370);
        switchInt(move _372) -> [0: bb190, 1: bb189, otherwise: bb75];
    }

    bb189: {
        _373 = ((_370 as Some).0: &LL<'_>);
        (_365.5: u32) = Add((_365.5: u32), const 1_u32);
        (_365.6: bool) = const false;
        _375 = &mut _365;
        _374 = <LL<'_> as Children<'_>>::descend_into_self::<ContextData>(_373, _375) -> [return: bb191, unwind: bb403];
    }

    bb190: {
        _379 = const _;
        switchInt(move _379) -> [0: bb195, otherwise: bb193];
    }

    bb191: {
        _377 = (_365.6: bool);
        _376 = Not(move _377);
        switchInt(move _376) -> [0: bb187, otherwise: bb192];
    }

    bb192: {
        _378 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb403;
    }

    bb193: {
        _693 = const _;
        _382 = _693 as &[&str] (Pointer(Unsize));
        _381 = Arguments::<'_>::new_const(move _382) -> [return: bb194, unwind: bb403];
    }

    bb194: {
        _380 = _print(move _381) -> [return: bb452, unwind: bb403];
    }

    bb195: {
        _383 = BinaryHeap::<BH<'_>>::new() -> [return: bb196, unwind: bb403];
    }

    bb196: {
        _385 = &mut _383;
        _386 = <BH<'_> as Named>::new(const "bh0") -> [return: bb197, unwind: bb402];
    }

    bb197: {
        _384 = BinaryHeap::<BH<'_>>::push(move _385, move _386) -> [return: bb198, unwind: bb402];
    }

    bb198: {
        _388 = &mut _383;
        _389 = <BH<'_> as Named>::new(const "bh1") -> [return: bb199, unwind: bb402];
    }

    bb199: {
        _387 = BinaryHeap::<BH<'_>>::push(move _388, move _389) -> [return: bb200, unwind: bb402];
    }

    bb200: {
        _392 = &_383;
        _391 = BinaryHeap::<BH<'_>>::iter(move _392) -> [return: bb201, unwind: bb402];
    }

    bb201: {
        _390 = <std::collections::binary_heap::Iter<'_, BH<'_>> as IntoIterator>::into_iter(move _391) -> [return: bb202, unwind: bb402];
    }

    bb202: {
        _393 = move _390;
        goto -> bb203;
    }

    bb203: {
        _395 = &mut _393;
        _394 = <std::collections::binary_heap::Iter<'_, BH<'_>> as Iterator>::next(_395) -> [return: bb204, unwind: bb402];
    }

    bb204: {
        _396 = discriminant(_394);
        switchInt(move _396) -> [0: bb206, 1: bb205, otherwise: bb75];
    }

    bb205: {
        _397 = ((_394 as Some).0: &BH<'_>);
        _399 = &((*_397).2: std::cell::Cell<std::option::Option<&std::collections::BinaryHeap<BH<'_>>>>);
        _401 = &_383;
        _400 = Option::<&BinaryHeap<BH<'_>>>::Some(_401);
        _398 = Cell::<Option<&BinaryHeap<BH<'_>>>>::set(move _399, move _400) -> [return: bb453, unwind: bb402];
    }

    bb206: {
        _403 = &_1;
        _402 = <ContextData as Clone>::clone(move _403) -> [return: bb207, unwind: bb402];
    }

    bb207: {
        (_402.5: u32) = const 90_u32;
        _405 = &_383;
        _404 = <&BinaryHeap<BH<'_>> as IntoIterator>::into_iter(move _405) -> [return: bb208, unwind: bb402];
    }

    bb208: {
        _406 = move _404;
        goto -> bb209;
    }

    bb209: {
        _408 = &mut _406;
        _407 = <std::collections::binary_heap::Iter<'_, BH<'_>> as Iterator>::next(_408) -> [return: bb210, unwind: bb402];
    }

    bb210: {
        _409 = discriminant(_407);
        switchInt(move _409) -> [0: bb212, 1: bb211, otherwise: bb75];
    }

    bb211: {
        _410 = ((_407 as Some).0: &BH<'_>);
        (_402.5: u32) = Add((_402.5: u32), const 1_u32);
        (_402.6: bool) = const false;
        _412 = &mut _402;
        _411 = <BH<'_> as Children<'_>>::descend_into_self::<ContextData>(_410, _412) -> [return: bb213, unwind: bb402];
    }

    bb212: {
        _416 = const _;
        switchInt(move _416) -> [0: bb217, otherwise: bb215];
    }

    bb213: {
        _414 = (_402.6: bool);
        _413 = Not(move _414);
        switchInt(move _413) -> [0: bb209, otherwise: bb214];
    }

    bb214: {
        _415 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb402;
    }

    bb215: {
        _692 = const _;
        _419 = _692 as &[&str] (Pointer(Unsize));
        _418 = Arguments::<'_>::new_const(move _419) -> [return: bb216, unwind: bb402];
    }

    bb216: {
        _417 = _print(move _418) -> [return: bb454, unwind: bb402];
    }

    bb217: {
        _420 = BTreeMap::<BTM<'_>, BTM<'_>>::new() -> [return: bb218, unwind: bb402];
    }

    bb218: {
        _422 = &mut _420;
        _423 = <BTM<'_> as Named>::new(const "btk0") -> [return: bb219, unwind: bb401];
    }

    bb219: {
        _424 = <BTM<'_> as Named>::new(const "btv0") -> [return: bb220, unwind: bb401];
    }

    bb220: {
        _421 = BTreeMap::<BTM<'_>, BTM<'_>>::insert(move _422, move _423, move _424) -> [return: bb221, unwind: bb401];
    }

    bb221: {
        _426 = &mut _420;
        _427 = <BTM<'_> as Named>::new(const "btk1") -> [return: bb222, unwind: bb401];
    }

    bb222: {
        _428 = <BTM<'_> as Named>::new(const "btv1") -> [return: bb223, unwind: bb401];
    }

    bb223: {
        _425 = BTreeMap::<BTM<'_>, BTM<'_>>::insert(move _426, move _427, move _428) -> [return: bb224, unwind: bb401];
    }

    bb224: {
        _431 = &_420;
        _430 = BTreeMap::<BTM<'_>, BTM<'_>>::iter(move _431) -> [return: bb225, unwind: bb401];
    }

    bb225: {
        _429 = <std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>> as IntoIterator>::into_iter(move _430) -> [return: bb226, unwind: bb401];
    }

    bb226: {
        _432 = move _429;
        goto -> bb227;
    }

    bb227: {
        _434 = &mut _432;
        _433 = <std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>> as Iterator>::next(_434) -> [return: bb228, unwind: bb401];
    }

    bb228: {
        _435 = discriminant(_433);
        switchInt(move _435) -> [0: bb230, 1: bb229, otherwise: bb75];
    }

    bb229: {
        _436 = (((_433 as Some).0: (&BTM<'_>, &BTM<'_>)).0: &BTM<'_>);
        _437 = (((_433 as Some).0: (&BTM<'_>, &BTM<'_>)).1: &BTM<'_>);
        _439 = &((*_436).2: std::cell::Cell<std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>>);
        _441 = &_420;
        _440 = Option::<&BTreeMap<BTM<'_>, BTM<'_>>>::Some(_441);
        _438 = Cell::<Option<&BTreeMap<BTM<'_>, BTM<'_>>>>::set(move _439, move _440) -> [return: bb231, unwind: bb401];
    }

    bb230: {
        _447 = &_1;
        _446 = <ContextData as Clone>::clone(move _447) -> [return: bb232, unwind: bb401];
    }

    bb231: {
        _443 = &((*_437).2: std::cell::Cell<std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>>);
        _445 = &_420;
        _444 = Option::<&BTreeMap<BTM<'_>, BTM<'_>>>::Some(_445);
        _442 = Cell::<Option<&BTreeMap<BTM<'_>, BTM<'_>>>>::set(move _443, move _444) -> [return: bb455, unwind: bb401];
    }

    bb232: {
        (_446.5: u32) = const 100_u32;
        _449 = &_420;
        _448 = <&BTreeMap<BTM<'_>, BTM<'_>> as IntoIterator>::into_iter(move _449) -> [return: bb233, unwind: bb401];
    }

    bb233: {
        _450 = move _448;
        goto -> bb234;
    }

    bb234: {
        _452 = &mut _450;
        _451 = <std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>> as Iterator>::next(_452) -> [return: bb235, unwind: bb401];
    }

    bb235: {
        _453 = discriminant(_451);
        switchInt(move _453) -> [0: bb237, 1: bb236, otherwise: bb75];
    }

    bb236: {
        _454 = (((_451 as Some).0: (&BTM<'_>, &BTM<'_>)).0: &BTM<'_>);
        (_446.5: u32) = Add((_446.5: u32), const 1_u32);
        (_446.6: bool) = const false;
        _456 = &mut _446;
        _455 = <BTM<'_> as Children<'_>>::descend_into_self::<ContextData>(_454, _456) -> [return: bb238, unwind: bb401];
    }

    bb237: {
        _460 = const _;
        switchInt(move _460) -> [0: bb242, otherwise: bb240];
    }

    bb238: {
        _458 = (_446.6: bool);
        _457 = Not(move _458);
        switchInt(move _457) -> [0: bb234, otherwise: bb239];
    }

    bb239: {
        _459 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb401;
    }

    bb240: {
        _691 = const _;
        _463 = _691 as &[&str] (Pointer(Unsize));
        _462 = Arguments::<'_>::new_const(move _463) -> [return: bb241, unwind: bb401];
    }

    bb241: {
        _461 = _print(move _462) -> [return: bb456, unwind: bb401];
    }

    bb242: {
        _464 = BTreeSet::<BTS<'_>>::new() -> [return: bb243, unwind: bb401];
    }

    bb243: {
        _466 = &mut _464;
        _467 = <BTS<'_> as Named>::new(const "bts0") -> [return: bb244, unwind: bb400];
    }

    bb244: {
        _465 = BTreeSet::<BTS<'_>>::insert(move _466, move _467) -> [return: bb245, unwind: bb400];
    }

    bb245: {
        _469 = &mut _464;
        _470 = <BTS<'_> as Named>::new(const "bts1") -> [return: bb246, unwind: bb400];
    }

    bb246: {
        _468 = BTreeSet::<BTS<'_>>::insert(move _469, move _470) -> [return: bb247, unwind: bb400];
    }

    bb247: {
        _473 = &_464;
        _472 = BTreeSet::<BTS<'_>>::iter(move _473) -> [return: bb248, unwind: bb400];
    }

    bb248: {
        _471 = <std::collections::btree_set::Iter<'_, BTS<'_>> as IntoIterator>::into_iter(move _472) -> [return: bb249, unwind: bb400];
    }

    bb249: {
        _474 = move _471;
        goto -> bb250;
    }

    bb250: {
        _476 = &mut _474;
        _475 = <std::collections::btree_set::Iter<'_, BTS<'_>> as Iterator>::next(_476) -> [return: bb251, unwind: bb400];
    }

    bb251: {
        _477 = discriminant(_475);
        switchInt(move _477) -> [0: bb253, 1: bb252, otherwise: bb75];
    }

    bb252: {
        _478 = ((_475 as Some).0: &BTS<'_>);
        _480 = &((*_478).2: std::cell::Cell<std::option::Option<&std::collections::BTreeSet<BTS<'_>>>>);
        _482 = &_464;
        _481 = Option::<&BTreeSet<BTS<'_>>>::Some(_482);
        _479 = Cell::<Option<&BTreeSet<BTS<'_>>>>::set(move _480, move _481) -> [return: bb457, unwind: bb400];
    }

    bb253: {
        _484 = &_1;
        _483 = <ContextData as Clone>::clone(move _484) -> [return: bb254, unwind: bb400];
    }

    bb254: {
        (_483.5: u32) = const 100_u32;
        _486 = &_464;
        _485 = <&BTreeSet<BTS<'_>> as IntoIterator>::into_iter(move _486) -> [return: bb255, unwind: bb400];
    }

    bb255: {
        _487 = move _485;
        goto -> bb256;
    }

    bb256: {
        _489 = &mut _487;
        _488 = <std::collections::btree_set::Iter<'_, BTS<'_>> as Iterator>::next(_489) -> [return: bb257, unwind: bb400];
    }

    bb257: {
        _490 = discriminant(_488);
        switchInt(move _490) -> [0: bb259, 1: bb258, otherwise: bb75];
    }

    bb258: {
        _491 = ((_488 as Some).0: &BTS<'_>);
        (_483.5: u32) = Add((_483.5: u32), const 1_u32);
        (_483.6: bool) = const false;
        _493 = &mut _483;
        _492 = <BTS<'_> as Children<'_>>::descend_into_self::<ContextData>(_491, _493) -> [return: bb260, unwind: bb400];
    }

    bb259: {
        _497 = const _;
        switchInt(move _497) -> [0: bb264, otherwise: bb262];
    }

    bb260: {
        _495 = (_483.6: bool);
        _494 = Not(move _495);
        switchInt(move _494) -> [0: bb256, otherwise: bb261];
    }

    bb261: {
        _496 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb400;
    }

    bb262: {
        _690 = const _;
        _500 = _690 as &[&str] (Pointer(Unsize));
        _499 = Arguments::<'_>::new_const(move _500) -> [return: bb263, unwind: bb400];
    }

    bb263: {
        _498 = _print(move _499) -> [return: bb458, unwind: bb400];
    }

    bb264: {
        _504 = <RCRC<'_> as Named>::new(const "rcrc0") -> [return: bb265, unwind: bb432];
    }

    bb265: {
        _716 = const true;
        _501 = move _504;
        _505 = <RCRC<'_> as Named>::new(const "rcrc1") -> [return: bb266, unwind: bb432];
    }

    bb266: {
        _715 = const true;
        _502 = move _505;
        _506 = <RCRC<'_> as Named>::new(const "rcrc2") -> [return: bb267, unwind: bb432];
    }

    bb267: {
        _714 = const true;
        _503 = move _506;
        _508 = &_502;
        _507 = Option::<&RCRC<'_>>::Some(_508);
        _514 = &(_501.0: std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>);
        _513 = <Rc<RefCell<RCRCData<'_>>> as Deref>::deref(move _514) -> [return: bb268, unwind: bb432];
    }

    bb268: {
        _512 = _513;
        _511 = RefCell::<RCRCData<'_>>::borrow_mut(move _512) -> [return: bb269, unwind: bb432];
    }

    bb269: {
        _510 = &mut _511;
        _509 = <RefMut<'_, RCRCData<'_>> as DerefMut>::deref_mut(move _510) -> [return: bb270, unwind: bb399];
    }

    bb270: {
        (((*_509).2: (std::option::Option<&RCRC<'_>>, std::option::Option<&RCRC<'_>>)).0: std::option::Option<&RCRC<'_>>) = move _507;
        drop(_511) -> [return: bb271, unwind: bb432];
    }

    bb271: {
        _516 = &_503;
        _515 = Option::<&RCRC<'_>>::Some(_516);
        _522 = &(_501.0: std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>);
        _521 = <Rc<RefCell<RCRCData<'_>>> as Deref>::deref(move _522) -> [return: bb272, unwind: bb432];
    }

    bb272: {
        _520 = _521;
        _519 = RefCell::<RCRCData<'_>>::borrow_mut(move _520) -> [return: bb273, unwind: bb432];
    }

    bb273: {
        _518 = &mut _519;
        _517 = <RefMut<'_, RCRCData<'_>> as DerefMut>::deref_mut(move _518) -> [return: bb274, unwind: bb398];
    }

    bb274: {
        (((*_517).2: (std::option::Option<&RCRC<'_>>, std::option::Option<&RCRC<'_>>)).1: std::option::Option<&RCRC<'_>>) = move _515;
        drop(_519) -> [return: bb275, unwind: bb432];
    }

    bb275: {
        _524 = &_501;
        _523 = Option::<&RCRC<'_>>::Some(_524);
        _530 = &(_503.0: std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>);
        _529 = <Rc<RefCell<RCRCData<'_>>> as Deref>::deref(move _530) -> [return: bb276, unwind: bb432];
    }

    bb276: {
        _528 = _529;
        _527 = RefCell::<RCRCData<'_>>::borrow_mut(move _528) -> [return: bb277, unwind: bb432];
    }

    bb277: {
        _526 = &mut _527;
        _525 = <RefMut<'_, RCRCData<'_>> as DerefMut>::deref_mut(move _526) -> [return: bb278, unwind: bb397];
    }

    bb278: {
        (((*_525).2: (std::option::Option<&RCRC<'_>>, std::option::Option<&RCRC<'_>>)).0: std::option::Option<&RCRC<'_>>) = move _523;
        drop(_527) -> [return: bb279, unwind: bb432];
    }

    bb279: {
        _532 = &_1;
        _531 = <ContextData as Clone>::clone(move _532) -> [return: bb280, unwind: bb432];
    }

    bb280: {
        (_531.7: u64) = const 1_u64;
        (_531.5: u32) = const 110_u32;
        _535 = (_531.6: bool);
        _534 = Not(move _535);
        _533 = Not(move _534);
        switchInt(move _533) -> [0: bb282, otherwise: bb281];
    }

    bb281: {
        _536 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb432;
    }

    bb282: {
        _538 = &_501;
        _539 = &mut _531;
        _537 = <RCRC<'_> as Children<'_>>::descend_into_self::<ContextData>(move _538, _539) -> [return: bb283, unwind: bb432];
    }

    bb283: {
        _541 = (_531.6: bool);
        _540 = Not(move _541);
        switchInt(move _540) -> [0: bb285, otherwise: bb284];
    }

    bb284: {
        _542 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb432;
    }

    bb285: {
        _543 = const _;
        switchInt(move _543) -> [0: bb288, otherwise: bb286];
    }

    bb286: {
        _689 = const _;
        _546 = _689 as &[&str] (Pointer(Unsize));
        _545 = Arguments::<'_>::new_const(move _546) -> [return: bb287, unwind: bb432];
    }

    bb287: {
        _544 = _print(move _545) -> [return: bb459, unwind: bb432];
    }

    bb288: {
        _550 = <ARCRC<'_> as Named>::new(const "arcrc0") -> [return: bb289, unwind: bb426];
    }

    bb289: {
        _713 = const true;
        _547 = move _550;
        _551 = <ARCRC<'_> as Named>::new(const "arcrc1") -> [return: bb290, unwind: bb426];
    }

    bb290: {
        _712 = const true;
        _548 = move _551;
        _552 = <ARCRC<'_> as Named>::new(const "arcrc2") -> [return: bb291, unwind: bb426];
    }

    bb291: {
        _711 = const true;
        _549 = move _552;
        _554 = &_548;
        _553 = Option::<&ARCRC<'_>>::Some(_554);
        _560 = &(_547.0: std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>);
        _559 = <Arc<RefCell<ARCRCData<'_>>> as Deref>::deref(move _560) -> [return: bb292, unwind: bb426];
    }

    bb292: {
        _558 = _559;
        _557 = RefCell::<ARCRCData<'_>>::borrow_mut(move _558) -> [return: bb293, unwind: bb426];
    }

    bb293: {
        _556 = &mut _557;
        _555 = <RefMut<'_, ARCRCData<'_>> as DerefMut>::deref_mut(move _556) -> [return: bb294, unwind: bb396];
    }

    bb294: {
        (((*_555).2: (std::option::Option<&ARCRC<'_>>, std::option::Option<&ARCRC<'_>>)).0: std::option::Option<&ARCRC<'_>>) = move _553;
        drop(_557) -> [return: bb295, unwind: bb426];
    }

    bb295: {
        _562 = &_549;
        _561 = Option::<&ARCRC<'_>>::Some(_562);
        _568 = &(_547.0: std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>);
        _567 = <Arc<RefCell<ARCRCData<'_>>> as Deref>::deref(move _568) -> [return: bb296, unwind: bb426];
    }

    bb296: {
        _566 = _567;
        _565 = RefCell::<ARCRCData<'_>>::borrow_mut(move _566) -> [return: bb297, unwind: bb426];
    }

    bb297: {
        _564 = &mut _565;
        _563 = <RefMut<'_, ARCRCData<'_>> as DerefMut>::deref_mut(move _564) -> [return: bb298, unwind: bb395];
    }

    bb298: {
        (((*_563).2: (std::option::Option<&ARCRC<'_>>, std::option::Option<&ARCRC<'_>>)).1: std::option::Option<&ARCRC<'_>>) = move _561;
        drop(_565) -> [return: bb299, unwind: bb426];
    }

    bb299: {
        _570 = &_547;
        _569 = Option::<&ARCRC<'_>>::Some(_570);
        _576 = &(_549.0: std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>);
        _575 = <Arc<RefCell<ARCRCData<'_>>> as Deref>::deref(move _576) -> [return: bb300, unwind: bb426];
    }

    bb300: {
        _574 = _575;
        _573 = RefCell::<ARCRCData<'_>>::borrow_mut(move _574) -> [return: bb301, unwind: bb426];
    }

    bb301: {
        _572 = &mut _573;
        _571 = <RefMut<'_, ARCRCData<'_>> as DerefMut>::deref_mut(move _572) -> [return: bb302, unwind: bb394];
    }

    bb302: {
        (((*_571).2: (std::option::Option<&ARCRC<'_>>, std::option::Option<&ARCRC<'_>>)).0: std::option::Option<&ARCRC<'_>>) = move _569;
        drop(_573) -> [return: bb303, unwind: bb426];
    }

    bb303: {
        _578 = &_1;
        _577 = <ContextData as Clone>::clone(move _578) -> [return: bb304, unwind: bb426];
    }

    bb304: {
        (_577.7: u64) = const 1_u64;
        (_577.5: u32) = const 110_u32;
        _581 = (_577.6: bool);
        _580 = Not(move _581);
        _579 = Not(move _580);
        switchInt(move _579) -> [0: bb306, otherwise: bb305];
    }

    bb305: {
        _582 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb426;
    }

    bb306: {
        _584 = &_547;
        _585 = &mut _577;
        _583 = <ARCRC<'_> as Children<'_>>::descend_into_self::<ContextData>(move _584, _585) -> [return: bb307, unwind: bb426];
    }

    bb307: {
        _587 = (_577.6: bool);
        _586 = Not(move _587);
        switchInt(move _586) -> [0: bb309, otherwise: bb308];
    }

    bb308: {
        _588 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb426;
    }

    bb309: {
        _589 = const _;
        switchInt(move _589) -> [0: bb312, otherwise: bb310];
    }

    bb310: {
        _688 = const _;
        _592 = _688 as &[&str] (Pointer(Unsize));
        _591 = Arguments::<'_>::new_const(move _592) -> [return: bb311, unwind: bb426];
    }

    bb311: {
        _590 = _print(move _591) -> [return: bb460, unwind: bb426];
    }

    bb312: {
        _596 = <ARCRW<'_> as Named>::new(const "arcrw0") -> [return: bb313, unwind: bb420];
    }

    bb313: {
        _710 = const true;
        _593 = move _596;
        _597 = <ARCRW<'_> as Named>::new(const "arcrw1") -> [return: bb314, unwind: bb420];
    }

    bb314: {
        _709 = const true;
        _594 = move _597;
        _598 = <ARCRW<'_> as Named>::new(const "arcrw2") -> [return: bb315, unwind: bb420];
    }

    bb315: {
        _708 = const true;
        _595 = move _598;
        _600 = &_594;
        _599 = Option::<&ARCRW<'_>>::Some(_600);
        _607 = &(_593.0: std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>);
        _606 = <Arc<RwLock<ARCRWData<'_>>> as Deref>::deref(move _607) -> [return: bb316, unwind: bb420];
    }

    bb316: {
        _605 = _606;
        _604 = RwLock::<ARCRWData<'_>>::write(move _605) -> [return: bb317, unwind: bb420];
    }

    bb317: {
        _603 = Result::<RwLockWriteGuard<'_, ARCRWData<'_>>, PoisonError<RwLockWriteGuard<'_, ARCRWData<'_>>>>::unwrap(move _604) -> [return: bb318, unwind: bb420];
    }

    bb318: {
        _602 = &mut _603;
        _601 = <RwLockWriteGuard<'_, ARCRWData<'_>> as DerefMut>::deref_mut(move _602) -> [return: bb319, unwind: bb393];
    }

    bb319: {
        (((*_601).2: (std::option::Option<&ARCRW<'_>>, std::option::Option<&ARCRW<'_>>)).0: std::option::Option<&ARCRW<'_>>) = move _599;
        drop(_603) -> [return: bb320, unwind: bb420];
    }

    bb320: {
        _609 = &_595;
        _608 = Option::<&ARCRW<'_>>::Some(_609);
        _616 = &(_593.0: std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>);
        _615 = <Arc<RwLock<ARCRWData<'_>>> as Deref>::deref(move _616) -> [return: bb321, unwind: bb420];
    }

    bb321: {
        _614 = _615;
        _613 = RwLock::<ARCRWData<'_>>::write(move _614) -> [return: bb322, unwind: bb420];
    }

    bb322: {
        _612 = Result::<RwLockWriteGuard<'_, ARCRWData<'_>>, PoisonError<RwLockWriteGuard<'_, ARCRWData<'_>>>>::unwrap(move _613) -> [return: bb323, unwind: bb420];
    }

    bb323: {
        _611 = &mut _612;
        _610 = <RwLockWriteGuard<'_, ARCRWData<'_>> as DerefMut>::deref_mut(move _611) -> [return: bb324, unwind: bb392];
    }

    bb324: {
        (((*_610).2: (std::option::Option<&ARCRW<'_>>, std::option::Option<&ARCRW<'_>>)).1: std::option::Option<&ARCRW<'_>>) = move _608;
        drop(_612) -> [return: bb325, unwind: bb420];
    }

    bb325: {
        _618 = &_593;
        _617 = Option::<&ARCRW<'_>>::Some(_618);
        _625 = &(_595.0: std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>);
        _624 = <Arc<RwLock<ARCRWData<'_>>> as Deref>::deref(move _625) -> [return: bb326, unwind: bb420];
    }

    bb326: {
        _623 = _624;
        _622 = RwLock::<ARCRWData<'_>>::write(move _623) -> [return: bb327, unwind: bb420];
    }

    bb327: {
        _621 = Result::<RwLockWriteGuard<'_, ARCRWData<'_>>, PoisonError<RwLockWriteGuard<'_, ARCRWData<'_>>>>::unwrap(move _622) -> [return: bb328, unwind: bb420];
    }

    bb328: {
        _620 = &mut _621;
        _619 = <RwLockWriteGuard<'_, ARCRWData<'_>> as DerefMut>::deref_mut(move _620) -> [return: bb329, unwind: bb391];
    }

    bb329: {
        (((*_619).2: (std::option::Option<&ARCRW<'_>>, std::option::Option<&ARCRW<'_>>)).0: std::option::Option<&ARCRW<'_>>) = move _617;
        drop(_621) -> [return: bb330, unwind: bb420];
    }

    bb330: {
        _627 = &_1;
        _626 = <ContextData as Clone>::clone(move _627) -> [return: bb331, unwind: bb420];
    }

    bb331: {
        (_626.7: u64) = const 1_u64;
        (_626.5: u32) = const 110_u32;
        _630 = (_626.6: bool);
        _629 = Not(move _630);
        _628 = Not(move _629);
        switchInt(move _628) -> [0: bb333, otherwise: bb332];
    }

    bb332: {
        _631 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb420;
    }

    bb333: {
        _633 = &_593;
        _634 = &mut _626;
        _632 = <ARCRW<'_> as Children<'_>>::descend_into_self::<ContextData>(move _633, _634) -> [return: bb334, unwind: bb420];
    }

    bb334: {
        _636 = (_626.6: bool);
        _635 = Not(move _636);
        switchInt(move _635) -> [0: bb336, otherwise: bb335];
    }

    bb335: {
        _637 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb420;
    }

    bb336: {
        _638 = const _;
        switchInt(move _638) -> [0: bb339, otherwise: bb337];
    }

    bb337: {
        _687 = const _;
        _641 = _687 as &[&str] (Pointer(Unsize));
        _640 = Arguments::<'_>::new_const(move _641) -> [return: bb338, unwind: bb420];
    }

    bb338: {
        _639 = _print(move _640) -> [return: bb461, unwind: bb420];
    }

    bb339: {
        _645 = <ARCM<'_> as Named>::new(const "arcm0") -> [return: bb340, unwind: bb414];
    }

    bb340: {
        _707 = const true;
        _642 = move _645;
        _646 = <ARCM<'_> as Named>::new(const "arcm1") -> [return: bb341, unwind: bb414];
    }

    bb341: {
        _706 = const true;
        _643 = move _646;
        _647 = <ARCM<'_> as Named>::new(const "arcm2") -> [return: bb342, unwind: bb414];
    }

    bb342: {
        _705 = const true;
        _644 = move _647;
        _649 = &_643;
        _648 = Option::<&ARCM<'_>>::Some(_649);
        _656 = &(_642.1: std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>);
        _655 = <Arc<Mutex<ARCMData<'_>>> as Deref>::deref(move _656) -> [return: bb343, unwind: bb414];
    }

    bb343: {
        _654 = _655;
        _653 = Mutex::<ARCMData<'_>>::lock(move _654) -> [return: bb344, unwind: bb414];
    }

    bb344: {
        _652 = Result::<MutexGuard<'_, ARCMData<'_>>, PoisonError<MutexGuard<'_, ARCMData<'_>>>>::unwrap(move _653) -> [return: bb345, unwind: bb414];
    }

    bb345: {
        _651 = &mut _652;
        _650 = <MutexGuard<'_, ARCMData<'_>> as DerefMut>::deref_mut(move _651) -> [return: bb346, unwind: bb390];
    }

    bb346: {
        (((*_650).1: (std::option::Option<&ARCM<'_>>, std::option::Option<&ARCM<'_>>)).0: std::option::Option<&ARCM<'_>>) = move _648;
        drop(_652) -> [return: bb347, unwind: bb414];
    }

    bb347: {
        _658 = &_644;
        _657 = Option::<&ARCM<'_>>::Some(_658);
        _665 = &(_642.1: std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>);
        _664 = <Arc<Mutex<ARCMData<'_>>> as Deref>::deref(move _665) -> [return: bb348, unwind: bb414];
    }

    bb348: {
        _663 = _664;
        _662 = Mutex::<ARCMData<'_>>::lock(move _663) -> [return: bb349, unwind: bb414];
    }

    bb349: {
        _661 = Result::<MutexGuard<'_, ARCMData<'_>>, PoisonError<MutexGuard<'_, ARCMData<'_>>>>::unwrap(move _662) -> [return: bb350, unwind: bb414];
    }

    bb350: {
        _660 = &mut _661;
        _659 = <MutexGuard<'_, ARCMData<'_>> as DerefMut>::deref_mut(move _660) -> [return: bb351, unwind: bb389];
    }

    bb351: {
        (((*_659).1: (std::option::Option<&ARCM<'_>>, std::option::Option<&ARCM<'_>>)).1: std::option::Option<&ARCM<'_>>) = move _657;
        drop(_661) -> [return: bb352, unwind: bb414];
    }

    bb352: {
        _667 = &_642;
        _666 = Option::<&ARCM<'_>>::Some(_667);
        _674 = &(_644.1: std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>);
        _673 = <Arc<Mutex<ARCMData<'_>>> as Deref>::deref(move _674) -> [return: bb353, unwind: bb414];
    }

    bb353: {
        _672 = _673;
        _671 = Mutex::<ARCMData<'_>>::lock(move _672) -> [return: bb354, unwind: bb414];
    }

    bb354: {
        _670 = Result::<MutexGuard<'_, ARCMData<'_>>, PoisonError<MutexGuard<'_, ARCMData<'_>>>>::unwrap(move _671) -> [return: bb355, unwind: bb414];
    }

    bb355: {
        _669 = &mut _670;
        _668 = <MutexGuard<'_, ARCMData<'_>> as DerefMut>::deref_mut(move _669) -> [return: bb356, unwind: bb388];
    }

    bb356: {
        (((*_668).1: (std::option::Option<&ARCM<'_>>, std::option::Option<&ARCM<'_>>)).0: std::option::Option<&ARCM<'_>>) = move _666;
        drop(_670) -> [return: bb357, unwind: bb414];
    }

    bb357: {
        _676 = &_1;
        _675 = <ContextData as Clone>::clone(move _676) -> [return: bb358, unwind: bb414];
    }

    bb358: {
        (_675.7: u64) = const 1_u64;
        (_675.5: u32) = const 110_u32;
        _679 = (_675.6: bool);
        _678 = Not(move _679);
        _677 = Not(move _678);
        switchInt(move _677) -> [0: bb360, otherwise: bb359];
    }

    bb359: {
        _680 = core::panicking::panic(const "assertion failed: !c.saw_prev_marked") -> bb414;
    }

    bb360: {
        _682 = &_642;
        _683 = &mut _675;
        _681 = <ARCM<'_> as Children<'_>>::descend_into_self::<ContextData>(move _682, _683) -> [return: bb361, unwind: bb414];
    }

    bb361: {
        _685 = (_675.6: bool);
        _684 = Not(move _685);
        switchInt(move _684) -> [0: bb363, otherwise: bb362];
    }

    bb362: {
        _686 = core::panicking::panic(const "assertion failed: c.saw_prev_marked") -> bb414;
    }

    bb363: {
        drop(_644) -> [return: bb364, unwind: bb416];
    }

    bb364: {
        _705 = const false;
        drop(_643) -> [return: bb365, unwind: bb418];
    }

    bb365: {
        _706 = const false;
        drop(_642) -> [return: bb366, unwind: bb420];
    }

    bb366: {
        _707 = const false;
        drop(_595) -> [return: bb367, unwind: bb422];
    }

    bb367: {
        _708 = const false;
        drop(_594) -> [return: bb368, unwind: bb424];
    }

    bb368: {
        _709 = const false;
        drop(_593) -> [return: bb369, unwind: bb426];
    }

    bb369: {
        _710 = const false;
        drop(_549) -> [return: bb370, unwind: bb428];
    }

    bb370: {
        _711 = const false;
        drop(_548) -> [return: bb371, unwind: bb430];
    }

    bb371: {
        _712 = const false;
        drop(_547) -> [return: bb372, unwind: bb432];
    }

    bb372: {
        _713 = const false;
        drop(_503) -> [return: bb373, unwind: bb434];
    }

    bb373: {
        _714 = const false;
        drop(_502) -> [return: bb374, unwind: bb436];
    }

    bb374: {
        _715 = const false;
        drop(_501) -> [return: bb375, unwind: bb400];
    }

    bb375: {
        _716 = const false;
        drop(_464) -> [return: bb376, unwind: bb401];
    }

    bb376: {
        drop(_420) -> [return: bb377, unwind: bb402];
    }

    bb377: {
        drop(_383) -> [return: bb378, unwind: bb403];
    }

    bb378: {
        drop(_347) -> [return: bb379, unwind: bb404];
    }

    bb379: {
        drop(_310) -> [return: bb380, unwind: bb405];
    }

    bb380: {
        drop(_273) -> [return: bb381, unwind: bb406];
    }

    bb381: {
        drop(_232) -> [return: bb382, unwind: bb407];
    }

    bb382: {
        drop(_187) -> [return: bb383, unwind: bb408];
    }

    bb383: {
        drop(_144) -> [return: bb384, unwind: bb409];
    }

    bb384: {
        drop(_115) -> [return: bb385, unwind: bb410];
    }

    bb385: {
        drop(_72) -> [return: bb386, unwind: bb411];
    }

    bb386: {
        drop(_2) -> [return: bb387, unwind continue];
    }

    bb387: {
        return;
    }

    bb388 (cleanup): {
        drop(_670) -> [return: bb414, unwind terminate];
    }

    bb389 (cleanup): {
        drop(_661) -> [return: bb414, unwind terminate];
    }

    bb390 (cleanup): {
        drop(_652) -> [return: bb414, unwind terminate];
    }

    bb391 (cleanup): {
        drop(_621) -> [return: bb420, unwind terminate];
    }

    bb392 (cleanup): {
        drop(_612) -> [return: bb420, unwind terminate];
    }

    bb393 (cleanup): {
        drop(_603) -> [return: bb420, unwind terminate];
    }

    bb394 (cleanup): {
        drop(_573) -> [return: bb426, unwind terminate];
    }

    bb395 (cleanup): {
        drop(_565) -> [return: bb426, unwind terminate];
    }

    bb396 (cleanup): {
        drop(_557) -> [return: bb426, unwind terminate];
    }

    bb397 (cleanup): {
        drop(_527) -> [return: bb432, unwind terminate];
    }

    bb398 (cleanup): {
        drop(_519) -> [return: bb432, unwind terminate];
    }

    bb399 (cleanup): {
        drop(_511) -> [return: bb432, unwind terminate];
    }

    bb400 (cleanup): {
        drop(_464) -> [return: bb401, unwind terminate];
    }

    bb401 (cleanup): {
        drop(_420) -> [return: bb402, unwind terminate];
    }

    bb402 (cleanup): {
        drop(_383) -> [return: bb403, unwind terminate];
    }

    bb403 (cleanup): {
        drop(_347) -> [return: bb404, unwind terminate];
    }

    bb404 (cleanup): {
        drop(_310) -> [return: bb405, unwind terminate];
    }

    bb405 (cleanup): {
        drop(_273) -> [return: bb406, unwind terminate];
    }

    bb406 (cleanup): {
        drop(_232) -> [return: bb407, unwind terminate];
    }

    bb407 (cleanup): {
        drop(_187) -> [return: bb408, unwind terminate];
    }

    bb408 (cleanup): {
        drop(_144) -> [return: bb409, unwind terminate];
    }

    bb409 (cleanup): {
        drop(_115) -> [return: bb410, unwind terminate];
    }

    bb410 (cleanup): {
        drop(_72) -> [return: bb411, unwind terminate];
    }

    bb411 (cleanup): {
        drop(_2) -> [return: bb412, unwind terminate];
    }

    bb412 (cleanup): {
        resume;
    }

    bb413 (cleanup): {
        drop(_644) -> [return: bb416, unwind terminate];
    }

    bb414 (cleanup): {
        switchInt(_705) -> [0: bb416, otherwise: bb413];
    }

    bb415 (cleanup): {
        drop(_643) -> [return: bb418, unwind terminate];
    }

    bb416 (cleanup): {
        switchInt(_706) -> [0: bb418, otherwise: bb415];
    }

    bb417 (cleanup): {
        drop(_642) -> [return: bb420, unwind terminate];
    }

    bb418 (cleanup): {
        switchInt(_707) -> [0: bb420, otherwise: bb417];
    }

    bb419 (cleanup): {
        drop(_595) -> [return: bb422, unwind terminate];
    }

    bb420 (cleanup): {
        switchInt(_708) -> [0: bb422, otherwise: bb419];
    }

    bb421 (cleanup): {
        drop(_594) -> [return: bb424, unwind terminate];
    }

    bb422 (cleanup): {
        switchInt(_709) -> [0: bb424, otherwise: bb421];
    }

    bb423 (cleanup): {
        drop(_593) -> [return: bb426, unwind terminate];
    }

    bb424 (cleanup): {
        switchInt(_710) -> [0: bb426, otherwise: bb423];
    }

    bb425 (cleanup): {
        drop(_549) -> [return: bb428, unwind terminate];
    }

    bb426 (cleanup): {
        switchInt(_711) -> [0: bb428, otherwise: bb425];
    }

    bb427 (cleanup): {
        drop(_548) -> [return: bb430, unwind terminate];
    }

    bb428 (cleanup): {
        switchInt(_712) -> [0: bb430, otherwise: bb427];
    }

    bb429 (cleanup): {
        drop(_547) -> [return: bb432, unwind terminate];
    }

    bb430 (cleanup): {
        switchInt(_713) -> [0: bb432, otherwise: bb429];
    }

    bb431 (cleanup): {
        drop(_503) -> [return: bb434, unwind terminate];
    }

    bb432 (cleanup): {
        switchInt(_714) -> [0: bb434, otherwise: bb431];
    }

    bb433 (cleanup): {
        drop(_502) -> [return: bb436, unwind terminate];
    }

    bb434 (cleanup): {
        switchInt(_715) -> [0: bb436, otherwise: bb433];
    }

    bb435 (cleanup): {
        drop(_501) -> [return: bb400, unwind terminate];
    }

    bb436 (cleanup): {
        switchInt(_716) -> [0: bb400, otherwise: bb435];
    }

    bb437 (cleanup): {
        _717 = &mut _78;
        _718 = <Box<[S<'_>; 2]> as Drop>::drop(move _717) -> [return: bb462, unwind terminate];
    }

    bb438 (cleanup): {
        _719 = &mut _8;
        _720 = <Box<[S2<'_>; 4]> as Drop>::drop(move _719) -> [return: bb463, unwind terminate];
    }

    bb439: {
        (*_722) = [move _79, move _80];
        _74 = move _78;
        _73 = move _74 as std::boxed::Box<[S<'_>]> (Pointer(Unsize));
        _72 = slice::<impl [S<'_>]>::into_vec::<std::alloc::Global>(move _73) -> [return: bb32, unwind: bb411];
    }

    bb440: {
        (*_721) = [move _9, move _10, move _11, move _12];
        _4 = move _8;
        _3 = move _4 as std::boxed::Box<[S2<'_>]> (Pointer(Unsize));
        _2 = slice::<impl [S2<'_>]>::into_vec::<std::alloc::Global>(move _3) -> [return: bb6, unwind continue];
    }

    bb441: {
        goto -> bb28;
    }

    bb442: {
        goto -> bb48;
    }

    bb443: {
        goto -> bb62;
    }

    bb444: {
        goto -> bb72;
    }

    bb445: {
        goto -> bb89;
    }

    bb446: {
        goto -> bb99;
    }

    bb447: {
        goto -> bb115;
    }

    bb448: {
        goto -> bb136;
    }

    bb449: {
        goto -> bb155;
    }

    bb450: {
        goto -> bb174;
    }

    bb451: {
        goto -> bb181;
    }

    bb452: {
        goto -> bb195;
    }

    bb453: {
        goto -> bb203;
    }

    bb454: {
        goto -> bb217;
    }

    bb455: {
        goto -> bb227;
    }

    bb456: {
        goto -> bb242;
    }

    bb457: {
        goto -> bb250;
    }

    bb458: {
        goto -> bb264;
    }

    bb459: {
        goto -> bb288;
    }

    bb460: {
        goto -> bb312;
    }

    bb461: {
        goto -> bb339;
    }

    bb462 (cleanup): {
        goto -> bb411;
    }

    bb463 (cleanup): {
        goto -> bb412;
    }
}

promoted[0] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[2] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[3] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[4] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[5] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[6] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[7] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[8] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 0_usize;
        _0 = &_1;
        return;
    }
}

promoted[9] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 1_usize;
        _0 = &_1;
        return;
    }
}

promoted[10] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 0_usize;
        _0 = &_1;
        return;
    }
}

promoted[11] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[12] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[13] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[14] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[15] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[16] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[17] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:451:1: 451:25>::new(_1: &str) -> S<'_> {
    debug name => _1;
    let mut _0: S<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::cell::Cell<std::option::Option<&S<'_>>>;
    let mut _4: std::option::Option<&S<'_>>;

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = Option::<&S<'_>>::None;
        _3 = Cell::<Option<&S<'_>>>::new(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = S::<'_> { name: _1, mark: move _2, next: move _3 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:451:1: 451:25>::name(_1: &S<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:458:1: 458:31>::mark(_1: &S<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:458:1: 458:31>::set_mark(_1: &S<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:469:1: 469:26>::new(_1: &str) -> S2<'_> {
    debug name => _1;
    let mut _0: S2<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>;
    let mut _4: (std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>);
    let mut _5: std::option::Option<&S2<'_>>;
    let mut _6: std::option::Option<&S2<'_>>;

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = Option::<&S2<'_>>::None;
        _6 = Option::<&S2<'_>>::None;
        _4 = (move _5, move _6);
        _3 = Cell::<(Option<&S2<'_>>, Option<&S2<'_>>)>::new(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = S2::<'_> { name: _1, mark: move _2, next: move _3 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:469:1: 469:26>::name(_1: &S2<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:476:1: 476:32>::mark(_1: &S2<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:476:1: 476:32>::set_mark(_1: &S2<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:489:1: 489:25>::new(_1: &str) -> V<'_> {
    debug name => _1;
    let mut _0: V<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::vec::Vec<std::cell::Cell<std::option::Option<&V<'_>>>>;
    let mut _4: std::boxed::Box<[std::cell::Cell<std::option::Option<&V<'_>>>]>;
    let mut _5: std::boxed::Box<[std::cell::Cell<std::option::Option<&V<'_>>>; 2]>;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: *mut u8;
    let mut _9: std::boxed::Box<[std::cell::Cell<std::option::Option<&V<'_>>>; 2]>;
    let mut _10: std::cell::Cell<std::option::Option<&V<'_>>>;
    let mut _11: std::option::Option<&V<'_>>;
    let mut _12: std::cell::Cell<std::option::Option<&V<'_>>>;
    let mut _13: std::option::Option<&V<'_>>;
    let mut _14: &mut std::boxed::Box<[std::cell::Cell<std::option::Option<&V<'_>>>; 2]>;
    let mut _15: ();
    let mut _16: *const [std::cell::Cell<std::option::Option<&V<'_>>>; 2];
    let mut _17: *const ();
    let mut _18: usize;
    let mut _19: usize;
    let mut _20: usize;
    let mut _21: usize;
    let mut _22: bool;
    scope 1 {
    }

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = SizeOf([std::cell::Cell<std::option::Option<&V<'_>>>; 2]);
        _7 = AlignOf([std::cell::Cell<std::option::Option<&V<'_>>>; 2]);
        _8 = alloc::alloc::exchange_malloc(move _6, move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = ShallowInitBox(move _8, [std::cell::Cell<std::option::Option<&V<'_>>>; 2]);
        _11 = Option::<&V<'_>>::None;
        _10 = Cell::<Option<&V<'_>>>::new(move _11) -> [return: bb3, unwind: bb7];
    }

    bb3: {
        _13 = Option::<&V<'_>>::None;
        _12 = Cell::<Option<&V<'_>>>::new(move _13) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        _16 = (((_9.0: std::ptr::Unique<[std::cell::Cell<std::option::Option<&V<'_>>>; 2]>).0: std::ptr::NonNull<[std::cell::Cell<std::option::Option<&V<'_>>>; 2]>).0: *const [std::cell::Cell<std::option::Option<&V<'_>>>; 2]);
        _17 = _16 as *const () (PtrToPtr);
        _18 = _17 as usize (Transmute);
        _19 = AlignOf(std::cell::Cell<std::option::Option<&V<'_>>>);
        _20 = Sub(_19, const 1_usize);
        _21 = BitAnd(_18, _20);
        _22 = Eq(_21, const 0_usize);
        assert(_22, "misaligned pointer dereference: address must be a multiple of {} but is {}", _19, _18) -> [success: bb8, unwind unreachable];
    }

    bb5: {
        _0 = V::<'_> { name: _1, mark: move _2, contents: move _3 };
        return;
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        _14 = &mut _9;
        _15 = <Box<[Cell<Option<&V<'_>>>; 2]> as Drop>::drop(move _14) -> [return: bb6, unwind terminate];
    }

    bb8: {
        (*_16) = [move _10, move _12];
        _5 = move _9;
        _4 = move _5 as std::boxed::Box<[std::cell::Cell<std::option::Option<&V<'_>>>]> (Pointer(Unsize));
        _3 = slice::<impl [Cell<Option<&V<'_>>>]>::into_vec::<std::alloc::Global>(move _4) -> [return: bb5, unwind continue];
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:489:1: 489:25>::name(_1: &V<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:499:1: 499:31>::mark(_1: &V<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:499:1: 499:31>::set_mark(_1: &V<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:504:10: 504:12>::assert_receiver_is_total_eq(_1: &H<'_>) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
            scope 3 {
            }
        }
    }

    bb0: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:511:1: 511:25>::new(_1: &str) -> H<'_> {
    debug name => _1;
    let mut _0: H<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::cell::Cell<std::option::Option<&H<'_>>>;
    let mut _4: std::option::Option<&H<'_>>;

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = Option::<&H<'_>>::None;
        _3 = Cell::<Option<&H<'_>>>::new(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = H::<'_> { name: _1, mark: move _2, next: move _3 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:511:1: 511:25>::name(_1: &H<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:518:1: 518:31>::mark(_1: &H<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:518:1: 518:31>::set_mark(_1: &H<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:523:1: 523:29>::eq(_1: &H<'_>, _2: &H<'_>) -> bool {
    debug self => _1;
    debug rhs => _2;
    let mut _0: bool;
    let mut _3: &&str;
    let mut _4: &&str;

    bb0: {
        _3 = &((*_1).0: &str);
        _4 = &((*_2).0: &str);
        _0 = <&str as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:529:1: 529:24>::hash(_1: &H<'_>, _2: &mut H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let mut _3: &str;

    bb0: {
        _3 = deref_copy ((*_1).0: &str);
        _0 = <str as Hash>::hash::<H>(_3, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:535:10: 535:12>::assert_receiver_is_total_eq(_1: &HM<'_>) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
            scope 3 {
            }
        }
    }

    bb0: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:542:1: 542:26>::new(_1: &str) -> HM<'_> {
    debug name => _1;
    let mut _0: HM<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::cell::Cell<std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>>;
    let mut _4: std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>;

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = Option::<&HashMap<HM<'_>, HM<'_>>>::None;
        _3 = Cell::<Option<&HashMap<HM<'_>, HM<'_>>>>::new(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = HM::<'_> { name: _1, mark: move _2, contents: move _3 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:542:1: 542:26>::name(_1: &HM<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:552:1: 552:32>::mark(_1: &HM<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:552:1: 552:32>::set_mark(_1: &HM<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:557:1: 557:30>::eq(_1: &HM<'_>, _2: &HM<'_>) -> bool {
    debug self => _1;
    debug rhs => _2;
    let mut _0: bool;
    let mut _3: &&str;
    let mut _4: &&str;

    bb0: {
        _3 = &((*_1).0: &str);
        _4 = &((*_2).0: &str);
        _0 = <&str as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:563:1: 563:25>::hash(_1: &HM<'_>, _2: &mut H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let mut _3: &str;

    bb0: {
        _3 = deref_copy ((*_1).0: &str);
        _0 = <str as Hash>::hash::<H>(_3, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:576:1: 576:26>::new(_1: &str) -> VD<'_> {
    debug name => _1;
    let mut _0: VD<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::cell::Cell<std::option::Option<&std::collections::VecDeque<VD<'_>>>>;
    let mut _4: std::option::Option<&std::collections::VecDeque<VD<'_>>>;

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = Option::<&VecDeque<VD<'_>>>::None;
        _3 = Cell::<Option<&VecDeque<VD<'_>>>>::new(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = VD::<'_> { name: _1, mark: move _2, contents: move _3 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:576:1: 576:26>::name(_1: &VD<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:586:1: 586:32>::mark(_1: &VD<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:586:1: 586:32>::set_mark(_1: &VD<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:597:1: 597:26>::new(_1: &str) -> VM<'_> {
    debug name => _1;
    let mut _0: VM<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::cell::Cell<std::option::Option<&std::collections::HashMap<usize, VM<'_>>>>;
    let mut _4: std::option::Option<&std::collections::HashMap<usize, VM<'_>>>;

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = Option::<&HashMap<usize, VM<'_>>>::None;
        _3 = Cell::<Option<&HashMap<usize, VM<'_>>>>::new(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = VM::<'_> { name: _1, mark: move _2, contents: move _3 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:597:1: 597:26>::name(_1: &VM<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:607:1: 607:32>::mark(_1: &VM<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:607:1: 607:32>::set_mark(_1: &VM<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:618:1: 618:26>::new(_1: &str) -> LL<'_> {
    debug name => _1;
    let mut _0: LL<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::cell::Cell<std::option::Option<&std::collections::LinkedList<LL<'_>>>>;
    let mut _4: std::option::Option<&std::collections::LinkedList<LL<'_>>>;

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = Option::<&LinkedList<LL<'_>>>::None;
        _3 = Cell::<Option<&LinkedList<LL<'_>>>>::new(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = LL::<'_> { name: _1, mark: move _2, contents: move _3 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:618:1: 618:26>::name(_1: &LL<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:628:1: 628:32>::mark(_1: &LL<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:628:1: 628:32>::set_mark(_1: &LL<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:639:1: 639:26>::new(_1: &str) -> BH<'_> {
    debug name => _1;
    let mut _0: BH<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::cell::Cell<std::option::Option<&std::collections::BinaryHeap<BH<'_>>>>;
    let mut _4: std::option::Option<&std::collections::BinaryHeap<BH<'_>>>;

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = Option::<&BinaryHeap<BH<'_>>>::None;
        _3 = Cell::<Option<&BinaryHeap<BH<'_>>>>::new(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = BH::<'_> { name: _1, mark: move _2, contents: move _3 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:639:1: 639:26>::name(_1: &BH<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:649:1: 649:32>::mark(_1: &BH<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:649:1: 649:32>::set_mark(_1: &BH<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:656:1: 656:30>::eq(_1: &BH<'_>, _2: &BH<'_>) -> bool {
    debug self => _1;
    debug rhs => _2;
    let mut _0: bool;
    let mut _3: &&str;
    let mut _4: &&str;

    bb0: {
        _3 = &((*_1).0: &str);
        _4 = &((*_2).0: &str);
        _0 = <&str as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:662:1: 662:31>::partial_cmp(_1: &BH<'_>, _2: &BH<'_>) -> Option<std::cmp::Ordering> {
    debug self => _1;
    debug rhs => _2;
    let mut _0: std::option::Option<std::cmp::Ordering>;
    let mut _3: std::cmp::Ordering;

    bb0: {
        _3 = <BH<'_> as Ord>::cmp(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Option::<std::cmp::Ordering>::Some(move _3);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:668:1: 668:24>::cmp(_1: &BH<'_>, _2: &BH<'_>) -> std::cmp::Ordering {
    debug self => _1;
    debug rhs => _2;
    let mut _0: std::cmp::Ordering;
    let mut _3: &str;
    let mut _4: &str;

    bb0: {
        _3 = deref_copy ((*_1).0: &str);
        _4 = deref_copy ((*_2).0: &str);
        _0 = <str as Ord>::cmp(_3, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:680:1: 680:27>::new(_1: &str) -> BTM<'_> {
    debug name => _1;
    let mut _0: BTM<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::cell::Cell<std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>>;
    let mut _4: std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>;

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = Option::<&BTreeMap<BTM<'_>, BTM<'_>>>::None;
        _3 = Cell::<Option<&BTreeMap<BTM<'_>, BTM<'_>>>>::new(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = BTM::<'_> { name: _1, mark: move _2, contents: move _3 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:680:1: 680:27>::name(_1: &BTM<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:690:1: 690:33>::mark(_1: &BTM<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:690:1: 690:33>::set_mark(_1: &BTM<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:697:1: 697:31>::eq(_1: &BTM<'_>, _2: &BTM<'_>) -> bool {
    debug self => _1;
    debug rhs => _2;
    let mut _0: bool;
    let mut _3: &&str;
    let mut _4: &&str;

    bb0: {
        _3 = &((*_1).0: &str);
        _4 = &((*_2).0: &str);
        _0 = <&str as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:703:1: 703:32>::partial_cmp(_1: &BTM<'_>, _2: &BTM<'_>) -> Option<std::cmp::Ordering> {
    debug self => _1;
    debug rhs => _2;
    let mut _0: std::option::Option<std::cmp::Ordering>;
    let mut _3: std::cmp::Ordering;

    bb0: {
        _3 = <BTM<'_> as Ord>::cmp(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Option::<std::cmp::Ordering>::Some(move _3);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:709:1: 709:25>::cmp(_1: &BTM<'_>, _2: &BTM<'_>) -> std::cmp::Ordering {
    debug self => _1;
    debug rhs => _2;
    let mut _0: std::cmp::Ordering;
    let mut _3: &str;
    let mut _4: &str;

    bb0: {
        _3 = deref_copy ((*_1).0: &str);
        _4 = deref_copy ((*_2).0: &str);
        _0 = <str as Ord>::cmp(_3, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:721:1: 721:27>::new(_1: &str) -> BTS<'_> {
    debug name => _1;
    let mut _0: BTS<'_>;
    let mut _2: std::cell::Cell<u32>;
    let mut _3: std::cell::Cell<std::option::Option<&std::collections::BTreeSet<BTS<'_>>>>;
    let mut _4: std::option::Option<&std::collections::BTreeSet<BTS<'_>>>;

    bb0: {
        _2 = Cell::<u32>::new(const 0_u32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = Option::<&BTreeSet<BTS<'_>>>::None;
        _3 = Cell::<Option<&BTreeSet<BTS<'_>>>>::new(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = BTS::<'_> { name: _1, mark: move _2, contents: move _3 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:721:1: 721:27>::name(_1: &BTS<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:731:1: 731:33>::mark(_1: &BTS<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;

    bb0: {
        _2 = &((*_1).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:731:1: 731:33>::set_mark(_1: &BTS<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;

    bb0: {
        _4 = &((*_1).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:738:1: 738:31>::eq(_1: &BTS<'_>, _2: &BTS<'_>) -> bool {
    debug self => _1;
    debug rhs => _2;
    let mut _0: bool;
    let mut _3: &&str;
    let mut _4: &&str;

    bb0: {
        _3 = &((*_1).0: &str);
        _4 = &((*_2).0: &str);
        _0 = <&str as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:744:1: 744:32>::partial_cmp(_1: &BTS<'_>, _2: &BTS<'_>) -> Option<std::cmp::Ordering> {
    debug self => _1;
    debug rhs => _2;
    let mut _0: std::option::Option<std::cmp::Ordering>;
    let mut _3: std::cmp::Ordering;

    bb0: {
        _3 = <BTS<'_> as Ord>::cmp(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Option::<std::cmp::Ordering>::Some(move _3);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:750:1: 750:25>::cmp(_1: &BTS<'_>, _2: &BTS<'_>) -> std::cmp::Ordering {
    debug self => _1;
    debug rhs => _2;
    let mut _0: std::cmp::Ordering;
    let mut _3: &str;
    let mut _4: &str;

    bb0: {
        _3 = deref_copy ((*_1).0: &str);
        _4 = deref_copy ((*_2).0: &str);
        _0 = <str as Ord>::cmp(_3, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:756:10: 756:15>::clone(_1: &RCRCData<'_>) -> RCRCData<'_> {
    debug self => _1;
    let mut _0: RCRCData<'_>;
    let mut _2: &str;
    let _3: &str;
    let _4: &&str;
    let mut _5: std::cell::Cell<u32>;
    let _6: &std::cell::Cell<u32>;
    let mut _7: (std::option::Option<&RCRC<'_>>, std::option::Option<&RCRC<'_>>);
    let _8: &(std::option::Option<&RCRC<'_>>, std::option::Option<&RCRC<'_>>);

    bb0: {
        _4 = &((*_1).0: &str);
        _3 = <&str as Clone>::clone(_4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = _3;
        _6 = &((*_1).1: std::cell::Cell<u32>);
        _5 = <Cell<u32> as Clone>::clone(_6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &((*_1).2: (std::option::Option<&RCRC<'_>>, std::option::Option<&RCRC<'_>>));
        _7 = <(Option<&RCRC<'_>>, Option<&RCRC<'_>>) as Clone>::clone(_8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = RCRCData::<'_> { name: move _2, mark: move _5, children: move _7 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:762:10: 762:15>::clone(_1: &RCRC<'_>) -> RCRC<'_> {
    debug self => _1;
    let mut _0: RCRC<'_>;
    let mut _2: std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>;
    let _3: &std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>;

    bb0: {
        _3 = &((*_1).0: std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>);
        _2 = <Rc<RefCell<RCRCData<'_>>> as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = RCRC::<'_>(move _2);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:765:1: 765:28>::new(_1: &str) -> RCRC<'_> {
    debug name => _1;
    let mut _0: RCRC<'_>;
    let mut _2: std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>;
    let mut _3: std::cell::RefCell<RCRCData<'_>>;
    let mut _4: RCRCData<'_>;
    let mut _5: std::cell::Cell<u32>;
    let mut _6: (std::option::Option<&RCRC<'_>>, std::option::Option<&RCRC<'_>>);
    let mut _7: std::option::Option<&RCRC<'_>>;
    let mut _8: std::option::Option<&RCRC<'_>>;

    bb0: {
        _5 = Cell::<u32>::new(const 0_u32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = Option::<&RCRC<'_>>::None;
        _8 = Option::<&RCRC<'_>>::None;
        _6 = (move _7, move _8);
        _4 = RCRCData::<'_> { name: _1, mark: move _5, children: move _6 };
        _3 = RefCell::<RCRCData<'_>>::new(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = Rc::<RefCell<RCRCData<'_>>>::new(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = RCRC::<'_>(move _2);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:765:1: 765:28>::name(_1: &RCRC<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;
    let _2: &RCRCData<'_>;
    let mut _3: &std::cell::Ref<'_, RCRCData<'_>>;
    let _4: std::cell::Ref<'_, RCRCData<'_>>;
    let mut _5: &std::cell::RefCell<RCRCData<'_>>;
    let _6: &std::cell::RefCell<RCRCData<'_>>;
    let mut _7: &std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>;

    bb0: {
        _7 = &((*_1).0: std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>);
        _6 = <Rc<RefCell<RCRCData<'_>>> as Deref>::deref(move _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = _6;
        _4 = RefCell::<RCRCData<'_>>::borrow(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = &_4;
        _2 = <Ref<'_, RCRCData<'_>> as Deref>::deref(move _3) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        _0 = deref_copy ((*_2).0: &str);
        drop(_4) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_4) -> [return: bb6, unwind terminate];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:773:1: 773:34>::mark(_1: &RCRC<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;
    let _3: &RCRCData<'_>;
    let mut _4: &std::cell::Ref<'_, RCRCData<'_>>;
    let _5: std::cell::Ref<'_, RCRCData<'_>>;
    let mut _6: &std::cell::RefCell<RCRCData<'_>>;
    let _7: &std::cell::RefCell<RCRCData<'_>>;
    let mut _8: &std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>;

    bb0: {
        _8 = &((*_1).0: std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>);
        _7 = <Rc<RefCell<RCRCData<'_>>> as Deref>::deref(move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = _7;
        _5 = RefCell::<RCRCData<'_>>::borrow(move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = &_5;
        _3 = <Ref<'_, RCRCData<'_>> as Deref>::deref(move _4) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _2 = &((*_3).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        drop(_5) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_5) -> [return: bb7, unwind terminate];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:773:1: 773:34>::set_mark(_1: &RCRC<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;
    let _5: &RCRCData<'_>;
    let mut _6: &std::cell::Ref<'_, RCRCData<'_>>;
    let _7: std::cell::Ref<'_, RCRCData<'_>>;
    let mut _8: &std::cell::RefCell<RCRCData<'_>>;
    let _9: &std::cell::RefCell<RCRCData<'_>>;
    let mut _10: &std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>;

    bb0: {
        _10 = &((*_1).0: std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>);
        _9 = <Rc<RefCell<RCRCData<'_>>> as Deref>::deref(move _10) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = _9;
        _7 = RefCell::<RCRCData<'_>>::borrow(move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = &_7;
        _5 = <Ref<'_, RCRCData<'_>> as Deref>::deref(move _6) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _4 = &((*_5).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        drop(_7) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_7) -> [return: bb7, unwind terminate];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:778:1: 778:35>::count_children(_1: &RCRC<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:778:1: 778:35>::descend_one_child(_1: &RCRC<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let _4: &(std::option::Option<&RCRC<'_>>, std::option::Option<&RCRC<'_>>);
    let _5: &RCRCData<'_>;
    let mut _6: &std::cell::Ref<'_, RCRCData<'_>>;
    let _7: std::cell::Ref<'_, RCRCData<'_>>;
    let mut _8: &std::cell::RefCell<RCRCData<'_>>;
    let _9: &std::cell::RefCell<RCRCData<'_>>;
    let mut _10: &std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>;
    let mut _12: isize;
    let mut _14: isize;
    let _16: !;
    let _17: ();
    let mut _18: &RCRC<'_>;
    scope 1 {
        debug children => _4;
        let _11: &RCRC<'_>;
        scope 2 {
            debug child => _11;
        }
        scope 3 {
            debug child => _13;
            let _13: &RCRC<'_>;
        }
        scope 4 {
            debug child => _15;
            let _15: &RCRC<'_>;
        }
    }

    bb0: {
        _10 = &((*_1).0: std::rc::Rc<std::cell::RefCell<RCRCData<'_>>>);
        _9 = <Rc<RefCell<RCRCData<'_>>> as Deref>::deref(move _10) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = _9;
        _7 = RefCell::<RCRCData<'_>>::borrow(move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = &_7;
        _5 = <Ref<'_, RCRCData<'_>> as Deref>::deref(move _6) -> [return: bb3, unwind: bb13];
    }

    bb3: {
        _4 = &((*_5).2: (std::option::Option<&RCRC<'_>>, std::option::Option<&RCRC<'_>>));
        switchInt(_3) -> [0: bb5, 1: bb7, otherwise: bb4];
    }

    bb4: {
        _16 = begin_panic::<&str>(const "bad children") -> bb13;
    }

    bb5: {
        _12 = discriminant(((*_4).0: std::option::Option<&RCRC<'_>>));
        switchInt(move _12) -> [1: bb6, otherwise: bb11];
    }

    bb6: {
        _13 = ((((*_4).0: std::option::Option<&RCRC<'_>>) as Some).0: &RCRC<'_>);
        _11 = _13;
        goto -> bb9;
    }

    bb7: {
        _14 = discriminant(((*_4).1: std::option::Option<&RCRC<'_>>));
        switchInt(move _14) -> [1: bb8, otherwise: bb11];
    }

    bb8: {
        _15 = ((((*_4).1: std::option::Option<&RCRC<'_>>) as Some).0: &RCRC<'_>);
        _11 = _15;
        goto -> bb9;
    }

    bb9: {
        _18 = _11;
        _17 = <RCRC<'_> as Children<'_>>::descend_into_self::<C>(move _18, _2) -> [return: bb10, unwind: bb13];
    }

    bb10: {
        drop(_7) -> [return: bb12, unwind continue];
    }

    bb11: {
        drop(_7) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        drop(_7) -> [return: bb14, unwind terminate];
    }

    bb14 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:793:10: 793:15>::clone(_1: &ARCRCData<'_>) -> ARCRCData<'_> {
    debug self => _1;
    let mut _0: ARCRCData<'_>;
    let mut _2: &str;
    let _3: &str;
    let _4: &&str;
    let mut _5: std::cell::Cell<u32>;
    let _6: &std::cell::Cell<u32>;
    let mut _7: (std::option::Option<&ARCRC<'_>>, std::option::Option<&ARCRC<'_>>);
    let _8: &(std::option::Option<&ARCRC<'_>>, std::option::Option<&ARCRC<'_>>);

    bb0: {
        _4 = &((*_1).0: &str);
        _3 = <&str as Clone>::clone(_4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = _3;
        _6 = &((*_1).1: std::cell::Cell<u32>);
        _5 = <Cell<u32> as Clone>::clone(_6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &((*_1).2: (std::option::Option<&ARCRC<'_>>, std::option::Option<&ARCRC<'_>>));
        _7 = <(Option<&ARCRC<'_>>, Option<&ARCRC<'_>>) as Clone>::clone(_8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = ARCRCData::<'_> { name: move _2, mark: move _5, children: move _7 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:799:10: 799:15>::clone(_1: &ARCRC<'_>) -> ARCRC<'_> {
    debug self => _1;
    let mut _0: ARCRC<'_>;
    let mut _2: std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>;
    let _3: &std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>;

    bb0: {
        _3 = &((*_1).0: std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>);
        _2 = <Arc<RefCell<ARCRCData<'_>>> as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = ARCRC::<'_>(move _2);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:802:1: 802:29>::new(_1: &str) -> ARCRC<'_> {
    debug name => _1;
    let mut _0: ARCRC<'_>;
    let mut _2: std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>;
    let mut _3: std::cell::RefCell<ARCRCData<'_>>;
    let mut _4: ARCRCData<'_>;
    let mut _5: std::cell::Cell<u32>;
    let mut _6: (std::option::Option<&ARCRC<'_>>, std::option::Option<&ARCRC<'_>>);
    let mut _7: std::option::Option<&ARCRC<'_>>;
    let mut _8: std::option::Option<&ARCRC<'_>>;

    bb0: {
        _5 = Cell::<u32>::new(const 0_u32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = Option::<&ARCRC<'_>>::None;
        _8 = Option::<&ARCRC<'_>>::None;
        _6 = (move _7, move _8);
        _4 = ARCRCData::<'_> { name: _1, mark: move _5, children: move _6 };
        _3 = RefCell::<ARCRCData<'_>>::new(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = Arc::<RefCell<ARCRCData<'_>>>::new(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = ARCRC::<'_>(move _2);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:802:1: 802:29>::name(_1: &ARCRC<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;
    let _2: &ARCRCData<'_>;
    let mut _3: &std::cell::Ref<'_, ARCRCData<'_>>;
    let _4: std::cell::Ref<'_, ARCRCData<'_>>;
    let mut _5: &std::cell::RefCell<ARCRCData<'_>>;
    let _6: &std::cell::RefCell<ARCRCData<'_>>;
    let mut _7: &std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>;

    bb0: {
        _7 = &((*_1).0: std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>);
        _6 = <Arc<RefCell<ARCRCData<'_>>> as Deref>::deref(move _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = _6;
        _4 = RefCell::<ARCRCData<'_>>::borrow(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = &_4;
        _2 = <Ref<'_, ARCRCData<'_>> as Deref>::deref(move _3) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        _0 = deref_copy ((*_2).0: &str);
        drop(_4) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_4) -> [return: bb6, unwind terminate];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:810:1: 810:35>::mark(_1: &ARCRC<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;
    let _3: &ARCRCData<'_>;
    let mut _4: &std::cell::Ref<'_, ARCRCData<'_>>;
    let _5: std::cell::Ref<'_, ARCRCData<'_>>;
    let mut _6: &std::cell::RefCell<ARCRCData<'_>>;
    let _7: &std::cell::RefCell<ARCRCData<'_>>;
    let mut _8: &std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>;

    bb0: {
        _8 = &((*_1).0: std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>);
        _7 = <Arc<RefCell<ARCRCData<'_>>> as Deref>::deref(move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = _7;
        _5 = RefCell::<ARCRCData<'_>>::borrow(move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = &_5;
        _3 = <Ref<'_, ARCRCData<'_>> as Deref>::deref(move _4) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _2 = &((*_3).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        drop(_5) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_5) -> [return: bb7, unwind terminate];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:810:1: 810:35>::set_mark(_1: &ARCRC<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;
    let _5: &ARCRCData<'_>;
    let mut _6: &std::cell::Ref<'_, ARCRCData<'_>>;
    let _7: std::cell::Ref<'_, ARCRCData<'_>>;
    let mut _8: &std::cell::RefCell<ARCRCData<'_>>;
    let _9: &std::cell::RefCell<ARCRCData<'_>>;
    let mut _10: &std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>;

    bb0: {
        _10 = &((*_1).0: std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>);
        _9 = <Arc<RefCell<ARCRCData<'_>>> as Deref>::deref(move _10) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = _9;
        _7 = RefCell::<ARCRCData<'_>>::borrow(move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = &_7;
        _5 = <Ref<'_, ARCRCData<'_>> as Deref>::deref(move _6) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _4 = &((*_5).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        drop(_7) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_7) -> [return: bb7, unwind terminate];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:815:1: 815:36>::count_children(_1: &ARCRC<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:815:1: 815:36>::descend_one_child(_1: &ARCRC<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let _4: &(std::option::Option<&ARCRC<'_>>, std::option::Option<&ARCRC<'_>>);
    let _5: &ARCRCData<'_>;
    let mut _6: &std::cell::Ref<'_, ARCRCData<'_>>;
    let _7: std::cell::Ref<'_, ARCRCData<'_>>;
    let mut _8: &std::cell::RefCell<ARCRCData<'_>>;
    let _9: &std::cell::RefCell<ARCRCData<'_>>;
    let mut _10: &std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>;
    let mut _11: isize;
    let _13: ();
    let mut _14: isize;
    let _16: ();
    let _17: !;
    let mut _18: &ARCRC<'_>;
    let mut _19: &ARCRC<'_>;
    scope 1 {
        debug children => _4;
        scope 2 {
            debug child => _12;
            let _12: &&ARCRC<'_>;
        }
        scope 3 {
            debug child => _15;
            let _15: &&ARCRC<'_>;
        }
    }

    bb0: {
        _10 = &((*_1).0: std::sync::Arc<std::cell::RefCell<ARCRCData<'_>>>);
        _9 = <Arc<RefCell<ARCRCData<'_>>> as Deref>::deref(move _10) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = _9;
        _7 = RefCell::<ARCRCData<'_>>::borrow(move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = &_7;
        _5 = <Ref<'_, ARCRCData<'_>> as Deref>::deref(move _6) -> [return: bb3, unwind: bb11];
    }

    bb3: {
        _4 = &((*_5).2: (std::option::Option<&ARCRC<'_>>, std::option::Option<&ARCRC<'_>>));
        switchInt(_3) -> [0: bb5, 1: bb7, otherwise: bb4];
    }

    bb4: {
        _17 = begin_panic::<&str>(const "bad children!") -> bb11;
    }

    bb5: {
        _11 = discriminant(((*_4).0: std::option::Option<&ARCRC<'_>>));
        switchInt(move _11) -> [1: bb6, otherwise: bb9];
    }

    bb6: {
        _12 = &((((*_4).0: std::option::Option<&ARCRC<'_>>) as Some).0: &ARCRC<'_>);
        _18 = deref_copy (*_12);
        _13 = <ARCRC<'_> as Children<'_>>::descend_into_self::<C>(_18, _2) -> [return: bb13, unwind: bb11];
    }

    bb7: {
        _14 = discriminant(((*_4).1: std::option::Option<&ARCRC<'_>>));
        switchInt(move _14) -> [1: bb8, otherwise: bb9];
    }

    bb8: {
        _15 = &((((*_4).1: std::option::Option<&ARCRC<'_>>) as Some).0: &ARCRC<'_>);
        _19 = deref_copy (*_15);
        _16 = <ARCRC<'_> as Children<'_>>::descend_into_self::<C>(_19, _2) -> [return: bb14, unwind: bb11];
    }

    bb9: {
        drop(_7) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        drop(_7) -> [return: bb12, unwind terminate];
    }

    bb12 (cleanup): {
        resume;
    }

    bb13: {
        goto -> bb9;
    }

    bb14: {
        goto -> bb9;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:833:10: 833:15>::clone(_1: &ARCMData<'_>) -> ARCMData<'_> {
    debug self => _1;
    let mut _0: ARCMData<'_>;
    let mut _2: std::cell::Cell<u32>;
    let _3: &std::cell::Cell<u32>;
    let mut _4: (std::option::Option<&ARCM<'_>>, std::option::Option<&ARCM<'_>>);
    let _5: &(std::option::Option<&ARCM<'_>>, std::option::Option<&ARCM<'_>>);

    bb0: {
        _3 = &((*_1).0: std::cell::Cell<u32>);
        _2 = <Cell<u32> as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &((*_1).1: (std::option::Option<&ARCM<'_>>, std::option::Option<&ARCM<'_>>));
        _4 = <(Option<&ARCM<'_>>, Option<&ARCM<'_>>) as Clone>::clone(_5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = ARCMData::<'_> { mark: move _2, children: move _4 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:839:10: 839:15>::clone(_1: &ARCM<'_>) -> ARCM<'_> {
    debug self => _1;
    let mut _0: ARCM<'_>;
    let mut _2: &str;
    let _3: &str;
    let _4: &&str;
    let mut _5: std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>;
    let _6: &std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>;

    bb0: {
        _4 = &((*_1).0: &str);
        _3 = <&str as Clone>::clone(_4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = _3;
        _6 = &((*_1).1: std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>);
        _5 = <Arc<Mutex<ARCMData<'_>>> as Clone>::clone(_6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = ARCM::<'_>(move _2, move _5);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:842:1: 842:28>::new(_1: &str) -> ARCM<'_> {
    debug name => _1;
    let mut _0: ARCM<'_>;
    let mut _2: std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>;
    let mut _3: std::sync::Mutex<ARCMData<'_>>;
    let mut _4: ARCMData<'_>;
    let mut _5: std::cell::Cell<u32>;
    let mut _6: (std::option::Option<&ARCM<'_>>, std::option::Option<&ARCM<'_>>);
    let mut _7: std::option::Option<&ARCM<'_>>;
    let mut _8: std::option::Option<&ARCM<'_>>;

    bb0: {
        _5 = Cell::<u32>::new(const 0_u32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = Option::<&ARCM<'_>>::None;
        _8 = Option::<&ARCM<'_>>::None;
        _6 = (move _7, move _8);
        _4 = ARCMData::<'_> { mark: move _5, children: move _6 };
        _3 = Mutex::<ARCMData<'_>>::new(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = Arc::<Mutex<ARCMData<'_>>>::new(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = ARCM::<'_>(_1, move _2);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:842:1: 842:28>::name(_1: &ARCM<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = deref_copy ((*_1).0: &str);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:850:1: 850:34>::mark(_1: &ARCM<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;
    let _3: &ARCMData<'_>;
    let mut _4: &std::sync::MutexGuard<'_, ARCMData<'_>>;
    let _5: std::sync::MutexGuard<'_, ARCMData<'_>>;
    let mut _6: std::result::Result<std::sync::MutexGuard<'_, ARCMData<'_>>, std::sync::PoisonError<std::sync::MutexGuard<'_, ARCMData<'_>>>>;
    let mut _7: &std::sync::Mutex<ARCMData<'_>>;
    let _8: &std::sync::Mutex<ARCMData<'_>>;
    let mut _9: &std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>;

    bb0: {
        _9 = &((*_1).1: std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>);
        _8 = <Arc<Mutex<ARCMData<'_>>> as Deref>::deref(move _9) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = _8;
        _6 = Mutex::<ARCMData<'_>>::lock(move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = Result::<MutexGuard<'_, ARCMData<'_>>, PoisonError<MutexGuard<'_, ARCMData<'_>>>>::unwrap(move _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = &_5;
        _3 = <MutexGuard<'_, ARCMData<'_>> as Deref>::deref(move _4) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        _2 = &((*_3).0: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> [return: bb5, unwind: bb7];
    }

    bb5: {
        drop(_5) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        drop(_5) -> [return: bb8, unwind terminate];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:850:1: 850:34>::set_mark(_1: &ARCM<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;
    let _5: &ARCMData<'_>;
    let mut _6: &std::sync::MutexGuard<'_, ARCMData<'_>>;
    let _7: std::sync::MutexGuard<'_, ARCMData<'_>>;
    let mut _8: std::result::Result<std::sync::MutexGuard<'_, ARCMData<'_>>, std::sync::PoisonError<std::sync::MutexGuard<'_, ARCMData<'_>>>>;
    let mut _9: &std::sync::Mutex<ARCMData<'_>>;
    let _10: &std::sync::Mutex<ARCMData<'_>>;
    let mut _11: &std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>;

    bb0: {
        _11 = &((*_1).1: std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>);
        _10 = <Arc<Mutex<ARCMData<'_>>> as Deref>::deref(move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = _10;
        _8 = Mutex::<ARCMData<'_>>::lock(move _9) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = Result::<MutexGuard<'_, ARCMData<'_>>, PoisonError<MutexGuard<'_, ARCMData<'_>>>>::unwrap(move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = &_7;
        _5 = <MutexGuard<'_, ARCMData<'_>> as Deref>::deref(move _6) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        _4 = &((*_5).0: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> [return: bb5, unwind: bb7];
    }

    bb5: {
        drop(_7) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        drop(_7) -> [return: bb8, unwind terminate];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:855:1: 855:35>::count_children(_1: &ARCM<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:855:1: 855:35>::descend_one_child(_1: &ARCM<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let _4: &(std::option::Option<&ARCM<'_>>, std::option::Option<&ARCM<'_>>);
    let mut _5: (std::option::Option<&ARCM<'_>>, std::option::Option<&ARCM<'_>>);
    let mut _6: std::result::Result<std::sync::MutexGuard<'_, ARCMData<'_>>, std::sync::TryLockError<std::sync::MutexGuard<'_, ARCMData<'_>>>>;
    let mut _7: &std::sync::Mutex<ARCMData<'_>>;
    let _8: &std::sync::Mutex<ARCMData<'_>>;
    let mut _9: &std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>;
    let mut _10: isize;
    let mut _12: &ARCMData<'_>;
    let mut _13: &std::sync::MutexGuard<'_, ARCMData<'_>>;
    let mut _14: isize;
    let _16: ();
    let mut _17: isize;
    let _19: ();
    let _20: !;
    let mut _21: &ARCM<'_>;
    let mut _22: &ARCM<'_>;
    let mut _23: isize;
    let mut _24: isize;
    scope 1 {
        debug children => _4;
        scope 3 {
            debug child => _15;
            let _15: &&ARCM<'_>;
        }
        scope 4 {
            debug child => _18;
            let _18: &&ARCM<'_>;
        }
    }
    scope 2 {
        debug data => _11;
        let _11: std::sync::MutexGuard<'_, ARCMData<'_>>;
    }

    bb0: {
        _9 = &((*_1).1: std::sync::Arc<std::sync::Mutex<ARCMData<'_>>>);
        _8 = <Arc<Mutex<ARCMData<'_>>> as Deref>::deref(move _9) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = _8;
        _6 = Mutex::<ARCMData<'_>>::try_lock(move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _10 = discriminant(_6);
        switchInt(move _10) -> [0: bb3, otherwise: bb5];
    }

    bb3: {
        _11 = move ((_6 as Ok).0: std::sync::MutexGuard<'_, ARCMData<'_>>);
        _13 = &_11;
        _12 = <MutexGuard<'_, ARCMData<'_>> as Deref>::deref(move _13) -> [return: bb4, unwind: bb13];
    }

    bb4: {
        _5 = ((*_12).1: (std::option::Option<&ARCM<'_>>, std::option::Option<&ARCM<'_>>));
        drop(_11) -> [return: bb6, unwind: bb18];
    }

    bb5: {
        drop(_6) -> [return: bb12, unwind continue];
    }

    bb6: {
        _4 = &_5;
        _23 = discriminant(_6);
        switchInt(move _23) -> [0: bb15, otherwise: bb16];
    }

    bb7: {
        _20 = begin_panic::<&str>(const "bad children!") -> unwind continue;
    }

    bb8: {
        _14 = discriminant(((*_4).0: std::option::Option<&ARCM<'_>>));
        switchInt(move _14) -> [1: bb9, otherwise: bb12];
    }

    bb9: {
        _15 = &((((*_4).0: std::option::Option<&ARCM<'_>>) as Some).0: &ARCM<'_>);
        _21 = deref_copy (*_15);
        _16 = <ARCM<'_> as Children<'_>>::descend_into_self::<C>(_21, _2) -> [return: bb12, unwind continue];
    }

    bb10: {
        _17 = discriminant(((*_4).1: std::option::Option<&ARCM<'_>>));
        switchInt(move _17) -> [1: bb11, otherwise: bb12];
    }

    bb11: {
        _18 = &((((*_4).1: std::option::Option<&ARCM<'_>>) as Some).0: &ARCM<'_>);
        _22 = deref_copy (*_18);
        _19 = <ARCM<'_> as Children<'_>>::descend_into_self::<C>(_22, _2) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        drop(_11) -> [return: bb18, unwind terminate];
    }

    bb14 (cleanup): {
        resume;
    }

    bb15: {
        switchInt(_3) -> [0: bb8, 1: bb10, otherwise: bb7];
    }

    bb16: {
        drop(_6) -> [return: bb15, unwind continue];
    }

    bb17 (cleanup): {
        drop(_6) -> [return: bb14, unwind terminate];
    }

    bb18 (cleanup): {
        _24 = discriminant(_6);
        switchInt(move _24) -> [0: bb14, otherwise: bb17];
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:875:10: 875:15>::clone(_1: &ARCRWData<'_>) -> ARCRWData<'_> {
    debug self => _1;
    let mut _0: ARCRWData<'_>;
    let mut _2: &str;
    let _3: &str;
    let _4: &&str;
    let mut _5: std::cell::Cell<u32>;
    let _6: &std::cell::Cell<u32>;
    let mut _7: (std::option::Option<&ARCRW<'_>>, std::option::Option<&ARCRW<'_>>);
    let _8: &(std::option::Option<&ARCRW<'_>>, std::option::Option<&ARCRW<'_>>);

    bb0: {
        _4 = &((*_1).0: &str);
        _3 = <&str as Clone>::clone(_4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = _3;
        _6 = &((*_1).1: std::cell::Cell<u32>);
        _5 = <Cell<u32> as Clone>::clone(_6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &((*_1).2: (std::option::Option<&ARCRW<'_>>, std::option::Option<&ARCRW<'_>>));
        _7 = <(Option<&ARCRW<'_>>, Option<&ARCRW<'_>>) as Clone>::clone(_8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = ARCRWData::<'_> { name: move _2, mark: move _5, children: move _7 };
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:882:10: 882:15>::clone(_1: &ARCRW<'_>) -> ARCRW<'_> {
    debug self => _1;
    let mut _0: ARCRW<'_>;
    let mut _2: std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>;
    let _3: &std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>;

    bb0: {
        _3 = &((*_1).0: std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>);
        _2 = <Arc<RwLock<ARCRWData<'_>>> as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = ARCRW::<'_>(move _2);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:885:1: 885:29>::new(_1: &str) -> ARCRW<'_> {
    debug name => _1;
    let mut _0: ARCRW<'_>;
    let mut _2: std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>;
    let mut _3: std::sync::RwLock<ARCRWData<'_>>;
    let mut _4: ARCRWData<'_>;
    let mut _5: std::cell::Cell<u32>;
    let mut _6: (std::option::Option<&ARCRW<'_>>, std::option::Option<&ARCRW<'_>>);
    let mut _7: std::option::Option<&ARCRW<'_>>;
    let mut _8: std::option::Option<&ARCRW<'_>>;

    bb0: {
        _5 = Cell::<u32>::new(const 0_u32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = Option::<&ARCRW<'_>>::None;
        _8 = Option::<&ARCRW<'_>>::None;
        _6 = (move _7, move _8);
        _4 = ARCRWData::<'_> { name: _1, mark: move _5, children: move _6 };
        _3 = RwLock::<ARCRWData<'_>>::new(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = Arc::<RwLock<ARCRWData<'_>>>::new(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = ARCRW::<'_>(move _2);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:885:1: 885:29>::name(_1: &ARCRW<'_>) -> &str {
    debug self => _1;
    let mut _0: &str;
    let _2: &ARCRWData<'_>;
    let mut _3: &std::sync::RwLockReadGuard<'_, ARCRWData<'_>>;
    let _4: std::sync::RwLockReadGuard<'_, ARCRWData<'_>>;
    let mut _5: std::result::Result<std::sync::RwLockReadGuard<'_, ARCRWData<'_>>, std::sync::PoisonError<std::sync::RwLockReadGuard<'_, ARCRWData<'_>>>>;
    let mut _6: &std::sync::RwLock<ARCRWData<'_>>;
    let _7: &std::sync::RwLock<ARCRWData<'_>>;
    let mut _8: &std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>;

    bb0: {
        _8 = &((*_1).0: std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>);
        _7 = <Arc<RwLock<ARCRWData<'_>>> as Deref>::deref(move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = _7;
        _5 = RwLock::<ARCRWData<'_>>::read(move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = Result::<RwLockReadGuard<'_, ARCRWData<'_>>, PoisonError<RwLockReadGuard<'_, ARCRWData<'_>>>>::unwrap(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = &_4;
        _2 = <RwLockReadGuard<'_, ARCRWData<'_>> as Deref>::deref(move _3) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        _0 = deref_copy ((*_2).0: &str);
        drop(_4) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_4) -> [return: bb7, unwind terminate];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:893:1: 893:35>::mark(_1: &ARCRW<'_>) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &std::cell::Cell<u32>;
    let _3: &ARCRWData<'_>;
    let mut _4: &std::sync::RwLockReadGuard<'_, ARCRWData<'_>>;
    let _5: std::sync::RwLockReadGuard<'_, ARCRWData<'_>>;
    let mut _6: std::result::Result<std::sync::RwLockReadGuard<'_, ARCRWData<'_>>, std::sync::PoisonError<std::sync::RwLockReadGuard<'_, ARCRWData<'_>>>>;
    let mut _7: &std::sync::RwLock<ARCRWData<'_>>;
    let _8: &std::sync::RwLock<ARCRWData<'_>>;
    let mut _9: &std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>;

    bb0: {
        _9 = &((*_1).0: std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>);
        _8 = <Arc<RwLock<ARCRWData<'_>>> as Deref>::deref(move _9) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = _8;
        _6 = RwLock::<ARCRWData<'_>>::read(move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = Result::<RwLockReadGuard<'_, ARCRWData<'_>>, PoisonError<RwLockReadGuard<'_, ARCRWData<'_>>>>::unwrap(move _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = &_5;
        _3 = <RwLockReadGuard<'_, ARCRWData<'_>> as Deref>::deref(move _4) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        _2 = &((*_3).1: std::cell::Cell<u32>);
        _0 = Cell::<u32>::get(move _2) -> [return: bb5, unwind: bb7];
    }

    bb5: {
        drop(_5) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        drop(_5) -> [return: bb8, unwind terminate];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:893:1: 893:35>::set_mark(_1: &ARCRW<'_>, _2: u32) -> () {
    debug self => _1;
    debug mark => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &std::cell::Cell<u32>;
    let _5: &ARCRWData<'_>;
    let mut _6: &std::sync::RwLockReadGuard<'_, ARCRWData<'_>>;
    let _7: std::sync::RwLockReadGuard<'_, ARCRWData<'_>>;
    let mut _8: std::result::Result<std::sync::RwLockReadGuard<'_, ARCRWData<'_>>, std::sync::PoisonError<std::sync::RwLockReadGuard<'_, ARCRWData<'_>>>>;
    let mut _9: &std::sync::RwLock<ARCRWData<'_>>;
    let _10: &std::sync::RwLock<ARCRWData<'_>>;
    let mut _11: &std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>;

    bb0: {
        _11 = &((*_1).0: std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>);
        _10 = <Arc<RwLock<ARCRWData<'_>>> as Deref>::deref(move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = _10;
        _8 = RwLock::<ARCRWData<'_>>::read(move _9) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = Result::<RwLockReadGuard<'_, ARCRWData<'_>>, PoisonError<RwLockReadGuard<'_, ARCRWData<'_>>>>::unwrap(move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = &_7;
        _5 = <RwLockReadGuard<'_, ARCRWData<'_>> as Deref>::deref(move _6) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        _4 = &((*_5).1: std::cell::Cell<u32>);
        _3 = Cell::<u32>::set(move _4, _2) -> [return: bb5, unwind: bb7];
    }

    bb5: {
        drop(_7) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        drop(_7) -> [return: bb8, unwind terminate];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:898:1: 898:36>::count_children(_1: &ARCRW<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:898:1: 898:36>::descend_one_child(_1: &ARCRW<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let _4: &(std::option::Option<&ARCRW<'_>>, std::option::Option<&ARCRW<'_>>);
    let _5: &ARCRWData<'_>;
    let mut _6: &std::sync::RwLockReadGuard<'_, ARCRWData<'_>>;
    let _7: std::sync::RwLockReadGuard<'_, ARCRWData<'_>>;
    let mut _8: std::result::Result<std::sync::RwLockReadGuard<'_, ARCRWData<'_>>, std::sync::PoisonError<std::sync::RwLockReadGuard<'_, ARCRWData<'_>>>>;
    let mut _9: &std::sync::RwLock<ARCRWData<'_>>;
    let _10: &std::sync::RwLock<ARCRWData<'_>>;
    let mut _11: &std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>;
    let mut _12: isize;
    let _14: ();
    let mut _15: isize;
    let _17: ();
    let _18: !;
    let mut _19: &ARCRW<'_>;
    let mut _20: &ARCRW<'_>;
    scope 1 {
        debug children => _4;
        scope 2 {
            debug child => _13;
            let _13: &&ARCRW<'_>;
        }
        scope 3 {
            debug child => _16;
            let _16: &&ARCRW<'_>;
        }
    }

    bb0: {
        _11 = &((*_1).0: std::sync::Arc<std::sync::RwLock<ARCRWData<'_>>>);
        _10 = <Arc<RwLock<ARCRWData<'_>>> as Deref>::deref(move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = _10;
        _8 = RwLock::<ARCRWData<'_>>::read(move _9) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = Result::<RwLockReadGuard<'_, ARCRWData<'_>>, PoisonError<RwLockReadGuard<'_, ARCRWData<'_>>>>::unwrap(move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = &_7;
        _5 = <RwLockReadGuard<'_, ARCRWData<'_>> as Deref>::deref(move _6) -> [return: bb4, unwind: bb12];
    }

    bb4: {
        _4 = &((*_5).2: (std::option::Option<&ARCRW<'_>>, std::option::Option<&ARCRW<'_>>));
        switchInt(_3) -> [0: bb6, 1: bb8, otherwise: bb5];
    }

    bb5: {
        _18 = begin_panic::<&str>(const "bad children!") -> bb12;
    }

    bb6: {
        _12 = discriminant(((*_4).0: std::option::Option<&ARCRW<'_>>));
        switchInt(move _12) -> [1: bb7, otherwise: bb10];
    }

    bb7: {
        _13 = &((((*_4).0: std::option::Option<&ARCRW<'_>>) as Some).0: &ARCRW<'_>);
        _19 = deref_copy (*_13);
        _14 = <ARCRW<'_> as Children<'_>>::descend_into_self::<C>(_19, _2) -> [return: bb14, unwind: bb12];
    }

    bb8: {
        _15 = discriminant(((*_4).1: std::option::Option<&ARCRW<'_>>));
        switchInt(move _15) -> [1: bb9, otherwise: bb10];
    }

    bb9: {
        _16 = &((((*_4).1: std::option::Option<&ARCRW<'_>>) as Some).0: &ARCRW<'_>);
        _20 = deref_copy (*_16);
        _17 = <ARCRW<'_> as Children<'_>>::descend_into_self::<C>(_20, _2) -> [return: bb15, unwind: bb12];
    }

    bb10: {
        drop(_7) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }

    bb12 (cleanup): {
        drop(_7) -> [return: bb13, unwind terminate];
    }

    bb13 (cleanup): {
        resume;
    }

    bb14: {
        goto -> bb10;
    }

    bb15: {
        goto -> bb10;
    }
}

fn Children::next_child(_1: &Self, _2: &mut C) -> () {
    debug self => _1;
    debug context => _2;
    let mut _0: ();
    let _3: usize;
    let mut _4: usize;
    let _5: ();
    let mut _6: usize;
    scope 1 {
        debug index => _3;
    }

    bb0: {
        _4 = <Self as Children<'_>>::count_children(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <C as Context>::next_index(_2, move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = _3;
        _5 = <Self as Children<'_>>::descend_one_child::<C>(_1, _2, move _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn Children::descend_into_self(_1: &Self, _2: &mut C) -> () {
    debug self => _1;
    debug context => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: bool;
    let mut _5: &C;
    let _6: ();
    let _7: ();
    let _8: ();
    let _9: ();
    let _10: ();
    let _11: ();
    let _12: ();

    bb0: {
        _3 = <C as PrePost<Self>>::pre(_2, _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &(*_2);
        _4 = <C as Context>::should_act(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _4) -> [0: bb7, otherwise: bb3];
    }

    bb3: {
        _6 = <C as Context>::increase_visited(_2) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = <C as Context>::increase_depth(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _8 = <Self as Children<'_>>::next_child::<C>(_1, _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        _9 = <C as Context>::decrease_depth(_2) -> [return: bb9, unwind continue];
    }

    bb7: {
        _10 = <C as PrePost<Self>>::hit_limit(_2, _1) -> [return: bb8, unwind continue];
    }

    bb8: {
        _11 = <C as Context>::increase_skipped(_2) -> [return: bb9, unwind continue];
    }

    bb9: {
        _12 = <C as PrePost<Self>>::post(_2, _1) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

fn Children::descend(_1: &Self, _2: &Cell<Option<&Self>>, _3: &mut C) -> () {
    debug self => _1;
    debug c => _2;
    debug context => _3;
    let mut _0: ();
    let mut _4: std::option::Option<&Self>;
    let mut _5: isize;
    let _7: ();
    scope 1 {
        debug r => _6;
        let _6: &Self;
    }

    bb0: {
        _4 = Cell::<Option<&Self>>::get(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = discriminant(_4);
        switchInt(move _5) -> [1: bb2, otherwise: bb3];
    }

    bb2: {
        _6 = ((_4 as Some).0: &Self);
        _7 = <Self as Children<'_>>::descend_into_self::<C>(_6, _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:968:1: 968:32>::count_children(_1: &S<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:968:1: 968:32>::descend_one_child(_1: &S<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    let mut _0: ();
    let _4: ();
    let _5: &std::cell::Cell<std::option::Option<&S<'_>>>;

    bb0: {
        _5 = &((*_1).2: std::cell::Cell<std::option::Option<&S<'_>>>);
        _4 = <S<'_> as Children<'_>>::descend::<C>(_1, _5, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:976:1: 976:33>::count_children(_1: &S2<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:976:1: 976:33>::descend_one_child(_1: &S2<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let _4: (std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>);
    let mut _5: &std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>;
    let mut _7: isize;
    let mut _9: isize;
    let _11: !;
    let _12: ();
    let mut _13: &S2<'_>;
    scope 1 {
        debug children => _4;
        let _6: &S2<'_>;
        scope 2 {
            debug child => _6;
        }
        scope 3 {
            debug child => _8;
            let _8: &S2<'_>;
        }
        scope 4 {
            debug child => _10;
            let _10: &S2<'_>;
        }
    }

    bb0: {
        _5 = &((*_1).2: std::cell::Cell<(std::option::Option<&S2<'_>>, std::option::Option<&S2<'_>>)>);
        _4 = Cell::<(Option<&S2<'_>>, Option<&S2<'_>>)>::get(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(_3) -> [0: bb3, 1: bb5, otherwise: bb2];
    }

    bb2: {
        _11 = begin_panic::<&str>(const "bad children") -> unwind continue;
    }

    bb3: {
        _7 = discriminant((_4.0: std::option::Option<&S2<'_>>));
        switchInt(move _7) -> [1: bb4, otherwise: bb8];
    }

    bb4: {
        _8 = (((_4.0: std::option::Option<&S2<'_>>) as Some).0: &S2<'_>);
        _6 = _8;
        goto -> bb7;
    }

    bb5: {
        _9 = discriminant((_4.1: std::option::Option<&S2<'_>>));
        switchInt(move _9) -> [1: bb6, otherwise: bb8];
    }

    bb6: {
        _10 = (((_4.1: std::option::Option<&S2<'_>>) as Some).0: &S2<'_>);
        _6 = _10;
        goto -> bb7;
    }

    bb7: {
        _13 = _6;
        _12 = <S2<'_> as Children<'_>>::descend_into_self::<C>(move _13, _2) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:992:1: 992:32>::count_children(_1: &V<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: &std::vec::Vec<std::cell::Cell<std::option::Option<&V<'_>>>>;

    bb0: {
        _2 = &((*_1).2: std::vec::Vec<std::cell::Cell<std::option::Option<&V<'_>>>>);
        _0 = Vec::<Cell<Option<&V<'_>>>>::len(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:992:1: 992:32>::descend_one_child(_1: &V<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let mut _4: std::option::Option<&V<'_>>;
    let mut _5: &std::cell::Cell<std::option::Option<&V<'_>>>;
    let _6: &std::cell::Cell<std::option::Option<&V<'_>>>;
    let mut _7: &std::vec::Vec<std::cell::Cell<std::option::Option<&V<'_>>>>;
    let mut _8: isize;
    let _10: ();
    scope 1 {
        debug child => _9;
        let _9: &V<'_>;
    }

    bb0: {
        _7 = &((*_1).2: std::vec::Vec<std::cell::Cell<std::option::Option<&V<'_>>>>);
        _6 = <Vec<Cell<Option<&V<'_>>>> as Index<usize>>::index(move _7, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = _6;
        _4 = Cell::<Option<&V<'_>>>::get(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = discriminant(_4);
        switchInt(move _8) -> [1: bb3, otherwise: bb4];
    }

    bb3: {
        _9 = ((_4 as Some).0: &V<'_>);
        _10 = <V<'_> as Children<'_>>::descend_into_self::<C>(_9, _2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1003:1: 1003:32>::count_children(_1: &H<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1003:1: 1003:32>::descend_one_child(_1: &H<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    let mut _0: ();
    let _4: ();
    let _5: &std::cell::Cell<std::option::Option<&H<'_>>>;

    bb0: {
        _5 = &((*_1).2: std::cell::Cell<std::option::Option<&H<'_>>>);
        _4 = <H<'_> as Children<'_>>::descend::<C>(_1, _5, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1012:1: 1012:33>::count_children(_1: &HM<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>;
    let mut _3: &std::cell::Cell<std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>>;
    let mut _4: isize;
    let mut _6: usize;
    let mut _7: std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
    scope 1 {
        debug m => _5;
        let _5: &std::collections::HashMap<HM<'_>, HM<'_>>;
    }

    bb0: {
        _3 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>>);
        _2 = Cell::<Option<&HashMap<HM<'_>, HM<'_>>>>::get(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [1: bb2, otherwise: bb5];
    }

    bb2: {
        _5 = ((_2 as Some).0: &std::collections::HashMap<HM<'_>, HM<'_>>);
        _7 = HashMap::<HM<'_>, HM<'_>>::iter(_5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = <std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>> as Iterator>::count(move _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = Mul(const 2_usize, move _6);
        goto -> bb6;
    }

    bb5: {
        _0 = const 0_usize;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1012:1: 1012:33>::descend_one_child(_1: &HM<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let mut _4: std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>;
    let mut _5: &std::cell::Cell<std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>>;
    let mut _6: isize;
    let mut _8: std::option::Option<(&HM<'_>, &HM<'_>)>;
    let mut _9: &mut std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
    let mut _10: std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>>;
    let mut _11: usize;
    let mut _12: bool;
    let mut _13: isize;
    let _16: ();
    let _17: [&HM<'_>; 2];
    let _18: usize;
    let mut _19: bool;
    let mut _20: usize;
    let mut _21: bool;
    let mut _22: &std::collections::HashMap<HM<'_>, HM<'_>>;
    let mut _23: &HM<'_>;
    scope 1 {
        debug hm => _7;
        let _7: &&std::collections::HashMap<HM<'_>, HM<'_>>;
        scope 2 {
            debug k => _14;
            debug v => _15;
            let _14: &HM<'_>;
            let _15: &HM<'_>;
        }
    }

    bb0: {
        _5 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::HashMap<HM<'_>, HM<'_>>>>);
        _4 = Cell::<Option<&HashMap<HM<'_>, HM<'_>>>>::get(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [1: bb2, otherwise: bb9];
    }

    bb2: {
        _7 = &((_4 as Some).0: &std::collections::HashMap<HM<'_>, HM<'_>>);
        _22 = deref_copy (*_7);
        _10 = HashMap::<HM<'_>, HM<'_>>::iter(_22) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = &mut _10;
        _12 = Eq(const 2_usize, const 0_usize);
        assert(!move _12, "attempt to divide `{}` by zero", _3) -> [success: bb4, unwind continue];
    }

    bb4: {
        _11 = Div(_3, const 2_usize);
        _8 = <std::collections::hash_map::Iter<'_, HM<'_>, HM<'_>> as Iterator>::nth(move _9, move _11) -> [return: bb5, unwind continue];
    }

    bb5: {
        _13 = discriminant(_8);
        switchInt(move _13) -> [1: bb6, otherwise: bb9];
    }

    bb6: {
        _14 = (((_8 as Some).0: (&HM<'_>, &HM<'_>)).0: &HM<'_>);
        _15 = (((_8 as Some).0: (&HM<'_>, &HM<'_>)).1: &HM<'_>);
        _17 = [_14, _15];
        _19 = Eq(const 2_usize, const 0_usize);
        assert(!move _19, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> [success: bb7, unwind continue];
    }

    bb7: {
        _18 = Rem(_3, const 2_usize);
        _20 = const 2_usize;
        _21 = Lt(_18, _20);
        assert(move _21, "index out of bounds: the length is {} but the index is {}", move _20, _18) -> [success: bb8, unwind continue];
    }

    bb8: {
        _23 = deref_copy _17[_18];
        _16 = <HM<'_> as Children<'_>>::descend_into_self::<C>(_23, _2) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1027:1: 1027:33>::count_children(_1: &VD<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: std::option::Option<&std::collections::VecDeque<VD<'_>>>;
    let mut _3: &std::cell::Cell<std::option::Option<&std::collections::VecDeque<VD<'_>>>>;
    let mut _4: isize;
    let mut _6: std::collections::vec_deque::Iter<'_, VD<'_>>;
    scope 1 {
        debug d => _5;
        let _5: &std::collections::VecDeque<VD<'_>>;
    }

    bb0: {
        _3 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::VecDeque<VD<'_>>>>);
        _2 = Cell::<Option<&VecDeque<VD<'_>>>>::get(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [1: bb2, otherwise: bb4];
    }

    bb2: {
        _5 = ((_2 as Some).0: &std::collections::VecDeque<VD<'_>>);
        _6 = VecDeque::<VD<'_>>::iter(_5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <std::collections::vec_deque::Iter<'_, VD<'_>> as Iterator>::count(move _6) -> [return: bb5, unwind continue];
    }

    bb4: {
        _0 = const 0_usize;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1027:1: 1027:33>::descend_one_child(_1: &VD<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let mut _4: std::option::Option<&std::collections::VecDeque<VD<'_>>>;
    let mut _5: &std::cell::Cell<std::option::Option<&std::collections::VecDeque<VD<'_>>>>;
    let mut _6: isize;
    let mut _8: std::option::Option<&VD<'_>>;
    let mut _9: &mut std::collections::vec_deque::Iter<'_, VD<'_>>;
    let mut _10: std::collections::vec_deque::Iter<'_, VD<'_>>;
    let mut _11: isize;
    let _13: ();
    let mut _14: &std::collections::VecDeque<VD<'_>>;
    scope 1 {
        debug vd => _7;
        let _7: &&std::collections::VecDeque<VD<'_>>;
        scope 2 {
            debug r => _12;
            let _12: &VD<'_>;
        }
    }

    bb0: {
        _5 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::VecDeque<VD<'_>>>>);
        _4 = Cell::<Option<&VecDeque<VD<'_>>>>::get(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [1: bb2, otherwise: bb6];
    }

    bb2: {
        _7 = &((_4 as Some).0: &std::collections::VecDeque<VD<'_>>);
        _14 = deref_copy (*_7);
        _10 = VecDeque::<VD<'_>>::iter(_14) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = &mut _10;
        _8 = <std::collections::vec_deque::Iter<'_, VD<'_>> as Iterator>::nth(move _9, _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _11 = discriminant(_8);
        switchInt(move _11) -> [1: bb5, otherwise: bb6];
    }

    bb5: {
        _12 = ((_8 as Some).0: &VD<'_>);
        _13 = <VD<'_> as Children<'_>>::descend_into_self::<C>(_12, _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1042:1: 1042:33>::count_children(_1: &VM<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: std::option::Option<&std::collections::HashMap<usize, VM<'_>>>;
    let mut _3: &std::cell::Cell<std::option::Option<&std::collections::HashMap<usize, VM<'_>>>>;
    let mut _4: isize;
    let mut _6: std::collections::hash_map::Iter<'_, usize, VM<'_>>;
    scope 1 {
        debug m => _5;
        let _5: &std::collections::HashMap<usize, VM<'_>>;
    }

    bb0: {
        _3 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::HashMap<usize, VM<'_>>>>);
        _2 = Cell::<Option<&HashMap<usize, VM<'_>>>>::get(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [1: bb2, otherwise: bb4];
    }

    bb2: {
        _5 = ((_2 as Some).0: &std::collections::HashMap<usize, VM<'_>>);
        _6 = HashMap::<usize, VM<'_>>::iter(_5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <std::collections::hash_map::Iter<'_, usize, VM<'_>> as Iterator>::count(move _6) -> [return: bb5, unwind continue];
    }

    bb4: {
        _0 = const 0_usize;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1042:1: 1042:33>::descend_one_child(_1: &VM<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let mut _4: std::option::Option<&std::collections::HashMap<usize, VM<'_>>>;
    let mut _5: &std::cell::Cell<std::option::Option<&std::collections::HashMap<usize, VM<'_>>>>;
    let mut _6: isize;
    let mut _8: std::option::Option<(&usize, &VM<'_>)>;
    let mut _9: &mut std::collections::hash_map::Iter<'_, usize, VM<'_>>;
    let mut _10: std::collections::hash_map::Iter<'_, usize, VM<'_>>;
    let mut _11: isize;
    let _14: ();
    let mut _15: &std::collections::HashMap<usize, VM<'_>>;
    scope 1 {
        debug vd => _7;
        let _7: &&std::collections::HashMap<usize, VM<'_>>;
        scope 2 {
            debug _idx => _12;
            debug r => _13;
            let _12: &usize;
            let _13: &VM<'_>;
        }
    }

    bb0: {
        _5 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::HashMap<usize, VM<'_>>>>);
        _4 = Cell::<Option<&HashMap<usize, VM<'_>>>>::get(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [1: bb2, otherwise: bb6];
    }

    bb2: {
        _7 = &((_4 as Some).0: &std::collections::HashMap<usize, VM<'_>>);
        _15 = deref_copy (*_7);
        _10 = HashMap::<usize, VM<'_>>::iter(_15) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = &mut _10;
        _8 = <std::collections::hash_map::Iter<'_, usize, VM<'_>> as Iterator>::nth(move _9, _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _11 = discriminant(_8);
        switchInt(move _11) -> [1: bb5, otherwise: bb6];
    }

    bb5: {
        _12 = (((_8 as Some).0: (&usize, &VM<'_>)).0: &usize);
        _13 = (((_8 as Some).0: (&usize, &VM<'_>)).1: &VM<'_>);
        _14 = <VM<'_> as Children<'_>>::descend_into_self::<C>(_13, _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1057:1: 1057:33>::count_children(_1: &LL<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: std::option::Option<&std::collections::LinkedList<LL<'_>>>;
    let mut _3: &std::cell::Cell<std::option::Option<&std::collections::LinkedList<LL<'_>>>>;
    let mut _4: isize;
    let mut _6: std::collections::linked_list::Iter<'_, LL<'_>>;
    scope 1 {
        debug l => _5;
        let _5: &std::collections::LinkedList<LL<'_>>;
    }

    bb0: {
        _3 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::LinkedList<LL<'_>>>>);
        _2 = Cell::<Option<&LinkedList<LL<'_>>>>::get(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [1: bb2, otherwise: bb4];
    }

    bb2: {
        _5 = ((_2 as Some).0: &std::collections::LinkedList<LL<'_>>);
        _6 = LinkedList::<LL<'_>>::iter(_5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <std::collections::linked_list::Iter<'_, LL<'_>> as Iterator>::count(move _6) -> [return: bb5, unwind continue];
    }

    bb4: {
        _0 = const 0_usize;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1057:1: 1057:33>::descend_one_child(_1: &LL<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let mut _4: std::option::Option<&std::collections::LinkedList<LL<'_>>>;
    let mut _5: &std::cell::Cell<std::option::Option<&std::collections::LinkedList<LL<'_>>>>;
    let mut _6: isize;
    let mut _8: std::option::Option<&LL<'_>>;
    let mut _9: &mut std::collections::linked_list::Iter<'_, LL<'_>>;
    let mut _10: std::collections::linked_list::Iter<'_, LL<'_>>;
    let mut _11: isize;
    let _13: ();
    let mut _14: &std::collections::LinkedList<LL<'_>>;
    scope 1 {
        debug ll => _7;
        let _7: &&std::collections::LinkedList<LL<'_>>;
        scope 2 {
            debug r => _12;
            let _12: &LL<'_>;
        }
    }

    bb0: {
        _5 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::LinkedList<LL<'_>>>>);
        _4 = Cell::<Option<&LinkedList<LL<'_>>>>::get(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [1: bb2, otherwise: bb6];
    }

    bb2: {
        _7 = &((_4 as Some).0: &std::collections::LinkedList<LL<'_>>);
        _14 = deref_copy (*_7);
        _10 = LinkedList::<LL<'_>>::iter(_14) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = &mut _10;
        _8 = <std::collections::linked_list::Iter<'_, LL<'_>> as Iterator>::nth(move _9, _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _11 = discriminant(_8);
        switchInt(move _11) -> [1: bb5, otherwise: bb6];
    }

    bb5: {
        _12 = ((_8 as Some).0: &LL<'_>);
        _13 = <LL<'_> as Children<'_>>::descend_into_self::<C>(_12, _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1072:1: 1072:33>::count_children(_1: &BH<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: std::option::Option<&std::collections::BinaryHeap<BH<'_>>>;
    let mut _3: &std::cell::Cell<std::option::Option<&std::collections::BinaryHeap<BH<'_>>>>;
    let mut _4: isize;
    let mut _6: std::collections::binary_heap::Iter<'_, BH<'_>>;
    scope 1 {
        debug h => _5;
        let _5: &std::collections::BinaryHeap<BH<'_>>;
    }

    bb0: {
        _3 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::BinaryHeap<BH<'_>>>>);
        _2 = Cell::<Option<&BinaryHeap<BH<'_>>>>::get(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [1: bb2, otherwise: bb4];
    }

    bb2: {
        _5 = ((_2 as Some).0: &std::collections::BinaryHeap<BH<'_>>);
        _6 = BinaryHeap::<BH<'_>>::iter(_5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <std::collections::binary_heap::Iter<'_, BH<'_>> as Iterator>::count(move _6) -> [return: bb5, unwind continue];
    }

    bb4: {
        _0 = const 0_usize;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1072:1: 1072:33>::descend_one_child(_1: &BH<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let mut _4: std::option::Option<&std::collections::BinaryHeap<BH<'_>>>;
    let mut _5: &std::cell::Cell<std::option::Option<&std::collections::BinaryHeap<BH<'_>>>>;
    let mut _6: isize;
    let mut _8: std::option::Option<&BH<'_>>;
    let mut _9: &mut std::collections::binary_heap::Iter<'_, BH<'_>>;
    let mut _10: std::collections::binary_heap::Iter<'_, BH<'_>>;
    let mut _11: isize;
    let _13: ();
    let mut _14: &std::collections::BinaryHeap<BH<'_>>;
    scope 1 {
        debug bh => _7;
        let _7: &&std::collections::BinaryHeap<BH<'_>>;
        scope 2 {
            debug r => _12;
            let _12: &BH<'_>;
        }
    }

    bb0: {
        _5 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::BinaryHeap<BH<'_>>>>);
        _4 = Cell::<Option<&BinaryHeap<BH<'_>>>>::get(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [1: bb2, otherwise: bb6];
    }

    bb2: {
        _7 = &((_4 as Some).0: &std::collections::BinaryHeap<BH<'_>>);
        _14 = deref_copy (*_7);
        _10 = BinaryHeap::<BH<'_>>::iter(_14) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = &mut _10;
        _8 = <std::collections::binary_heap::Iter<'_, BH<'_>> as Iterator>::nth(move _9, _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _11 = discriminant(_8);
        switchInt(move _11) -> [1: bb5, otherwise: bb6];
    }

    bb5: {
        _12 = ((_8 as Some).0: &BH<'_>);
        _13 = <BH<'_> as Children<'_>>::descend_into_self::<C>(_12, _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1087:1: 1087:34>::count_children(_1: &BTM<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>;
    let mut _3: &std::cell::Cell<std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>>;
    let mut _4: isize;
    let mut _6: usize;
    let mut _7: std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>>;
    scope 1 {
        debug m => _5;
        let _5: &std::collections::BTreeMap<BTM<'_>, BTM<'_>>;
    }

    bb0: {
        _3 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>>);
        _2 = Cell::<Option<&BTreeMap<BTM<'_>, BTM<'_>>>>::get(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [1: bb2, otherwise: bb5];
    }

    bb2: {
        _5 = ((_2 as Some).0: &std::collections::BTreeMap<BTM<'_>, BTM<'_>>);
        _7 = BTreeMap::<BTM<'_>, BTM<'_>>::iter(_5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = <std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>> as Iterator>::count(move _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = Mul(const 2_usize, move _6);
        goto -> bb6;
    }

    bb5: {
        _0 = const 0_usize;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1087:1: 1087:34>::descend_one_child(_1: &BTM<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let mut _4: std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>;
    let mut _5: &std::cell::Cell<std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>>;
    let mut _6: isize;
    let mut _8: std::option::Option<(&BTM<'_>, &BTM<'_>)>;
    let mut _9: &mut std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>>;
    let mut _10: std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>>;
    let mut _11: usize;
    let mut _12: bool;
    let mut _13: isize;
    let _16: ();
    let _17: [&BTM<'_>; 2];
    let _18: usize;
    let mut _19: bool;
    let mut _20: usize;
    let mut _21: bool;
    let mut _22: &std::collections::BTreeMap<BTM<'_>, BTM<'_>>;
    let mut _23: &BTM<'_>;
    scope 1 {
        debug bh => _7;
        let _7: &&std::collections::BTreeMap<BTM<'_>, BTM<'_>>;
        scope 2 {
            debug k => _14;
            debug v => _15;
            let _14: &BTM<'_>;
            let _15: &BTM<'_>;
        }
    }

    bb0: {
        _5 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::BTreeMap<BTM<'_>, BTM<'_>>>>);
        _4 = Cell::<Option<&BTreeMap<BTM<'_>, BTM<'_>>>>::get(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [1: bb2, otherwise: bb9];
    }

    bb2: {
        _7 = &((_4 as Some).0: &std::collections::BTreeMap<BTM<'_>, BTM<'_>>);
        _22 = deref_copy (*_7);
        _10 = BTreeMap::<BTM<'_>, BTM<'_>>::iter(_22) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = &mut _10;
        _12 = Eq(const 2_usize, const 0_usize);
        assert(!move _12, "attempt to divide `{}` by zero", _3) -> [success: bb4, unwind continue];
    }

    bb4: {
        _11 = Div(_3, const 2_usize);
        _8 = <std::collections::btree_map::Iter<'_, BTM<'_>, BTM<'_>> as Iterator>::nth(move _9, move _11) -> [return: bb5, unwind continue];
    }

    bb5: {
        _13 = discriminant(_8);
        switchInt(move _13) -> [1: bb6, otherwise: bb9];
    }

    bb6: {
        _14 = (((_8 as Some).0: (&BTM<'_>, &BTM<'_>)).0: &BTM<'_>);
        _15 = (((_8 as Some).0: (&BTM<'_>, &BTM<'_>)).1: &BTM<'_>);
        _17 = [_14, _15];
        _19 = Eq(const 2_usize, const 0_usize);
        assert(!move _19, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> [success: bb7, unwind continue];
    }

    bb7: {
        _18 = Rem(_3, const 2_usize);
        _20 = const 2_usize;
        _21 = Lt(_18, _20);
        assert(move _21, "index out of bounds: the length is {} but the index is {}", move _20, _18) -> [success: bb8, unwind continue];
    }

    bb8: {
        _23 = deref_copy _17[_18];
        _16 = <BTM<'_> as Children<'_>>::descend_into_self::<C>(_23, _2) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1102:1: 1102:34>::count_children(_1: &BTS<'_>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: std::option::Option<&std::collections::BTreeSet<BTS<'_>>>;
    let mut _3: &std::cell::Cell<std::option::Option<&std::collections::BTreeSet<BTS<'_>>>>;
    let mut _4: isize;
    let mut _6: std::collections::btree_set::Iter<'_, BTS<'_>>;
    scope 1 {
        debug s => _5;
        let _5: &std::collections::BTreeSet<BTS<'_>>;
    }

    bb0: {
        _3 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::BTreeSet<BTS<'_>>>>);
        _2 = Cell::<Option<&BTreeSet<BTS<'_>>>>::get(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [1: bb2, otherwise: bb4];
    }

    bb2: {
        _5 = ((_2 as Some).0: &std::collections::BTreeSet<BTS<'_>>);
        _6 = BTreeSet::<BTS<'_>>::iter(_5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <std::collections::btree_set::Iter<'_, BTS<'_>> as Iterator>::count(move _6) -> [return: bb5, unwind continue];
    }

    bb4: {
        _0 = const 0_usize;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1102:1: 1102:34>::descend_one_child(_1: &BTS<'_>, _2: &mut C, _3: usize) -> () {
    debug self => _1;
    debug context => _2;
    debug index => _3;
    let mut _0: ();
    let mut _4: std::option::Option<&std::collections::BTreeSet<BTS<'_>>>;
    let mut _5: &std::cell::Cell<std::option::Option<&std::collections::BTreeSet<BTS<'_>>>>;
    let mut _6: isize;
    let mut _8: std::option::Option<&BTS<'_>>;
    let mut _9: &mut std::collections::btree_set::Iter<'_, BTS<'_>>;
    let mut _10: std::collections::btree_set::Iter<'_, BTS<'_>>;
    let mut _11: isize;
    let _13: ();
    let mut _14: &std::collections::BTreeSet<BTS<'_>>;
    scope 1 {
        debug bh => _7;
        let _7: &&std::collections::BTreeSet<BTS<'_>>;
        scope 2 {
            debug r => _12;
            let _12: &BTS<'_>;
        }
    }

    bb0: {
        _5 = &((*_1).2: std::cell::Cell<std::option::Option<&std::collections::BTreeSet<BTS<'_>>>>);
        _4 = Cell::<Option<&BTreeSet<BTS<'_>>>>::get(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [1: bb2, otherwise: bb6];
    }

    bb2: {
        _7 = &((_4 as Some).0: &std::collections::BTreeSet<BTS<'_>>);
        _14 = deref_copy (*_7);
        _10 = BTreeSet::<BTS<'_>>::iter(_14) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = &mut _10;
        _8 = <std::collections::btree_set::Iter<'_, BTS<'_>> as Iterator>::nth(move _9, _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _11 = discriminant(_8);
        switchInt(move _11) -> [1: bb5, otherwise: bb6];
    }

    bb5: {
        _12 = ((_8 as Some).0: &BTS<'_>);
        _13 = <BTS<'_> as Children<'_>>::descend_into_self::<C>(_12, _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1117:16: 1117:21>::clone(_1: &ContextData) -> ContextData {
    debug self => _1;
    let mut _0: ContextData;
    scope 1 {
        scope 2 {
            scope 3 {
                scope 4 {
                }
            }
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1129:1: 1129:29>::next_index(_1: &mut ContextData, _2: usize) -> usize {
    debug self => _1;
    debug len => _2;
    let mut _0: usize;
    let mut _3: bool;
    let mut _4: usize;
    let mut _8: bool;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: usize;
    let mut _12: usize;
    let mut _13: u64;
    let mut _14: u64;
    let mut _15: u64;
    let mut _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    let mut _19: u64;
    scope 1 {
        debug pow2 => _4;
        let _5: usize;
        scope 2 {
            debug _pow2_orig => _5;
            let mut _6: usize;
            scope 3 {
                debug idx => _6;
                let mut _7: u64;
                scope 4 {
                    debug bits => _7;
                }
            }
        }
    }

    bb0: {
        _3 = Lt(_2, const 2_usize);
        switchInt(move _3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = const 0_usize;
        goto -> bb8;
    }

    bb2: {
        _4 = core::num::<impl usize>::next_power_of_two(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = _4;
        _6 = const 0_usize;
        _7 = ((*_1).7: u64);
        goto -> bb4;
    }

    bb4: {
        _9 = _4;
        _8 = Gt(move _9, const 1_usize);
        switchInt(move _8) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _11 = _6;
        _10 = Shl(move _11, const 1_i32);
        _14 = _7;
        _13 = BitAnd(move _14, const 1_u64);
        _12 = move _13 as usize (IntToInt);
        _6 = BitOr(move _10, move _12);
        _15 = _7;
        _7 = Shr(move _15, const 1_i32);
        _16 = _4;
        _4 = Shr(move _16, const 1_i32);
        goto -> bb4;
    }

    bb6: {
        _17 = _6;
        _18 = Eq(_2, const 0_usize);
        assert(!move _18, "attempt to calculate the remainder of `{}` with a divisor of zero", _17) -> [success: bb7, unwind continue];
    }

    bb7: {
        _6 = Rem(move _17, _2);
        _19 = _7;
        ((*_1).7: u64) = move _19;
        _0 = _6;
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1129:1: 1129:29>::should_act(_1: &ContextData) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let mut _3: usize;
    let mut _4: usize;
    let mut _5: bool;
    let mut _6: usize;
    let mut _7: usize;

    bb0: {
        _3 = ((*_1).0: usize);
        _4 = ((*_1).1: usize);
        _2 = Lt(move _3, move _4);
        switchInt(move _2) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const false;
        goto -> bb3;
    }

    bb2: {
        _6 = ((*_1).2: usize);
        _7 = ((*_1).3: usize);
        _5 = Lt(move _6, move _7);
        _0 = move _5;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1129:1: 1129:29>::increase_visited(_1: &mut ContextData) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        ((*_1).2: usize) = Add(((*_1).2: usize), const 1_usize);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1129:1: 1129:29>::increase_skipped(_1: &mut ContextData) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        ((*_1).4: usize) = Add(((*_1).4: usize), const 1_usize);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1129:1: 1129:29>::increase_depth(_1: &mut ContextData) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        ((*_1).0: usize) = Add(((*_1).0: usize), const 1_usize);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1129:1: 1129:29>::decrease_depth(_1: &mut ContextData) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        ((*_1).0: usize) = Sub(((*_1).0: usize), const 1_usize);
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1156:1: 1156:53>::pre(_1: &mut ContextData, _2: &T) -> () {
    debug self => _1;
    debug t => _2;
    let mut _0: ();
    let mut _3: std::ops::Range<usize>;
    let mut _4: std::ops::Range<usize>;
    let mut _5: usize;
    let mut _6: std::ops::Range<usize>;
    let mut _7: std::option::Option<usize>;
    let mut _8: &mut std::ops::Range<usize>;
    let mut _9: isize;
    let mut _10: bool;
    let _11: ();
    let mut _12: std::fmt::Arguments<'_>;
    let mut _13: &[&str];
    let mut _14: bool;
    let _15: ();
    let mut _16: std::fmt::Arguments<'_>;
    let mut _17: &[&str];
    let mut _18: &[core::fmt::rt::Argument<'_>];
    let _19: &[core::fmt::rt::Argument<'_>; 1];
    let _20: [core::fmt::rt::Argument<'_>; 1];
    let mut _21: core::fmt::rt::Argument<'_>;
    let _22: &&str;
    let _23: &str;
    let mut _24: bool;
    let mut _25: u32;
    let mut _26: u32;
    let mut _27: std::ops::Range<usize>;
    let mut _28: std::ops::Range<usize>;
    let mut _29: usize;
    let mut _30: std::ops::Range<usize>;
    let mut _31: std::option::Option<usize>;
    let mut _32: &mut std::ops::Range<usize>;
    let mut _33: isize;
    let mut _34: bool;
    let _35: ();
    let mut _36: std::fmt::Arguments<'_>;
    let mut _37: &[&str];
    let mut _38: bool;
    let _39: ();
    let mut _40: std::fmt::Arguments<'_>;
    let mut _41: &[&str];
    let _42: ();
    let mut _43: u32;
    let mut _46: &[&str; 1];
    let mut _47: &[&str; 2];
    scope 1 {
        debug iter => _6;
        let mut _44: &[&str; 1];
    }
    scope 2 {
        debug iter => _30;
        let mut _45: &[&str; 1];
    }

    bb0: {
        _5 = ((*_1).0: usize);
        _4 = std::ops::Range::<usize> { start: const 0_usize, end: move _5 };
        _3 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = move _3;
        goto -> bb2;
    }

    bb2: {
        _8 = &mut _6;
        _7 = <std::ops::Range<usize> as Iterator>::next(_8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _10 = const _;
        switchInt(move _10) -> [0: bb2, otherwise: bb7];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _14 = const _;
        switchInt(move _14) -> [0: bb13, otherwise: bb9];
    }

    bb7: {
        _44 = const _;
        _13 = _44 as &[&str] (Pointer(Unsize));
        _12 = Arguments::<'_>::new_const(move _13) -> [return: bb8, unwind continue];
    }

    bb8: {
        _11 = _print(move _12) -> [return: bb2, unwind continue];
    }

    bb9: {
        _47 = const _;
        _17 = _47 as &[&str] (Pointer(Unsize));
        _23 = <T as Named>::name(_2) -> [return: bb10, unwind continue];
    }

    bb10: {
        _22 = &_23;
        _21 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_22) -> [return: bb11, unwind continue];
    }

    bb11: {
        _20 = [move _21];
        _19 = &_20;
        _18 = _19 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _16 = Arguments::<'_>::new_v1(move _17, move _18) -> [return: bb12, unwind continue];
    }

    bb12: {
        _15 = _print(move _16) -> [return: bb13, unwind continue];
    }

    bb13: {
        _25 = <T as Marked<u32>>::mark(_2) -> [return: bb14, unwind continue];
    }

    bb14: {
        _26 = ((*_1).5: u32);
        _24 = Eq(move _25, move _26);
        switchInt(move _24) -> [0: bb26, otherwise: bb15];
    }

    bb15: {
        _29 = ((*_1).0: usize);
        _28 = std::ops::Range::<usize> { start: const 0_usize, end: move _29 };
        _27 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _28) -> [return: bb16, unwind continue];
    }

    bb16: {
        _30 = move _27;
        goto -> bb17;
    }

    bb17: {
        _32 = &mut _30;
        _31 = <std::ops::Range<usize> as Iterator>::next(_32) -> [return: bb18, unwind continue];
    }

    bb18: {
        _33 = discriminant(_31);
        switchInt(move _33) -> [0: bb20, 1: bb19, otherwise: bb5];
    }

    bb19: {
        _34 = const _;
        switchInt(move _34) -> [0: bb17, otherwise: bb21];
    }

    bb20: {
        _38 = const _;
        switchInt(move _38) -> [0: bb25, otherwise: bb23];
    }

    bb21: {
        _45 = const _;
        _37 = _45 as &[&str] (Pointer(Unsize));
        _36 = Arguments::<'_>::new_const(move _37) -> [return: bb22, unwind continue];
    }

    bb22: {
        _35 = _print(move _36) -> [return: bb17, unwind continue];
    }

    bb23: {
        _46 = const _;
        _41 = _46 as &[&str] (Pointer(Unsize));
        _40 = Arguments::<'_>::new_const(move _41) -> [return: bb24, unwind continue];
    }

    bb24: {
        _39 = _print(move _40) -> [return: bb25, unwind continue];
    }

    bb25: {
        ((*_1).6: bool) = const true;
        goto -> bb26;
    }

    bb26: {
        _43 = ((*_1).5: u32);
        _42 = <T as Marked<u32>>::set_mark(_2, move _43) -> [return: bb27, unwind continue];
    }

    bb27: {
        return;
    }
}

promoted[0] in <impl at ui/drop/dropck_legal_cycles.rs:1156:1: 1156:53>::pre: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const " "];
        _0 = &_1;
        return;
    }
}

promoted[1] in <impl at ui/drop/dropck_legal_cycles.rs:1156:1: 1156:53>::pre: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const " "];
        _0 = &_1;
        return;
    }
}

promoted[2] in <impl at ui/drop/dropck_legal_cycles.rs:1156:1: 1156:53>::pre: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "(probably previously marked)\n"];
        _0 = &_1;
        return;
    }
}

promoted[3] in <impl at ui/drop/dropck_legal_cycles.rs:1156:1: 1156:53>::pre: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "prev ", const "\n"];
        _0 = &_1;
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1156:1: 1156:53>::post(_1: &mut ContextData, _2: &T) -> () {
    debug self => _1;
    debug t => _2;
    let mut _0: ();
    let mut _3: std::ops::Range<usize>;
    let mut _4: std::ops::Range<usize>;
    let mut _5: usize;
    let mut _6: std::ops::Range<usize>;
    let mut _7: std::option::Option<usize>;
    let mut _8: &mut std::ops::Range<usize>;
    let mut _9: isize;
    let mut _10: bool;
    let _11: ();
    let mut _12: std::fmt::Arguments<'_>;
    let mut _13: &[&str];
    let mut _14: bool;
    let _15: ();
    let mut _16: std::fmt::Arguments<'_>;
    let mut _17: &[&str];
    let mut _18: &[core::fmt::rt::Argument<'_>];
    let _19: &[core::fmt::rt::Argument<'_>; 1];
    let _20: [core::fmt::rt::Argument<'_>; 1];
    let mut _21: core::fmt::rt::Argument<'_>;
    let _22: &&str;
    let _23: &str;
    let mut _25: &[&str; 2];
    scope 1 {
        debug iter => _6;
        let mut _24: &[&str; 1];
    }

    bb0: {
        _5 = ((*_1).0: usize);
        _4 = std::ops::Range::<usize> { start: const 0_usize, end: move _5 };
        _3 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = move _3;
        goto -> bb2;
    }

    bb2: {
        _8 = &mut _6;
        _7 = <std::ops::Range<usize> as Iterator>::next(_8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _10 = const _;
        switchInt(move _10) -> [0: bb2, otherwise: bb7];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _14 = const _;
        switchInt(move _14) -> [0: bb13, otherwise: bb9];
    }

    bb7: {
        _24 = const _;
        _13 = _24 as &[&str] (Pointer(Unsize));
        _12 = Arguments::<'_>::new_const(move _13) -> [return: bb8, unwind continue];
    }

    bb8: {
        _11 = _print(move _12) -> [return: bb2, unwind continue];
    }

    bb9: {
        _25 = const _;
        _17 = _25 as &[&str] (Pointer(Unsize));
        _23 = <T as Named>::name(_2) -> [return: bb10, unwind continue];
    }

    bb10: {
        _22 = &_23;
        _21 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_22) -> [return: bb11, unwind continue];
    }

    bb11: {
        _20 = [move _21];
        _19 = &_20;
        _18 = _19 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _16 = Arguments::<'_>::new_v1(move _17, move _18) -> [return: bb12, unwind continue];
    }

    bb12: {
        _15 = _print(move _16) -> [return: bb13, unwind continue];
    }

    bb13: {
        return;
    }
}

promoted[0] in <impl at ui/drop/dropck_legal_cycles.rs:1156:1: 1156:53>::post: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const " "];
        _0 = &_1;
        return;
    }
}

promoted[1] in <impl at ui/drop/dropck_legal_cycles.rs:1156:1: 1156:53>::post: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "post ", const "\n"];
        _0 = &_1;
        return;
    }
}

fn <impl at ui/drop/dropck_legal_cycles.rs:1156:1: 1156:53>::hit_limit(_1: &mut ContextData, _2: &T) -> () {
    debug self => _1;
    debug t => _2;
    let mut _0: ();
    let mut _3: std::ops::Range<usize>;
    let mut _4: std::ops::Range<usize>;
    let mut _5: usize;
    let mut _6: std::ops::Range<usize>;
    let mut _7: std::option::Option<usize>;
    let mut _8: &mut std::ops::Range<usize>;
    let mut _9: isize;
    let mut _10: bool;
    let _11: ();
    let mut _12: std::fmt::Arguments<'_>;
    let mut _13: &[&str];
    let mut _14: bool;
    let _15: ();
    let mut _16: std::fmt::Arguments<'_>;
    let mut _17: &[&str];
    let mut _18: &[core::fmt::rt::Argument<'_>];
    let _19: &[core::fmt::rt::Argument<'_>; 1];
    let _20: [core::fmt::rt::Argument<'_>; 1];
    let mut _21: core::fmt::rt::Argument<'_>;
    let _22: &&str;
    let _23: &str;
    let mut _25: &[&str; 2];
    scope 1 {
        debug iter => _6;
        let mut _24: &[&str; 1];
    }

    bb0: {
        _5 = ((*_1).0: usize);
        _4 = std::ops::Range::<usize> { start: const 0_usize, end: move _5 };
        _3 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = move _3;
        goto -> bb2;
    }

    bb2: {
        _8 = &mut _6;
        _7 = <std::ops::Range<usize> as Iterator>::next(_8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _10 = const _;
        switchInt(move _10) -> [0: bb2, otherwise: bb7];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _14 = const _;
        switchInt(move _14) -> [0: bb13, otherwise: bb9];
    }

    bb7: {
        _24 = const _;
        _13 = _24 as &[&str] (Pointer(Unsize));
        _12 = Arguments::<'_>::new_const(move _13) -> [return: bb8, unwind continue];
    }

    bb8: {
        _11 = _print(move _12) -> [return: bb2, unwind continue];
    }

    bb9: {
        _25 = const _;
        _17 = _25 as &[&str] (Pointer(Unsize));
        _23 = <T as Named>::name(_2) -> [return: bb10, unwind continue];
    }

    bb10: {
        _22 = &_23;
        _21 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_22) -> [return: bb11, unwind continue];
    }

    bb11: {
        _20 = [move _21];
        _19 = &_20;
        _18 = _19 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _16 = Arguments::<'_>::new_v1(move _17, move _18) -> [return: bb12, unwind continue];
    }

    bb12: {
        _15 = _print(move _16) -> [return: bb13, unwind continue];
    }

    bb13: {
        return;
    }
}

promoted[0] in <impl at ui/drop/dropck_legal_cycles.rs:1156:1: 1156:53>::hit_limit: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const " "];
        _0 = &_1;
        return;
    }
}

promoted[1] in <impl at ui/drop/dropck_legal_cycles.rs:1156:1: 1156:53>::hit_limit: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "LIMIT ", const "\n"];
        _0 = &_1;
        return;
    }
}

fn RCRC(_1: Rc<RefCell<RCRCData<'_>>>) -> RCRC<'_> {
    let mut _0: RCRC<'_>;

    bb0: {
        _0 = RCRC::<'_>(move _1);
        return;
    }
}

// MIR FOR CTFE
fn RCRC(_1: Rc<RefCell<RCRCData<'_>>>) -> RCRC<'_> {
    let mut _0: RCRC<'_>;

    bb0: {
        _0 = RCRC::<'_>(move _1);
        return;
    }
}

fn ARCRC(_1: Arc<RefCell<ARCRCData<'_>>>) -> ARCRC<'_> {
    let mut _0: ARCRC<'_>;

    bb0: {
        _0 = ARCRC::<'_>(move _1);
        return;
    }
}

// MIR FOR CTFE
fn ARCRC(_1: Arc<RefCell<ARCRCData<'_>>>) -> ARCRC<'_> {
    let mut _0: ARCRC<'_>;

    bb0: {
        _0 = ARCRC::<'_>(move _1);
        return;
    }
}

fn ARCM(_1: &str, _2: Arc<Mutex<ARCMData<'_>>>) -> ARCM<'_> {
    let mut _0: ARCM<'_>;

    bb0: {
        _0 = ARCM::<'_>(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn ARCM(_1: &str, _2: Arc<Mutex<ARCMData<'_>>>) -> ARCM<'_> {
    let mut _0: ARCM<'_>;

    bb0: {
        _0 = ARCM::<'_>(move _1, move _2);
        return;
    }
}

fn ARCRW(_1: Arc<RwLock<ARCRWData<'_>>>) -> ARCRW<'_> {
    let mut _0: ARCRW<'_>;

    bb0: {
        _0 = ARCRW::<'_>(move _1);
        return;
    }
}

// MIR FOR CTFE
fn ARCRW(_1: Arc<RwLock<ARCRWData<'_>>>) -> ARCRW<'_> {
    let mut _0: ARCRW<'_>;

    bb0: {
        _0 = ARCRW::<'_>(move _1);
        return;
    }
}
