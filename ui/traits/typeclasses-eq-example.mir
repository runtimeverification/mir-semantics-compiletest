// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/traits/typeclasses-eq-example.rs:15:10: 15:15>::clone(_1: &Color) -> Color {
    debug self => _1;
    let mut _0: Color;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn <impl at ui/traits/typeclasses-eq-example.rs:18:1: 18:21>::isEq(_1: &Color, _2: &Color) -> bool {
    debug self => _1;
    debug a => _2;
    let mut _0: bool;
    let mut _3: (Color, Color);
    let mut _4: Color;
    let mut _5: Color;
    let mut _6: isize;
    let mut _7: isize;
    let mut _8: isize;
    let mut _9: isize;
    let mut _10: isize;

    bb0: {
        _4 = (*_1);
        _5 = (*_2);
        _3 = (move _4, move _5);
        _10 = discriminant((_3.0: Color));
        switchInt(move _10) -> [0: bb1, 1: bb2, 2: bb3, 3: bb4, otherwise: bb6];
    }

    bb1: {
        _6 = discriminant((_3.1: Color));
        _0 = Eq(_6, const 0_isize);
        goto -> bb5;
    }

    bb2: {
        _7 = discriminant((_3.1: Color));
        _0 = Eq(_7, const 1_isize);
        goto -> bb5;
    }

    bb3: {
        _8 = discriminant((_3.1: Color));
        _0 = Eq(_8, const 2_isize);
        goto -> bb5;
    }

    bb4: {
        _9 = discriminant((_3.1: Color));
        _0 = Eq(_9, const 3_isize);
        goto -> bb5;
    }

    bb5: {
        return;
    }

    bb6: {
        unreachable;
    }
}

fn <impl at ui/traits/typeclasses-eq-example.rs:30:10: 30:15>::clone(_1: &ColorTree) -> ColorTree {
    debug self => _1;
    let mut _0: ColorTree;
    let mut _2: isize;
    let _3: &Color;
    let mut _4: Color;
    let _5: &std::boxed::Box<ColorTree>;
    let _6: &std::boxed::Box<ColorTree>;
    let mut _7: std::boxed::Box<ColorTree>;
    let mut _8: std::boxed::Box<ColorTree>;
    scope 1 {
        debug __self_0 => _3;
    }
    scope 2 {
        debug __self_0 => _5;
        debug __self_1 => _6;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _5 = &(((*_1) as branch).0: std::boxed::Box<ColorTree>);
        _6 = &(((*_1) as branch).1: std::boxed::Box<ColorTree>);
        _7 = <Box<ColorTree> as Clone>::clone(_5) -> [return: bb5, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _3 = &(((*_1) as leaf).0: Color);
        _4 = <Color as Clone>::clone(_3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = ColorTree::leaf(move _4);
        goto -> bb7;
    }

    bb5: {
        _8 = <Box<ColorTree> as Clone>::clone(_6) -> [return: bb6, unwind: bb8];
    }

    bb6: {
        _0 = ColorTree::branch(move _7, move _8);
        goto -> bb7;
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_7) -> [return: bb9, unwind terminate];
    }

    bb9 (cleanup): {
        resume;
    }
}

fn <impl at ui/traits/typeclasses-eq-example.rs:36:1: 36:25>::isEq(_1: &ColorTree, _2: &ColorTree) -> bool {
    debug self => _1;
    debug a => _2;
    let mut _0: bool;
    let mut _3: (&ColorTree, &ColorTree);
    let mut _4: isize;
    let mut _5: isize;
    let mut _6: isize;
    let _7: &Color;
    let _8: &Color;
    let _9: &Color;
    let _10: Color;
    let _11: &std::boxed::Box<ColorTree>;
    let _12: &std::boxed::Box<ColorTree>;
    let _13: &std::boxed::Box<ColorTree>;
    let _14: &std::boxed::Box<ColorTree>;
    let mut _15: bool;
    let mut _16: &ColorTree;
    let _17: &ColorTree;
    let _18: ColorTree;
    let mut _19: &ColorTree;
    let mut _20: bool;
    let mut _21: &ColorTree;
    let _22: &ColorTree;
    let _23: ColorTree;
    let mut _24: &ColorTree;
    let mut _25: &ColorTree;
    let mut _26: &ColorTree;
    let mut _27: &ColorTree;
    let mut _28: &ColorTree;
    let mut _29: &ColorTree;
    let mut _30: &ColorTree;
    let mut _31: &ColorTree;
    let mut _32: &ColorTree;
    let mut _33: &ColorTree;
    let mut _34: std::boxed::Box<ColorTree>;
    let mut _35: std::boxed::Box<ColorTree>;
    let mut _36: std::boxed::Box<ColorTree>;
    let mut _37: std::boxed::Box<ColorTree>;
    let mut _38: *const ColorTree;
    let mut _39: *const ColorTree;
    let mut _40: *const ColorTree;
    let mut _41: *const ColorTree;
    scope 1 {
        debug x => _7;
        debug y => _8;
    }
    scope 2 {
        debug l1 => _11;
        debug r1 => _12;
        debug l2 => _13;
        debug r2 => _14;
        let mut _42: *const ();
        let mut _43: usize;
        let mut _44: usize;
        let mut _45: usize;
        let mut _46: usize;
        let mut _47: bool;
        let mut _48: *const ();
        let mut _49: usize;
        let mut _50: usize;
        let mut _51: usize;
        let mut _52: usize;
        let mut _53: bool;
        let mut _54: *const ();
        let mut _55: usize;
        let mut _56: usize;
        let mut _57: usize;
        let mut _58: usize;
        let mut _59: bool;
        let mut _60: *const ();
        let mut _61: usize;
        let mut _62: usize;
        let mut _63: usize;
        let mut _64: usize;
        let mut _65: bool;
    }

    bb0: {
        _3 = (_1, _2);
        _25 = deref_copy (_3.0: &ColorTree);
        _6 = discriminant((*_25));
        switchInt(move _6) -> [0: bb1, 1: bb3, otherwise: bb23];
    }

    bb1: {
        _26 = deref_copy (_3.1: &ColorTree);
        _4 = discriminant((*_26));
        switchInt(move _4) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb15;
    }

    bb3: {
        _27 = deref_copy (_3.1: &ColorTree);
        _5 = discriminant((*_27));
        switchInt(move _5) -> [1: bb6, otherwise: bb2];
    }

    bb4: {
        _28 = deref_copy (_3.0: &ColorTree);
        _7 = &(((*_28) as leaf).0: Color);
        _29 = deref_copy (_3.1: &ColorTree);
        _8 = &(((*_29) as leaf).0: Color);
        _10 = <Color as Clone>::clone(_8) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = &_10;
        _0 = <Color as Equal>::isEq(_7, _9) -> [return: bb15, unwind continue];
    }

    bb6: {
        _30 = deref_copy (_3.0: &ColorTree);
        _11 = &(((*_30) as branch).0: std::boxed::Box<ColorTree>);
        _31 = deref_copy (_3.0: &ColorTree);
        _12 = &(((*_31) as branch).1: std::boxed::Box<ColorTree>);
        _32 = deref_copy (_3.1: &ColorTree);
        _13 = &(((*_32) as branch).0: std::boxed::Box<ColorTree>);
        _33 = deref_copy (_3.1: &ColorTree);
        _14 = &(((*_33) as branch).1: std::boxed::Box<ColorTree>);
        _34 = deref_copy (*_11);
        _38 = (((_34.0: std::ptr::Unique<ColorTree>).0: std::ptr::NonNull<ColorTree>).0: *const ColorTree);
        _60 = _38 as *const () (PtrToPtr);
        _61 = _60 as usize (Transmute);
        _62 = AlignOf(ColorTree);
        _63 = Sub(_62, const 1_usize);
        _64 = BitAnd(_61, _63);
        _65 = Eq(_64, const 0_usize);
        assert(_65, "misaligned pointer dereference: address must be a multiple of {} but is {}", _62, _61) -> [success: bb22, unwind unreachable];
    }

    bb7: {
        _0 = const false;
        goto -> bb15;
    }

    bb8: {
        _36 = deref_copy (*_12);
        _40 = (((_36.0: std::ptr::Unique<ColorTree>).0: std::ptr::NonNull<ColorTree>).0: *const ColorTree);
        _48 = _40 as *const () (PtrToPtr);
        _49 = _48 as usize (Transmute);
        _50 = AlignOf(ColorTree);
        _51 = Sub(_50, const 1_usize);
        _52 = BitAnd(_49, _51);
        _53 = Eq(_52, const 0_usize);
        assert(_53, "misaligned pointer dereference: address must be a multiple of {} but is {}", _50, _49) -> [success: bb20, unwind unreachable];
    }

    bb9: {
        _17 = &_18;
        _15 = <ColorTree as Equal>::isEq(move _16, _17) -> [return: bb10, unwind: bb17];
    }

    bb10: {
        drop(_18) -> [return: bb11, unwind continue];
    }

    bb11: {
        switchInt(move _15) -> [0: bb7, otherwise: bb8];
    }

    bb12: {
        _22 = &_23;
        _20 = <ColorTree as Equal>::isEq(move _21, _22) -> [return: bb13, unwind: bb16];
    }

    bb13: {
        drop(_23) -> [return: bb14, unwind continue];
    }

    bb14: {
        _0 = move _20;
        goto -> bb15;
    }

    bb15: {
        return;
    }

    bb16 (cleanup): {
        drop(_23) -> [return: bb18, unwind terminate];
    }

    bb17 (cleanup): {
        drop(_18) -> [return: bb18, unwind terminate];
    }

    bb18 (cleanup): {
        resume;
    }

    bb19: {
        _24 = &(*_41);
        _23 = <ColorTree as Clone>::clone(move _24) -> [return: bb12, unwind continue];
    }

    bb20: {
        _21 = &(*_40);
        _37 = deref_copy (*_14);
        _41 = (((_37.0: std::ptr::Unique<ColorTree>).0: std::ptr::NonNull<ColorTree>).0: *const ColorTree);
        _42 = _41 as *const () (PtrToPtr);
        _43 = _42 as usize (Transmute);
        _44 = AlignOf(ColorTree);
        _45 = Sub(_44, const 1_usize);
        _46 = BitAnd(_43, _45);
        _47 = Eq(_46, const 0_usize);
        assert(_47, "misaligned pointer dereference: address must be a multiple of {} but is {}", _44, _43) -> [success: bb19, unwind unreachable];
    }

    bb21: {
        _19 = &(*_39);
        _18 = <ColorTree as Clone>::clone(move _19) -> [return: bb9, unwind continue];
    }

    bb22: {
        _16 = &(*_38);
        _35 = deref_copy (*_13);
        _39 = (((_35.0: std::ptr::Unique<ColorTree>).0: std::ptr::NonNull<ColorTree>).0: *const ColorTree);
        _54 = _39 as *const () (PtrToPtr);
        _55 = _54 as usize (Transmute);
        _56 = AlignOf(ColorTree);
        _57 = Sub(_56, const 1_usize);
        _58 = BitAnd(_55, _57);
        _59 = Eq(_58, const 0_usize);
        assert(_59, "misaligned pointer dereference: address must be a multiple of {} but is {}", _56, _55) -> [success: bb21, unwind unreachable];
    }

    bb23: {
        unreachable;
    }
}

fn main() -> () {
    let mut _0: ();
    let mut _1: bool;
    let mut _2: bool;
    let mut _3: !;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: !;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: !;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: !;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: !;
    let mut _18: bool;
    let mut _19: bool;
    let mut _20: bool;
    let mut _21: !;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: &ColorTree;
    let _25: ColorTree;
    let mut _26: std::boxed::Box<ColorTree>;
    let mut _27: ColorTree;
    let mut _28: Color;
    let mut _29: std::boxed::Box<ColorTree>;
    let mut _30: ColorTree;
    let mut _31: Color;
    let _32: &ColorTree;
    let _33: ColorTree;
    let mut _34: std::boxed::Box<ColorTree>;
    let mut _35: ColorTree;
    let mut _36: Color;
    let mut _37: std::boxed::Box<ColorTree>;
    let mut _38: ColorTree;
    let mut _39: Color;
    let mut _40: !;
    let mut _41: bool;
    let mut _42: bool;
    let mut _43: bool;
    let mut _44: &ColorTree;
    let _45: ColorTree;
    let mut _46: std::boxed::Box<ColorTree>;
    let mut _47: ColorTree;
    let mut _48: Color;
    let mut _49: std::boxed::Box<ColorTree>;
    let mut _50: ColorTree;
    let mut _51: Color;
    let _52: &ColorTree;
    let _53: ColorTree;
    let mut _54: std::boxed::Box<ColorTree>;
    let mut _55: ColorTree;
    let mut _56: Color;
    let mut _57: std::boxed::Box<ColorTree>;
    let mut _58: ColorTree;
    let mut _59: Color;
    let mut _60: !;
    let _61: ();
    let mut _62: std::fmt::Arguments<'_>;
    let mut _63: &[&str];
    let mut _64: &[&str; 1];
    let mut _65: &ColorTree;
    let mut _66: &ColorTree;
    let mut _67: &ColorTree;
    let mut _68: &ColorTree;
    let mut _69: &Color;
    let mut _70: &Color;
    let mut _71: &Color;
    let mut _72: &Color;
    let mut _73: &Color;
    let mut _74: &Color;
    let mut _75: &Color;
    let mut _76: &Color;

    bb0: {
        _76 = const _;
        _75 = const _;
        _2 = <Color as Equal>::isEq(_76, _75) -> [return: bb1, unwind continue];
    }

    bb1: {
        _1 = Not(move _2);
        switchInt(move _1) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _3 = core::panicking::panic(const "assertion failed: cyan.isEq(&cyan)") -> unwind continue;
    }

    bb3: {
        _74 = const _;
        _73 = const _;
        _5 = <Color as Equal>::isEq(_74, _73) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = Not(move _5);
        switchInt(move _4) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _6 = core::panicking::panic(const "assertion failed: magenta.isEq(&magenta)") -> unwind continue;
    }

    bb6: {
        _72 = const _;
        _71 = const _;
        _9 = <Color as Equal>::isEq(_72, _71) -> [return: bb7, unwind continue];
    }

    bb7: {
        _8 = Not(move _9);
        _7 = Not(move _8);
        switchInt(move _7) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _10 = core::panicking::panic(const "assertion failed: !cyan.isEq(&yellow)") -> unwind continue;
    }

    bb9: {
        _70 = const _;
        _69 = const _;
        _13 = <Color as Equal>::isEq(_70, _69) -> [return: bb10, unwind continue];
    }

    bb10: {
        _12 = Not(move _13);
        _11 = Not(move _12);
        switchInt(move _11) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _14 = core::panicking::panic(const "assertion failed: !magenta.isEq(&cyan)") -> unwind continue;
    }

    bb12: {
        _68 = const _;
        _67 = const _;
        _16 = <ColorTree as Equal>::isEq(_68, _67) -> [return: bb13, unwind continue];
    }

    bb13: {
        _15 = Not(move _16);
        switchInt(move _15) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _17 = core::panicking::panic(const "assertion failed: leaf(cyan).isEq(&leaf(cyan))") -> unwind continue;
    }

    bb15: {
        _66 = const _;
        _65 = const _;
        _20 = <ColorTree as Equal>::isEq(_66, _65) -> [return: bb16, unwind continue];
    }

    bb16: {
        _19 = Not(move _20);
        _18 = Not(move _19);
        switchInt(move _18) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _21 = core::panicking::panic(const "assertion failed: !leaf(cyan).isEq(&leaf(yellow))") -> unwind continue;
    }

    bb18: {
        _28 = Color::magenta;
        _27 = ColorTree::leaf(move _28);
        _26 = Box::<ColorTree>::new(move _27) -> [return: bb19, unwind continue];
    }

    bb19: {
        _31 = Color::cyan;
        _30 = ColorTree::leaf(move _31);
        _29 = Box::<ColorTree>::new(move _30) -> [return: bb20, unwind: bb46];
    }

    bb20: {
        _25 = ColorTree::branch(move _26, move _29);
        _24 = &_25;
        _36 = Color::magenta;
        _35 = ColorTree::leaf(move _36);
        _34 = Box::<ColorTree>::new(move _35) -> [return: bb21, unwind: bb45];
    }

    bb21: {
        _39 = Color::cyan;
        _38 = ColorTree::leaf(move _39);
        _37 = Box::<ColorTree>::new(move _38) -> [return: bb22, unwind: bb44];
    }

    bb22: {
        _33 = ColorTree::branch(move _34, move _37);
        _32 = &_33;
        _23 = <ColorTree as Equal>::isEq(move _24, _32) -> [return: bb23, unwind: bb43];
    }

    bb23: {
        _22 = Not(move _23);
        drop(_33) -> [return: bb24, unwind: bb45];
    }

    bb24: {
        drop(_25) -> [return: bb25, unwind continue];
    }

    bb25: {
        switchInt(move _22) -> [0: bb27, otherwise: bb26];
    }

    bb26: {
        _40 = core::panicking::panic(const "assertion failed: branch(Box::new(leaf(magenta)),\\n        Box::new(leaf(cyan))).isEq(&branch(Box::new(leaf(magenta)),\\n            Box::new(leaf(cyan))))") -> unwind continue;
    }

    bb27: {
        _48 = Color::magenta;
        _47 = ColorTree::leaf(move _48);
        _46 = Box::<ColorTree>::new(move _47) -> [return: bb28, unwind continue];
    }

    bb28: {
        _51 = Color::cyan;
        _50 = ColorTree::leaf(move _51);
        _49 = Box::<ColorTree>::new(move _50) -> [return: bb29, unwind: bb42];
    }

    bb29: {
        _45 = ColorTree::branch(move _46, move _49);
        _44 = &_45;
        _56 = Color::magenta;
        _55 = ColorTree::leaf(move _56);
        _54 = Box::<ColorTree>::new(move _55) -> [return: bb30, unwind: bb41];
    }

    bb30: {
        _59 = Color::magenta;
        _58 = ColorTree::leaf(move _59);
        _57 = Box::<ColorTree>::new(move _58) -> [return: bb31, unwind: bb40];
    }

    bb31: {
        _53 = ColorTree::branch(move _54, move _57);
        _52 = &_53;
        _43 = <ColorTree as Equal>::isEq(move _44, _52) -> [return: bb32, unwind: bb39];
    }

    bb32: {
        _42 = Not(move _43);
        _41 = Not(move _42);
        drop(_53) -> [return: bb33, unwind: bb41];
    }

    bb33: {
        drop(_45) -> [return: bb34, unwind continue];
    }

    bb34: {
        switchInt(move _41) -> [0: bb36, otherwise: bb35];
    }

    bb35: {
        _60 = core::panicking::panic(const "assertion failed: !branch(Box::new(leaf(magenta)),\\n            Box::new(leaf(cyan))).isEq(&branch(Box::new(leaf(magenta)),\\n                Box::new(leaf(magenta))))") -> unwind continue;
    }

    bb36: {
        _64 = const _;
        _63 = _64 as &[&str] (Pointer(Unsize));
        _62 = Arguments::<'_>::new_const(move _63) -> [return: bb37, unwind continue];
    }

    bb37: {
        _61 = _print(move _62) -> [return: bb38, unwind continue];
    }

    bb38: {
        return;
    }

    bb39 (cleanup): {
        drop(_53) -> [return: bb41, unwind terminate];
    }

    bb40 (cleanup): {
        drop(_54) -> [return: bb41, unwind terminate];
    }

    bb41 (cleanup): {
        drop(_45) -> [return: bb47, unwind terminate];
    }

    bb42 (cleanup): {
        drop(_46) -> [return: bb47, unwind terminate];
    }

    bb43 (cleanup): {
        drop(_33) -> [return: bb45, unwind terminate];
    }

    bb44 (cleanup): {
        drop(_34) -> [return: bb45, unwind terminate];
    }

    bb45 (cleanup): {
        drop(_25) -> [return: bb47, unwind terminate];
    }

    bb46 (cleanup): {
        drop(_26) -> [return: bb47, unwind terminate];
    }

    bb47 (cleanup): {
        resume;
    }
}

promoted[0] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Assertions all succeeded!\n"];
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &ColorTree = {
    let mut _0: &ColorTree;
    let mut _1: ColorTree;
    let mut _2: Color;

    bb0: {
        _2 = Color::yellow;
        _1 = ColorTree::leaf(move _2);
        _0 = &_1;
        return;
    }
}

promoted[2] in main: &ColorTree = {
    let mut _0: &ColorTree;
    let mut _1: ColorTree;
    let mut _2: Color;

    bb0: {
        _2 = Color::cyan;
        _1 = ColorTree::leaf(move _2);
        _0 = &_1;
        return;
    }
}

promoted[3] in main: &ColorTree = {
    let mut _0: &ColorTree;
    let mut _1: ColorTree;
    let mut _2: Color;

    bb0: {
        _2 = Color::cyan;
        _1 = ColorTree::leaf(move _2);
        _0 = &_1;
        return;
    }
}

promoted[4] in main: &ColorTree = {
    let mut _0: &ColorTree;
    let mut _1: ColorTree;
    let mut _2: Color;

    bb0: {
        _2 = Color::cyan;
        _1 = ColorTree::leaf(move _2);
        _0 = &_1;
        return;
    }
}

promoted[5] in main: &Color = {
    let mut _0: &Color;
    let mut _1: Color;

    bb0: {
        _1 = Color::cyan;
        _0 = &_1;
        return;
    }
}

promoted[6] in main: &Color = {
    let mut _0: &Color;
    let mut _1: Color;

    bb0: {
        _1 = Color::magenta;
        _0 = &_1;
        return;
    }
}

promoted[7] in main: &Color = {
    let mut _0: &Color;
    let mut _1: Color;

    bb0: {
        _1 = Color::yellow;
        _0 = &_1;
        return;
    }
}

promoted[8] in main: &Color = {
    let mut _0: &Color;
    let mut _1: Color;

    bb0: {
        _1 = Color::cyan;
        _0 = &_1;
        return;
    }
}

promoted[9] in main: &Color = {
    let mut _0: &Color;
    let mut _1: Color;

    bb0: {
        _1 = Color::magenta;
        _0 = &_1;
        return;
    }
}

promoted[10] in main: &Color = {
    let mut _0: &Color;
    let mut _1: Color;

    bb0: {
        _1 = Color::magenta;
        _0 = &_1;
        return;
    }
}

promoted[11] in main: &Color = {
    let mut _0: &Color;
    let mut _1: Color;

    bb0: {
        _1 = Color::cyan;
        _0 = &_1;
        return;
    }
}

promoted[12] in main: &Color = {
    let mut _0: &Color;
    let mut _1: Color;

    bb0: {
        _1 = Color::cyan;
        _0 = &_1;
        return;
    }
}

fn ColorTree::leaf(_1: Color) -> ColorTree {
    let mut _0: ColorTree;

    bb0: {
        _0 = ColorTree::leaf(move _1);
        return;
    }
}

// MIR FOR CTFE
fn ColorTree::leaf(_1: Color) -> ColorTree {
    let mut _0: ColorTree;

    bb0: {
        _0 = ColorTree::leaf(move _1);
        return;
    }
}

fn ColorTree::branch(_1: Box<ColorTree>, _2: Box<ColorTree>) -> ColorTree {
    let mut _0: ColorTree;

    bb0: {
        _0 = ColorTree::branch(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn ColorTree::branch(_1: Box<ColorTree>, _2: Box<ColorTree>) -> ColorTree {
    let mut _0: ColorTree;

    bb0: {
        _0 = ColorTree::branch(move _1, move _2);
        return;
    }
}
