// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/traits/to-str.rs:9:1: 9:22>::to_string_(_1: &isize) -> String {
    debug self => _1;
    let mut _0: std::string::String;

    bb0: {
        _0 = <isize as ToString>::to_string(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/traits/to-str.rs:13:1: 13:33>::to_string_(_1: &Vec<T>) -> String {
    debug self => _1;
    let mut _0: std::string::String;
    let _2: std::string::String;
    let mut _3: std::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 1];
    let _7: [core::fmt::rt::Argument<'_>; 1];
    let mut _8: core::fmt::rt::Argument<'_>;
    let _9: &std::string::String;
    let _10: std::string::String;
    let mut _11: &[std::string::String];
    let _12: &[std::string::String];
    let mut _13: &std::vec::Vec<std::string::String>;
    let _14: std::vec::Vec<std::string::String>;
    let mut _15: std::iter::Map<std::slice::Iter<'_, T>, [closure@ui/traits/to-str.rs:17:26: 17:29]>;
    let mut _16: std::slice::Iter<'_, T>;
    let mut _17: &[T];
    let _18: &[T];
    let _19: &str;
    let mut _20: &[&str; 2];
    scope 1 {
        debug res => _2;
    }

    bb0: {
        _20 = const _;
        _4 = _20 as &[&str] (Pointer(Unsize));
        _18 = <Vec<T> as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _17 = _18;
        _16 = core::slice::<impl [T]>::iter(move _17) -> [return: bb2, unwind continue];
    }

    bb2: {
        _15 = <std::slice::Iter<'_, T> as Iterator>::map::<String, [closure@ui/traits/to-str.rs:17:26: 17:29]>(move _16, const ZeroSized: [closure@ui/traits/to-str.rs:17:26: 17:29]) -> [return: bb3, unwind continue];
    }

    bb3: {
        _14 = <Map<std::slice::Iter<'_, T>, [closure@ui/traits/to-str.rs:17:26: 17:29]> as Iterator>::collect::<Vec<String>>(move _15) -> [return: bb4, unwind continue];
    }

    bb4: {
        _13 = &_14;
        _12 = <Vec<String> as Deref>::deref(move _13) -> [return: bb5, unwind: bb15];
    }

    bb5: {
        _11 = _12;
        _19 = const ", ";
        _10 = slice::<impl [String]>::join::<&str>(move _11, _19) -> [return: bb6, unwind: bb15];
    }

    bb6: {
        _9 = &_10;
        _8 = core::fmt::rt::Argument::<'_>::new_display::<String>(_9) -> [return: bb7, unwind: bb14];
    }

    bb7: {
        _7 = [move _8];
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _3 = Arguments::<'_>::new_v1(move _4, move _5) -> [return: bb8, unwind: bb14];
    }

    bb8: {
        _2 = format(move _3) -> [return: bb9, unwind: bb14];
    }

    bb9: {
        drop(_10) -> [return: bb10, unwind: bb12];
    }

    bb10: {
        drop(_14) -> [return: bb11, unwind: bb13];
    }

    bb11: {
        _0 = move _2;
        return;
    }

    bb12 (cleanup): {
        drop(_14) -> [return: bb13, unwind terminate];
    }

    bb13 (cleanup): {
        drop(_2) -> [return: bb16, unwind terminate];
    }

    bb14 (cleanup): {
        drop(_10) -> [return: bb15, unwind terminate];
    }

    bb15 (cleanup): {
        drop(_14) -> [return: bb16, unwind terminate];
    }

    bb16 (cleanup): {
        resume;
    }
}

promoted[0] in <impl at ui/traits/to-str.rs:13:1: 13:33>::to_string_: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "[", const "]"];
        _0 = &_1;
        return;
    }
}

fn <impl at ui/traits/to-str.rs:13:1: 13:33>::to_string_::{closure#0}(_1: &mut [closure@ui/traits/to-str.rs:17:26: 17:29], _2: &T) -> String {
    debug e => _2;
    let mut _0: std::string::String;

    bb0: {
        _0 = <T as to_str>::to_string_(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let mut _1: (&std::string::String, &std::string::String);
    let mut _2: &std::string::String;
    let _3: std::string::String;
    let mut _4: &std::string::String;
    let _5: std::string::String;
    let _6: &str;
    let _7: &std::string::String;
    let _8: &std::string::String;
    let mut _9: bool;
    let mut _10: bool;
    let _12: !;
    let mut _13: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _14: (&std::string::String, &std::string::String);
    let mut _15: &std::string::String;
    let _16: std::string::String;
    let mut _17: &std::vec::Vec<isize>;
    let _18: std::vec::Vec<isize>;
    let mut _19: std::boxed::Box<[isize]>;
    let mut _20: usize;
    let mut _21: usize;
    let mut _22: *mut u8;
    let mut _23: std::boxed::Box<[isize; 3]>;
    let mut _24: &std::string::String;
    let _25: std::string::String;
    let _26: &str;
    let _27: &std::string::String;
    let _28: &std::string::String;
    let mut _29: bool;
    let mut _30: bool;
    let _32: !;
    let mut _33: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _34: (&std::string::String, &std::string::String);
    let mut _35: &std::string::String;
    let _36: std::string::String;
    let mut _37: std::vec::Vec<isize>;
    let mut _38: std::boxed::Box<[isize]>;
    let mut _39: usize;
    let mut _40: usize;
    let mut _41: *mut u8;
    let mut _42: std::boxed::Box<[isize; 2]>;
    let mut _43: &std::string::String;
    let _44: std::string::String;
    let _45: &str;
    let _46: &std::string::String;
    let _47: &std::string::String;
    let mut _48: bool;
    let mut _49: bool;
    let _51: !;
    let mut _52: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _53: (&std::string::String, &std::string::String);
    let mut _54: &std::string::String;
    let _55: std::string::String;
    let mut _56: std::vec::Vec<isize>;
    let mut _57: std::boxed::Box<[isize]>;
    let mut _58: usize;
    let mut _59: usize;
    let mut _60: *mut u8;
    let mut _61: std::boxed::Box<[isize; 1]>;
    let mut _62: &std::string::String;
    let _63: std::string::String;
    let _64: &str;
    let _65: &std::string::String;
    let _66: &std::string::String;
    let mut _67: bool;
    let mut _68: bool;
    let _70: !;
    let mut _71: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _72: &isize;
    let mut _73: *const [isize; 3];
    let mut _74: *const [isize; 2];
    let mut _75: *const [isize; 1];
    let mut _76: *const ();
    let mut _77: usize;
    let mut _78: usize;
    let mut _79: usize;
    let mut _80: usize;
    let mut _81: bool;
    let mut _82: *const ();
    let mut _83: usize;
    let mut _84: usize;
    let mut _85: usize;
    let mut _86: usize;
    let mut _87: bool;
    let mut _88: *const ();
    let mut _89: usize;
    let mut _90: usize;
    let mut _91: usize;
    let mut _92: usize;
    let mut _93: bool;
    scope 1 {
        debug left_val => _7;
        debug right_val => _8;
        let _11: core::panicking::AssertKind;
        scope 2 {
            debug kind => _11;
        }
    }
    scope 3 {
    }
    scope 4 {
        debug left_val => _27;
        debug right_val => _28;
        let _31: core::panicking::AssertKind;
        scope 5 {
            debug kind => _31;
        }
    }
    scope 6 {
    }
    scope 7 {
        debug left_val => _46;
        debug right_val => _47;
        let _50: core::panicking::AssertKind;
        scope 8 {
            debug kind => _50;
        }
    }
    scope 9 {
    }
    scope 10 {
        debug left_val => _65;
        debug right_val => _66;
        let _69: core::panicking::AssertKind;
        scope 11 {
            debug kind => _69;
        }
    }

    bb0: {
        _72 = const _;
        _3 = <isize as to_str>::to_string_(_72) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = &_3;
        _6 = const "1";
        _5 = <str as ToString>::to_string(_6) -> [return: bb2, unwind: bb44];
    }

    bb2: {
        _4 = &_5;
        _1 = (move _2, move _4);
        _7 = (_1.0: &std::string::String);
        _8 = (_1.1: &std::string::String);
        _10 = <String as PartialEq>::eq(_7, _8) -> [return: bb3, unwind: bb43];
    }

    bb3: {
        _9 = Not(move _10);
        switchInt(move _9) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _11 = core::panicking::AssertKind::Eq;
        _13 = Option::<Arguments<'_>>::None;
        _12 = core::panicking::assert_failed::<String, String>(move _11, _7, _8, move _13) -> bb43;
    }

    bb5: {
        drop(_5) -> [return: bb6, unwind: bb44];
    }

    bb6: {
        drop(_3) -> [return: bb7, unwind continue];
    }

    bb7: {
        _20 = SizeOf([isize; 3]);
        _21 = AlignOf([isize; 3]);
        _22 = alloc::alloc::exchange_malloc(move _20, move _21) -> [return: bb8, unwind continue];
    }

    bb8: {
        _23 = ShallowInitBox(move _22, [isize; 3]);
        _73 = (((_23.0: std::ptr::Unique<[isize; 3]>).0: std::ptr::NonNull<[isize; 3]>).0: *const [isize; 3]);
        _88 = _73 as *const () (PtrToPtr);
        _89 = _88 as usize (Transmute);
        _90 = AlignOf(isize);
        _91 = Sub(_90, const 1_usize);
        _92 = BitAnd(_89, _91);
        _93 = Eq(_92, const 0_usize);
        assert(_93, "misaligned pointer dereference: address must be a multiple of {} but is {}", _90, _89) -> [success: bb48, unwind unreachable];
    }

    bb9: {
        _17 = &_18;
        _16 = <Vec<isize> as to_str>::to_string_(move _17) -> [return: bb10, unwind: bb42];
    }

    bb10: {
        _15 = &_16;
        _26 = const "[2, 3, 4]";
        _25 = <str as ToString>::to_string(_26) -> [return: bb11, unwind: bb41];
    }

    bb11: {
        _24 = &_25;
        _14 = (move _15, move _24);
        _27 = (_14.0: &std::string::String);
        _28 = (_14.1: &std::string::String);
        _30 = <String as PartialEq>::eq(_27, _28) -> [return: bb12, unwind: bb40];
    }

    bb12: {
        _29 = Not(move _30);
        switchInt(move _29) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _31 = core::panicking::AssertKind::Eq;
        _33 = Option::<Arguments<'_>>::None;
        _32 = core::panicking::assert_failed::<String, String>(move _31, _27, _28, move _33) -> bb40;
    }

    bb14: {
        drop(_25) -> [return: bb15, unwind: bb41];
    }

    bb15: {
        drop(_16) -> [return: bb16, unwind: bb42];
    }

    bb16: {
        drop(_18) -> [return: bb17, unwind continue];
    }

    bb17: {
        _39 = SizeOf([isize; 2]);
        _40 = AlignOf([isize; 2]);
        _41 = alloc::alloc::exchange_malloc(move _39, move _40) -> [return: bb18, unwind continue];
    }

    bb18: {
        _42 = ShallowInitBox(move _41, [isize; 2]);
        _74 = (((_42.0: std::ptr::Unique<[isize; 2]>).0: std::ptr::NonNull<[isize; 2]>).0: *const [isize; 2]);
        _82 = _74 as *const () (PtrToPtr);
        _83 = _82 as usize (Transmute);
        _84 = AlignOf(isize);
        _85 = Sub(_84, const 1_usize);
        _86 = BitAnd(_83, _85);
        _87 = Eq(_86, const 0_usize);
        assert(_87, "misaligned pointer dereference: address must be a multiple of {} but is {}", _84, _83) -> [success: bb47, unwind unreachable];
    }

    bb19: {
        _36 = indirect::<Vec<isize>>(move _37) -> [return: bb20, unwind continue];
    }

    bb20: {
        _35 = &_36;
        _45 = const "[10, 20]!";
        _44 = <str as ToString>::to_string(_45) -> [return: bb21, unwind: bb39];
    }

    bb21: {
        _43 = &_44;
        _34 = (move _35, move _43);
        _46 = (_34.0: &std::string::String);
        _47 = (_34.1: &std::string::String);
        _49 = <String as PartialEq>::eq(_46, _47) -> [return: bb22, unwind: bb38];
    }

    bb22: {
        _48 = Not(move _49);
        switchInt(move _48) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _50 = core::panicking::AssertKind::Eq;
        _52 = Option::<Arguments<'_>>::None;
        _51 = core::panicking::assert_failed::<String, String>(move _50, _46, _47, move _52) -> bb38;
    }

    bb24: {
        drop(_44) -> [return: bb25, unwind: bb39];
    }

    bb25: {
        drop(_36) -> [return: bb26, unwind continue];
    }

    bb26: {
        _58 = SizeOf([isize; 1]);
        _59 = AlignOf([isize; 1]);
        _60 = alloc::alloc::exchange_malloc(move _58, move _59) -> [return: bb27, unwind continue];
    }

    bb27: {
        _61 = ShallowInitBox(move _60, [isize; 1]);
        _75 = (((_61.0: std::ptr::Unique<[isize; 1]>).0: std::ptr::NonNull<[isize; 1]>).0: *const [isize; 1]);
        _76 = _75 as *const () (PtrToPtr);
        _77 = _76 as usize (Transmute);
        _78 = AlignOf(isize);
        _79 = Sub(_78, const 1_usize);
        _80 = BitAnd(_77, _79);
        _81 = Eq(_80, const 0_usize);
        assert(_81, "misaligned pointer dereference: address must be a multiple of {} but is {}", _78, _77) -> [success: bb46, unwind unreachable];
    }

    bb28: {
        _55 = indirect2::<Vec<isize>>(move _56) -> [return: bb29, unwind continue];
    }

    bb29: {
        _54 = &_55;
        _64 = const "[1]!";
        _63 = <str as ToString>::to_string(_64) -> [return: bb30, unwind: bb37];
    }

    bb30: {
        _62 = &_63;
        _53 = (move _54, move _62);
        _65 = (_53.0: &std::string::String);
        _66 = (_53.1: &std::string::String);
        _68 = <String as PartialEq>::eq(_65, _66) -> [return: bb31, unwind: bb36];
    }

    bb31: {
        _67 = Not(move _68);
        switchInt(move _67) -> [0: bb33, otherwise: bb32];
    }

    bb32: {
        _69 = core::panicking::AssertKind::Eq;
        _71 = Option::<Arguments<'_>>::None;
        _70 = core::panicking::assert_failed::<String, String>(move _69, _65, _66, move _71) -> bb36;
    }

    bb33: {
        drop(_63) -> [return: bb34, unwind: bb37];
    }

    bb34: {
        drop(_55) -> [return: bb35, unwind continue];
    }

    bb35: {
        return;
    }

    bb36 (cleanup): {
        drop(_63) -> [return: bb37, unwind terminate];
    }

    bb37 (cleanup): {
        drop(_55) -> [return: bb45, unwind terminate];
    }

    bb38 (cleanup): {
        drop(_44) -> [return: bb39, unwind terminate];
    }

    bb39 (cleanup): {
        drop(_36) -> [return: bb45, unwind terminate];
    }

    bb40 (cleanup): {
        drop(_25) -> [return: bb41, unwind terminate];
    }

    bb41 (cleanup): {
        drop(_16) -> [return: bb42, unwind terminate];
    }

    bb42 (cleanup): {
        drop(_18) -> [return: bb45, unwind terminate];
    }

    bb43 (cleanup): {
        drop(_5) -> [return: bb44, unwind terminate];
    }

    bb44 (cleanup): {
        drop(_3) -> [return: bb45, unwind terminate];
    }

    bb45 (cleanup): {
        resume;
    }

    bb46: {
        (*_75) = [const 1_isize];
        _57 = move _61 as std::boxed::Box<[isize]> (Pointer(Unsize));
        _56 = slice::<impl [isize]>::into_vec::<std::alloc::Global>(move _57) -> [return: bb28, unwind continue];
    }

    bb47: {
        (*_74) = [const 10_isize, const 20_isize];
        _38 = move _42 as std::boxed::Box<[isize]> (Pointer(Unsize));
        _37 = slice::<impl [isize]>::into_vec::<std::alloc::Global>(move _38) -> [return: bb19, unwind continue];
    }

    bb48: {
        (*_73) = [const 2_isize, const 3_isize, const 4_isize];
        _19 = move _23 as std::boxed::Box<[isize]> (Pointer(Unsize));
        _18 = slice::<impl [isize]>::into_vec::<std::alloc::Global>(move _19) -> [return: bb9, unwind continue];
    }
}

promoted[0] in main: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 1_isize;
        _0 = &_1;
        return;
    }
}

fn indirect(_1: T) -> String {
    debug x => _1;
    let mut _0: std::string::String;
    let _2: std::string::String;
    let mut _3: std::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 1];
    let _7: [core::fmt::rt::Argument<'_>; 1];
    let mut _8: core::fmt::rt::Argument<'_>;
    let _9: &std::string::String;
    let _10: std::string::String;
    let mut _11: &T;
    let mut _12: &[&str; 2];
    scope 1 {
        debug res => _2;
    }

    bb0: {
        _12 = const _;
        _4 = _12 as &[&str] (Pointer(Unsize));
        _11 = &_1;
        _10 = <T as to_str>::to_string_(move _11) -> [return: bb1, unwind: bb9];
    }

    bb1: {
        _9 = &_10;
        _8 = core::fmt::rt::Argument::<'_>::new_display::<String>(_9) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _7 = [move _8];
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _3 = Arguments::<'_>::new_v1(move _4, move _5) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _2 = format(move _3) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        drop(_10) -> [return: bb5, unwind: bb7];
    }

    bb5: {
        _0 = move _2;
        drop(_1) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb9, unwind terminate];
    }

    bb8 (cleanup): {
        drop(_10) -> [return: bb9, unwind terminate];
    }

    bb9 (cleanup): {
        drop(_1) -> [return: bb10, unwind terminate];
    }

    bb10 (cleanup): {
        resume;
    }
}

promoted[0] in indirect: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "!"];
        _0 = &_1;
        return;
    }
}

fn indirect2(_1: T) -> String {
    debug x => _1;
    let mut _0: std::string::String;

    bb0: {
        _0 = indirect::<T>(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}
