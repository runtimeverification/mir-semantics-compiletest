// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
static FLAG: std::sync::atomic::AtomicBool = {
    let mut _0: std::sync::atomic::AtomicBool; // return place in scope 0 at ui/consts/promoted_const_call4.rs:5:14: 5:24

    bb0: {
        ConstEvalCounter;                // scope 0 at ui/consts/promoted_const_call4.rs:5:27: 5:49
        _0 = std::sync::atomic::AtomicBool::new(const false) -> bb1; // scope 0 at ui/consts/promoted_const_call4.rs:5:27: 5:49
                                         // mir::Constant
                                         // + span: ui/consts/promoted_const_call4.rs:5:27: 5:42
                                         // + literal: Const { ty: fn(bool) -> std::sync::atomic::AtomicBool {std::sync::atomic::AtomicBool::new}, val: Value(<ZST>) }
    }

    bb1: {
        return;                          // scope 0 at ui/consts/promoted_const_call4.rs:5:1: 5:50
    }
}

fn <impl at ui/consts/promoted_const_call4.rs:8:1: 8:24>::drop(_1: &mut NoisyDrop) -> () {
    debug self => _1;                    // in scope 0 at ui/consts/promoted_const_call4.rs:9:13: 9:22
    let mut _0: ();                      // return place in scope 0 at ui/consts/promoted_const_call4.rs:9:24: 9:24
    let _2: ();                          // in scope 0 at ui/consts/promoted_const_call4.rs:10:9: 10:43
    let mut _3: &std::sync::atomic::AtomicBool; // in scope 0 at ui/consts/promoted_const_call4.rs:10:9: 10:43
    let _4: &std::sync::atomic::AtomicBool; // in scope 0 at ui/consts/promoted_const_call4.rs:10:9: 10:13
    let mut _5: std::sync::atomic::Ordering; // in scope 0 at ui/consts/promoted_const_call4.rs:10:26: 10:42

    bb0: {
        _4 = const {alloc1: &std::sync::atomic::AtomicBool}; // scope 0 at ui/consts/promoted_const_call4.rs:10:9: 10:13
                                         // mir::Constant
                                         // + span: ui/consts/promoted_const_call4.rs:10:9: 10:13
                                         // + literal: Const { ty: &std::sync::atomic::AtomicBool, val: Value(Scalar(alloc1)) }
        _3 = _4;                         // scope 0 at ui/consts/promoted_const_call4.rs:10:9: 10:43
        _5 = const SeqCst;               // scope 0 at ui/consts/promoted_const_call4.rs:10:26: 10:42
                                         // mir::Constant
                                         // + span: ui/consts/promoted_const_call4.rs:10:26: 10:42
                                         // + literal: Const { ty: std::sync::atomic::Ordering, val: Value(Scalar(0x04)) }
        _2 = std::sync::atomic::AtomicBool::store(move _3, const true, move _5) -> bb1; // scope 0 at ui/consts/promoted_const_call4.rs:10:9: 10:43
                                         // mir::Constant
                                         // + span: ui/consts/promoted_const_call4.rs:10:14: 10:19
                                         // + literal: Const { ty: for<'a> fn(&'a std::sync::atomic::AtomicBool, bool, std::sync::atomic::Ordering) {std::sync::atomic::AtomicBool::store}, val: Value(<ZST>) }
    }

    bb1: {
        return;                          // scope 0 at ui/consts/promoted_const_call4.rs:11:6: 11:6
    }
}

alloc1 (static: FLAG, size: 1, align: 1) {
    00                                              │ .
}

fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/consts/promoted_const_call4.rs:13:11: 13:11
    let _1: &&i32;                       // in scope 0 at ui/consts/promoted_const_call4.rs:15:13: 15:17
    let _2: &i32;                        // in scope 0 at ui/consts/promoted_const_call4.rs:15:21: 15:47
    let _3: (NoisyDrop, i32);            // in scope 0 at ui/consts/promoted_const_call4.rs:15:22: 15:45
    let mut _4: NoisyDrop;               // in scope 0 at ui/consts/promoted_const_call4.rs:15:23: 15:41
    let mut _5: bool;                    // in scope 0 at ui/consts/promoted_const_call4.rs:17:5: 17:41
    let mut _6: bool;                    // in scope 0 at ui/consts/promoted_const_call4.rs:17:13: 17:40
    let mut _7: &std::sync::atomic::AtomicBool; // in scope 0 at ui/consts/promoted_const_call4.rs:17:13: 17:40
    let _8: &std::sync::atomic::AtomicBool; // in scope 0 at ui/consts/promoted_const_call4.rs:17:13: 17:17
    let mut _9: std::sync::atomic::Ordering; // in scope 0 at ui/consts/promoted_const_call4.rs:17:23: 17:39
    let mut _10: !;                      // in scope 0 at ui/consts/promoted_const_call4.rs:17:5: 17:41
    scope 1 {
        debug _val => _1;                // in scope 1 at ui/consts/promoted_const_call4.rs:15:13: 15:17
    }

    bb0: {
        _4 = NoisyDrop(const "drop!");   // scope 0 at ui/consts/promoted_const_call4.rs:15:23: 15:41
                                         // mir::Constant
                                         // + span: ui/consts/promoted_const_call4.rs:15:33: 15:40
                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }
        _3 = (move _4, const 0_i32);     // scope 0 at ui/consts/promoted_const_call4.rs:15:22: 15:45
        _2 = &(_3.1: i32);               // scope 0 at ui/consts/promoted_const_call4.rs:15:21: 15:47
        _1 = &_2;                        // scope 0 at ui/consts/promoted_const_call4.rs:15:20: 15:47
        drop(_3) -> bb1;                 // scope 0 at ui/consts/promoted_const_call4.rs:16:5: 16:6
    }

    bb1: {
        _8 = const {alloc1: &std::sync::atomic::AtomicBool}; // scope 0 at ui/consts/promoted_const_call4.rs:17:13: 17:17
                                         // mir::Constant
                                         // + span: ui/consts/promoted_const_call4.rs:17:13: 17:17
                                         // + literal: Const { ty: &std::sync::atomic::AtomicBool, val: Value(Scalar(alloc1)) }
        _7 = _8;                         // scope 0 at ui/consts/promoted_const_call4.rs:17:13: 17:40
        _9 = const SeqCst;               // scope 0 at ui/consts/promoted_const_call4.rs:17:23: 17:39
                                         // mir::Constant
                                         // + span: ui/consts/promoted_const_call4.rs:17:23: 17:39
                                         // + literal: Const { ty: std::sync::atomic::Ordering, val: Value(Scalar(0x04)) }
        _6 = std::sync::atomic::AtomicBool::load(move _7, move _9) -> bb2; // scope 0 at ui/consts/promoted_const_call4.rs:17:13: 17:40
                                         // mir::Constant
                                         // + span: ui/consts/promoted_const_call4.rs:17:18: 17:22
                                         // + literal: Const { ty: for<'a> fn(&'a std::sync::atomic::AtomicBool, std::sync::atomic::Ordering) -> bool {std::sync::atomic::AtomicBool::load}, val: Value(<ZST>) }
    }

    bb2: {
        _5 = Not(move _6);               // scope 0 at ui/consts/promoted_const_call4.rs:17:5: 17:41
        switchInt(move _5) -> [0: bb4, otherwise: bb3]; // scope 0 at ui/consts/promoted_const_call4.rs:17:5: 17:41
    }

    bb3: {
        _10 = core::panicking::panic(const "assertion failed: FLAG.load(Ordering::SeqCst)"); // scope 0 at ui/consts/promoted_const_call4.rs:17:5: 17:41
                                         // mir::Constant
                                         // + span: ui/consts/promoted_const_call4.rs:17:5: 17:41
                                         // + literal: Const { ty: fn(&'static str) -> ! {core::panicking::panic}, val: Value(<ZST>) }
                                         // mir::Constant
                                         // + span: no-location
                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }
    }

    bb4: {
        return;                          // scope 0 at ui/consts/promoted_const_call4.rs:18:2: 18:2
    }
}

alloc1 (static: FLAG, size: 1, align: 1) {
    00                                              │ .
}

fn NoisyDrop(_1: &str) -> NoisyDrop {
    let mut _0: NoisyDrop;               // return place in scope 0 at ui/consts/promoted_const_call4.rs:7:1: 7:17

    bb0: {
        _0 = NoisyDrop(move _1);         // scope 0 at ui/consts/promoted_const_call4.rs:7:1: 7:17
        return;                          // scope 0 at ui/consts/promoted_const_call4.rs:7:1: 7:17
    }
}

// MIR FOR CTFE
fn NoisyDrop(_1: &str) -> NoisyDrop {
    let mut _0: NoisyDrop;               // return place in scope 0 at ui/consts/promoted_const_call4.rs:7:1: 7:17

    bb0: {
        _0 = NoisyDrop(move _1);         // scope 0 at ui/consts/promoted_const_call4.rs:7:1: 7:17
        return;                          // scope 0 at ui/consts/promoted_const_call4.rs:7:1: 7:17
    }
}
