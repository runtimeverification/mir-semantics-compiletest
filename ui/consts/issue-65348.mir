// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
const <impl at ui/consts/issue-65348.rs:5:1: 5:19>::ARRAY: [T; 0] = {
    let mut _0: [T; 0];                  // return place in scope 0 at ui/consts/issue-65348.rs:6:18: 6:24

    bb0: {
        _0 = [];                         // scope 0 at ui/consts/issue-65348.rs:6:27: 6:29
        return;                          // scope 0 at ui/consts/issue-65348.rs:6:5: 6:30
    }
}

<impl at ui/consts/issue-65348.rs:5:1: 5:19>::ARRAY::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/consts/issue-65348.rs:6:22: 6:23

    bb0: {
        _0 = const 0_usize;              // scope 0 at ui/consts/issue-65348.rs:6:22: 6:23
        return;                          // scope 0 at ui/consts/issue-65348.rs:6:22: 6:23
    }
}

const <impl at ui/consts/issue-65348.rs:5:1: 5:19>::NEWTYPE_ARRAY: Generic<[T; 0]> = {
    let mut _0: Generic<[T; 0]>;         // return place in scope 0 at ui/consts/issue-65348.rs:7:26: 7:41
    let mut _1: [T; 0];                  // in scope 0 at ui/consts/issue-65348.rs:7:52: 7:54

    bb0: {
        StorageLive(_1);                 // scope 0 at ui/consts/issue-65348.rs:7:52: 7:54
        _1 = [];                         // scope 0 at ui/consts/issue-65348.rs:7:52: 7:54
        _0 = Generic::<[T; 0]>(move _1); // scope 0 at ui/consts/issue-65348.rs:7:44: 7:55
        StorageDead(_1);                 // scope 0 at ui/consts/issue-65348.rs:7:54: 7:55
        return;                          // scope 0 at ui/consts/issue-65348.rs:7:5: 7:56
    }
}

<impl at ui/consts/issue-65348.rs:5:1: 5:19>::NEWTYPE_ARRAY::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/consts/issue-65348.rs:7:38: 7:39

    bb0: {
        _0 = const 0_usize;              // scope 0 at ui/consts/issue-65348.rs:7:38: 7:39
        return;                          // scope 0 at ui/consts/issue-65348.rs:7:38: 7:39
    }
}

const <impl at ui/consts/issue-65348.rs:5:1: 5:19>::ARRAY_FIELD: Generic<(i32, [T; 0])> = {
    let mut _0: Generic<(i32, [T; 0])>;  // return place in scope 0 at ui/consts/issue-65348.rs:8:24: 8:46
    let mut _1: (i32, [T; 0]);           // in scope 0 at ui/consts/issue-65348.rs:8:57: 8:64
    let mut _2: [T; 0];                  // in scope 0 at ui/consts/issue-65348.rs:8:61: 8:63

    bb0: {
        StorageLive(_1);                 // scope 0 at ui/consts/issue-65348.rs:8:57: 8:64
        StorageLive(_2);                 // scope 0 at ui/consts/issue-65348.rs:8:61: 8:63
        _2 = [];                         // scope 0 at ui/consts/issue-65348.rs:8:61: 8:63
        _1 = (const 0_i32, move _2);     // scope 0 at ui/consts/issue-65348.rs:8:57: 8:64
        StorageDead(_2);                 // scope 0 at ui/consts/issue-65348.rs:8:63: 8:64
        _0 = Generic::<(i32, [T; 0])>(move _1); // scope 0 at ui/consts/issue-65348.rs:8:49: 8:65
        StorageDead(_1);                 // scope 0 at ui/consts/issue-65348.rs:8:64: 8:65
        return;                          // scope 0 at ui/consts/issue-65348.rs:8:5: 8:66
    }
}

<impl at ui/consts/issue-65348.rs:5:1: 5:19>::ARRAY_FIELD::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at ui/consts/issue-65348.rs:8:42: 8:43

    bb0: {
        _0 = const 0_usize;              // scope 0 at ui/consts/issue-65348.rs:8:42: 8:43
        return;                          // scope 0 at ui/consts/issue-65348.rs:8:42: 8:43
    }
}

fn array() -> &T {
    let mut _0: &T;                      // return place in scope 0 at ui/consts/issue-65348.rs:12:5: 12:28
    let _1: usize;                       // in scope 0 at ui/consts/issue-65348.rs:12:26: 12:27
    let mut _2: usize;                   // in scope 0 at ui/consts/issue-65348.rs:12:6: 12:28
    let mut _3: bool;                    // in scope 0 at ui/consts/issue-65348.rs:12:6: 12:28
    let mut _4: &[T; 0];                 // in scope 0 at ui/consts/issue-65348.rs:12:5: 12:28

    bb0: {
        _1 = const 0_usize;              // scope 0 at ui/consts/issue-65348.rs:12:26: 12:27
        _2 = const 0_usize;              // scope 0 at ui/consts/issue-65348.rs:12:6: 12:28
        _3 = const false;                // scope 0 at ui/consts/issue-65348.rs:12:6: 12:28
        assert(move _3, "index out of bounds: the length is {} but the index is {}", move _2, _1) -> bb1; // scope 0 at ui/consts/issue-65348.rs:12:6: 12:28
    }

    bb1: {
        _4 = const _;                    // scope 0 at ui/consts/issue-65348.rs:12:5: 12:28
                                         // mir::Constant
                                         // + span: ui/consts/issue-65348.rs:12:5: 12:28
                                         // + literal: Const { ty: &[T; 0], val: Unevaluated(array, [T], Some(promoted[0])) }
        _0 = &(*_4)[_1];                 // scope 0 at ui/consts/issue-65348.rs:12:5: 12:28
        return;                          // scope 0 at ui/consts/issue-65348.rs:13:2: 13:2
    }
}

promoted[0] in array: &[T; 0] = {
    let mut _0: &[T; 0];                 // return place in scope 0 at ui/consts/issue-65348.rs:12:5: 12:28
    let mut _1: [T; 0];                  // in scope 0 at ui/consts/issue-65348.rs:12:6: 12:25

    bb0: {
        _1 = const _;                    // scope 0 at ui/consts/issue-65348.rs:12:6: 12:25
                                         // mir::Constant
                                         // + span: ui/consts/issue-65348.rs:12:6: 12:25
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: [T; 0], val: Unevaluated(Generic::<T>::ARRAY, [T], None) }
        _0 = &_1;                        // scope 0 at ui/consts/issue-65348.rs:12:5: 12:28
        return;                          // scope 0 at ui/consts/issue-65348.rs:12:5: 12:28
    }
}

// MIR FOR CTFE
fn array() -> &T {
    let mut _0: &T;                      // return place in scope 0 at ui/consts/issue-65348.rs:11:29: 11:39
    let _1: &T;                          // in scope 0 at ui/consts/issue-65348.rs:12:5: 12:28
    let _2: [T; 0];                      // in scope 0 at ui/consts/issue-65348.rs:12:6: 12:25
    let _3: usize;                       // in scope 0 at ui/consts/issue-65348.rs:12:26: 12:27
    let mut _4: usize;                   // in scope 0 at ui/consts/issue-65348.rs:12:6: 12:28
    let mut _5: bool;                    // in scope 0 at ui/consts/issue-65348.rs:12:6: 12:28
    let mut _6: &[T; 0];                 // in scope 0 at ui/consts/issue-65348.rs:12:5: 12:28

    bb0: {
        StorageLive(_1);                 // scope 0 at ui/consts/issue-65348.rs:12:5: 12:28
        StorageLive(_2);                 // scope 0 at ui/consts/issue-65348.rs:12:6: 12:25
        _2 = const _;                    // scope 0 at ui/consts/issue-65348.rs:12:6: 12:25
                                         // mir::Constant
                                         // + span: ui/consts/issue-65348.rs:12:6: 12:25
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: [T; 0], val: Unevaluated(Generic::<T>::ARRAY, [T], None) }
        StorageLive(_3);                 // scope 0 at ui/consts/issue-65348.rs:12:26: 12:27
        _3 = const 0_usize;              // scope 0 at ui/consts/issue-65348.rs:12:26: 12:27
        _4 = Len(_2);                    // scope 0 at ui/consts/issue-65348.rs:12:6: 12:28
        _5 = Lt(_3, _4);                 // scope 0 at ui/consts/issue-65348.rs:12:6: 12:28
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> bb1; // scope 0 at ui/consts/issue-65348.rs:12:6: 12:28
    }

    bb1: {
        _6 = const _;                    // scope 0 at ui/consts/issue-65348.rs:12:5: 12:28
                                         // mir::Constant
                                         // + span: ui/consts/issue-65348.rs:12:5: 12:28
                                         // + literal: Const { ty: &[T; 0], val: Unevaluated(array, [T], Some(promoted[0])) }
        _1 = &(*_6)[_3];                 // scope 0 at ui/consts/issue-65348.rs:12:5: 12:28
        _0 = &(*_1);                     // scope 0 at ui/consts/issue-65348.rs:12:5: 12:28
        StorageDead(_3);                 // scope 0 at ui/consts/issue-65348.rs:13:1: 13:2
        StorageDead(_2);                 // scope 0 at ui/consts/issue-65348.rs:13:1: 13:2
        StorageDead(_1);                 // scope 0 at ui/consts/issue-65348.rs:13:1: 13:2
        return;                          // scope 0 at ui/consts/issue-65348.rs:13:2: 13:2
    }
}

fn newtype_array() -> &T {
    let mut _0: &T;                      // return place in scope 0 at ui/consts/issue-65348.rs:16:5: 16:38
    let _1: usize;                       // in scope 0 at ui/consts/issue-65348.rs:16:36: 16:37
    let mut _2: usize;                   // in scope 0 at ui/consts/issue-65348.rs:16:6: 16:38
    let mut _3: bool;                    // in scope 0 at ui/consts/issue-65348.rs:16:6: 16:38
    let mut _4: &Generic<[T; 0]>;        // in scope 0 at ui/consts/issue-65348.rs:16:5: 16:38

    bb0: {
        _1 = const 0_usize;              // scope 0 at ui/consts/issue-65348.rs:16:36: 16:37
        _2 = const 0_usize;              // scope 0 at ui/consts/issue-65348.rs:16:6: 16:38
        _3 = const false;                // scope 0 at ui/consts/issue-65348.rs:16:6: 16:38
        assert(move _3, "index out of bounds: the length is {} but the index is {}", move _2, _1) -> bb1; // scope 0 at ui/consts/issue-65348.rs:16:6: 16:38
    }

    bb1: {
        _4 = const _;                    // scope 0 at ui/consts/issue-65348.rs:16:5: 16:38
                                         // mir::Constant
                                         // + span: ui/consts/issue-65348.rs:16:5: 16:38
                                         // + literal: Const { ty: &Generic<[T; 0]>, val: Unevaluated(newtype_array, [T], Some(promoted[0])) }
        _0 = &((*_4).0: [T; 0])[_1];     // scope 0 at ui/consts/issue-65348.rs:16:5: 16:38
        return;                          // scope 0 at ui/consts/issue-65348.rs:17:2: 17:2
    }
}

promoted[0] in newtype_array: &Generic<[T; 0]> = {
    let mut _0: &Generic<[T; 0]>;        // return place in scope 0 at ui/consts/issue-65348.rs:16:5: 16:38
    let mut _1: Generic<[T; 0]>;         // in scope 0 at ui/consts/issue-65348.rs:16:6: 16:33

    bb0: {
        _1 = const _;                    // scope 0 at ui/consts/issue-65348.rs:16:6: 16:33
                                         // mir::Constant
                                         // + span: ui/consts/issue-65348.rs:16:6: 16:33
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: Generic<[T; 0]>, val: Unevaluated(Generic::<T>::NEWTYPE_ARRAY, [T], None) }
        _0 = &_1;                        // scope 0 at ui/consts/issue-65348.rs:16:5: 16:38
        return;                          // scope 0 at ui/consts/issue-65348.rs:16:5: 16:38
    }
}

// MIR FOR CTFE
fn newtype_array() -> &T {
    let mut _0: &T;                      // return place in scope 0 at ui/consts/issue-65348.rs:15:37: 15:47
    let _1: &T;                          // in scope 0 at ui/consts/issue-65348.rs:16:5: 16:38
    let _2: Generic<[T; 0]>;             // in scope 0 at ui/consts/issue-65348.rs:16:6: 16:33
    let _3: usize;                       // in scope 0 at ui/consts/issue-65348.rs:16:36: 16:37
    let mut _4: usize;                   // in scope 0 at ui/consts/issue-65348.rs:16:6: 16:38
    let mut _5: bool;                    // in scope 0 at ui/consts/issue-65348.rs:16:6: 16:38
    let mut _6: &Generic<[T; 0]>;        // in scope 0 at ui/consts/issue-65348.rs:16:5: 16:38

    bb0: {
        StorageLive(_1);                 // scope 0 at ui/consts/issue-65348.rs:16:5: 16:38
        StorageLive(_2);                 // scope 0 at ui/consts/issue-65348.rs:16:6: 16:33
        _2 = const _;                    // scope 0 at ui/consts/issue-65348.rs:16:6: 16:33
                                         // mir::Constant
                                         // + span: ui/consts/issue-65348.rs:16:6: 16:33
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: Generic<[T; 0]>, val: Unevaluated(Generic::<T>::NEWTYPE_ARRAY, [T], None) }
        StorageLive(_3);                 // scope 0 at ui/consts/issue-65348.rs:16:36: 16:37
        _3 = const 0_usize;              // scope 0 at ui/consts/issue-65348.rs:16:36: 16:37
        _4 = Len((_2.0: [T; 0]));        // scope 0 at ui/consts/issue-65348.rs:16:6: 16:38
        _5 = Lt(_3, _4);                 // scope 0 at ui/consts/issue-65348.rs:16:6: 16:38
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> bb1; // scope 0 at ui/consts/issue-65348.rs:16:6: 16:38
    }

    bb1: {
        _6 = const _;                    // scope 0 at ui/consts/issue-65348.rs:16:5: 16:38
                                         // mir::Constant
                                         // + span: ui/consts/issue-65348.rs:16:5: 16:38
                                         // + literal: Const { ty: &Generic<[T; 0]>, val: Unevaluated(newtype_array, [T], Some(promoted[0])) }
        _1 = &((*_6).0: [T; 0])[_3];     // scope 0 at ui/consts/issue-65348.rs:16:5: 16:38
        _0 = &(*_1);                     // scope 0 at ui/consts/issue-65348.rs:16:5: 16:38
        StorageDead(_3);                 // scope 0 at ui/consts/issue-65348.rs:17:1: 17:2
        StorageDead(_2);                 // scope 0 at ui/consts/issue-65348.rs:17:1: 17:2
        StorageDead(_1);                 // scope 0 at ui/consts/issue-65348.rs:17:1: 17:2
        return;                          // scope 0 at ui/consts/issue-65348.rs:17:2: 17:2
    }
}

fn array_field() -> &T {
    let mut _0: &T;                      // return place in scope 0 at ui/consts/issue-65348.rs:20:5: 20:40
    let _1: usize;                       // in scope 0 at ui/consts/issue-65348.rs:20:38: 20:39
    let mut _2: usize;                   // in scope 0 at ui/consts/issue-65348.rs:20:6: 20:40
    let mut _3: bool;                    // in scope 0 at ui/consts/issue-65348.rs:20:6: 20:40
    let mut _4: &Generic<(i32, [T; 0])>; // in scope 0 at ui/consts/issue-65348.rs:20:5: 20:40

    bb0: {
        _1 = const 0_usize;              // scope 0 at ui/consts/issue-65348.rs:20:38: 20:39
        _2 = const 0_usize;              // scope 0 at ui/consts/issue-65348.rs:20:6: 20:40
        _3 = const false;                // scope 0 at ui/consts/issue-65348.rs:20:6: 20:40
        assert(move _3, "index out of bounds: the length is {} but the index is {}", move _2, _1) -> bb1; // scope 0 at ui/consts/issue-65348.rs:20:6: 20:40
    }

    bb1: {
        _4 = const _;                    // scope 0 at ui/consts/issue-65348.rs:20:5: 20:40
                                         // mir::Constant
                                         // + span: ui/consts/issue-65348.rs:20:5: 20:40
                                         // + literal: Const { ty: &Generic<(i32, [T; 0])>, val: Unevaluated(array_field, [T], Some(promoted[0])) }
        _0 = &(((*_4).0: (i32, [T; 0])).1: [T; 0])[_1]; // scope 0 at ui/consts/issue-65348.rs:20:5: 20:40
        return;                          // scope 0 at ui/consts/issue-65348.rs:21:2: 21:2
    }
}

promoted[0] in array_field: &Generic<(i32, [T; 0])> = {
    let mut _0: &Generic<(i32, [T; 0])>; // return place in scope 0 at ui/consts/issue-65348.rs:20:5: 20:40
    let mut _1: Generic<(i32, [T; 0])>;  // in scope 0 at ui/consts/issue-65348.rs:20:7: 20:32

    bb0: {
        _1 = const _;                    // scope 0 at ui/consts/issue-65348.rs:20:7: 20:32
                                         // mir::Constant
                                         // + span: ui/consts/issue-65348.rs:20:7: 20:32
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: Generic<(i32, [T; 0])>, val: Unevaluated(Generic::<T>::ARRAY_FIELD, [T], None) }
        _0 = &_1;                        // scope 0 at ui/consts/issue-65348.rs:20:5: 20:40
        return;                          // scope 0 at ui/consts/issue-65348.rs:20:5: 20:40
    }
}

// MIR FOR CTFE
fn array_field() -> &T {
    let mut _0: &T;                      // return place in scope 0 at ui/consts/issue-65348.rs:19:35: 19:45
    let _1: &T;                          // in scope 0 at ui/consts/issue-65348.rs:20:5: 20:40
    let _2: Generic<(i32, [T; 0])>;      // in scope 0 at ui/consts/issue-65348.rs:20:7: 20:32
    let _3: usize;                       // in scope 0 at ui/consts/issue-65348.rs:20:38: 20:39
    let mut _4: usize;                   // in scope 0 at ui/consts/issue-65348.rs:20:6: 20:40
    let mut _5: bool;                    // in scope 0 at ui/consts/issue-65348.rs:20:6: 20:40
    let mut _6: &Generic<(i32, [T; 0])>; // in scope 0 at ui/consts/issue-65348.rs:20:5: 20:40

    bb0: {
        StorageLive(_1);                 // scope 0 at ui/consts/issue-65348.rs:20:5: 20:40
        StorageLive(_2);                 // scope 0 at ui/consts/issue-65348.rs:20:7: 20:32
        _2 = const _;                    // scope 0 at ui/consts/issue-65348.rs:20:7: 20:32
                                         // mir::Constant
                                         // + span: ui/consts/issue-65348.rs:20:7: 20:32
                                         // + user_ty: UserType(0)
                                         // + literal: Const { ty: Generic<(i32, [T; 0])>, val: Unevaluated(Generic::<T>::ARRAY_FIELD, [T], None) }
        StorageLive(_3);                 // scope 0 at ui/consts/issue-65348.rs:20:38: 20:39
        _3 = const 0_usize;              // scope 0 at ui/consts/issue-65348.rs:20:38: 20:39
        _4 = Len(((_2.0: (i32, [T; 0])).1: [T; 0])); // scope 0 at ui/consts/issue-65348.rs:20:6: 20:40
        _5 = Lt(_3, _4);                 // scope 0 at ui/consts/issue-65348.rs:20:6: 20:40
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> bb1; // scope 0 at ui/consts/issue-65348.rs:20:6: 20:40
    }

    bb1: {
        _6 = const _;                    // scope 0 at ui/consts/issue-65348.rs:20:5: 20:40
                                         // mir::Constant
                                         // + span: ui/consts/issue-65348.rs:20:5: 20:40
                                         // + literal: Const { ty: &Generic<(i32, [T; 0])>, val: Unevaluated(array_field, [T], Some(promoted[0])) }
        _1 = &(((*_6).0: (i32, [T; 0])).1: [T; 0])[_3]; // scope 0 at ui/consts/issue-65348.rs:20:5: 20:40
        _0 = &(*_1);                     // scope 0 at ui/consts/issue-65348.rs:20:5: 20:40
        StorageDead(_3);                 // scope 0 at ui/consts/issue-65348.rs:21:1: 21:2
        StorageDead(_2);                 // scope 0 at ui/consts/issue-65348.rs:21:1: 21:2
        StorageDead(_1);                 // scope 0 at ui/consts/issue-65348.rs:21:1: 21:2
        return;                          // scope 0 at ui/consts/issue-65348.rs:21:2: 21:2
    }
}

fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/consts/issue-65348.rs:23:11: 23:11

    bb0: {
        return;                          // scope 0 at ui/consts/issue-65348.rs:23:13: 23:13
    }
}

fn Generic(_1: T) -> Generic<T> {
    let mut _0: Generic<T>;              // return place in scope 0 at ui/consts/issue-65348.rs:3:1: 3:18

    bb0: {
        _0 = Generic::<T>(move _1);      // scope 0 at ui/consts/issue-65348.rs:3:1: 3:18
        return;                          // scope 0 at ui/consts/issue-65348.rs:3:1: 3:18
    }
}

// MIR FOR CTFE
fn Generic(_1: T) -> Generic<T> {
    let mut _0: Generic<T>;              // return place in scope 0 at ui/consts/issue-65348.rs:3:1: 3:18

    bb0: {
        _0 = Generic::<T>(move _1);      // scope 0 at ui/consts/issue-65348.rs:3:1: 3:18
        return;                          // scope 0 at ui/consts/issue-65348.rs:3:1: 3:18
    }
}
