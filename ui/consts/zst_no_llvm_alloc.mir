// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
static FOO: Foo = {
    let mut _0: Foo;

    bb0: {
        _0 = Foo;
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let mut _1: (&usize, &usize);
    let mut _2: &usize;
    let _3: usize;
    let mut _4: *const ();
    let mut _7: bool;
    let mut _8: usize;
    let mut _9: usize;
    let _11: !;
    let mut _12: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _13: (&usize, &usize);
    let mut _14: &usize;
    let _15: usize;
    let mut _16: *const Foo;
    let mut _19: bool;
    let mut _20: usize;
    let mut _21: usize;
    let _23: !;
    let mut _24: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _25: (&usize, &usize);
    let mut _26: &usize;
    let _27: usize;
    let mut _28: *const Foo;
    let _29: &Foo;
    let mut _32: bool;
    let mut _33: usize;
    let mut _34: usize;
    let _36: !;
    let mut _37: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _38: (&*const i32, &*const i32);
    let mut _39: &*const i32;
    let _40: *const i32;
    let mut _41: &std::vec::Vec<i32>;
    let _42: std::vec::Vec<i32>;
    let mut _43: &*const i32;
    let _44: *const i32;
    let mut _45: &[i32];
    let _46: &[i32];
    let mut _49: bool;
    let mut _50: *const i32;
    let mut _51: *const i32;
    let _53: !;
    let mut _54: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _55: (&*const i32, &*const i32);
    let mut _56: &*const i32;
    let _57: *const i32;
    let mut _58: &[i32];
    let _59: std::boxed::Box<[i32]>;
    let mut _60: &*const i32;
    let _61: *const i32;
    let mut _62: &[i32];
    let mut _65: bool;
    let mut _66: *const i32;
    let mut _67: *const i32;
    let _69: !;
    let mut _70: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _76: &();
    let mut _77: *const [i32];
    scope 1 {
        debug x => const _;
        let _5: &usize;
        let _6: &usize;
        let mut _74: &Foo;
        let mut _75: &usize;
        scope 2 {
            debug left_val => _5;
            debug right_val => _6;
            let _10: core::panicking::AssertKind;
            scope 3 {
                debug kind => _10;
            }
        }
        scope 4 {
            debug x => const _;
            let _17: &usize;
            let _18: &usize;
            let _30: &usize;
            let _31: &usize;
            let _47: &*const i32;
            let _48: &*const i32;
            let _63: &*const i32;
            let _64: &*const i32;
            let mut _71: &[i32; 0];
            let mut _72: &usize;
            let mut _73: &usize;
            let mut _78: *const ();
            let mut _79: usize;
            let mut _80: usize;
            let mut _81: usize;
            let mut _82: usize;
            let mut _83: bool;
            scope 5 {
                debug left_val => _17;
                debug right_val => _18;
                let _22: core::panicking::AssertKind;
                scope 6 {
                    debug kind => _22;
                }
            }
            scope 7 {
                debug left_val => _30;
                debug right_val => _31;
                let _35: core::panicking::AssertKind;
                scope 8 {
                    debug kind => _35;
                }
            }
            scope 9 {
                debug left_val => _47;
                debug right_val => _48;
                let _52: core::panicking::AssertKind;
                scope 10 {
                    debug kind => _52;
                }
            }
            scope 11 {
                debug left_val => _63;
                debug right_val => _64;
                let _68: core::panicking::AssertKind;
                scope 12 {
                    debug kind => _68;
                }
            }
        }
    }

    bb0: {
        _76 = const _;
        _4 = &raw const (*_76);
        _3 = move _4 as usize (PointerExposeAddress);
        _2 = &_3;
        _75 = const _;
        _1 = (move _2, _75);
        _5 = (_1.0: &usize);
        _6 = (_1.1: &usize);
        _8 = (*_5);
        _9 = (*_6);
        _7 = Eq(move _8, move _9);
        switchInt(move _7) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _10 = core::panicking::AssertKind::Ne;
        _12 = Option::<Arguments<'_>>::None;
        _11 = core::panicking::assert_failed::<usize, usize>(move _10, _5, _6, move _12) -> unwind continue;
    }

    bb2: {
        _74 = const _;
        _16 = &raw const (*_74);
        _15 = move _16 as usize (PointerExposeAddress);
        _14 = &_15;
        _73 = const _;
        _13 = (move _14, _73);
        _17 = (_13.0: &usize);
        _18 = (_13.1: &usize);
        _20 = (*_17);
        _21 = (*_18);
        _19 = Eq(move _20, move _21);
        switchInt(move _19) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _22 = core::panicking::AssertKind::Ne;
        _24 = Option::<Arguments<'_>>::None;
        _23 = core::panicking::assert_failed::<usize, usize>(move _22, _17, _18, move _24) -> unwind continue;
    }

    bb4: {
        _29 = const {alloc1: &Foo};
        _28 = &raw const (*_29);
        _27 = move _28 as usize (PointerExposeAddress);
        _26 = &_27;
        _72 = const _;
        _25 = (move _26, _72);
        _30 = (_25.0: &usize);
        _31 = (_25.1: &usize);
        _33 = (*_30);
        _34 = (*_31);
        _32 = Eq(move _33, move _34);
        switchInt(move _32) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _35 = core::panicking::AssertKind::Ne;
        _37 = Option::<Arguments<'_>>::None;
        _36 = core::panicking::assert_failed::<usize, usize>(move _35, _30, _31, move _37) -> unwind continue;
    }

    bb6: {
        _42 = Vec::<i32>::new() -> [return: bb7, unwind continue];
    }

    bb7: {
        _41 = &_42;
        _40 = Vec::<i32>::as_ptr(move _41) -> [return: bb8, unwind: bb21];
    }

    bb8: {
        _39 = &_40;
        _46 = <&[i32] as Default>::default() -> [return: bb9, unwind: bb21];
    }

    bb9: {
        _45 = _46;
        _44 = core::slice::<impl [i32]>::as_ptr(move _45) -> [return: bb10, unwind: bb21];
    }

    bb10: {
        _43 = &_44;
        _38 = (move _39, move _43);
        _47 = (_38.0: &*const i32);
        _48 = (_38.1: &*const i32);
        _50 = (*_47);
        _51 = (*_48);
        _49 = Eq(move _50, move _51);
        switchInt(move _49) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _52 = core::panicking::AssertKind::Ne;
        _54 = Option::<Arguments<'_>>::None;
        _53 = core::panicking::assert_failed::<*const i32, *const i32>(move _52, _47, _48, move _54) -> bb21;
    }

    bb12: {
        drop(_42) -> [return: bb13, unwind continue];
    }

    bb13: {
        _59 = <Box<[i32]> as Default>::default() -> [return: bb14, unwind continue];
    }

    bb14: {
        _77 = (((_59.0: std::ptr::Unique<[i32]>).0: std::ptr::NonNull<[i32]>).0: *const [i32]);
        _78 = _77 as *const () (PtrToPtr);
        _79 = _78 as usize (Transmute);
        _80 = AlignOf(i32);
        _81 = Sub(_80, const 1_usize);
        _82 = BitAnd(_79, _81);
        _83 = Eq(_82, const 0_usize);
        assert(_83, "misaligned pointer dereference: address must be a multiple of {} but is {}", _80, _79) -> [success: bb23, unwind unreachable];
    }

    bb15: {
        _56 = &_57;
        _71 = const _;
        _62 = _71 as &[i32] (Pointer(Unsize));
        _61 = core::slice::<impl [i32]>::as_ptr(move _62) -> [return: bb16, unwind: bb20];
    }

    bb16: {
        _60 = &_61;
        _55 = (move _56, move _60);
        _63 = (_55.0: &*const i32);
        _64 = (_55.1: &*const i32);
        _66 = (*_63);
        _67 = (*_64);
        _65 = Eq(move _66, move _67);
        switchInt(move _65) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _68 = core::panicking::AssertKind::Ne;
        _70 = Option::<Arguments<'_>>::None;
        _69 = core::panicking::assert_failed::<*const i32, *const i32>(move _68, _63, _64, move _70) -> bb20;
    }

    bb18: {
        drop(_59) -> [return: bb19, unwind continue];
    }

    bb19: {
        return;
    }

    bb20 (cleanup): {
        drop(_59) -> [return: bb22, unwind terminate];
    }

    bb21 (cleanup): {
        drop(_42) -> [return: bb22, unwind terminate];
    }

    bb22 (cleanup): {
        resume;
    }

    bb23: {
        _58 = &(*_77);
        _57 = core::slice::<impl [i32]>::as_ptr(move _58) -> [return: bb15, unwind: bb20];
    }
}

alloc1 (static: FOO, size: 0, align: 4) {}

promoted[0] in main: &[i32; 0] = {
    let mut _0: &[i32; 0];
    let mut _1: [i32; 0];

    bb0: {
        _1 = [];
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 4_usize;
        _0 = &_1;
        return;
    }
}

promoted[2] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 4_usize;
        _0 = &_1;
        return;
    }
}

promoted[3] in main: &Foo = {
    let mut _0: &Foo;
    let mut _1: Foo;

    bb0: {
        _1 = Foo;
        _0 = &_1;
        return;
    }
}

promoted[4] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 1_usize;
        _0 = &_1;
        return;
    }
}

promoted[5] in main: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = ();
        _0 = &_1;
        return;
    }
}
