// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/consts/const-trait-to-trait.rs:10:11: 10:11
    let _1: &[&dyn Trait];               // in scope 0 at ui/consts/const-trait-to-trait.rs:11:9: 11:10
    let mut _2: &[&dyn Trait; 1];        // in scope 0 at ui/consts/const-trait-to-trait.rs:11:28: 11:39
    let _3: &[&dyn Trait; 1];            // in scope 0 at ui/consts/const-trait-to-trait.rs:11:28: 11:39
    let mut _4: &[&dyn Trait; 1];        // in scope 0 at ui/consts/const-trait-to-trait.rs:11:28: 11:39
    scope 1 {
        debug x => _1;                   // in scope 1 at ui/consts/const-trait-to-trait.rs:11:9: 11:10
    }

    bb0: {
        _4 = const _;                    // scope 0 at ui/consts/const-trait-to-trait.rs:11:28: 11:39
                                         // mir::Constant
                                         // + span: ui/consts/const-trait-to-trait.rs:11:28: 11:39
                                         // + literal: Const { ty: &[&dyn Trait; 1], val: Unevaluated(main, [], Some(promoted[0])) }
        _3 = _4;                         // scope 0 at ui/consts/const-trait-to-trait.rs:11:28: 11:39
        _2 = _3;                         // scope 0 at ui/consts/const-trait-to-trait.rs:11:28: 11:39
        _1 = move _2 as &[&dyn Trait] (Pointer(Unsize)); // scope 0 at ui/consts/const-trait-to-trait.rs:11:28: 11:39
        return;                          // scope 0 at ui/consts/const-trait-to-trait.rs:12:2: 12:2
    }
}

promoted[0] in main: &[&dyn Trait; 1] = {
    let mut _0: &[&dyn Trait; 1];        // return place in scope 0 at ui/consts/const-trait-to-trait.rs:11:28: 11:39
    let mut _1: [&dyn Trait; 1];         // in scope 0 at ui/consts/const-trait-to-trait.rs:11:29: 11:39
    let mut _2: &dyn Trait;              // in scope 0 at ui/consts/const-trait-to-trait.rs:11:32: 11:36
    let mut _3: &dyn Trait;              // in scope 0 at ui/consts/const-trait-to-trait.rs:11:32: 11:36
    let mut _4: &dyn Trait;              // in scope 0 at ui/consts/const-trait-to-trait.rs:11:32: 11:36
    let mut _5: &Bar;                    // in scope 0 at ui/consts/const-trait-to-trait.rs:11:32: 11:36
    let mut _6: &Bar;                    // in scope 0 at ui/consts/const-trait-to-trait.rs:11:32: 11:36
    let mut _7: Bar;                     // in scope 0 at ui/consts/const-trait-to-trait.rs:11:33: 11:36

    bb0: {
        _7 = Bar;                        // scope 0 at ui/consts/const-trait-to-trait.rs:11:33: 11:36
        _6 = &_7;                        // scope 0 at ui/consts/const-trait-to-trait.rs:11:32: 11:36
        _5 = &(*_6);                     // scope 0 at ui/consts/const-trait-to-trait.rs:11:32: 11:36
        _4 = move _5 as &dyn Trait (Pointer(Unsize)); // scope 0 at ui/consts/const-trait-to-trait.rs:11:32: 11:36
        _3 = &(*_4);                     // scope 0 at ui/consts/const-trait-to-trait.rs:11:32: 11:36
        _2 = move _3 as &dyn Trait (Pointer(Unsize)); // scope 0 at ui/consts/const-trait-to-trait.rs:11:32: 11:36
        _1 = [move _2];                  // scope 0 at ui/consts/const-trait-to-trait.rs:11:29: 11:39
        _0 = &_1;                        // scope 0 at ui/consts/const-trait-to-trait.rs:11:28: 11:39
        return;                          // scope 0 at ui/consts/const-trait-to-trait.rs:11:28: 11:39
    }
}

const UTF_8: &UTF8Encoding = {
    let mut _0: &UTF8Encoding;           // return place in scope 0 at ui/consts/const-trait-to-trait.rs:16:18: 16:39
    let _1: &UTF8Encoding;               // in scope 0 at ui/consts/const-trait-to-trait.rs:16:42: 16:55
    let _2: UTF8Encoding;                // in scope 0 at ui/consts/const-trait-to-trait.rs:16:43: 16:55
    let mut _3: &UTF8Encoding;           // in scope 0 at ui/consts/const-trait-to-trait.rs:16:42: 16:55

    bb0: {
        StorageLive(_1);                 // scope 0 at ui/consts/const-trait-to-trait.rs:16:42: 16:55
        _3 = const _;                    // scope 0 at ui/consts/const-trait-to-trait.rs:16:42: 16:55
                                         // mir::Constant
                                         // + span: ui/consts/const-trait-to-trait.rs:16:42: 16:55
                                         // + literal: Const { ty: &UTF8Encoding, val: Unevaluated(UTF_8, [], Some(promoted[0])) }
        _1 = &(*_3);                     // scope 0 at ui/consts/const-trait-to-trait.rs:16:42: 16:55
        _0 = &(*_1);                     // scope 0 at ui/consts/const-trait-to-trait.rs:16:42: 16:55
        StorageDead(_1);                 // scope 0 at ui/consts/const-trait-to-trait.rs:16:54: 16:55
        return;                          // scope 0 at ui/consts/const-trait-to-trait.rs:16:1: 16:56
    }
}

promoted[0] in UTF_8: &UTF8Encoding = {
    let mut _0: &UTF8Encoding;           // return place in scope 0 at ui/consts/const-trait-to-trait.rs:16:42: 16:55
    let mut _1: UTF8Encoding;            // in scope 0 at ui/consts/const-trait-to-trait.rs:16:43: 16:55

    bb0: {
        _1 = UTF8Encoding;               // scope 0 at ui/consts/const-trait-to-trait.rs:16:43: 16:55
        _0 = &_1;                        // scope 0 at ui/consts/const-trait-to-trait.rs:16:42: 16:55
        return;                          // scope 0 at ui/consts/const-trait-to-trait.rs:16:42: 16:55
    }
}

fn f() -> &dyn Encoding {
    let mut _0: &dyn Encoding;           // return place in scope 0 at ui/consts/const-trait-to-trait.rs:19:15: 19:36
    let mut _1: &dyn Encoding;           // in scope 0 at ui/consts/const-trait-to-trait.rs:19:39: 19:69
    let _2: &dyn Encoding;               // in scope 0 at ui/consts/const-trait-to-trait.rs:19:39: 19:69
    let mut _3: &dyn Encoding;           // in scope 0 at ui/consts/const-trait-to-trait.rs:19:39: 19:69
    let _4: &dyn Encoding;               // in scope 0 at ui/consts/const-trait-to-trait.rs:19:39: 19:69
    let mut _5: &UTF8Encoding;           // in scope 0 at ui/consts/const-trait-to-trait.rs:19:39: 19:44
    let _6: &UTF8Encoding;               // in scope 0 at ui/consts/const-trait-to-trait.rs:19:39: 19:44

    bb0: {
        _6 = const _;                    // scope 0 at ui/consts/const-trait-to-trait.rs:19:39: 19:44
                                         // mir::Constant
                                         // + span: ui/consts/const-trait-to-trait.rs:19:39: 19:44
                                         // + literal: Const { ty: &UTF8Encoding, val: Unevaluated(UTF_8, [], None) }
        _5 = _6;                         // scope 0 at ui/consts/const-trait-to-trait.rs:19:39: 19:44
        _4 = move _5 as &dyn Encoding (Pointer(Unsize)); // scope 0 at ui/consts/const-trait-to-trait.rs:19:39: 19:44
        _3 = _4;                         // scope 0 at ui/consts/const-trait-to-trait.rs:19:39: 19:69
        _2 = move _3 as &dyn Encoding (Pointer(Unsize)); // scope 0 at ui/consts/const-trait-to-trait.rs:19:39: 19:69
        _1 = _2;                         // scope 0 at ui/consts/const-trait-to-trait.rs:19:39: 19:69
        _0 = move _1 as &dyn Encoding (Pointer(Unsize)); // scope 0 at ui/consts/const-trait-to-trait.rs:19:39: 19:69
        return;                          // scope 0 at ui/consts/const-trait-to-trait.rs:19:71: 19:71
    }
}

const FOO: &dyn Trait = {
    let mut _0: &dyn Trait;              // return place in scope 0 at ui/consts/const-trait-to-trait.rs:22:12: 22:30
    let mut _1: &Bar;                    // in scope 0 at ui/consts/const-trait-to-trait.rs:22:33: 22:37
    let _2: &Bar;                        // in scope 0 at ui/consts/const-trait-to-trait.rs:22:33: 22:37
    let _3: Bar;                         // in scope 0 at ui/consts/const-trait-to-trait.rs:22:34: 22:37
    let mut _4: &Bar;                    // in scope 0 at ui/consts/const-trait-to-trait.rs:22:33: 22:37

    bb0: {
        StorageLive(_1);                 // scope 0 at ui/consts/const-trait-to-trait.rs:22:33: 22:37
        StorageLive(_2);                 // scope 0 at ui/consts/const-trait-to-trait.rs:22:33: 22:37
        _4 = const _;                    // scope 0 at ui/consts/const-trait-to-trait.rs:22:33: 22:37
                                         // mir::Constant
                                         // + span: ui/consts/const-trait-to-trait.rs:22:33: 22:37
                                         // + literal: Const { ty: &Bar, val: Unevaluated(FOO, [], Some(promoted[0])) }
        _2 = &(*_4);                     // scope 0 at ui/consts/const-trait-to-trait.rs:22:33: 22:37
        _1 = &(*_2);                     // scope 0 at ui/consts/const-trait-to-trait.rs:22:33: 22:37
        _0 = move _1 as &dyn Trait (Pointer(Unsize)); // scope 0 at ui/consts/const-trait-to-trait.rs:22:33: 22:37
        StorageDead(_2);                 // scope 0 at ui/consts/const-trait-to-trait.rs:22:36: 22:37
        StorageDead(_1);                 // scope 0 at ui/consts/const-trait-to-trait.rs:22:36: 22:37
        return;                          // scope 0 at ui/consts/const-trait-to-trait.rs:22:1: 22:38
    }
}

promoted[0] in FOO: &Bar = {
    let mut _0: &Bar;                    // return place in scope 0 at ui/consts/const-trait-to-trait.rs:22:33: 22:37
    let mut _1: Bar;                     // in scope 0 at ui/consts/const-trait-to-trait.rs:22:34: 22:37

    bb0: {
        _1 = Bar;                        // scope 0 at ui/consts/const-trait-to-trait.rs:22:34: 22:37
        _0 = &_1;                        // scope 0 at ui/consts/const-trait-to-trait.rs:22:33: 22:37
        return;                          // scope 0 at ui/consts/const-trait-to-trait.rs:22:33: 22:37
    }
}

const BAR: &dyn Trait = {
    let mut _0: &dyn Trait;              // return place in scope 0 at ui/consts/const-trait-to-trait.rs:23:12: 23:30
    let mut _1: &dyn Trait;              // in scope 0 at ui/consts/const-trait-to-trait.rs:23:33: 23:36
    let _2: &dyn Trait;                  // in scope 0 at ui/consts/const-trait-to-trait.rs:23:33: 23:36

    bb0: {
        StorageLive(_1);                 // scope 0 at ui/consts/const-trait-to-trait.rs:23:33: 23:36
        StorageLive(_2);                 // scope 0 at ui/consts/const-trait-to-trait.rs:23:33: 23:36
        _2 = const _;                    // scope 0 at ui/consts/const-trait-to-trait.rs:23:33: 23:36
                                         // mir::Constant
                                         // + span: ui/consts/const-trait-to-trait.rs:23:33: 23:36
                                         // + literal: Const { ty: &dyn Trait, val: Unevaluated(FOO, [], None) }
        _1 = &(*_2);                     // scope 0 at ui/consts/const-trait-to-trait.rs:23:33: 23:36
        _0 = move _1 as &dyn Trait (Pointer(Unsize)); // scope 0 at ui/consts/const-trait-to-trait.rs:23:33: 23:36
        StorageDead(_2);                 // scope 0 at ui/consts/const-trait-to-trait.rs:23:35: 23:36
        StorageDead(_1);                 // scope 0 at ui/consts/const-trait-to-trait.rs:23:35: 23:36
        return;                          // scope 0 at ui/consts/const-trait-to-trait.rs:23:1: 23:37
    }
}

fn foo() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/consts/const-trait-to-trait.rs:24:10: 24:10
    let _1: &dyn Trait;                  // in scope 0 at ui/consts/const-trait-to-trait.rs:24:16: 24:18
    scope 1 {
        debug _x => _1;                  // in scope 1 at ui/consts/const-trait-to-trait.rs:24:16: 24:18
    }

    bb0: {
        _1 = const _;                    // scope 0 at ui/consts/const-trait-to-trait.rs:24:21: 24:24
                                         // mir::Constant
                                         // + span: ui/consts/const-trait-to-trait.rs:24:21: 24:24
                                         // + literal: Const { ty: &dyn Trait, val: Unevaluated(BAR, [], None) }
        return;                          // scope 0 at ui/consts/const-trait-to-trait.rs:24:27: 24:27
    }
}
