// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/consts/issue-90762.rs:8:1: 8:20>::drop(_1: &mut Print) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: std::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 1];
    let _7: [core::fmt::rt::Argument<'_>; 1];
    let mut _8: core::fmt::rt::Argument<'_>;
    let _9: &usize;
    let _10: ();
    let mut _11: &std::sync::atomic::AtomicBool;
    let _12: &[std::sync::atomic::AtomicBool; 3];
    let _13: usize;
    let mut _14: usize;
    let mut _15: bool;
    let mut _16: std::sync::atomic::Ordering;
    let mut _17: (&usize, &usize);
    let mut _18: &usize;
    let _19: usize;
    let _20: &std::sync::atomic::AtomicUsize;
    let mut _21: std::sync::atomic::Ordering;
    let mut _22: &usize;
    let _23: &usize;
    let _24: &usize;
    let mut _25: bool;
    let mut _26: bool;
    let mut _27: usize;
    let mut _28: usize;
    let _30: !;
    let mut _31: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _32: &[&str; 2];
    scope 1 {
        debug left_val => _23;
        debug right_val => _24;
        let _29: core::panicking::AssertKind;
        scope 2 {
            debug kind => _29;
        }
    }

    bb0: {
        _32 = const _;
        _4 = _32 as &[&str] (Pointer(Unsize));
        _9 = &((*_1).0: usize);
        _8 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_9) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = [move _8];
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _3 = Arguments::<'_>::new_v1(move _4, move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = _print(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _12 = const {alloc1: &[AtomicBool; 3]};
        _13 = ((*_1).0: usize);
        _14 = const 3_usize;
        _15 = Lt(_13, _14);
        assert(move _15, "index out of bounds: the length is {} but the index is {}", move _14, _13) -> [success: bb4, unwind continue];
    }

    bb4: {
        _11 = &(*_12)[_13];
        _16 = Relaxed;
        _10 = AtomicBool::store(move _11, const true, move _16) -> [return: bb5, unwind continue];
    }

    bb5: {
        _20 = const {alloc2: &AtomicUsize};
        _21 = Relaxed;
        _19 = AtomicUsize::fetch_sub(_20, const 1_usize, move _21) -> [return: bb6, unwind continue];
    }

    bb6: {
        _18 = &_19;
        _22 = &((*_1).0: usize);
        _17 = (move _18, move _22);
        _23 = (_17.0: &usize);
        _24 = (_17.1: &usize);
        _27 = (*_23);
        _28 = (*_24);
        _26 = Eq(move _27, move _28);
        _25 = Not(move _26);
        switchInt(move _25) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _29 = core::panicking::AssertKind::Eq;
        _31 = Option::<Arguments<'_>>::None;
        _30 = core::panicking::assert_failed::<usize, usize>(move _29, _23, _24, move _31) -> unwind continue;
    }

    bb8: {
        return;
    }
}

alloc2 (static: BAR, size: 8, align: 8) {
    02 00 00 00 00 00 00 00                         │ ........
}

alloc1 (static: FOO, size: 3, align: 1) {
    00 00 00                                        │ ...
}

promoted[0] in <impl at ui/consts/issue-90762.rs:8:1: 8:20>::drop: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n"];
        _0 = &_1;
        return;
    }
}

const A: Print = {
    let mut _0: Print;

    bb0: {
        _0 = Print(const 0_usize);
        return;
    }
}

const B: Print = {
    let mut _0: Print;

    bb0: {
        _0 = Print(const 1_usize);
        return;
    }
}

static FOO: [AtomicBool; 3] = {
    let mut _0: [std::sync::atomic::AtomicBool; 3];
    let mut _1: std::sync::atomic::AtomicBool;
    let mut _2: std::sync::atomic::AtomicBool;
    let mut _3: std::sync::atomic::AtomicBool;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = AtomicBool::new(const false) -> [return: bb1, unwind continue];
    }

    bb1: {
        StorageLive(_2);
        ConstEvalCounter;
        _2 = AtomicBool::new(const false) -> [return: bb2, unwind continue];
    }

    bb2: {
        StorageLive(_3);
        ConstEvalCounter;
        _3 = AtomicBool::new(const false) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = [move _1, move _2, move _3];
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

FOO::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 3_usize;
        return;
    }
}

static BAR: AtomicUsize = {
    let mut _0: std::sync::atomic::AtomicUsize;

    bb0: {
        ConstEvalCounter;
        _0 = AtomicUsize::new(const 2_usize) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let mut _1: Print;
    let mut _2: Print;
    let mut _3: Print;
    let mut _4: std::iter::Enumerate<std::slice::Iter<'_, std::sync::atomic::AtomicBool>>;
    let mut _5: std::iter::Enumerate<std::slice::Iter<'_, std::sync::atomic::AtomicBool>>;
    let mut _6: std::slice::Iter<'_, std::sync::atomic::AtomicBool>;
    let mut _7: &[std::sync::atomic::AtomicBool];
    let _8: &[std::sync::atomic::AtomicBool; 3];
    let mut _9: std::iter::Enumerate<std::slice::Iter<'_, std::sync::atomic::AtomicBool>>;
    let mut _10: std::option::Option<(usize, &std::sync::atomic::AtomicBool)>;
    let mut _11: &mut std::iter::Enumerate<std::slice::Iter<'_, std::sync::atomic::AtomicBool>>;
    let mut _12: isize;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: std::sync::atomic::Ordering;
    let _18: !;
    let mut _19: std::fmt::Arguments<'_>;
    let mut _20: &[&str];
    let mut _21: &[core::fmt::rt::Argument<'_>];
    let _22: &[core::fmt::rt::Argument<'_>; 1];
    let _23: [core::fmt::rt::Argument<'_>; 1];
    let mut _24: core::fmt::rt::Argument<'_>;
    let _25: &usize;
    let mut _26: (&usize, &usize);
    let mut _27: &usize;
    let _28: usize;
    let _29: &std::sync::atomic::AtomicUsize;
    let mut _30: std::sync::atomic::Ordering;
    let _31: &usize;
    let _32: &usize;
    let mut _33: bool;
    let mut _34: bool;
    let mut _35: usize;
    let mut _36: usize;
    let _38: !;
    let mut _39: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _41: &usize;
    scope 1 {
        debug iter => _9;
        let _13: usize;
        let _14: &std::sync::atomic::AtomicBool;
        scope 2 {
            debug i => _13;
            debug b => _14;
            let mut _40: &[&str; 2];
        }
    }
    scope 3 {
        debug left_val => _31;
        debug right_val => _32;
        let _37: core::panicking::AssertKind;
        scope 4 {
            debug kind => _37;
        }
    }

    bb0: {
        _1 = const _;
        _2 = const _;
        _3 = Print(const 2_usize);
        drop(_3) -> [return: bb1, unwind: bb19];
    }

    bb1: {
        drop(_2) -> [return: bb2, unwind: bb20];
    }

    bb2: {
        drop(_1) -> [return: bb3, unwind continue];
    }

    bb3: {
        _8 = const {alloc1: &[AtomicBool; 3]};
        _7 = _8 as &[std::sync::atomic::AtomicBool] (Pointer(Unsize));
        _6 = core::slice::<impl [AtomicBool]>::iter(move _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = <std::slice::Iter<'_, AtomicBool> as Iterator>::enumerate(move _6) -> [return: bb5, unwind continue];
    }

    bb5: {
        _4 = <Enumerate<std::slice::Iter<'_, AtomicBool>> as IntoIterator>::into_iter(move _5) -> [return: bb6, unwind continue];
    }

    bb6: {
        _9 = move _4;
        goto -> bb7;
    }

    bb7: {
        _11 = &mut _9;
        _10 = <Enumerate<std::slice::Iter<'_, AtomicBool>> as Iterator>::next(_11) -> [return: bb8, unwind continue];
    }

    bb8: {
        _12 = discriminant(_10);
        switchInt(move _12) -> [0: bb11, 1: bb9, otherwise: bb10];
    }

    bb9: {
        _13 = (((_10 as Some).0: (usize, &std::sync::atomic::AtomicBool)).0: usize);
        _14 = (((_10 as Some).0: (usize, &std::sync::atomic::AtomicBool)).1: &std::sync::atomic::AtomicBool);
        _17 = Relaxed;
        _16 = AtomicBool::load(_14, move _17) -> [return: bb12, unwind continue];
    }

    bb10: {
        unreachable;
    }

    bb11: {
        _29 = const {alloc2: &AtomicUsize};
        _30 = Relaxed;
        _28 = AtomicUsize::fetch_add(_29, const 1_usize, move _30) -> [return: bb16, unwind continue];
    }

    bb12: {
        _15 = Not(move _16);
        switchInt(move _15) -> [0: bb7, otherwise: bb13];
    }

    bb13: {
        _40 = const _;
        _20 = _40 as &[&str] (Pointer(Unsize));
        _25 = &_13;
        _24 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_25) -> [return: bb14, unwind continue];
    }

    bb14: {
        _23 = [move _24];
        _22 = &_23;
        _21 = _22 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _19 = Arguments::<'_>::new_v1(move _20, move _21) -> [return: bb15, unwind continue];
    }

    bb15: {
        _18 = panic_fmt(move _19) -> unwind continue;
    }

    bb16: {
        _27 = &_28;
        _41 = const _;
        _26 = (move _27, _41);
        _31 = (_26.0: &usize);
        _32 = (_26.1: &usize);
        _35 = (*_31);
        _36 = (*_32);
        _34 = Eq(move _35, move _36);
        _33 = Not(move _34);
        switchInt(move _33) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _37 = core::panicking::AssertKind::Eq;
        _39 = Option::<Arguments<'_>>::None;
        _38 = core::panicking::assert_failed::<usize, usize>(move _37, _31, _32, move _39) -> unwind continue;
    }

    bb18: {
        return;
    }

    bb19 (cleanup): {
        drop(_2) -> [return: bb20, unwind terminate];
    }

    bb20 (cleanup): {
        drop(_1) -> [return: bb21, unwind terminate];
    }

    bb21 (cleanup): {
        resume;
    }
}

alloc2 (static: BAR, size: 8, align: 8) {
    02 00 00 00 00 00 00 00                         │ ........
}

alloc1 (static: FOO, size: 3, align: 1) {
    00 00 00                                        │ ...
}

promoted[0] in main: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const " not set"];
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = core::num::<impl usize>::max_value() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = &_1;
        return;
    }
}

fn Print(_1: usize) -> Print {
    let mut _0: Print;

    bb0: {
        _0 = Print(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Print(_1: usize) -> Print {
    let mut _0: Print;

    bb0: {
        _0 = Print(move _1);
        return;
    }
}
