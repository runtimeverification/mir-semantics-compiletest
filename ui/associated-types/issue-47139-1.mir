// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/associated-types/issue-47139-1.rs:30:1: 30:33>::values(_1: Option<T>) -> <T as Insertable>::Values {
    debug self => _1;                    // in scope 0 at ui/associated-types/issue-47139-1.rs:37:15: 37:19
    let mut _0: <T as Insertable>::Values; // return place in scope 0 at ui/associated-types/issue-47139-1.rs:37:24: 37:36
    let mut _2: std::option::Option<<T as Insertable>::Values>; // in scope 0 at ui/associated-types/issue-47139-1.rs:38:9: 38:37
    let mut _3: std::option::Option<T>;  // in scope 0 at ui/associated-types/issue-47139-1.rs:38:9: 38:13

    bb0: {
        _3 = move _1;                    // scope 0 at ui/associated-types/issue-47139-1.rs:38:9: 38:13
        _2 = Option::<T>::map::<<T as Insertable>::Values, fn(T) -> <T as Insertable>::Values {<T as Insertable>::values}>(move _3, <T as Insertable>::values) -> bb1; // scope 0 at ui/associated-types/issue-47139-1.rs:38:9: 38:37
                                         // mir::Constant
                                         // + span: ui/associated-types/issue-47139-1.rs:38:14: 38:17
                                         // + literal: Const { ty: fn(Option<T>, fn(T) -> <T as Insertable>::Values {<T as Insertable>::values}) -> Option<<T as Insertable>::Values> {Option::<T>::map::<<T as Insertable>::Values, fn(T) -> <T as Insertable>::Values {<T as Insertable>::values}>}, val: Value(<ZST>) }
                                         // mir::Constant
                                         // + span: ui/associated-types/issue-47139-1.rs:38:18: 38:36
                                         // + literal: Const { ty: fn(T) -> <T as Insertable>::Values {<T as Insertable>::values}, val: Value(<ZST>) }
    }

    bb1: {
        _0 = Option::<<T as Insertable>::Values>::unwrap_or_default(move _2) -> bb2; // scope 0 at ui/associated-types/issue-47139-1.rs:38:9: 38:57
                                         // mir::Constant
                                         // + span: ui/associated-types/issue-47139-1.rs:38:38: 38:55
                                         // + literal: Const { ty: fn(Option<<T as Insertable>::Values>) -> <T as Insertable>::Values {Option::<<T as Insertable>::Values>::unwrap_or_default}, val: Value(<ZST>) }
    }

    bb2: {
        return;                          // scope 0 at ui/associated-types/issue-47139-1.rs:39:6: 39:6
    }
}

fn <impl at ui/associated-types/issue-47139-1.rs:42:1: 42:41>::values(_1: &Option<T>) -> <Option<&T> as Insertable>::Values {
    debug self => _1;                    // in scope 0 at ui/associated-types/issue-47139-1.rs:48:15: 48:19
    let mut _0: <std::option::Option<&T> as Insertable>::Values; // return place in scope 0 at ui/associated-types/issue-47139-1.rs:48:24: 48:36
    let mut _2: std::option::Option<&T>; // in scope 0 at ui/associated-types/issue-47139-1.rs:49:9: 49:22
    let mut _3: &std::option::Option<T>; // in scope 0 at ui/associated-types/issue-47139-1.rs:49:9: 49:22

    bb0: {
        _3 = _1;                         // scope 0 at ui/associated-types/issue-47139-1.rs:49:9: 49:22
        _2 = Option::<T>::as_ref(move _3) -> bb1; // scope 0 at ui/associated-types/issue-47139-1.rs:49:9: 49:22
                                         // mir::Constant
                                         // + span: ui/associated-types/issue-47139-1.rs:49:14: 49:20
                                         // + literal: Const { ty: for<'a> fn(&'a Option<T>) -> Option<&'a T> {Option::<T>::as_ref}, val: Value(<ZST>) }
    }

    bb1: {
        _0 = <Option<&T> as Insertable>::values(move _2) -> bb2; // scope 0 at ui/associated-types/issue-47139-1.rs:49:9: 49:31
                                         // mir::Constant
                                         // + span: ui/associated-types/issue-47139-1.rs:49:23: 49:29
                                         // + literal: Const { ty: fn(Option<&T>) -> <Option<&T> as Insertable>::Values {<Option<&T> as Insertable>::values}, val: Value(<ZST>) }
    }

    bb2: {
        return;                          // scope 0 at ui/associated-types/issue-47139-1.rs:50:6: 50:6
    }
}

fn <impl at ui/associated-types/issue-47139-1.rs:53:1: 53:35>::values(_1: &[T]) -> &[T] {
    debug self => _1;                    // in scope 0 at ui/associated-types/issue-47139-1.rs:57:15: 57:19
    let mut _0: &[T];                    // return place in scope 0 at ui/associated-types/issue-47139-1.rs:57:24: 57:36

    bb0: {
        _0 = _1;                         // scope 0 at ui/associated-types/issue-47139-1.rs:58:9: 58:13
        return;                          // scope 0 at ui/associated-types/issue-47139-1.rs:59:6: 59:6
    }
}

fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/associated-types/issue-47139-1.rs:77:11: 77:11

    bb0: {
        return;                          // scope 0 at ui/associated-types/issue-47139-1.rs:78:2: 78:2
    }
}
