// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/associated-types/issue-47139-2.rs:18:1: 18:33>::values(_1: Option<T>) -> <T as Insertable>::Values {
    debug self => _1;                    // in scope 0 at ui/associated-types/issue-47139-2.rs:25:15: 25:19
    let mut _0: <T as Insertable>::Values; // return place in scope 0 at ui/associated-types/issue-47139-2.rs:25:24: 25:36
    let mut _2: std::option::Option<<T as Insertable>::Values>; // in scope 0 at ui/associated-types/issue-47139-2.rs:26:9: 26:37
    let mut _3: std::option::Option<T>;  // in scope 0 at ui/associated-types/issue-47139-2.rs:26:9: 26:13

    bb0: {
        _3 = move _1;                    // scope 0 at ui/associated-types/issue-47139-2.rs:26:9: 26:13
        _2 = Option::<T>::map::<<T as Insertable>::Values, fn(T) -> <T as Insertable>::Values {<T as Insertable>::values}>(move _3, <T as Insertable>::values) -> bb1; // scope 0 at ui/associated-types/issue-47139-2.rs:26:9: 26:37
                                         // mir::Constant
                                         // + span: ui/associated-types/issue-47139-2.rs:26:14: 26:17
                                         // + literal: Const { ty: fn(Option<T>, fn(T) -> <T as Insertable>::Values {<T as Insertable>::values}) -> Option<<T as Insertable>::Values> {Option::<T>::map::<<T as Insertable>::Values, fn(T) -> <T as Insertable>::Values {<T as Insertable>::values}>}, val: Value(<ZST>) }
                                         // mir::Constant
                                         // + span: ui/associated-types/issue-47139-2.rs:26:18: 26:36
                                         // + literal: Const { ty: fn(T) -> <T as Insertable>::Values {<T as Insertable>::values}, val: Value(<ZST>) }
    }

    bb1: {
        _0 = Option::<<T as Insertable>::Values>::unwrap_or_default(move _2) -> bb2; // scope 0 at ui/associated-types/issue-47139-2.rs:26:9: 26:57
                                         // mir::Constant
                                         // + span: ui/associated-types/issue-47139-2.rs:26:38: 26:55
                                         // + literal: Const { ty: fn(Option<<T as Insertable>::Values>) -> <T as Insertable>::Values {Option::<<T as Insertable>::Values>::unwrap_or_default}, val: Value(<ZST>) }
    }

    bb2: {
        return;                          // scope 0 at ui/associated-types/issue-47139-2.rs:27:6: 27:6
    }
}

fn <impl at ui/associated-types/issue-47139-2.rs:30:1: 30:41>::values(_1: &Option<T>) -> <Option<&T> as Insertable>::Values {
    debug self => _1;                    // in scope 0 at ui/associated-types/issue-47139-2.rs:36:15: 36:19
    let mut _0: <std::option::Option<&T> as Insertable>::Values; // return place in scope 0 at ui/associated-types/issue-47139-2.rs:36:24: 36:36
    let mut _2: std::option::Option<&T>; // in scope 0 at ui/associated-types/issue-47139-2.rs:37:9: 37:22
    let mut _3: &std::option::Option<T>; // in scope 0 at ui/associated-types/issue-47139-2.rs:37:9: 37:22

    bb0: {
        _3 = _1;                         // scope 0 at ui/associated-types/issue-47139-2.rs:37:9: 37:22
        _2 = Option::<T>::as_ref(move _3) -> bb1; // scope 0 at ui/associated-types/issue-47139-2.rs:37:9: 37:22
                                         // mir::Constant
                                         // + span: ui/associated-types/issue-47139-2.rs:37:14: 37:20
                                         // + literal: Const { ty: for<'a> fn(&'a Option<T>) -> Option<&'a T> {Option::<T>::as_ref}, val: Value(<ZST>) }
    }

    bb1: {
        _0 = <Option<&T> as Insertable>::values(move _2) -> bb2; // scope 0 at ui/associated-types/issue-47139-2.rs:37:9: 37:31
                                         // mir::Constant
                                         // + span: ui/associated-types/issue-47139-2.rs:37:23: 37:29
                                         // + literal: Const { ty: fn(Option<&T>) -> <Option<&T> as Insertable>::Values {<Option<&T> as Insertable>::values}, val: Value(<ZST>) }
    }

    bb2: {
        return;                          // scope 0 at ui/associated-types/issue-47139-2.rs:38:6: 38:6
    }
}

fn <impl at ui/associated-types/issue-47139-2.rs:41:1: 41:35>::values(_1: &[T]) -> &[T] {
    debug self => _1;                    // in scope 0 at ui/associated-types/issue-47139-2.rs:45:15: 45:19
    let mut _0: &[T];                    // return place in scope 0 at ui/associated-types/issue-47139-2.rs:45:24: 45:36

    bb0: {
        _0 = _1;                         // scope 0 at ui/associated-types/issue-47139-2.rs:46:9: 46:13
        return;                          // scope 0 at ui/associated-types/issue-47139-2.rs:47:6: 47:6
    }
}

fn main() -> () {
    let mut _0: ();                      // return place in scope 0 at ui/associated-types/issue-47139-2.rs:65:11: 65:11

    bb0: {
        return;                          // scope 0 at ui/associated-types/issue-47139-2.rs:66:2: 66:2
    }
}
