// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
static COUNTER: AtomicUsize = {
    let mut _0: std::sync::atomic::AtomicUsize;

    bb0: {
        ConstEvalCounter;
        _0 = AtomicUsize::new(const 0_usize) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/associated-types/associated-types-project-from-type-param-via-bound-in-where.rs:21:1: 21:7>::foo(_1: <T as Trait>::Item) -> () {
    debug _x => _1;
    let mut _0: ();
    let _2: usize;
    let _3: &std::sync::atomic::AtomicUsize;
    let mut _4: std::sync::atomic::Ordering;

    bb0: {
        _3 = const {alloc1: &AtomicUsize};
        _4 = SeqCst;
        _2 = AtomicUsize::fetch_add(_3, const 1_usize, move _4) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        drop(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }

    bb3 (cleanup): {
        drop(_1) -> [return: bb4, unwind terminate];
    }

    bb4 (cleanup): {
        resume;
    }
}

alloc1 (static: COUNTER, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

fn <impl at ui/associated-types/associated-types-project-from-type-param-via-bound-in-where.rs:29:1: 29:13>::foo(_1: <T as Trait>::Item) -> () {
    debug _x => _1;
    let mut _0: ();
    let _2: usize;
    let _3: &std::sync::atomic::AtomicUsize;
    let mut _4: std::sync::atomic::Ordering;

    bb0: {
        _3 = const {alloc1: &AtomicUsize};
        _4 = SeqCst;
        _2 = AtomicUsize::fetch_add(_3, const 10_usize, move _4) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        drop(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }

    bb3 (cleanup): {
        drop(_1) -> [return: bb4, unwind terminate];
    }

    bb4 (cleanup): {
        resume;
    }
}

alloc1 (static: COUNTER, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

fn c(_1: <T as Trait>::Item) -> () {
    let mut _0: ();
    let _2: usize;
    let _3: &std::sync::atomic::AtomicUsize;
    let mut _4: std::sync::atomic::Ordering;

    bb0: {
        _3 = const {alloc1: &AtomicUsize};
        _4 = SeqCst;
        _2 = AtomicUsize::fetch_add(_3, const 100_usize, move _4) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        drop(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }

    bb3 (cleanup): {
        drop(_1) -> [return: bb4, unwind terminate];
    }

    bb4 (cleanup): {
        resume;
    }
}

alloc1 (static: COUNTER, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

fn AnotherTrait::default_method(_1: &Self, _2: <T as Trait>::Item) -> () {
    debug self => _1;
    let mut _0: ();
    let _3: usize;
    let _4: &std::sync::atomic::AtomicUsize;
    let mut _5: std::sync::atomic::Ordering;

    bb0: {
        _4 = const {alloc1: &AtomicUsize};
        _5 = SeqCst;
        _3 = AtomicUsize::fetch_add(_4, const 1000_usize, move _5) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        drop(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }

    bb3 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate];
    }

    bb4 (cleanup): {
        resume;
    }
}

alloc1 (static: COUNTER, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

fn <impl at ui/associated-types/associated-types-project-from-type-param-via-bound-in-where.rs:48:1: 48:24>::method(_1: &D, _2: <T as Trait>::Item) -> () {
    debug self => _1;
    let mut _0: ();
    let _3: usize;
    let _4: &std::sync::atomic::AtomicUsize;
    let mut _5: std::sync::atomic::Ordering;

    bb0: {
        _4 = const {alloc1: &AtomicUsize};
        _5 = SeqCst;
        _3 = AtomicUsize::fetch_add(_4, const 10000_usize, move _5) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        drop(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }

    bb3 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate];
    }

    bb4 (cleanup): {
        resume;
    }
}

alloc1 (static: COUNTER, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

fn YetAnotherTrait::default_method(_1: &Self, _2: <T as Trait>::Item) -> () {
    debug self => _1;
    let mut _0: ();
    let _3: usize;
    let _4: &std::sync::atomic::AtomicUsize;
    let mut _5: std::sync::atomic::Ordering;

    bb0: {
        _4 = const {alloc1: &AtomicUsize};
        _5 = SeqCst;
        _3 = AtomicUsize::fetch_add(_4, const 100000_usize, move _5) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        drop(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }

    bb3 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate];
    }

    bb4 (cleanup): {
        resume;
    }
}

alloc1 (static: COUNTER, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

fn <impl at ui/associated-types/associated-types-project-from-type-param-via-bound-in-where.rs:64:1: 64:36>::method(_1: &E<T>, _2: <T as Trait>::Item) -> () {
    debug self => _1;
    let mut _0: ();
    let _3: usize;
    let _4: &std::sync::atomic::AtomicUsize;
    let mut _5: std::sync::atomic::Ordering;

    bb0: {
        _4 = const {alloc1: &AtomicUsize};
        _5 = SeqCst;
        _3 = AtomicUsize::fetch_add(_4, const 1000000_usize, move _5) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        drop(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }

    bb3 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate];
    }

    bb4 (cleanup): {
        resume;
    }
}

alloc1 (static: COUNTER, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

fn <impl at ui/associated-types/associated-types-project-from-type-param-via-bound-in-where.rs:74:1: 74:13>::method(_1: &F<T>, _2: <T as Trait>::Item) -> () {
    debug self => _1;
    let mut _0: ();
    let _3: usize;
    let _4: &std::sync::atomic::AtomicUsize;
    let mut _5: std::sync::atomic::Ordering;

    bb0: {
        _4 = const {alloc1: &AtomicUsize};
        _5 = SeqCst;
        _3 = AtomicUsize::fetch_add(_4, const 10000000_usize, move _5) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        drop(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }

    bb3 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate];
    }

    bb4 (cleanup): {
        resume;
    }
}

alloc1 (static: COUNTER, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

fn main() -> () {
    let mut _0: ();
    let _1: ();
    let _2: ();
    let _3: ();
    let _4: ();
    let _5: ();
    let _6: ();
    let _7: ();
    let _8: ();
    let mut _9: (&usize, &usize);
    let mut _10: &usize;
    let _11: usize;
    let _12: &std::sync::atomic::AtomicUsize;
    let mut _13: std::sync::atomic::Ordering;
    let _14: &usize;
    let _15: &usize;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: usize;
    let mut _19: usize;
    let _21: !;
    let mut _22: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _23: &usize;
    let mut _24: &F<Struct>;
    let mut _25: &E<Struct>;
    let mut _26: &E<Struct>;
    let mut _27: &D;
    let mut _28: &D;
    scope 1 {
        debug left_val => _14;
        debug right_val => _15;
        let _20: core::panicking::AssertKind;
        scope 2 {
            debug kind => _20;
        }
    }

    bb0: {
        _1 = A::foo::<Struct>(const 22_u32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = B::<Struct>::foo(const 22_u32) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = c::<Struct>(const 22_u32) -> [return: bb3, unwind continue];
    }

    bb3: {
        _28 = const _;
        _4 = <D as AnotherTrait>::method::<Struct>(_28, const 22_u32) -> [return: bb4, unwind continue];
    }

    bb4: {
        _27 = const _;
        _5 = <D as AnotherTrait>::default_method::<Struct>(_27, const 22_u32) -> [return: bb5, unwind continue];
    }

    bb5: {
        _26 = const _;
        _6 = <E<Struct> as YetAnotherTrait<Struct>>::method(_26, const 22_u32) -> [return: bb6, unwind continue];
    }

    bb6: {
        _25 = const _;
        _7 = <E<Struct> as YetAnotherTrait<Struct>>::default_method(_25, const 22_u32) -> [return: bb7, unwind continue];
    }

    bb7: {
        _24 = const _;
        _8 = F::<Struct>::method(_24, const 22_u32) -> [return: bb8, unwind continue];
    }

    bb8: {
        _12 = const {alloc1: &AtomicUsize};
        _13 = SeqCst;
        _11 = AtomicUsize::load(_12, move _13) -> [return: bb9, unwind continue];
    }

    bb9: {
        _10 = &_11;
        _23 = const _;
        _9 = (move _10, _23);
        _14 = (_9.0: &usize);
        _15 = (_9.1: &usize);
        _18 = (*_14);
        _19 = (*_15);
        _17 = Eq(move _18, move _19);
        _16 = Not(move _17);
        switchInt(move _16) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _20 = core::panicking::AssertKind::Eq;
        _22 = Option::<Arguments<'_>>::None;
        _21 = core::panicking::assert_failed::<usize, usize>(move _20, _14, _15, move _22) -> unwind continue;
    }

    bb11: {
        return;
    }
}

alloc1 (static: COUNTER, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

promoted[0] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 11111111_usize;
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &F<Struct> = {
    let mut _0: &F<Struct>;
    let mut _1: F<Struct>;
    let mut _2: std::marker::PhantomData<Struct>;

    bb0: {
        _2 = PhantomData::<Struct>;
        _1 = F::<Struct>(move _2);
        _0 = &_1;
        return;
    }
}

promoted[2] in main: &E<Struct> = {
    let mut _0: &E<Struct>;
    let mut _1: E<Struct>;
    let mut _2: std::marker::PhantomData<Struct>;

    bb0: {
        _2 = PhantomData::<Struct>;
        _1 = E::<Struct>(move _2);
        _0 = &_1;
        return;
    }
}

promoted[3] in main: &E<Struct> = {
    let mut _0: &E<Struct>;
    let mut _1: E<Struct>;
    let mut _2: std::marker::PhantomData<Struct>;

    bb0: {
        _2 = PhantomData::<Struct>;
        _1 = E::<Struct>(move _2);
        _0 = &_1;
        return;
    }
}

promoted[4] in main: &D = {
    let mut _0: &D;
    let mut _1: D;

    bb0: {
        _1 = D;
        _0 = &_1;
        return;
    }
}

promoted[5] in main: &D = {
    let mut _0: &D;
    let mut _1: D;

    bb0: {
        _1 = D;
        _0 = &_1;
        return;
    }
}

fn B(_1: PhantomData<T>) -> B<T> {
    let mut _0: B<T>;

    bb0: {
        _0 = B::<T>(move _1);
        return;
    }
}

// MIR FOR CTFE
fn B(_1: PhantomData<T>) -> B<T> {
    let mut _0: B<T>;

    bb0: {
        _0 = B::<T>(move _1);
        return;
    }
}

fn E(_1: PhantomData<T>) -> E<T> {
    let mut _0: E<T>;

    bb0: {
        _0 = E::<T>(move _1);
        return;
    }
}

// MIR FOR CTFE
fn E(_1: PhantomData<T>) -> E<T> {
    let mut _0: E<T>;

    bb0: {
        _0 = E::<T>(move _1);
        return;
    }
}

fn F(_1: PhantomData<T>) -> F<T> {
    let mut _0: F<T>;

    bb0: {
        _0 = F::<T>(move _1);
        return;
    }
}

// MIR FOR CTFE
fn F(_1: PhantomData<T>) -> F<T> {
    let mut _0: F<T>;

    bb0: {
        _0 = F::<T>(move _1);
        return;
    }
}
