// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -> () {
    let mut _0: ();
    let _1: std::vec::Vec<std::string::String>;
    let mut _2: std::env::Args;
    let mut _3: bool;
    let mut _4: usize;
    let mut _5: &std::vec::Vec<std::string::String>;
    let mut _6: (&std::string::String, &&str);
    let mut _7: &std::string::String;
    let _8: &std::string::String;
    let mut _9: &std::vec::Vec<std::string::String>;
    let mut _12: bool;
    let mut _13: bool;
    let _15: !;
    let mut _16: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _17: (&std::string::String, &&str);
    let mut _18: &std::string::String;
    let _19: &std::string::String;
    let mut _20: &std::vec::Vec<std::string::String>;
    let mut _23: bool;
    let mut _24: bool;
    let _26: !;
    let mut _27: std::option::Option<std::fmt::Arguments<'_>>;
    let _28: ();
    let mut _29: std::fmt::Arguments<'_>;
    let mut _30: &[&str];
    let mut _32: std::result::Result<std::process::Output, std::io::Error>;
    let mut _33: &mut std::process::Command;
    let mut _34: &mut std::process::Command;
    let mut _35: &mut std::process::Command;
    let mut _36: &mut std::process::Command;
    let mut _37: &mut std::process::Command;
    let mut _38: std::process::Command;
    let mut _39: &std::string::String;
    let _40: &std::string::String;
    let mut _41: &std::vec::Vec<std::string::String>;
    let mut _42: bool;
    let mut _43: bool;
    let mut _44: &std::vec::Vec<u8>;
    let _45: !;
    let mut _46: std::fmt::Arguments<'_>;
    let mut _47: &[&str];
    let mut _48: &[core::fmt::rt::Argument<'_>];
    let _49: &[core::fmt::rt::Argument<'_>; 1];
    let _50: [core::fmt::rt::Argument<'_>; 1];
    let mut _51: core::fmt::rt::Argument<'_>;
    let _52: &std::borrow::Cow<'_, str>;
    let _53: std::borrow::Cow<'_, str>;
    let mut _54: &[u8];
    let _55: &[u8];
    let _56: &std::vec::Vec<u8>;
    let mut _57: bool;
    let mut _58: bool;
    let mut _59: &std::process::ExitStatus;
    let mut _60: !;
    let mut _61: (&std::vec::Vec<u8>, &&[u8; 7]);
    let mut _62: &std::vec::Vec<u8>;
    let mut _65: bool;
    let mut _66: bool;
    let _68: !;
    let mut _69: std::option::Option<std::fmt::Arguments<'_>>;
    scope 1 {
        debug args => _1;
        let _10: &std::string::String;
        let _11: &&str;
        let _21: &std::string::String;
        let _22: &&str;
        let _31: std::process::Output;
        let mut _70: &[&str; 1];
        let mut _71: &&str;
        let mut _72: &&str;
        scope 2 {
            debug left_val => _10;
            debug right_val => _11;
            let _14: core::panicking::AssertKind;
            scope 3 {
                debug kind => _14;
            }
        }
        scope 4 {
            debug left_val => _21;
            debug right_val => _22;
            let _25: core::panicking::AssertKind;
            scope 5 {
                debug kind => _25;
            }
        }
        scope 6 {
            debug output => _31;
            let _63: &std::vec::Vec<u8>;
            let _64: &&[u8; 7];
            let mut _73: &[&str; 1];
            let mut _74: &&[u8; 7];
            scope 7 {
                debug left_val => _63;
                debug right_val => _64;
                let _67: core::panicking::AssertKind;
                scope 8 {
                    debug kind => _67;
                }
            }
        }
    }

    bb0: {
        _2 = args() -> [return: bb1, unwind continue];
    }

    bb1: {
        _1 = <Args as Iterator>::collect::<Vec<String>>(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = &_1;
        _4 = Vec::<String>::len(move _5) -> [return: bb3, unwind: bb41];
    }

    bb3: {
        _3 = Gt(move _4, const 1_usize);
        switchInt(move _3) -> [0: bb15, otherwise: bb4];
    }

    bb4: {
        _9 = &_1;
        _8 = <Vec<String> as Index<usize>>::index(move _9, const 1_usize) -> [return: bb5, unwind: bb41];
    }

    bb5: {
        _7 = _8;
        _72 = const _;
        _6 = (move _7, _72);
        _10 = (_6.0: &std::string::String);
        _11 = (_6.1: &&str);
        _13 = <String as PartialEq<&str>>::eq(_10, _11) -> [return: bb6, unwind: bb41];
    }

    bb6: {
        _12 = Not(move _13);
        switchInt(move _12) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _14 = core::panicking::AssertKind::Eq;
        _16 = Option::<Arguments<'_>>::None;
        _15 = core::panicking::assert_failed::<String, &str>(move _14, _10, _11, move _16) -> bb41;
    }

    bb8: {
        _20 = &_1;
        _19 = <Vec<String> as Index<usize>>::index(move _20, const 0_usize) -> [return: bb9, unwind: bb41];
    }

    bb9: {
        _18 = _19;
        _71 = const _;
        _17 = (move _18, _71);
        _21 = (_17.0: &std::string::String);
        _22 = (_17.1: &&str);
        _24 = <String as PartialEq<&str>>::eq(_21, _22) -> [return: bb10, unwind: bb41];
    }

    bb10: {
        _23 = Not(move _24);
        switchInt(move _23) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _25 = core::panicking::AssertKind::Eq;
        _27 = Option::<Arguments<'_>>::None;
        _26 = core::panicking::assert_failed::<String, &str>(move _25, _21, _22, move _27) -> bb41;
    }

    bb12: {
        _70 = const _;
        _30 = _70 as &[&str] (Pointer(Unsize));
        _29 = Arguments::<'_>::new_const(move _30) -> [return: bb13, unwind: bb41];
    }

    bb13: {
        _28 = _print(move _29) -> [return: bb14, unwind: bb41];
    }

    bb14: {
        drop(_1) -> [return: bb37, unwind continue];
    }

    bb15: {
        _41 = &_1;
        _40 = <Vec<String> as Index<usize>>::index(move _41, const 0_usize) -> [return: bb16, unwind: bb41];
    }

    bb16: {
        _39 = _40;
        _38 = Command::new::<&String>(move _39) -> [return: bb17, unwind: bb41];
    }

    bb17: {
        _37 = &mut _38;
        _36 = Command::arg::<&str>(move _37, const "doing-test") -> [return: bb18, unwind: bb40];
    }

    bb18: {
        _35 = _36;
        _34 = <Command as std::os::unix::process::CommandExt>::arg0::<&str>(move _35, const "i have a silly name") -> [return: bb19, unwind: bb40];
    }

    bb19: {
        _33 = _34;
        _32 = Command::output(move _33) -> [return: bb20, unwind: bb40];
    }

    bb20: {
        _31 = Result::<Output, std::io::Error>::unwrap(move _32) -> [return: bb21, unwind: bb40];
    }

    bb21: {
        drop(_38) -> [return: bb22, unwind: bb39];
    }

    bb22: {
        _44 = &(_31.2: std::vec::Vec<u8>);
        _43 = Vec::<u8>::is_empty(move _44) -> [return: bb23, unwind: bb39];
    }

    bb23: {
        _42 = Not(move _43);
        switchInt(move _42) -> [0: bb29, otherwise: bb24];
    }

    bb24: {
        _73 = const _;
        _47 = _73 as &[&str] (Pointer(Unsize));
        _56 = &(_31.2: std::vec::Vec<u8>);
        _55 = <Vec<u8> as Deref>::deref(_56) -> [return: bb25, unwind: bb39];
    }

    bb25: {
        _54 = _55;
        _53 = String::from_utf8_lossy(move _54) -> [return: bb26, unwind: bb39];
    }

    bb26: {
        _52 = &_53;
        _51 = core::fmt::rt::Argument::<'_>::new_display::<Cow<'_, str>>(_52) -> [return: bb27, unwind: bb38];
    }

    bb27: {
        _50 = [move _51];
        _49 = &_50;
        _48 = _49 as &[core::fmt::rt::Argument<'_>] (Pointer(Unsize));
        _46 = Arguments::<'_>::new_v1(move _47, move _48) -> [return: bb28, unwind: bb38];
    }

    bb28: {
        _45 = panic_fmt(move _46) -> bb38;
    }

    bb29: {
        _59 = &(_31.0: std::process::ExitStatus);
        _58 = ExitStatus::success(move _59) -> [return: bb30, unwind: bb39];
    }

    bb30: {
        _57 = Not(move _58);
        switchInt(move _57) -> [0: bb32, otherwise: bb31];
    }

    bb31: {
        _60 = core::panicking::panic(const "assertion failed: output.status.success()") -> bb39;
    }

    bb32: {
        _62 = &(_31.1: std::vec::Vec<u8>);
        _74 = const _;
        _61 = (move _62, _74);
        _63 = (_61.0: &std::vec::Vec<u8>);
        _64 = (_61.1: &&[u8; 7]);
        _66 = <Vec<u8> as PartialEq<&[u8; 7]>>::eq(_63, _64) -> [return: bb33, unwind: bb39];
    }

    bb33: {
        _65 = Not(move _66);
        switchInt(move _65) -> [0: bb35, otherwise: bb34];
    }

    bb34: {
        _67 = core::panicking::AssertKind::Eq;
        _69 = Option::<Arguments<'_>>::None;
        _68 = core::panicking::assert_failed::<Vec<u8>, &[u8; 7]>(move _67, _63, _64, move _69) -> bb39;
    }

    bb35: {
        drop(_31) -> [return: bb36, unwind: bb41];
    }

    bb36: {
        drop(_1) -> [return: bb37, unwind continue];
    }

    bb37: {
        return;
    }

    bb38 (cleanup): {
        drop(_53) -> [return: bb39, unwind terminate];
    }

    bb39 (cleanup): {
        drop(_31) -> [return: bb41, unwind terminate];
    }

    bb40 (cleanup): {
        drop(_38) -> [return: bb41, unwind terminate];
    }

    bb41 (cleanup): {
        drop(_1) -> [return: bb42, unwind terminate];
    }

    bb42 (cleanup): {
        resume;
    }
}

promoted[0] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "passed\n"];
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "i have a silly name";
        _0 = &_1;
        return;
    }
}

promoted[2] in main: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "doing-test";
        _0 = &_1;
        return;
    }
}

promoted[3] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Non-empty stderr: "];
        _0 = &_1;
        return;
    }
}

promoted[4] in main: &&[u8; 7] = {
    let mut _0: &&[u8; 7];
    let mut _1: &[u8; 7];

    bb0: {
        _1 = const b"passed\n";
        _0 = &_1;
        return;
    }
}

alloc1 (size: 7, align: 1) {
    70 61 73 73 65 64 0a                            │ passed.
}
