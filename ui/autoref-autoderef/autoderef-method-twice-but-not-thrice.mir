// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/autoref-autoderef/autoderef-method-twice-but-not-thrice.rs:8:1: 8:27>::double(_1: Box<Box<usize>>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: usize;
    let mut _3: std::boxed::Box<usize>;
    let mut _4: *const std::boxed::Box<usize>;
    let mut _5: *const usize;
    let mut _6: *const ();
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _12: *const ();
    let mut _13: usize;
    let mut _14: usize;
    let mut _15: usize;
    let mut _16: usize;
    let mut _17: bool;

    bb0: {
        _4 = (((_1.0: std::ptr::Unique<std::boxed::Box<usize>>).0: std::ptr::NonNull<std::boxed::Box<usize>>).0: *const std::boxed::Box<usize>);
        _12 = _4 as *const () (PtrToPtr);
        _13 = _12 as usize (Transmute);
        _14 = AlignOf(std::boxed::Box<usize>);
        _15 = Sub(_14, const 1_usize);
        _16 = BitAnd(_13, _15);
        _17 = Eq(_16, const 0_usize);
        assert(_17, "misaligned pointer dereference: address must be a multiple of {} but is {}", _14, _13) -> [success: bb3, unwind unreachable];
    }

    bb1: {
        return;
    }

    bb2: {
        _2 = (*_5);
        _0 = Mul(move _2, const 2_usize);
        drop(_1) -> [return: bb1, unwind continue];
    }

    bb3: {
        _3 = deref_copy (*_4);
        _5 = (((_3.0: std::ptr::Unique<usize>).0: std::ptr::NonNull<usize>).0: *const usize);
        _6 = _5 as *const () (PtrToPtr);
        _7 = _6 as usize (Transmute);
        _8 = AlignOf(usize);
        _9 = Sub(_8, const 1_usize);
        _10 = BitAnd(_7, _9);
        _11 = Eq(_10, const 0_usize);
        assert(_11, "misaligned pointer dereference: address must be a multiple of {} but is {}", _8, _7) -> [success: bb2, unwind unreachable];
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>>;
    let mut _2: std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>;
    let mut _3: std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>;
    let mut _4: std::boxed::Box<std::boxed::Box<usize>>;
    let mut _5: std::boxed::Box<usize>;
    let mut _6: (&usize, &usize);
    let mut _7: &usize;
    let _8: usize;
    let mut _9: std::boxed::Box<std::boxed::Box<usize>>;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: usize;
    let mut _15: usize;
    let _17: !;
    let mut _18: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _20: std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>;
    let mut _21: std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>;
    let mut _22: &mut std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>>;
    let mut _23: ();
    let mut _24: &mut std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>>;
    let mut _25: ();
    let mut _26: &mut std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>;
    let mut _27: ();
    let mut _28: &mut std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>;
    let mut _29: ();
    let mut _30: &mut std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>;
    let mut _31: ();
    let mut _32: &mut std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>>;
    let mut _33: ();
    let mut _34: &mut std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>;
    let mut _35: ();
    let mut _36: &mut std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>;
    let mut _37: ();
    let mut _38: *const std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>;
    let mut _39: *const std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>;
    let mut _40: *const std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>;
    let mut _41: *const std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>;
    let mut _42: *const std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>;
    let mut _43: *const std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>;
    let mut _44: *const std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>;
    let mut _45: *const std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>;
    let mut _46: *const std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>;
    let mut _47: *const std::boxed::Box<std::boxed::Box<usize>>;
    let mut _48: *const ();
    let mut _49: usize;
    let mut _50: usize;
    let mut _51: usize;
    let mut _52: usize;
    let mut _53: bool;
    let mut _54: *const ();
    let mut _55: usize;
    let mut _56: usize;
    let mut _57: usize;
    let mut _58: usize;
    let mut _59: bool;
    let mut _60: *const ();
    let mut _61: usize;
    let mut _62: usize;
    let mut _63: usize;
    let mut _64: usize;
    let mut _65: bool;
    let mut _66: *const ();
    let mut _67: usize;
    let mut _68: usize;
    let mut _69: usize;
    let mut _70: usize;
    let mut _71: bool;
    let mut _72: *const ();
    let mut _73: usize;
    let mut _74: usize;
    let mut _75: usize;
    let mut _76: usize;
    let mut _77: bool;
    let mut _78: *const ();
    let mut _79: usize;
    let mut _80: usize;
    let mut _81: usize;
    let mut _82: usize;
    let mut _83: bool;
    let mut _84: *const ();
    let mut _85: usize;
    let mut _86: usize;
    let mut _87: usize;
    let mut _88: usize;
    let mut _89: bool;
    scope 1 {
        debug x => _1;
        let _10: &usize;
        let _11: &usize;
        let mut _19: &usize;
        let mut _90: *const ();
        let mut _91: usize;
        let mut _92: usize;
        let mut _93: usize;
        let mut _94: usize;
        let mut _95: bool;
        let mut _96: *const ();
        let mut _97: usize;
        let mut _98: usize;
        let mut _99: usize;
        let mut _100: usize;
        let mut _101: bool;
        let mut _102: *const ();
        let mut _103: usize;
        let mut _104: usize;
        let mut _105: usize;
        let mut _106: usize;
        let mut _107: bool;
        scope 2 {
            debug left_val => _10;
            debug right_val => _11;
            let _16: core::panicking::AssertKind;
            scope 3 {
                debug kind => _16;
            }
        }
    }

    bb0: {
        _5 = Box::<usize>::new(const 3_usize) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = Box::<Box<usize>>::new(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = Box::<Box<Box<usize>>>::new(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = Box::<Box<Box<Box<usize>>>>::new(move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _1 = Box::<Box<Box<Box<Box<usize>>>>>::new(move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _45 = (((_1.0: std::ptr::Unique<std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>>).0: std::ptr::NonNull<std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>>).0: *const std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>);
        _102 = _45 as *const () (PtrToPtr);
        _103 = _102 as usize (Transmute);
        _104 = AlignOf(std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>);
        _105 = Sub(_104, const 1_usize);
        _106 = BitAnd(_103, _105);
        _107 = Eq(_106, const 0_usize);
        assert(_107, "misaligned pointer dereference: address must be a multiple of {} but is {}", _104, _103) -> [success: bb27, unwind unreachable];
    }

    bb6: {
        _7 = &_8;
        _19 = const _;
        _6 = (move _7, _19);
        _10 = (_6.0: &usize);
        _11 = (_6.1: &usize);
        _14 = (*_10);
        _15 = (*_11);
        _13 = Eq(move _14, move _15);
        _12 = Not(move _13);
        switchInt(move _12) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _16 = core::panicking::AssertKind::Eq;
        _18 = Option::<Arguments<'_>>::None;
        _17 = core::panicking::assert_failed::<usize, usize>(move _16, _10, _11, move _18) -> bb17;
    }

    bb8: {
        _40 = deref_copy (((_1.0: std::ptr::Unique<std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>>).0: std::ptr::NonNull<std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>>).0: *const std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>);
        _84 = _40 as *const () (PtrToPtr);
        _85 = _84 as usize (Transmute);
        _86 = AlignOf(std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>);
        _87 = Sub(_86, const 1_usize);
        _88 = BitAnd(_85, _87);
        _89 = Eq(_88, const 0_usize);
        assert(_89, "misaligned pointer dereference: address must be a multiple of {} but is {}", _86, _85) -> [success: bb24, unwind unreachable];
    }

    bb9 (cleanup): {
        resume;
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        _24 = &mut _1;
        _25 = <Box<Box<Box<Box<Box<usize>>>>> as Drop>::drop(move _24) -> [return: bb28, unwind terminate];
    }

    bb12: {
        _22 = &mut _1;
        _23 = <Box<Box<Box<Box<Box<usize>>>>> as Drop>::drop(move _22) -> [return: bb10, unwind continue];
    }

    bb13 (cleanup): {
        _39 = deref_copy (((_1.0: std::ptr::Unique<std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>>).0: std::ptr::NonNull<std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>>).0: *const std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>);
        _72 = _39 as *const () (PtrToPtr);
        _73 = _72 as usize (Transmute);
        _74 = AlignOf(std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>);
        _75 = Sub(_74, const 1_usize);
        _76 = BitAnd(_73, _75);
        _77 = Eq(_76, const 0_usize);
        assert(_77, "misaligned pointer dereference: address must be a multiple of {} but is {}", _74, _73) -> [success: bb22, unwind unreachable];
    }

    bb14: {
        _38 = deref_copy (((_1.0: std::ptr::Unique<std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>>).0: std::ptr::NonNull<std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>>).0: *const std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>);
        _66 = _38 as *const () (PtrToPtr);
        _67 = _66 as usize (Transmute);
        _68 = AlignOf(std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>);
        _69 = Sub(_68, const 1_usize);
        _70 = BitAnd(_67, _69);
        _71 = Eq(_70, const 0_usize);
        assert(_71, "misaligned pointer dereference: address must be a multiple of {} but is {}", _68, _67) -> [success: bb21, unwind unreachable];
    }

    bb15 (cleanup): {
        _32 = &mut _1;
        _33 = <Box<Box<Box<Box<Box<usize>>>>> as Drop>::drop(move _32) -> [return: bb29, unwind terminate];
    }

    bb16 (cleanup): {
        _42 = deref_copy (((_1.0: std::ptr::Unique<std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>>).0: std::ptr::NonNull<std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>>).0: *const std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>);
        _60 = _42 as *const () (PtrToPtr);
        _61 = _60 as usize (Transmute);
        _62 = AlignOf(std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>);
        _63 = Sub(_62, const 1_usize);
        _64 = BitAnd(_61, _63);
        _65 = Eq(_64, const 0_usize);
        assert(_65, "misaligned pointer dereference: address must be a multiple of {} but is {}", _62, _61) -> [success: bb20, unwind unreachable];
    }

    bb17 (cleanup): {
        _43 = deref_copy (((_1.0: std::ptr::Unique<std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>>).0: std::ptr::NonNull<std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>>).0: *const std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>);
        _54 = _43 as *const () (PtrToPtr);
        _55 = _54 as usize (Transmute);
        _56 = AlignOf(std::boxed::Box<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>);
        _57 = Sub(_56, const 1_usize);
        _58 = BitAnd(_55, _57);
        _59 = Eq(_58, const 0_usize);
        assert(_59, "misaligned pointer dereference: address must be a multiple of {} but is {}", _56, _55) -> [success: bb19, unwind unreachable];
    }

    bb18 (cleanup): {
        _36 = &mut (*_44);
        _37 = <Box<Box<Box<usize>>> as Drop>::drop(move _36) -> [return: bb16, unwind terminate];
    }

    bb19 (cleanup): {
        _44 = deref_copy ((((*_43).0: std::ptr::Unique<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>).0: std::ptr::NonNull<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>).0: *const std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>);
        _48 = _44 as *const () (PtrToPtr);
        _49 = _48 as usize (Transmute);
        _50 = AlignOf(std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>);
        _51 = Sub(_50, const 1_usize);
        _52 = BitAnd(_49, _51);
        _53 = Eq(_52, const 0_usize);
        assert(_53, "misaligned pointer dereference: address must be a multiple of {} but is {}", _50, _49) -> [success: bb18, unwind unreachable];
    }

    bb20 (cleanup): {
        _34 = &mut (*_42);
        _35 = <Box<Box<Box<Box<usize>>>> as Drop>::drop(move _34) -> [return: bb15, unwind terminate];
    }

    bb21: {
        _26 = &mut (*_38);
        _27 = <Box<Box<Box<Box<usize>>>> as Drop>::drop(move _26) -> [return: bb12, unwind: bb11];
    }

    bb22 (cleanup): {
        _28 = &mut (*_39);
        _29 = <Box<Box<Box<Box<usize>>>> as Drop>::drop(move _28) -> [return: bb30, unwind terminate];
    }

    bb23: {
        _30 = &mut (*_41);
        _31 = <Box<Box<Box<usize>>> as Drop>::drop(move _30) -> [return: bb14, unwind: bb13];
    }

    bb24: {
        _41 = deref_copy ((((*_40).0: std::ptr::Unique<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>).0: std::ptr::NonNull<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>).0: *const std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>);
        _78 = _41 as *const () (PtrToPtr);
        _79 = _78 as usize (Transmute);
        _80 = AlignOf(std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>);
        _81 = Sub(_80, const 1_usize);
        _82 = BitAnd(_79, _81);
        _83 = Eq(_82, const 0_usize);
        assert(_83, "misaligned pointer dereference: address must be a multiple of {} but is {}", _80, _79) -> [success: bb23, unwind unreachable];
    }

    bb25: {
        _9 = move (*_47);
        _8 = <Box<usize> as double>::double(move _9) -> [return: bb6, unwind: bb17];
    }

    bb26: {
        _21 = deref_copy (*_46);
        _47 = (((_21.0: std::ptr::Unique<std::boxed::Box<std::boxed::Box<usize>>>).0: std::ptr::NonNull<std::boxed::Box<std::boxed::Box<usize>>>).0: *const std::boxed::Box<std::boxed::Box<usize>>);
        _90 = _47 as *const () (PtrToPtr);
        _91 = _90 as usize (Transmute);
        _92 = AlignOf(std::boxed::Box<std::boxed::Box<usize>>);
        _93 = Sub(_92, const 1_usize);
        _94 = BitAnd(_91, _93);
        _95 = Eq(_94, const 0_usize);
        assert(_95, "misaligned pointer dereference: address must be a multiple of {} but is {}", _92, _91) -> [success: bb25, unwind unreachable];
    }

    bb27: {
        _20 = deref_copy (*_45);
        _46 = (((_20.0: std::ptr::Unique<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>).0: std::ptr::NonNull<std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>>).0: *const std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>);
        _96 = _46 as *const () (PtrToPtr);
        _97 = _96 as usize (Transmute);
        _98 = AlignOf(std::boxed::Box<std::boxed::Box<std::boxed::Box<usize>>>);
        _99 = Sub(_98, const 1_usize);
        _100 = BitAnd(_97, _99);
        _101 = Eq(_100, const 0_usize);
        assert(_101, "misaligned pointer dereference: address must be a multiple of {} but is {}", _98, _97) -> [success: bb26, unwind unreachable];
    }

    bb28 (cleanup): {
        goto -> bb9;
    }

    bb29 (cleanup): {
        goto -> bb9;
    }

    bb30 (cleanup): {
        goto -> bb11;
    }
}

promoted[0] in main: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 6_usize;
        _0 = &_1;
        return;
    }
}
