// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at ui/augmented-assignments-rpass.rs:12:10: 12:15>::fmt(_1: &Int, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&i32;
    let _6: &i32;

    bb0: {
        _3 = const "Int";
        _6 = &((*_1).0: i32);
        _5 = &_6;
        _4 = _5 as &dyn std::fmt::Debug (Pointer(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at ui/augmented-assignments-rpass.rs:12:17: 12:26>::eq(_1: &Int, _2: &Int) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: i32;
    let mut _4: i32;

    bb0: {
        _3 = ((*_1).0: i32);
        _4 = ((*_2).0: i32);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn <impl at ui/augmented-assignments-rpass.rs:17:1: 17:11>::new(_1: &mut [i32]) -> &mut Slice {
    debug slice => _1;
    let mut _0: &mut Slice;
    scope 1 {
    }

    bb0: {
        _0 = move _1 as &mut Slice (Transmute);
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let mut _1: Int;
    let _2: ();
    let mut _3: &mut Int;
    let mut _4: Int;
    let mut _5: (&Int, &Int);
    let mut _6: &Int;
    let mut _9: bool;
    let mut _10: bool;
    let _12: !;
    let mut _13: std::option::Option<std::fmt::Arguments<'_>>;
    let _14: ();
    let mut _15: &mut Int;
    let mut _16: Int;
    let mut _17: (&Int, &Int);
    let mut _18: &Int;
    let mut _21: bool;
    let mut _22: bool;
    let _24: !;
    let mut _25: std::option::Option<std::fmt::Arguments<'_>>;
    let _26: ();
    let mut _27: &mut Int;
    let mut _28: Int;
    let mut _29: (&Int, &Int);
    let mut _30: &Int;
    let mut _33: bool;
    let mut _34: bool;
    let _36: !;
    let mut _37: std::option::Option<std::fmt::Arguments<'_>>;
    let _38: ();
    let mut _39: &mut Int;
    let mut _40: Int;
    let mut _41: (&Int, &Int);
    let mut _42: &Int;
    let mut _45: bool;
    let mut _46: bool;
    let _48: !;
    let mut _49: std::option::Option<std::fmt::Arguments<'_>>;
    let _50: ();
    let mut _51: &mut Int;
    let mut _52: Int;
    let mut _53: (&Int, &Int);
    let mut _54: &Int;
    let mut _57: bool;
    let mut _58: bool;
    let _60: !;
    let mut _61: std::option::Option<std::fmt::Arguments<'_>>;
    let _62: ();
    let mut _63: &mut Int;
    let mut _64: Int;
    let mut _65: (&Int, &Int);
    let mut _66: &Int;
    let mut _69: bool;
    let mut _70: bool;
    let _72: !;
    let mut _73: std::option::Option<std::fmt::Arguments<'_>>;
    let _74: ();
    let mut _75: &mut Int;
    let mut _76: Int;
    let mut _77: (&Int, &Int);
    let mut _78: &Int;
    let mut _81: bool;
    let mut _82: bool;
    let _84: !;
    let mut _85: std::option::Option<std::fmt::Arguments<'_>>;
    let _86: ();
    let mut _87: &mut Int;
    let mut _88: (&Int, &Int);
    let mut _89: &Int;
    let mut _92: bool;
    let mut _93: bool;
    let _95: !;
    let mut _96: std::option::Option<std::fmt::Arguments<'_>>;
    let _97: ();
    let mut _98: &mut Int;
    let mut _99: (&Int, &Int);
    let mut _100: &Int;
    let mut _103: bool;
    let mut _104: bool;
    let _106: !;
    let mut _107: std::option::Option<std::fmt::Arguments<'_>>;
    let _108: ();
    let mut _109: &mut Int;
    let mut _110: (&Int, &Int);
    let mut _111: &Int;
    let mut _114: bool;
    let mut _115: bool;
    let _117: !;
    let mut _118: std::option::Option<std::fmt::Arguments<'_>>;
    let _119: ();
    let mut _120: &mut Int;
    let mut _121: (&Int, &Int);
    let mut _122: &Int;
    let mut _125: bool;
    let mut _126: bool;
    let _128: !;
    let mut _129: std::option::Option<std::fmt::Arguments<'_>>;
    let _130: ();
    let mut _131: &mut Int;
    let mut _132: Int;
    let mut _133: (&Int, &Int);
    let mut _134: &Int;
    let mut _137: bool;
    let mut _138: bool;
    let _140: !;
    let mut _141: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _143: std::boxed::Box<[Int]>;
    let mut _144: usize;
    let mut _145: usize;
    let mut _146: *mut u8;
    let mut _147: std::boxed::Box<[Int; 2]>;
    let mut _148: Int;
    let mut _149: Int;
    let _150: ();
    let mut _151: &mut Int;
    let mut _152: &mut Int;
    let mut _153: &mut std::vec::Vec<Int>;
    let mut _154: Int;
    let mut _155: (&Int, &Int);
    let mut _156: &Int;
    let _157: &Int;
    let mut _158: &std::vec::Vec<Int>;
    let mut _161: bool;
    let mut _162: bool;
    let _164: !;
    let mut _165: std::option::Option<std::fmt::Arguments<'_>>;
    let _167: ();
    let mut _168: &mut Slice;
    let mut _169: &mut Slice;
    let mut _170: &mut [i32];
    let mut _171: &mut [i32; 3];
    let mut _172: (&i32, &i32);
    let mut _173: &i32;
    let _174: usize;
    let mut _175: usize;
    let mut _176: bool;
    let mut _179: bool;
    let mut _180: bool;
    let mut _181: i32;
    let mut _182: i32;
    let _184: !;
    let mut _185: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _186: (&i32, &i32);
    let mut _187: &i32;
    let _188: usize;
    let mut _189: usize;
    let mut _190: bool;
    let mut _193: bool;
    let mut _194: bool;
    let mut _195: i32;
    let mut _196: i32;
    let _198: !;
    let mut _199: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _200: (&i32, &i32);
    let mut _201: &i32;
    let _202: usize;
    let mut _203: usize;
    let mut _204: bool;
    let mut _207: bool;
    let mut _208: bool;
    let mut _209: i32;
    let mut _210: i32;
    let _212: !;
    let mut _213: std::option::Option<std::fmt::Arguments<'_>>;
    let mut _216: &mut [i32];
    let mut _217: &mut [i32; 3];
    let _218: ();
    let mut _219: &mut View<'_>;
    let mut _236: *const [Int; 2];
    scope 1 {
        debug x => _1;
        let _7: &Int;
        let _8: &Int;
        let _19: &Int;
        let _20: &Int;
        let _31: &Int;
        let _32: &Int;
        let _43: &Int;
        let _44: &Int;
        let _55: &Int;
        let _56: &Int;
        let _67: &Int;
        let _68: &Int;
        let _79: &Int;
        let _80: &Int;
        let _90: &Int;
        let _91: &Int;
        let _101: &Int;
        let _102: &Int;
        let _112: &Int;
        let _113: &Int;
        let _123: &Int;
        let _124: &Int;
        let _135: &Int;
        let _136: &Int;
        let mut _142: std::vec::Vec<Int>;
        let mut _224: &Int;
        let mut _225: &Int;
        let mut _226: &Int;
        let mut _227: &Int;
        let mut _228: &Int;
        let mut _229: &Int;
        let mut _230: &Int;
        let mut _231: &Int;
        let mut _232: &Int;
        let mut _233: &Int;
        let mut _234: &Int;
        let mut _235: &Int;
        let mut _237: *const ();
        let mut _238: usize;
        let mut _239: usize;
        let mut _240: usize;
        let mut _241: usize;
        let mut _242: bool;
        scope 2 {
            debug left_val => _7;
            debug right_val => _8;
            let _11: core::panicking::AssertKind;
            scope 3 {
                debug kind => _11;
            }
        }
        scope 4 {
            debug left_val => _19;
            debug right_val => _20;
            let _23: core::panicking::AssertKind;
            scope 5 {
                debug kind => _23;
            }
        }
        scope 6 {
            debug left_val => _31;
            debug right_val => _32;
            let _35: core::panicking::AssertKind;
            scope 7 {
                debug kind => _35;
            }
        }
        scope 8 {
            debug left_val => _43;
            debug right_val => _44;
            let _47: core::panicking::AssertKind;
            scope 9 {
                debug kind => _47;
            }
        }
        scope 10 {
            debug left_val => _55;
            debug right_val => _56;
            let _59: core::panicking::AssertKind;
            scope 11 {
                debug kind => _59;
            }
        }
        scope 12 {
            debug left_val => _67;
            debug right_val => _68;
            let _71: core::panicking::AssertKind;
            scope 13 {
                debug kind => _71;
            }
        }
        scope 14 {
            debug left_val => _79;
            debug right_val => _80;
            let _83: core::panicking::AssertKind;
            scope 15 {
                debug kind => _83;
            }
        }
        scope 16 {
            debug left_val => _90;
            debug right_val => _91;
            let _94: core::panicking::AssertKind;
            scope 17 {
                debug kind => _94;
            }
        }
        scope 18 {
            debug left_val => _101;
            debug right_val => _102;
            let _105: core::panicking::AssertKind;
            scope 19 {
                debug kind => _105;
            }
        }
        scope 20 {
            debug left_val => _112;
            debug right_val => _113;
            let _116: core::panicking::AssertKind;
            scope 21 {
                debug kind => _116;
            }
        }
        scope 22 {
            debug left_val => _123;
            debug right_val => _124;
            let _127: core::panicking::AssertKind;
            scope 23 {
                debug kind => _127;
            }
        }
        scope 24 {
            debug left_val => _135;
            debug right_val => _136;
            let _139: core::panicking::AssertKind;
            scope 25 {
                debug kind => _139;
            }
        }
        scope 26 {
            debug v => _142;
            let _159: &Int;
            let _160: &Int;
            let mut _166: [i32; 3];
            let mut _223: &Int;
            scope 28 {
                debug left_val => _159;
                debug right_val => _160;
                let _163: core::panicking::AssertKind;
                scope 29 {
                    debug kind => _163;
                }
            }
            scope 30 {
                debug array => _166;
                let _177: &i32;
                let _178: &i32;
                let _191: &i32;
                let _192: &i32;
                let _205: &i32;
                let _206: &i32;
                let mut _214: [i32; 3];
                let mut _220: &i32;
                let mut _221: &i32;
                let mut _222: &i32;
                scope 31 {
                    debug left_val => _177;
                    debug right_val => _178;
                    let _183: core::panicking::AssertKind;
                    scope 32 {
                        debug kind => _183;
                    }
                }
                scope 33 {
                    debug left_val => _191;
                    debug right_val => _192;
                    let _197: core::panicking::AssertKind;
                    scope 34 {
                        debug kind => _197;
                    }
                }
                scope 35 {
                    debug left_val => _205;
                    debug right_val => _206;
                    let _211: core::panicking::AssertKind;
                    scope 36 {
                        debug kind => _211;
                    }
                }
                scope 37 {
                    debug array => _214;
                    let mut _215: View<'_>;
                    scope 38 {
                        debug view => _215;
                    }
                }
            }
        }
        scope 27 {
        }
    }

    bb0: {
        _1 = Int(const 1_i32);
        _3 = &mut _1;
        _4 = Int(const 2_i32);
        _2 = <Int as AddAssign>::add_assign(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &_1;
        _235 = const _;
        _5 = (move _6, _235);
        _7 = (_5.0: &Int);
        _8 = (_5.1: &Int);
        _10 = <Int as PartialEq>::eq(_7, _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = Not(move _10);
        switchInt(move _9) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _11 = core::panicking::AssertKind::Eq;
        _13 = Option::<Arguments<'_>>::None;
        _12 = core::panicking::assert_failed::<Int, Int>(move _11, _7, _8, move _13) -> unwind continue;
    }

    bb4: {
        _15 = &mut _1;
        _16 = Int(const 1_i32);
        _14 = <Int as BitAndAssign>::bitand_assign(move _15, move _16) -> [return: bb5, unwind continue];
    }

    bb5: {
        _18 = &_1;
        _234 = const _;
        _17 = (move _18, _234);
        _19 = (_17.0: &Int);
        _20 = (_17.1: &Int);
        _22 = <Int as PartialEq>::eq(_19, _20) -> [return: bb6, unwind continue];
    }

    bb6: {
        _21 = Not(move _22);
        switchInt(move _21) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _23 = core::panicking::AssertKind::Eq;
        _25 = Option::<Arguments<'_>>::None;
        _24 = core::panicking::assert_failed::<Int, Int>(move _23, _19, _20, move _25) -> unwind continue;
    }

    bb8: {
        _27 = &mut _1;
        _28 = Int(const 2_i32);
        _26 = <Int as BitOrAssign>::bitor_assign(move _27, move _28) -> [return: bb9, unwind continue];
    }

    bb9: {
        _30 = &_1;
        _233 = const _;
        _29 = (move _30, _233);
        _31 = (_29.0: &Int);
        _32 = (_29.1: &Int);
        _34 = <Int as PartialEq>::eq(_31, _32) -> [return: bb10, unwind continue];
    }

    bb10: {
        _33 = Not(move _34);
        switchInt(move _33) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _35 = core::panicking::AssertKind::Eq;
        _37 = Option::<Arguments<'_>>::None;
        _36 = core::panicking::assert_failed::<Int, Int>(move _35, _31, _32, move _37) -> unwind continue;
    }

    bb12: {
        _39 = &mut _1;
        _40 = Int(const 1_i32);
        _38 = <Int as BitXorAssign>::bitxor_assign(move _39, move _40) -> [return: bb13, unwind continue];
    }

    bb13: {
        _42 = &_1;
        _232 = const _;
        _41 = (move _42, _232);
        _43 = (_41.0: &Int);
        _44 = (_41.1: &Int);
        _46 = <Int as PartialEq>::eq(_43, _44) -> [return: bb14, unwind continue];
    }

    bb14: {
        _45 = Not(move _46);
        switchInt(move _45) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _47 = core::panicking::AssertKind::Eq;
        _49 = Option::<Arguments<'_>>::None;
        _48 = core::panicking::assert_failed::<Int, Int>(move _47, _43, _44, move _49) -> unwind continue;
    }

    bb16: {
        _51 = &mut _1;
        _52 = Int(const 2_i32);
        _50 = <Int as DivAssign>::div_assign(move _51, move _52) -> [return: bb17, unwind continue];
    }

    bb17: {
        _54 = &_1;
        _231 = const _;
        _53 = (move _54, _231);
        _55 = (_53.0: &Int);
        _56 = (_53.1: &Int);
        _58 = <Int as PartialEq>::eq(_55, _56) -> [return: bb18, unwind continue];
    }

    bb18: {
        _57 = Not(move _58);
        switchInt(move _57) -> [0: bb20, otherwise: bb19];
    }

    bb19: {
        _59 = core::panicking::AssertKind::Eq;
        _61 = Option::<Arguments<'_>>::None;
        _60 = core::panicking::assert_failed::<Int, Int>(move _59, _55, _56, move _61) -> unwind continue;
    }

    bb20: {
        _63 = &mut _1;
        _64 = Int(const 3_i32);
        _62 = <Int as MulAssign>::mul_assign(move _63, move _64) -> [return: bb21, unwind continue];
    }

    bb21: {
        _66 = &_1;
        _230 = const _;
        _65 = (move _66, _230);
        _67 = (_65.0: &Int);
        _68 = (_65.1: &Int);
        _70 = <Int as PartialEq>::eq(_67, _68) -> [return: bb22, unwind continue];
    }

    bb22: {
        _69 = Not(move _70);
        switchInt(move _69) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _71 = core::panicking::AssertKind::Eq;
        _73 = Option::<Arguments<'_>>::None;
        _72 = core::panicking::assert_failed::<Int, Int>(move _71, _67, _68, move _73) -> unwind continue;
    }

    bb24: {
        _75 = &mut _1;
        _76 = Int(const 2_i32);
        _74 = <Int as RemAssign>::rem_assign(move _75, move _76) -> [return: bb25, unwind continue];
    }

    bb25: {
        _78 = &_1;
        _229 = const _;
        _77 = (move _78, _229);
        _79 = (_77.0: &Int);
        _80 = (_77.1: &Int);
        _82 = <Int as PartialEq>::eq(_79, _80) -> [return: bb26, unwind continue];
    }

    bb26: {
        _81 = Not(move _82);
        switchInt(move _81) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        _83 = core::panicking::AssertKind::Eq;
        _85 = Option::<Arguments<'_>>::None;
        _84 = core::panicking::assert_failed::<Int, Int>(move _83, _79, _80, move _85) -> unwind continue;
    }

    bb28: {
        _87 = &mut _1;
        _86 = <Int as ShlAssign<u8>>::shl_assign(move _87, const 1_u8) -> [return: bb29, unwind continue];
    }

    bb29: {
        _89 = &_1;
        _228 = const _;
        _88 = (move _89, _228);
        _90 = (_88.0: &Int);
        _91 = (_88.1: &Int);
        _93 = <Int as PartialEq>::eq(_90, _91) -> [return: bb30, unwind continue];
    }

    bb30: {
        _92 = Not(move _93);
        switchInt(move _92) -> [0: bb32, otherwise: bb31];
    }

    bb31: {
        _94 = core::panicking::AssertKind::Eq;
        _96 = Option::<Arguments<'_>>::None;
        _95 = core::panicking::assert_failed::<Int, Int>(move _94, _90, _91, move _96) -> unwind continue;
    }

    bb32: {
        _98 = &mut _1;
        _97 = <Int as ShlAssign<u16>>::shl_assign(move _98, const 1_u16) -> [return: bb33, unwind continue];
    }

    bb33: {
        _100 = &_1;
        _227 = const _;
        _99 = (move _100, _227);
        _101 = (_99.0: &Int);
        _102 = (_99.1: &Int);
        _104 = <Int as PartialEq>::eq(_101, _102) -> [return: bb34, unwind continue];
    }

    bb34: {
        _103 = Not(move _104);
        switchInt(move _103) -> [0: bb36, otherwise: bb35];
    }

    bb35: {
        _105 = core::panicking::AssertKind::Eq;
        _107 = Option::<Arguments<'_>>::None;
        _106 = core::panicking::assert_failed::<Int, Int>(move _105, _101, _102, move _107) -> unwind continue;
    }

    bb36: {
        _109 = &mut _1;
        _108 = <Int as ShrAssign<u8>>::shr_assign(move _109, const 1_u8) -> [return: bb37, unwind continue];
    }

    bb37: {
        _111 = &_1;
        _226 = const _;
        _110 = (move _111, _226);
        _112 = (_110.0: &Int);
        _113 = (_110.1: &Int);
        _115 = <Int as PartialEq>::eq(_112, _113) -> [return: bb38, unwind continue];
    }

    bb38: {
        _114 = Not(move _115);
        switchInt(move _114) -> [0: bb40, otherwise: bb39];
    }

    bb39: {
        _116 = core::panicking::AssertKind::Eq;
        _118 = Option::<Arguments<'_>>::None;
        _117 = core::panicking::assert_failed::<Int, Int>(move _116, _112, _113, move _118) -> unwind continue;
    }

    bb40: {
        _120 = &mut _1;
        _119 = <Int as ShrAssign<u16>>::shr_assign(move _120, const 1_u16) -> [return: bb41, unwind continue];
    }

    bb41: {
        _122 = &_1;
        _225 = const _;
        _121 = (move _122, _225);
        _123 = (_121.0: &Int);
        _124 = (_121.1: &Int);
        _126 = <Int as PartialEq>::eq(_123, _124) -> [return: bb42, unwind continue];
    }

    bb42: {
        _125 = Not(move _126);
        switchInt(move _125) -> [0: bb44, otherwise: bb43];
    }

    bb43: {
        _127 = core::panicking::AssertKind::Eq;
        _129 = Option::<Arguments<'_>>::None;
        _128 = core::panicking::assert_failed::<Int, Int>(move _127, _123, _124, move _129) -> unwind continue;
    }

    bb44: {
        _131 = &mut _1;
        _132 = Int(const 1_i32);
        _130 = <Int as SubAssign>::sub_assign(move _131, move _132) -> [return: bb45, unwind continue];
    }

    bb45: {
        _134 = &_1;
        _224 = const _;
        _133 = (move _134, _224);
        _135 = (_133.0: &Int);
        _136 = (_133.1: &Int);
        _138 = <Int as PartialEq>::eq(_135, _136) -> [return: bb46, unwind continue];
    }

    bb46: {
        _137 = Not(move _138);
        switchInt(move _137) -> [0: bb48, otherwise: bb47];
    }

    bb47: {
        _139 = core::panicking::AssertKind::Eq;
        _141 = Option::<Arguments<'_>>::None;
        _140 = core::panicking::assert_failed::<Int, Int>(move _139, _135, _136, move _141) -> unwind continue;
    }

    bb48: {
        _144 = SizeOf([Int; 2]);
        _145 = AlignOf([Int; 2]);
        _146 = alloc::alloc::exchange_malloc(move _144, move _145) -> [return: bb49, unwind continue];
    }

    bb49: {
        _147 = ShallowInitBox(move _146, [Int; 2]);
        _148 = Int(const 1_i32);
        _149 = Int(const 2_i32);
        _236 = (((_147.0: std::ptr::Unique<[Int; 2]>).0: std::ptr::NonNull<[Int; 2]>).0: *const [Int; 2]);
        _237 = _236 as *const () (PtrToPtr);
        _238 = _237 as usize (Transmute);
        _239 = AlignOf(Int);
        _240 = Sub(_239, const 1_usize);
        _241 = BitAnd(_238, _240);
        _242 = Eq(_241, const 0_usize);
        assert(_242, "misaligned pointer dereference: address must be a multiple of {} but is {}", _239, _238) -> [success: bb72, unwind unreachable];
    }

    bb50: {
        _153 = &mut _142;
        _152 = <Vec<Int> as IndexMut<usize>>::index_mut(move _153, const 0_usize) -> [return: bb51, unwind: bb70];
    }

    bb51: {
        _151 = _152;
        _154 = Int(const 2_i32);
        _150 = <Int as AddAssign>::add_assign(move _151, move _154) -> [return: bb52, unwind: bb70];
    }

    bb52: {
        _158 = &_142;
        _157 = <Vec<Int> as Index<usize>>::index(move _158, const 0_usize) -> [return: bb53, unwind: bb70];
    }

    bb53: {
        _156 = _157;
        _223 = const _;
        _155 = (move _156, _223);
        _159 = (_155.0: &Int);
        _160 = (_155.1: &Int);
        _162 = <Int as PartialEq>::eq(_159, _160) -> [return: bb54, unwind: bb70];
    }

    bb54: {
        _161 = Not(move _162);
        switchInt(move _161) -> [0: bb56, otherwise: bb55];
    }

    bb55: {
        _163 = core::panicking::AssertKind::Eq;
        _165 = Option::<Arguments<'_>>::None;
        _164 = core::panicking::assert_failed::<Int, Int>(move _163, _159, _160, move _165) -> bb70;
    }

    bb56: {
        _166 = [const 0_i32, const 1_i32, const 2_i32];
        _171 = &mut _166;
        _170 = _171 as &mut [i32] (Pointer(Unsize));
        _169 = Slice::new(move _170) -> [return: bb57, unwind: bb70];
    }

    bb57: {
        _168 = _169;
        _167 = <Slice as AddAssign<i32>>::add_assign(move _168, const 1_i32) -> [return: bb58, unwind: bb70];
    }

    bb58: {
        _174 = const 0_usize;
        _175 = const 3_usize;
        _176 = Lt(_174, _175);
        assert(move _176, "index out of bounds: the length is {} but the index is {}", move _175, _174) -> [success: bb59, unwind: bb70];
    }

    bb59: {
        _173 = &_166[_174];
        _222 = const _;
        _172 = (move _173, _222);
        _177 = (_172.0: &i32);
        _178 = (_172.1: &i32);
        _181 = (*_177);
        _182 = (*_178);
        _180 = Eq(move _181, move _182);
        _179 = Not(move _180);
        switchInt(move _179) -> [0: bb61, otherwise: bb60];
    }

    bb60: {
        _183 = core::panicking::AssertKind::Eq;
        _185 = Option::<Arguments<'_>>::None;
        _184 = core::panicking::assert_failed::<i32, i32>(move _183, _177, _178, move _185) -> bb70;
    }

    bb61: {
        _188 = const 1_usize;
        _189 = const 3_usize;
        _190 = Lt(_188, _189);
        assert(move _190, "index out of bounds: the length is {} but the index is {}", move _189, _188) -> [success: bb62, unwind: bb70];
    }

    bb62: {
        _187 = &_166[_188];
        _221 = const _;
        _186 = (move _187, _221);
        _191 = (_186.0: &i32);
        _192 = (_186.1: &i32);
        _195 = (*_191);
        _196 = (*_192);
        _194 = Eq(move _195, move _196);
        _193 = Not(move _194);
        switchInt(move _193) -> [0: bb64, otherwise: bb63];
    }

    bb63: {
        _197 = core::panicking::AssertKind::Eq;
        _199 = Option::<Arguments<'_>>::None;
        _198 = core::panicking::assert_failed::<i32, i32>(move _197, _191, _192, move _199) -> bb70;
    }

    bb64: {
        _202 = const 2_usize;
        _203 = const 3_usize;
        _204 = Lt(_202, _203);
        assert(move _204, "index out of bounds: the length is {} but the index is {}", move _203, _202) -> [success: bb65, unwind: bb70];
    }

    bb65: {
        _201 = &_166[_202];
        _220 = const _;
        _200 = (move _201, _220);
        _205 = (_200.0: &i32);
        _206 = (_200.1: &i32);
        _209 = (*_205);
        _210 = (*_206);
        _208 = Eq(move _209, move _210);
        _207 = Not(move _208);
        switchInt(move _207) -> [0: bb67, otherwise: bb66];
    }

    bb66: {
        _211 = core::panicking::AssertKind::Eq;
        _213 = Option::<Arguments<'_>>::None;
        _212 = core::panicking::assert_failed::<i32, i32>(move _211, _205, _206, move _213) -> bb70;
    }

    bb67: {
        _214 = [const 0_i32, const 1_i32, const 2_i32];
        _217 = &mut _214;
        _216 = _217 as &mut [i32] (Pointer(Unsize));
        _215 = View::<'_>(move _216);
        _219 = &mut _215;
        _218 = <View<'_> as AddAssign<i32>>::add_assign(move _219, const 1_i32) -> [return: bb68, unwind: bb70];
    }

    bb68: {
        drop(_142) -> [return: bb69, unwind continue];
    }

    bb69: {
        return;
    }

    bb70 (cleanup): {
        drop(_142) -> [return: bb71, unwind terminate];
    }

    bb71 (cleanup): {
        resume;
    }

    bb72: {
        (*_236) = [move _148, move _149];
        _143 = move _147 as std::boxed::Box<[Int]> (Pointer(Unsize));
        _142 = slice::<impl [Int]>::into_vec::<std::alloc::Global>(move _143) -> [return: bb50, unwind continue];
    }
}

promoted[0] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 3_i32;
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 2_i32;
        _0 = &_1;
        return;
    }
}

promoted[2] in main: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 1_i32;
        _0 = &_1;
        return;
    }
}

promoted[3] in main: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 3_i32);
        _0 = &_1;
        return;
    }
}

promoted[4] in main: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 0_i32);
        _0 = &_1;
        return;
    }
}

promoted[5] in main: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 1_i32);
        _0 = &_1;
        return;
    }
}

promoted[6] in main: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 2_i32);
        _0 = &_1;
        return;
    }
}

promoted[7] in main: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 4_i32);
        _0 = &_1;
        return;
    }
}

promoted[8] in main: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 2_i32);
        _0 = &_1;
        return;
    }
}

promoted[9] in main: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 1_i32);
        _0 = &_1;
        return;
    }
}

promoted[10] in main: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 3_i32);
        _0 = &_1;
        return;
    }
}

promoted[11] in main: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 1_i32);
        _0 = &_1;
        return;
    }
}

promoted[12] in main: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 2_i32);
        _0 = &_1;
        return;
    }
}

promoted[13] in main: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 3_i32);
        _0 = &_1;
        return;
    }
}

promoted[14] in main: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 1_i32);
        _0 = &_1;
        return;
    }
}

promoted[15] in main: &Int = {
    let mut _0: &Int;
    let mut _1: Int;

    bb0: {
        _1 = Int(const 3_i32);
        _0 = &_1;
        return;
    }
}

fn <impl at ui/augmented-assignments-rpass.rs:86:1: 86:23>::add_assign(_1: &mut Int, _2: Int) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: i32;

    bb0: {
        _3 = (_2.0: i32);
        ((*_1).0: i32) = Add(((*_1).0: i32), move _3);
        return;
    }
}

fn <impl at ui/augmented-assignments-rpass.rs:92:1: 92:26>::bitand_assign(_1: &mut Int, _2: Int) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: i32;

    bb0: {
        _3 = (_2.0: i32);
        ((*_1).0: i32) = BitAnd(((*_1).0: i32), move _3);
        return;
    }
}

fn <impl at ui/augmented-assignments-rpass.rs:98:1: 98:25>::bitor_assign(_1: &mut Int, _2: Int) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: i32;

    bb0: {
        _3 = (_2.0: i32);
        ((*_1).0: i32) = BitOr(((*_1).0: i32), move _3);
        return;
    }
}

fn <impl at ui/augmented-assignments-rpass.rs:104:1: 104:26>::bitxor_assign(_1: &mut Int, _2: Int) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: i32;

    bb0: {
        _3 = (_2.0: i32);
        ((*_1).0: i32) = BitXor(((*_1).0: i32), move _3);
        return;
    }
}

fn <impl at ui/augmented-assignments-rpass.rs:110:1: 110:23>::div_assign(_1: &mut Int, _2: Int) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: i32;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;

    bb0: {
        _3 = (_2.0: i32);
        _4 = Eq(_3, const 0_i32);
        assert(!move _4, "attempt to divide `{}` by zero", ((*_1).0: i32)) -> [success: bb1, unwind continue];
    }

    bb1: {
        _5 = Eq(_3, const -1_i32);
        _6 = Eq(((*_1).0: i32), const i32::MIN);
        _7 = BitAnd(move _5, move _6);
        assert(!move _7, "attempt to compute `{} / {}`, which would overflow", ((*_1).0: i32), _3) -> [success: bb2, unwind continue];
    }

    bb2: {
        ((*_1).0: i32) = Div(((*_1).0: i32), move _3);
        return;
    }
}

fn <impl at ui/augmented-assignments-rpass.rs:116:1: 116:23>::mul_assign(_1: &mut Int, _2: Int) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: i32;

    bb0: {
        _3 = (_2.0: i32);
        ((*_1).0: i32) = Mul(((*_1).0: i32), move _3);
        return;
    }
}

fn <impl at ui/augmented-assignments-rpass.rs:122:1: 122:23>::rem_assign(_1: &mut Int, _2: Int) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: i32;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;

    bb0: {
        _3 = (_2.0: i32);
        _4 = Eq(_3, const 0_i32);
        assert(!move _4, "attempt to calculate the remainder of `{}` with a divisor of zero", ((*_1).0: i32)) -> [success: bb1, unwind continue];
    }

    bb1: {
        _5 = Eq(_3, const -1_i32);
        _6 = Eq(((*_1).0: i32), const i32::MIN);
        _7 = BitAnd(move _5, move _6);
        assert(!move _7, "attempt to compute the remainder of `{} % {}`, which would overflow", ((*_1).0: i32), _3) -> [success: bb2, unwind continue];
    }

    bb2: {
        ((*_1).0: i32) = Rem(((*_1).0: i32), move _3);
        return;
    }
}

fn <impl at ui/augmented-assignments-rpass.rs:128:1: 128:27>::shl_assign(_1: &mut Int, _2: u8) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();

    bb0: {
        ((*_1).0: i32) = Shl(((*_1).0: i32), _2);
        return;
    }
}

fn <impl at ui/augmented-assignments-rpass.rs:134:1: 134:28>::shl_assign(_1: &mut Int, _2: u16) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();

    bb0: {
        ((*_1).0: i32) = Shl(((*_1).0: i32), _2);
        return;
    }
}

fn <impl at ui/augmented-assignments-rpass.rs:140:1: 140:27>::shr_assign(_1: &mut Int, _2: u8) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();

    bb0: {
        ((*_1).0: i32) = Shr(((*_1).0: i32), _2);
        return;
    }
}

fn <impl at ui/augmented-assignments-rpass.rs:146:1: 146:28>::shr_assign(_1: &mut Int, _2: u16) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();

    bb0: {
        ((*_1).0: i32) = Shr(((*_1).0: i32), _2);
        return;
    }
}

fn <impl at ui/augmented-assignments-rpass.rs:152:1: 152:23>::sub_assign(_1: &mut Int, _2: Int) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: i32;

    bb0: {
        _3 = (_2.0: i32);
        ((*_1).0: i32) = Sub(((*_1).0: i32), move _3);
        return;
    }
}

fn <impl at ui/augmented-assignments-rpass.rs:158:1: 158:30>::add_assign(_1: &mut Slice, _2: i32) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: std::slice::IterMut<'_, i32>;
    let mut _4: &mut [i32];
    let mut _5: std::slice::IterMut<'_, i32>;
    let mut _6: std::option::Option<&mut i32>;
    let mut _7: &mut std::slice::IterMut<'_, i32>;
    let mut _8: isize;
    scope 1 {
        debug iter => _5;
        let _9: &mut i32;
        scope 2 {
            debug lhs => _9;
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: [i32]);
        _3 = <&mut [i32] as IntoIterator>::into_iter(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _5;
        _6 = <std::slice::IterMut<'_, i32> as Iterator>::next(_7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _9 = move ((_6 as Some).0: &mut i32);
        (*_9) = Add((*_9), _2);
        goto -> bb2;
    }

    bb5: {
        unreachable;
    }

    bb6: {
        return;
    }
}

fn <impl at ui/augmented-assignments-rpass.rs:166:1: 166:37>::add_assign(_1: &mut View<'_>, _2: i32) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: std::slice::IterMut<'_, i32>;
    let mut _4: std::slice::IterMut<'_, i32>;
    let mut _5: std::slice::IterMut<'_, i32>;
    let mut _6: std::option::Option<&mut i32>;
    let mut _7: &mut std::slice::IterMut<'_, i32>;
    let mut _8: isize;
    let mut _10: &mut [i32];
    scope 1 {
        debug iter => _5;
        let _9: &mut i32;
        scope 2 {
            debug lhs => _9;
        }
    }

    bb0: {
        _10 = deref_copy ((*_1).0: &mut [i32]);
        _4 = core::slice::<impl [i32]>::iter_mut(_10) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::slice::IterMut<'_, i32> as IntoIterator>::into_iter(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = move _3;
        goto -> bb3;
    }

    bb3: {
        _7 = &mut _5;
        _6 = <std::slice::IterMut<'_, i32> as Iterator>::next(_7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb7, 1: bb5, otherwise: bb6];
    }

    bb5: {
        _9 = move ((_6 as Some).0: &mut i32);
        (*_9) = Add((*_9), _2);
        goto -> bb3;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        return;
    }
}

fn Int(_1: i32) -> Int {
    let mut _0: Int;

    bb0: {
        _0 = Int(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Int(_1: i32) -> Int {
    let mut _0: Int;

    bb0: {
        _0 = Int(move _1);
        return;
    }
}

fn Slice(_1: [i32]) -> Slice {
    let mut _0: Slice;

    bb0: {
        _0 = Slice(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Slice(_1: [i32]) -> Slice {
    let mut _0: Slice;

    bb0: {
        _0 = Slice(move _1);
        return;
    }
}

fn View(_1: &mut [i32]) -> View<'_> {
    let mut _0: View<'_>;

    bb0: {
        _0 = View::<'_>(move _1);
        return;
    }
}

// MIR FOR CTFE
fn View(_1: &mut [i32]) -> View<'_> {
    let mut _0: View<'_>;

    bb0: {
        _0 = View::<'_>(move _1);
        return;
    }
}
